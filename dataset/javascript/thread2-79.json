[["getCroppedCanvas", "\nfunction getCroppedCanvas() {\n  <verifyStateAndFeatureSupport>\n  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  if (!this.ready || !window.HTMLCanvasElement) {\n    return null;\n  }\n  var canvasData = this.canvasData;\n  </verifyStateAndFeatureSupport>\n\n  <getSourceCanvas>\n  var source = getSourceCanvas(this.image, this.imageData, canvasData, options);\n  </getSourceCanvas>\n\n  <checkCropped>\n  if (!this.cropped) {\n    return source;\n  }\n  </checkCropped>\n\n  <calculateInitialDimensionsAndRatio>\n  var _getData = this.getData(),\n      initialX = _getData.x,\n      initialY = _getData.y,\n      initialWidth = _getData.width,\n      initialHeight = _getData.height;\n  var ratio = source.width / Math.floor(canvasData.naturalWidth);\n  if (ratio !== 1) {\n    initialX *= ratio;\n    initialY *= ratio;\n    initialWidth *= ratio;\n    initialHeight *= ratio;\n  }\n  </calculateInitialDimensionsAndRatio>\n\n  <computeSizes>\n  var aspectRatio = initialWidth / initialHeight;\n  var maxSizes = getAdjustedSizes({\n    aspectRatio: aspectRatio,\n    width: options.maxWidth || Infinity,\n    height: options.maxHeight || Infinity\n  });\n  var minSizes = getAdjustedSizes({\n    aspectRatio: aspectRatio,\n    width: options.minWidth || 0,\n    height: options.minHeight || 0\n  }, 'cover');\n  var _getAdjustedSizes = getAdjustedSizes({\n    aspectRatio: aspectRatio,\n    width: options.width || (ratio !== 1 ? source.width : initialWidth),\n    height: options.height || (ratio !== 1 ? source.height : initialHeight)\n  }),\n      width = _getAdjustedSizes.width,\n      height = _getAdjustedSizes.height;\n  width = Math.min(maxSizes.width, Math.max(minSizes.width, width));\n  height = Math.min(maxSizes.height, Math.max(minSizes.height, height));\n  </computeSizes>\n  \n  <createAndConfigureCanvas>\n  var canvas = document.createElement('canvas');\n  var context = canvas.getContext('2d');\n  canvas.width = normalizeDecimalNumber(width);\n  canvas.height = normalizeDecimalNumber(height);\n  context.fillStyle = options.fillColor || 'transparent';\n  context.fillRect(0, 0, width, height);\n  var _options$imageSmoothingEnabled = options.imageSmoothingEnabled,\n      imageSmoothingEnabled = _options$imageSmoothingEnabled === undefined ? true : _options$imageSmoothingEnabled,\n      imageSmoothingQuality = options.imageSmoothingQuality;\n  context.imageSmoothingEnabled = imageSmoothingEnabled;\n  if (imageSmoothingQuality) {\n    context.imageSmoothingQuality = imageSmoothingQuality;\n  }\n  </createAndConfigureCanvas>\n\n  <defineDrawingDimensions>\n  var sourceWidth = source.width;\n  var sourceHeight = source.height;\n  var srcX = initialX;\n  var srcY = initialY;\n  var srcWidth = void 0;\n  var srcHeight = void 0;\n  var dstX = void 0;\n  var dstY = void 0;\n  var dstWidth = void 0;\n  var dstHeight = void 0;\n  if (srcX <= -initialWidth || srcX > sourceWidth) {\n    srcX = 0;\n    srcWidth = 0;\n    dstX = 0;\n    dstWidth = 0;\n  } else if (srcX <= 0) {\n    dstX = -srcX;\n    srcX = 0;\n    srcWidth = Math.min(sourceWidth, initialWidth + srcX);\n    dstWidth = srcWidth;\n  } else if (srcX <= sourceWidth) {\n    dstX = 0;\n    srcWidth = Math.min(initialWidth, sourceWidth - srcX);\n    dstWidth = srcWidth;\n  }\n  if (srcWidth <= 0 || srcY <= -initialHeight || srcY > sourceHeight) {\n    srcY = 0;\n    srcHeight = 0;\n    dstY = 0;\n    dstHeight = 0;\n  } else if (srcY <= 0) {\n    dstY = -srcY;\n    srcY = 0;\n    srcHeight = Math.min(sourceHeight, initialHeight + srcY);\n    dstHeight = srcHeight;\n  } else if (srcY <= sourceHeight) {\n    dstY = 0;\n    srcHeight = Math.min(initialHeight, sourceHeight - srcY);\n    dstHeight = srcHeight;\n  }\n  var params = [srcX, srcY, srcWidth, srcHeight];\n  if (dstWidth > 0 && dstHeight > 0) {\n    var scale = width / initialWidth;\n    params.push(dstX * scale, dstY * scale, dstWidth * scale, dstHeight * scale);\n  }\n  </defineDrawingDimensions>\n\n  <performDrawImage>\n  context.drawImage.apply(context, [source].concat(toConsumableArray(params.map(function (param) {\n    return Math.floor(normalizeDecimalNumber(param));\n  }))));\n  </performDrawImage>\n\n  return canvas;\n}\n"], ["App", "\nfunction App() {\n  <initializeUI>\n  this.ui = {\n    'map': 'j-map',\n    'panel': 'j-panel',\n    'header': 'j-header',\n    'overlay': 'j-overlay'\n  };\n  </initializeUI>\n\n  <selectAppElement>\n  this.$app = document.getElementById('j-app');\n  </selectAppElement>\n\n  <instantiateModels>\n  this.map;\n  this.user = new User();\n  this.places = new Places();\n  this.checkin = Checkin;\n  </instantiateModels>\n\n  <definePages>\n  this._PAGES = ['dashboard', 'new_place', 'place_detailed', 'checkin'];\n  </definePages>\n\n  <setUpActivePageControl>\n  this._activePageName = '';\n  Object.defineProperty(this, 'activePage', {\n    set: function(params) {\n      var self = this;\n      self._PAGES.forEach(function(pName) {\n        self.$app.classList.remove(pName);\n      });\n      self.$app.classList.add(params.pageName);\n      self.renderPage(params.pageName, params.detailed);\n      this._activePageName = params.pageName;\n    },\n    get: function() {\n      return this._activePageName;\n    }\n  });\n  </setUpActivePageControl>\n\n  <initializeApp>\n  this._init();\n  </initializeApp>\n}\n"], ["mkScriptHashReplayScript", "\nfunction mkScriptHashReplayScript(address) {\n  <decodeAddress>\n  var addrHex = bs58check.decode(address).toString('hex');\n  var subAddrHex = addrHex.substring(4, addrHex.length);\n  </decodeAddress>\n\n  <constructScript>\n  return zopcodes.OP_DUP + zopcodes.OP_HASH160 + zbufferutils.getStringBufferLength(subAddrHex) + subAddrHex + zopcodes.OP_EQUALVERIFY + zopcodes.OP_CHECKSIG;\n  </constructScript>\n}\n"], ["initializeRecord", "\nfunction(records,config) {\n  this.id = new Date();\n  <processRecords>\n  if ( records instanceof Array ) {\n      this.records = records;\n  } else {\n      var dataField = records.data;\n      var data = records.datasource;\n      this.records =  data[dataField];\n  }\n  </processRecords>\n  <setUpConfig>\n  this.config = config;\n  if ( this.config ) {\n      this.propertyConfigMap = {};\n      this.config.cols.forEach( col => {\n          this.propertyConfigMap[col.property] = col;\n      });\n  }\n  </setUpConfig>\n}\n"], ["SemanticResponse", "\nfunction SemanticResponse (response, path) {\n  <assignSchemaAndHeaders>\n  this.schema = response.schema || null;\n  this.headers = response.headers || null;\n  </assignSchemaAndHeaders>\n\n  <determineEmptiness>\n  this.isEmpty = !response.schema;\n  </determineEmptiness>\n\n  <defaultCollectionAndWrapping>\n  this.isCollection = false;\n  this.isWrapped = false;\n  this.wrapperProperty = \"\";\n  </defaultCollectionAndWrapping>\n\n  <lastModifiedAndLocationDefaults>\n  this.lastModified = null;\n  this.location = \"\";\n  </lastModifiedAndLocationDefaults>\n\n  <setWrapperInfo>\n  if (!this.isEmpty) {\n    this.setWrapperInfo(response, path);\n  }\n  </setWrapperInfo>\n}\n"], ["CommandProcessor", "\nfunction CommandProcessor(conn) {\n  <inheritEventEmitter>\n  events.EventEmitter.call(this);\n  </inheritEventEmitter>\n\n  <initializeConnectionsAndTimeStamps>\n  this.conn = conn;\n  this.connected_at = +new Date();\n  this.last_data_at = 0;\n  this.last_ping_at = 0;\n  </initializeConnectionsAndTimeStamps>\n\n  <initializeTimeouts>\n  p.data_timeout = -1; \n  p.data_timeout_TID = null;\n  p.ping_timeout = -1; \n  p.ping_timeout_TID = null;\n  </initializeTimeouts>\n\n  <setupRequests>\n  this._request_id = 0;\n  this._requests_in_flight = {};\n  </setupRequests>\n\n  <setupConnectionEvents>\n  var _handle_disconnection = _.once(this._handle_disconnection.bind(this));\n  conn.on('data',  this.process_data.bind(this));\n  conn.on('error', _handle_disconnection);\n  conn.on('end',   _handle_disconnection); \n  conn.on('close', _handle_disconnection);\n  </setupConnectionEvents>\n\n  <initializeTimeoutHandlers>\n  this._emit_data_timeout = this._emit_data_timeout .bind(this);\n  this._emit_ping_timeout = this._emit_ping_timeout .bind(this);\n  this.set_timeouts();\n  </initializeTimeoutHandlers>\n}\n"], ["makeLineChartPath", "\nfunction makeLineChartPath(chart, width, t, maxValue, chartHeight, chartHeightOffset, markerRadius, pointsOnScreen) {\n  <makePath>\n  return makeLineOrAreaChartPath(chart, width, t, maxValue, chartHeight, chartHeightOffset, markerRadius, pointsOnScreen, false, false);\n  </makePath>\n}\n"], ["AppMessageListener", "\nfunction AppMessageListener(message) {\n  <processPID>\n  if (message.pid) { \n    dashboard.pid = message.pid\n    if (message.state === 'run'&& conf.signal) pidlink.getData(dashboard.pid, conf.id, pidLinkListener)\n  }\n  </processPID>\n  <processExitAndLaunch>\n  if (message.exit) dashboard.exitCode = message.exit\n  if (message.lastLaunch) dashboard.lastLaunch = message.lastLaunch\n  </processExitAndLaunch>\n  <handleStateChange>\n  if (message.state) {\n    dashboard.state = message.state\n    if (message.state === 'stop') {\n      watchers.deactivate() \n      dashboard.pid = 0\n    }\n    if (message.state === 'crash') {\n      \n      var previousCrash = dashboard.lastCrash\n      dashboard.lastCrash = message.lastExit\n      dashboard.crashCount++\n      dashboard.pid = 0\n      <recoveryDecision>\n      var doRecovery = !previousCrash \n      if (!doRecovery) { \n        var elapsed = Math.floor((dashboard.lastCrash - previousCrash) / 1000)\n        doRecovery = elapsed >= minSecondsCrashToCrash\n      }\n      if (doRecovery) appLink.recover()\n      </recoveryDecision>\n    }\n    if (message.state === 'run' ||\n      message.state === 'debug' ||\n      message.state === 'crash') {\n      watchers.activate()\n    }\n    updateDashboard()\n  }\n  </handleStateChange>\n}\n"], ["changedActiveItems", "\nfunction changedActiveItems(item) {\n  <handleNonDataflowURL>\n  if (!defined(item._dataflowUrl)) {\n    var shownDimensionCombinations = calculateShownDimensionCombinations(\n      item,\n      item._fullDimensions\n    );\n    var columns = item._tableStructure.columns.slice(\n      0,\n      shownDimensionCombinations.ids.length + item._numberOfInitialColumns\n    );\n    if (columns.length > 0) {\n      columns = columns.concat(\n        buildTotalSelectedColumn(item, shownDimensionCombinations)\n      );\n      updateColumns(item, columns);\n    }\n    return when();\n  } else {\n    <dataflowURLDataLoading>\n    var activeConceptIds = calculateActiveConceptIds(item);\n    var dimensionRequestString = calculateDimensionRequestString(\n      item,\n      activeConceptIds,\n      item._fullDimensions\n    );\n    if (!defined(dimensionRequestString)) {\n      return; \n    }\n    return loadAndBuildTable(item, dimensionRequestString);\n    </dataflowURLDataLoading>\n  }\n  </handleNonDataflowURL>\n}\n"], ["Compiler", "\nfunction Compiler(options) {\n  options = options || {};\n  Base.call(this, options);\n  this.indentation = options.indent;\n}\n"], "```"]