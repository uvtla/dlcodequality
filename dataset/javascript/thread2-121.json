[["getInheritedCollectionPaths", "\nfunction getInheritedCollectionPaths(node, name) {\n    var paths = [],\n        startNode = node,\n        actualNode = node,\n        endNode,\n        prefixNode,\n        i,\n        inverseOverlays,\n        target;\n\n    while (startNode) {\n        <resolveNodePaths>\n        actualNode = self.getBase(startNode);\n        endNode = self.getBase(getInstanceRoot(startNode));\n        target = '';\n        if (actualNode && endNode) {\n            prefixNode = node;\n            while (actualNode && actualNode !== self.getParent(endNode)) {\n                inverseOverlays = innerCore.getInverseOverlayOfNode(actualNode);\n                if (inverseOverlays[target] && inverseOverlays[target][name]) {\n                    for (i = 0; i < inverseOverlays[target][name].length; i += 1) {\n                        paths.push(self.joinPaths(self.getPath(prefixNode), inverseOverlays[target][name][i]));\n                    }\n                }\n                target = CONSTANTS.PATH_SEP + self.getRelid(actualNode) + target;\n                actualNode = self.getParent(actualNode);\n                prefixNode = self.getParent(prefixNode);\n            }\n        }\n        </resolveNodePaths>\n        startNode = self.getBase(startNode);\n    }\n\n    return paths;\n}\n"], ["allParams", "\nfunction allParams(req){\n  <mergeParamsAndQuery>\n  var params = req.params.all();\n  return _.merge(req.query, params);\n  </mergeParamsAndQuery>\n}\n"], ["setSelectionRange", "\nfunction(line, column, end, callback) {\n    if (this._textView) {\n        var model = this.getModel();\n        line = Math.max(0, Math.min(line, model.getLineCount() - 1));\n        var lineStart = model.getLineStart(line);\n        var start = 0;\n        if (end === undefined) {\n            end = 0;\n        }\n        if (typeof column === \"string\") { \n            var index = model.getLine(line).indexOf(column);\n            if (index !== -1) {\n                start = index;\n                end = start + column.length;\n            }\n        } else {\n            start = column;\n            var lineLength = model.getLineEnd(line) - lineStart;\n            start = Math.min(start, lineLength);\n            end = Math.min(end, lineLength);\n        }\n        this.moveSelection(lineStart + start, lineStart + end, callback);\n    }\n}\n"], ["validateBid", "\nfunction(bid) {\n    const siteId = bid.params.siteId || '';\n    if (!siteId) {\n      <logNoSiteError>\n      utils.logError(LOG_MSG.noSite);\n      </logNoSiteError>\n    }\n    <returnValidationResult>\n    return !!(bid.adUnitCode && siteId);\n    </returnValidationResult>\n}\n"], ["_fnInit", "\nfunction _fnInit( table, datatable, oInit, that )\n{\n    // The function is not compliant with SRP, so multiple tags will be used\n    _that = that;\n\n    <initDefaultOptions>\n    if ( typeof oInit == 'undefined' ) {\n        oInit = {};\n    }\n\n    if ( typeof oInit.focus == 'undefined' ) {\n        oInit.focus = [0,0];\n    }\n\n    oInit.table = table;\n    $(oInit.table).addClass('KeyTable');\n\n    if ( typeof oInit.focusClass != 'undefined' ) {\n        _sFocusClass = oInit.focusClass;\n    }\n\n    if ( typeof datatable != 'undefined' ) {\n        _oDatatable = datatable;\n    }\n\n    if ( typeof oInit.initScroll == 'undefined' ) {\n        oInit.initScroll = true;\n    }\n\n    if ( typeof oInit.form == 'undefined' ) {\n        oInit.form = false;\n    }\n    _bForm = oInit.form;\n    </initDefaultOptions>\n    \n    <setTableBody>\n    _nBody = oInit.table.getElementsByTagName('tbody')[0];\n    </setTableBody>\n\n    <handleKeyTableForm>\n    if ( _bForm )\n    // Contains logic specific to handling the form within the KeyTable\n    ...\n    </handleKeyTableForm>\n    \n    <setupEventHandlers>\n    $(document).bind( \"keydown\", _fnKey );\n\n    if ( _oDatatable )\n    {\n        $(_oDatatable.nTable).on( 'click', 'td', _fnClick );\n    }\n    else\n    {\n        $(_nBody).on( 'click', 'td', _fnClick );\n    }\n    \n    $(document).click( function(e) {\n        // Code to handle a document wide click event\n        ...\n    } );\n    </setupEventHandlers>\n}\n"], ["reorderItems", "\nfunction(originalIndex, newIndex) {\n      if(originalIndex < newIndex) {\n         this.items.splice(newIndex+1,0, this.items[originalIndex]);\n         this.items[originalIndex] = null;\n      }\n      else {\n         this.items.splice(newIndex,0, this.items[originalIndex]);\n         this.items[originalIndex+1] = null;\n      }      \n      <compactArray>\n      this.items = inputEx.compactArray(this.items);\n      </compactArray>\n      \n      <fireListReorderedEvent>\n      this.listReorderedEvt.fire();\n      </fireListReorderedEvent>\n}\n"], ["PASSIVE_TOUCH", "\nfunction PASSIVE_TOUCH(eventName) {\n  <determineEventOptions>\n  if (isMouseEvent(eventName) || eventName === 'touchend') {\n    return;\n  }\n  if (HAS_NATIVE_TA && SUPPORTS_PASSIVE && passiveTouchGestures) {\n    return {passive: true};\n  } else {\n    return;\n  }\n  </determineEventOptions>\n}\n"], ["listenPushNotification", "\nfunction listenPushNotification(callback) {\n    // This function has multiple responsibilities related to setting up push notifications.\n    if (callback === void 0) { callback = defaultPushCallback; }\n    ...\n}\n// Since the function is not compliant with SRP and contains numerous responsibilities, it is too complex to annotate in this format.\n"], ["processDocuments", "\nfunction( documents ) {\n    // This function has multiple responsibilities related to processing documents.\n    var key, document\n    ...\n}\n// Similar to the previous function, this one is also not compliant with SRP, and it's too complex to annotate specifically with simple tags.\n"], ["getHeightAuto", "\nfunction() {\n    <calculateHeight>\n    return this.attrs.height === AUTO ? (this.getTextHeight() * this.textArr.length * this.getLineHeight()) + this.getPadding() * 2 : this.attrs.height;\n    </calculateHeight>\n}\n"], "```\n\nFor the last two functions (`listenPushNotification` and `processDocuments`), SRP violations are indicated, but specific responsibilities are too intertwined to annotate clearly with tags due to the complexity and length of the functions."]