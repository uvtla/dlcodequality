[["compileDirective", "\nfunction compileDirective (node, scope) {\n        <initializeStructures>\n        var ast = {\n                attrs: {},\n                dires: {}\n            }\n        var dirtDefs = _getAllDirts()\n        </initializeStructures>\n\n        <processAttributes>\n        _slice(node.attributes).forEach(function(att) {\n            var aname = att.name\n            var v = att.value\n            \n            if (~componentProps.indexOf(aname)) {\n                return\n            } else if (_isExpr(aname)) {\n                \n                ast.attrs[aname] = v\n            } else if (aname.indexOf(NS) === 0) {\n                var def = dirtDefs[aname]\n                if (def) {\n                    \n                    ast.dires[aname] = {\n                        def: def,\n                        expr: v\n                    }\n                } else {\n                    return\n                }\n            } else if (_isExpr(v.trim())) {\n                \n                ast.attrs[aname] = v\n            } else {\n                return\n            }\n            node.removeAttribute(aname)\n        })\n        </processAttributes>\n\n        <createAttributeDirectives>\n        util.objEach(ast.attrs, function(name, value) {\n            var attd = new AttributeDirective(vm, scope, node, name, value)\n            _directives.push(attd)\n            _setBindings2Scope(scope, attd)\n        })\n        </createAttributeDirectives>\n\n        <createDirectives>\n        util.objEach(ast.dires, function(dname, spec) {\n            var def = spec.def\n            var expr = spec.expr\n            var sep = ';'\n            var d\n            \n            if (def.multi && expr.match(sep)) {\n                Expression.strip(expr)\n                        .split(sep)\n                        .forEach(function(item) {\n                            \n                            if (!item.trim()) return\n                            \n                            d = new Directive(vm, scope, node, def, dname, '{' + item + '}')\n                            _directives.push(d)\n                            _setBindings2Scope(scope, d)\n                        })\n            } else {\n                d = new Directive(vm, scope, node, def, dname, expr)\n                _directives.push(d)\n                _setBindings2Scope(scope, d)\n            }\n        })\n        </createDirectives>\n    }\n"], ["getTouchList", "\nfunction getTouchList(ev, eventType) {\n    <handlePointerEvents>\n    if (GestureDetector.HAS_POINTEREVENTS) {\n      return PointerEvent.getTouchList();\n    }\n    </handlePointerEvents>\n\n    <processTouchEvent>\n    if (ev.touches) {\n      if (eventType == EVENT_MOVE) {\n        return ev.touches;\n      }\n\n      <initializeIdentifiers>\n      var identifiers = [];\n      var concat = [].concat(Utils.toArray(ev.touches), Utils.toArray(ev.changedTouches));\n      var touchList = [];\n      </initializeIdentifiers>\n\n      <createTouchList>\n      Utils.each(concat, function(touch) {\n        if (Utils.inArray(identifiers, touch.identifier) === -1) {\n          touchList.push(touch);\n        }\n        identifiers.push(touch.identifier);\n      });\n      </createTouchList>\n\n      return touchList;\n    }\n    </processTouchEvent>\n\n    <createDefaultEvent>\n    ev.identifier = 1;\n    return [ev];\n    </createDefaultEvent>\n  }\n"], ["retrieveModels", "\nfunction(req, res) {\n            <collectModelInfo>\n            var models = [];\n            for (modelName in onmModelDictionary) {\n                models.push({\n                    modelName: modelName,\n                    modelPackage: onmModelDictionary[modelName].package\n                });\n            }\n            </collectModelInfo>\n            <sendResponse>\n            res.send(200, models);\n            </sendResponse>\n        }\n"], ["bufferCountOperator", "\nfunction bufferCount(bufferSize, startBufferEvery) {\n    <setDefault>\n    if (startBufferEvery === void 0) {\n        startBufferEvery = null;\n    }\n    </setDefault>\n    <returnOperatorFunction>\n    return function bufferCountOperatorFunction(source) {\n        return source.lift(new BufferCountOperator(bufferSize, startBufferEvery));\n    };\n    </returnOperatorFunction>\n}\n"], ["takeOff", "\nfunction takeOff(options, callback) {\n  <handleFunctionOverloading>\n  if (typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n  </handleFunctionOverloading>\n  this.logger('RollingSpider#takeOff');\n\n  <checkBatteryStatus>\n  if (this.status.battery < 10) {\n    this.logger('!!! BATTERY LEVEL TOO LOW !!!');\n  }\n  </checkBatteryStatus>\n  <initiateTakeOff>\n  if (!this.status.flying) {\n    this.writeTo(\n      'fa0b',\n      new Buffer([0x02, ++this.steps.fa0b & 0xFF, 0x02, 0x00, 0x01, 0x00])\n    );\n    this.status.flying = true;\n  }\n  </initiateTakeOff>\n\n  <handleStatusChange>\n  this.on('flyingStatusChange', function(newStatus) {\n    if (newStatus === 2) {\n      <executeCallback>\n      if (typeof callback === 'function') {\n        callback();\n      }\n      </executeCallback>\n    }\n  });\n  </handleStatusChange>\n\n}\n"], ["getComponentName", "\nfunction getComponentName(destPath) {\n  <preprocessPath>\n  const splitregex = new RegExp(`[\\\\${path.sep}-]+`);\n\n  const parts = destPath\n    .replace('.js', '')\n    .split(splitregex)\n    .map(part => part.charAt(0).toUpperCase() + part.substring(1));\n  </preprocessPath>\n\n  <concatenateParts>\n  return parts.join('');\n  </concatenateParts>\n}\n"], ["submitData", "\nfunction () {\n          <initializeVars>\n          var self = this;\n          var ref = self.$ref();\n          var data = $wilddogUtils.toJSON(self);\n          </initializeVars>\n          <updateData>\n          return $wilddogUtils.doSet(ref, data).then(function() {\n            self.$$notify();\n            return self.$ref();\n          });\n          </updateData>\n        }\n"], ["sendResetPasswordEmail", "\nfunction(userEmailToReset) {\n                <logActivity>\n                console.log('iamInterface.users.sendResetPasswordEmail', userEmailToReset);\n                </logActivity>\n                <createQueryString>\n                var query = 'email=' + encodeURIComponent(userEmailToReset);\n                </createQueryString>\n                <submitRequest>\n                return this.request({\n                    url: this._buildUriWithDomain(this.uri + '/resetPassword'),\n                    method: corbel.request.method.GET,\n                    query: query\n                });\n                </submitRequest>\n            }\n"], ["readProtocol", "\nfunction(options) {\n        <applyProtocolDefaults>\n        OpenLayers.Protocol.prototype.read.apply(this, arguments);\n        options = options || {};\n        options.params = OpenLayers.Util.applyDefaults(\n            options.params, this.options.params);\n        options = OpenLayers.Util.applyDefaults(options, this.options);\n        if (options.filter && this.filterToParams) {\n            options.params = this.filterToParams(\n                options.filter, options.params\n            );\n        }\n        </applyProtocolDefaults>\n        <determineReadMethod>\n        var readWithPOST = (options.readWithPOST !== undefined) ?\n                           options.readWithPOST : this.readWithPOST;\n        </determineReadMethod>\n        <initializeResponse>\n        var resp = new OpenLayers.Protocol.Response({requestType: \"read\"});\n        </initializeResponse>\n        <handleRequest>\n        if(readWithPOST) {\n            var headers = options.headers || {};\n            headers[\"Content-Type\"] = \"application/x-www-form-urlencoded\";\n            resp.priv = OpenLayers.Request.POST({\n                url: options.url,\n                callback: this.createCallback(this.handleRead, resp, options),\n                data: OpenLayers.Util.getParameterString(options.params),\n                headers: headers\n            });\n        } else {\n            resp.priv = OpenLayers.Request.GET({\n                url: options.url,\n                callback: this.createCallback(this.handleRead, resp, options),\n                params: options.params,\n                headers: options.headers\n            });\n        }\n        </handleRequest>\n        return resp;\n    }\n"], ["getBanner", "\nfunction getBanner (packagePath) {\n  <loadPackageInfo>\n  const pkg = require(packagePath)\n  const { name, version, license } = pkg\n  </loadPackageInfo>\n\n  <extractURL>\n  const url = pkg.homepage.replace(/#.*$/, '')\n  </extractURL>\n\n  <generateBanner>\n  \n  \n  return ``\n  </generateBanner>\n}\n"], ""]