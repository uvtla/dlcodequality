[["buttonEmphasize", "\nfunction buttonEmphasize(e) {\n  <updateButtonStyles>\n  for (var n = 0; n < buttons.length; n++) {\n    if (vars[buttons[n].name] && buttons[n].emphasis && buttons[n].tag != '')\n      detectElement(buttons[n].tag) ? toolbar.find('.' + vars.css + '_tool_' + buttons[n].cls).addClass(emphasize) : $('.' + vars.css + '_tool_' + buttons[n].cls).removeClass(emphasize);\n  }\n  </updateButtonStyles>\n\n  <checkTextFormats>\n  if (vars.format && $.isArray(vars.formats)) {\n    var isFoundFormat = false;\n\n    for (var f = 0; f < vars.formats.length; f++) {\n      var thisFormat = [];\n      thisFormat[0] = vars.formats[f][0];\n\n      if (vars.formats[f][0].length > 0 && detectElement(thisFormat)) {\n        formatLabelView(vars.formats[f][1]);\n\n        isFoundFormat = true;\n        break;\n      }\n    }\n\n    if (!isFoundFormat)\n      formatLabelView(vars.formats[0][1]);\n  }\n  </checkTextFormats>\n\n  <switchStyles>\n  styleFieldSwitch(\"\", false);\n  formatFieldSwitch(false);\n  </switchStyles>\n}\n"], ["parseObj", "\nfunction parseObj(opts) {\n  var obj = new Obj();\n\n  <assignProperties>\n  Object.keys(opts).forEach(function (key) {\n    obj[key] = opts[key];\n  });\n  </assignProperties>\n\n  return obj;\n}\n"], ["removeGroup", "\nfunction (group, containersAsWell) {\n  var index = this.groups.indexOf(group), i;\n\n  <removeFromGroups>\n  if (index != -1) {\n    this.groups.splice(index, 1);\n  }\n  </removeFromGroups>\n\n  <handleAssociatedContainers>\n  if (containersAsWell) {\n    if (YAHOO.lang.isValue(group.groupContainer)) {\n      this.removeContainer(group.groupContainer);\n    } else {\n      for (i in group.containers) {\n        if (group.containers.hasOwnProperty(i)) {\n          var elem = group.containers[i].container;\n          this.removeContainer(elem);\n        }\n      }\n\n      for (i in group.groups) {\n        if (group.containers.hasOwnProperty(i)) {\n          var g = group.groups[i].group;\n          this.removeGroup(g);\n        }\n      }\n    }\n  }\n  </handleAssociatedContainers>\n}\n"], ["knRestifyHandler", "\nfunction knRestifyHandler(args) {\n  var svc = new knServiceContext(args);\n\n  return (function (request, response, next) {\n    <handleRequest>\n    knHandleRequest(svc, request, response, next);\n    </handleRequest>\n  });\n}\n"], ["stopObserver", "\nfunction () {\n  var self = this;\n  if (self._stopped)\n    return;\n  self._stopped = true;\n\n  <stopHandles>\n  _.each(self._stopHandles, function (handle) {\n    handle.stop();\n  });\n  </stopHandles>\n\n\n  <clearProperties>\n  _.each(self._writesToCommitWhenWeReachSteady, function (w) {\n    w.committed();\n  });\n  self._writesToCommitWhenWeReachSteady = null;\n\n  \n  self._published = null;\n  self._unpublishedBuffer = null;\n  self._needToFetch = null;\n  self._currentlyFetching = null;\n  self._oplogEntryHandle = null;\n  self._listenersHandle = null;\n\n  Package.facts && Package.facts.Facts.incrementServerFact(\n    \"mongo-livedata\", \"observe-drivers-oplog\", -1);\n  </clearProperties>\n}\n"], ["gulpInjectStringifiedHtml", "\nfunction gulpInjectStringifiedHtml(params) {\n  return through.obj(function (file, enc, cb) {\n\n    if (file.isNull()) {\n      return cb(null, file);\n    }\n\n    <handleFileStreams>\n    if (file.isStream()) {\n      file.contents = file.contents.pipe(new bufferstreams(function (err, buf, cb) {\n        if (err) throw err;\n        cb(null, doInjectHtml(buf.toString(), file, params));\n      }));\n      cb(null, file);\n    }\n    </handleFileStreams>\n\n    <handleFileBuffers>\n    if (file.isBuffer()) {\n      file.contents = doInjectHtml(file.contents.toString(), file, params);\n      cb(null, file);\n    }\n    </handleFileBuffers>\n\n  });\n}\n"], ["UnaryFilter", "\nfunction UnaryFilter(properties) {\n  if (properties)\n    <assignProperties>\n    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n      if (properties[keys[i]] != null)\n        this[keys[i]] = properties[keys[i]];\n    </assignProperties>\n}\n"], ["addOverlay", "\nfunction (element, location, placement, onDraw) {\n  var options;\n  <prepareOptions>\n  if ($.isPlainObject(element)) {\n    options = element;\n  } else {\n    options = {\n      element: element,\n      location: location,\n      placement: placement,\n      onDraw: onDraw\n    };\n  }\n  </prepareOptions>\n\n  element = $.getElement(options.element);\n\n  <avoidDuplicateOverlays>\n  if (getOverlayIndex(this.currentOverlays, element) >= 0) {\n    \n    return this;\n  }\n  </avoidDuplicateOverlays>\n\n  <createAndDrawOverlay>\n  var overlay = getOverlayObject(this, options);\n  this.currentOverlays.push(overlay);\n  overlay.drawHTML(this.overlaysContainer, this.viewport);\n  </createAndDrawOverlay>\n\n  <triggerAddOverlayEvent>\n  this.raiseEvent('add-overlay', {\n    element: element,\n    location: options.location,\n    placement: options.placement\n  });\n  </triggerAddOverlayEvent>\n  return this;\n}\n"], ["combineResults", "\nfunction () {\n  var level = this.$level === 0 ? 0 : this.$level - 1;\n\n  <storeArgumentsAsResults>\n  if (arguments.length > 0) {\n    this.$results[level] = [];\n    for (var i = 0; i < arguments.length; i++) {\n      this.$results[level][i] = arguments[i];\n    }\n  } else {\n    var $this = this,\n        index = this.$busy++;\n\n    return function () {\n      if ($this.$results[level] === null || $this.$results[level] === undefined) {\n        $this.$results[level] = [];\n      }\n\n      <storeCallbackResults>\n      if ($this.$busy > 0) {\n        var i = 0;\n\n        if (arguments.length > 0) {\n          $this.$results[level][index] = [];\n          for (i = 0; i < arguments.length; i++) {\n            $this.$results[level][index][i] = arguments[i];\n          }\n        }\n      </storeCallbackResults>\n\n      <scheduleNextTask>\n      if (--$this.$busy === 0) {\n        if ($this.$results[level].length > 0) {\n          var args = $this.$results[level],\n              res = [];\n\n          for (i = 0; i < args.length; i++) {\n            Array.prototype.push.apply(res, args[i]);\n          }\n          $this.$results[level] = res;\n        }\n\n        $this.$schedule();\n      }\n      </scheduleNextTask>\n    };\n  }\n}\n"], ["isItemTag", "\nfunction isItemTag(tagName, prefix, local, feedType) {\n  return tagName === 'item' || tagName === 'entry' ||\n    (local === 'item' && (prefix === '' || feedType === 'rdf')) ||\n    (local === 'entry' && (prefix === '' || feedType === 'atom'));\n}\n"], "```\n- It's a single responsibility function to determine if a given tag name corresponds to an item or an entry tag. It's SRP compliant."]