[["compile", "\nfunction compile(\n  source,\n  filename = '',\n  includeModule = false,\n  debugMode = false,\n) {\n  <compileInitialization>\n  let res\n  let resName\n  let errors\n  </compileInitialization>\n\n  <compileProcess>\n  try {\n    const [moduleName, bsCode, diagnosticErrors] = Retyped.compile(filename, source, debugMode)\n    const fmtCode = format(bsCode)\n    res = fmtCode\n    resName = moduleName\n    errors = diagnosticErrors\n  } catch (e) {\n    console.error(e)\n    throw new Error(`${e[0][0]}`)\n  }\n\n  if (res.includes('SYNTAX ERROR>')) {\n    throw new Error(res)\n  }\n  </compileProcess>\n\n  <compileReturn>\n  if (!includeModule) {\n    return res\n  } else {\n    return {\n      moduleName: resName,\n      bsCode: res,\n      diagnosticErrors: errors\n    }\n  }\n  </compileReturn>\n}\n"], ["mapHeader", "\nfunction mapHeader (h) {\n  <mapHeaderValidation>\n  if (h === undefined) return undefined;\n  </mapHeaderValidation>\n\n  <mapHeaderTransformation>\n  return {\n    test: toBoolean(getElementText(h, 'Test', mes)),\n    id: getElementText(h, 'ID', mes)),\n    prepared: getElementText(h, 'Prepared', mes)),\n    sender: mapParty(_getFirstChildNS(h, 'Sender', mes)),\n    receiver: mapParty(_getFirstChildNS(h, 'Receiver', mes))\n  };\n  </mapHeaderTransformation>\n}\n"], ["parseStringSeedlist", "\nfunction parseStringSeedlist(seedlist) {\n  return seedlist.split(',').map(seed => ({\n    host: seed.split(':')[0],\n    port: seed.split(':')[1] || 27017\n  }));\n}\n"], ["syncRoutes", "\nasync function syncRoutes (dir, routes, opts) {\n  <syncRoutesGeneration>\n  let text = routes.map(it => {\n    return `\\tapp.Handle(\"${it.modalName}\", \"${it.actionName}\", func(ctx interface{}, ctrl sav.Controller, handler sav.DataHandler, extra interface{}) {\n${it.routeBody}\n\\t})`\n  }).join('\\n')\n  let data = `${noticeString}package ${opts.packageName}\n\nimport (\n\\t\"github.com/savfx/savgo/sav\"\n\\t\"github.com/savfx/savgo/server/sgin\"\n\\t\"github.com/savfx/savgo/util/convert\"\n)\n\nfunc registerRoutes(app sgin.GinApplication) {\n${text}\n}\n`\n  </syncRoutesGeneration>\n\n  <syncRoutesFileOperations>\n  let file = path.resolve(dir, 'routes.go')\n  if (await pathExists(file)) {\n    let src = await inputFile(file)\n    if (data === src.toString()) {\n      return\n    }\n  }\n  await outputFile(file, data)\n  </syncRoutesFileOperations>\n}\n"], ["unnamedTimeStampFunction", "\nfunction (timestamp) {\n  <unnamedTimeStampFunctionProcessing>\n  var time = (new Date(timestamp)).toISOString();\n  return {\n      msg       : time,\n      msgLength : time.length\n  };\n  </unnamedTimeStampFunctionProcessing>\n}\n"], ["needBuild", "\nfunction needBuild(mode, system, cdef, out, cb) {\n  <needBuildCommandGeneration>\n  var cmds = commands(os.platform());\n  var tag = cmds.generateTag(config, system, cdef);\n  var baseUrl = 'http:';\n  var url = tag.replace(config.registry, baseUrl) + '/tags';\n  </needBuildCommandGeneration>\n\n  <needBuildRequest>\n  request({ url: url, json: true }, function(err, res, body) {\n    if (err) { return cb(err); }\n    cb(null, Object.keys(body).length === 0 ? cdef : null);\n  });\n  </needBuildRequest>\n}\n"], ["unnamedTimegroupInitialization", "\nfunction () {\n  <unnamedTimegroupInitializationDOMManipulation>\n  this._el.message = TL.Dom.create(\"div\", \"tl-timegroup-message\", this._el.container);\n  this._el.message.innerHTML = this.data.label;\n  </unnamedTimegroupInitializationDOMManipulation>\n}\n"], ["unnamedConfigurationInitialization", "\nfunction(baseDir, config) {\n  <unnamedConfigurationInitializationAssignments>\n  this._baseDir = baseDir;\n  this._config = _.merge({}, DEFAULT_CONFIG, config);\n  this._folderPercentages = {};\n  </unnamedConfigurationInitializationAssignments>\n}\n"], ["sshKeyToPEM", "\nfunction sshKeyToPEM(key) {\n  <sshKeyToPEMValidationConversion>\n  assert.string(key, 'ssh_key');\n  var k = sshpk.parseKey(key, 'ssh');\n  return (k.toString('pem'));\n  </sshKeyToPEMValidationConversion>\n}\n"], ["injectAttribute", "\nfunction injectAttribute(attrNameToInject) {\n  <injectAttributeValidations>\n  ngDevMode && assertPreviousIsParent();\n  ngDevMode && assertNodeType(lElement, 3 );\n  ngDevMode && assertDefined(tElement, 'expecting tNode');\n  </injectAttributeValidations>\n\n  <injectAttributeExtraction>\n  var lElement = getPreviousOrParentNode();\n  var tElement = lElement.tNode;\n  var attrs = tElement.attrs;\n  if (attrs) {\n      for (var i = 0; i < attrs.length; i = i + 2) {\n          var attrName = attrs[i];\n          if (attrName === 1 )\n              break;\n          if (attrName == attrNameToInject) {\n              return attrs[i + 1];\n          }\n      }\n  }\n  </injectAttributeExtraction>\n  \n  <injectAttributeDefaultReturn>\n  return undefined;\n  </injectAttributeDefaultReturn>\n}\n"], ""]