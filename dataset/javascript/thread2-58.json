[["webpackInheritanceMechanism", "\nfunction(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t<setupInheritance>\n\tvar __extends = (this && this.__extends) || function (d, b) {\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\t    function __() { this.constructor = d; }\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t};\n\t</setupInheritance>\n\tvar Subscriber_1 = __webpack_require__(8);\n\tvar Subscription_1 = __webpack_require__(10);\n\t\n\t<defineFinallyMethod>\n\tfunction _finally(callback) {\n\t    return this.lift(new FinallyOperator(callback));\n\t}\n\texports._finally = _finally;\n\t</defineFinallyMethod>\n\tvar FinallyOperator = (function () {\n\t    function FinallyOperator(callback) {\n\t        this.callback = callback;\n\t    }\n\t    FinallyOperator.prototype.call = function (subscriber, source) {\n\t        return source._subscribe(new FinallySubscriber(subscriber, this.callback));\n\t    };\n\t    return FinallyOperator;\n\t}());\n\t\n\tvar FinallySubscriber = (function (_super) {\n\t    __extends(FinallySubscriber, _super);\n\t    function FinallySubscriber(destination, callback) {\n\t        _super.call(this, destination);\n\t        this.add(new Subscription_1.Subscription(callback));\n\t    }\n\t    return FinallySubscriber;\n\t}(Subscriber_1.Subscriber));\n\t\n }\n"], ["rawgitUrlCreation", "\nfunction rawgit( options ) {\n\tvar opts;\n\tvar err;\n\t\n\t<optionsManipulation>\n\topts = copy( defaults );\n\terr = validate( opts, options );\n\tif ( err ) {\n\t\tthrow err;\n\t}\n\topts.slug = opts.slug.replace( DANGLING_SLASH, '' );\n\topts.file = opts.file.replace( FILEPATH_PREFIX, '' );\n\t</optionsManipulation>\n\n\treturn url( opts );\n}\n"], ["colorFormatting", " \nfunction chalk(srcStr, color) {\n      <defaultColorCheck>\n      if (!has(colorList, color)) color = 'default';\n      </defaultColorCheck>\n      return colorList[color].replace(/%s/, srcStr);\n    }\n"], ["directiveFiltering", "\nfunction (response, type) {\n\t\t'use strict';\n\t\tlet directives = response.response.directives;\n\t\tif (directives) {\n\t\t\tfor (let i = 0; i < directives.length; i++) {\n\t\t\t\tif (directives[i].type === type) {\n\t\t\t\t\treturn directives[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn undefined;\n\t}\n"], ["scalarTypesEnhancement", "\nfunction defineScalarTypes(schema: GraphQLSchema): void {\n  Object.entries(scalarTypeDefinitions).forEach(([typeName, definition]) => {\n    const type = schema.getType(typeName);\n    Object.assign(type._scalarConfig, definition);\n  });\n}\n"], ["mutableUpdate", "\nfunction (subpath, newValue) {\n    var args = Util.resolveArgs(arguments, '?subpath', 'newValue');\n    update(this, args.subpath, Util.constantly(args.newValue));\n    return this;\n  }\n"], ["oauthLinkingOrCreation", "\nfunction oauth(id, username, email, req, done) {\n\t<linkAccountCheck>\n\tif (req.params[\"0\"] === \"/link\") {\n\t\treturn done(null, {\n\t\t\t__linkUser: true,\n\t\t\temail: email,\n\t\t\tusername: username,\n\t\t\tid: id\n\t\t});\n\t}\n\t</linkAccountCheck>\n\t<getUser>\n\tfileUtil.getMetastoreSafe(req).then(function(store) {\n\t\tstore.getUserByOAuth(id, function(err, user) {\n\t\t\tif (err) {\n\t\t\t\treturn done(err);\n\t\t\t}\n\t\t\tif (!user) {\n\t\t\t\t<createNewUser>\n\t\t\t\treturn done(null, {\n\t\t\t\t\t__newUser: true,\n\t\t\t\t\temail: email,\n\t\t\t\t\tusername: username,\n\t\t\t\t\tid: id\n\t\t\t\t});\n\t\t\t\t</createNewUser>\n\t\t\t}\n\t\t\tdone(null, user);\n\t\t}, function noMetastore(err) {\n\t\t\tdone(err);\n\t\t});\n\t});\n\t</getUser>\n}\n"], ["databaseTableReflection", "\nfunction (tableName, opts) {\n            var m = this.outputIdentifierFunc, im = this.inputIdentifierFunc, self = this;\n            <metadataQuery>\n            return this.metadataDataset.withSql(\"DESCRIBE ?\", sql.identifier(im(tableName))).map(function (row) {\n                var ret = {};\n                var e = row[m(\"Extra\")];\n                var allowNull = row[m(\"Null\")];\n                var key = row[m(\"Key\")];\n                ret.autoIncrement = e.match(/auto_increment/i) !== null;\n                ret.allowNull = allowNull.match(/Yes/i) !== null;\n                ret.primaryKey = key.match(/PRI/i) !== null;\n                var defaultValue = row[m(\"Default\")];\n                ret[\"default\"] = Buffer.isBuffer(defaultValue) ? defaultValue.toString() : defaultValue;\n                if (isEmpty(row[\"default\"])) {\n                    row[\"default\"] = null;\n                }\n                ret.dbType = row[m(\"Type\")];\n                if (Buffer.isBuffer(ret.dbType)) {\n                    \n                    ret.dbType = ret.dbType.toString();\n                }\n                ret.type = self.schemaColumnType(ret.dbType.toString(\"utf8\"));\n                var fieldName = m(row[m(\"Field\")]);\n                return [fieldName, ret];\n            });\n            </metadataQuery>\n        }\n"], ["textContentModification", "\nfunction (text, start, end, show, callback) {\n\t\t\tvar isSingle = typeof text === \"string\"; \n\t\t\tvar reset = start === undefined && end === undefined && isSingle;\n\t\t\tvar edit;\n\t\t\tif (isSingle) {\n\t\t\t\t<prepareSingleEdit>\n\t\t\t\tif (start === undefined) { start = 0; }\n\t\t\t\tif (end === undefined) { end = this._model.getCharCount(); }\n\t\t\t\tedit = {text: text, selection: [new Selection(start, end, false)]};\n\t\t\t\t</prepareSingleEdit>\n\t\t\t} else {\n\t\t\t\tedit = text;\n\t\t\t\t<convertRangesToSelections>\n\t\t\t\tedit.selection = this._rangesToSelections(edit.selection);\n\t\t\t\t</convertRangesToSelections>\n\t\t\t}\n\t\t\tedit._code = true;\n\t\t\t<performTextModification>\n\t\t\tif (reset) {\n\t\t\t\tthis._variableLineHeight = false;\n\t\t\t}\n\t\t\tthis._modifyContent(edit, !reset, show === undefined || show, callback);\n\t\t\tif (reset) {\n\t\t\t\t\n\t\t\t\tif (util.isFirefox < 13) {\n\t\t\t\t\tthis._fixCaret();\n\t\t\t\t}\n\t\t\t}\n\t\t\t</performTextModification>\n\t\t}\n"], ["ruleMatching", "\nfunction _match (rule, cmtData) {\n        var path = rule.subject.split('.');\n        <dataExtraction>\n        var extracted = cmtData;\n        while (path.length > 0) {\n            var item = path.shift();\n            if (item === '') {\n                continue;\n            }\n            if (extracted.hasOwnProperty(item)) {\n                extracted = extracted[item];\n            }\n            if (extracted === null || typeof extracted === 'undefined') {\n                extracted = null;\n                break;\n            }\n        }\n        if (extracted === null) {\n            \n            return true;\n        }\n        </dataExtraction>\n        <evaluateMatch>\n        switch (rule.op) {\n            case '<':\n                return extracted < rule.value;\n            case '>':\n                return extracted > rule.value;\n            case '~':\n            case 'regexp':\n                return (new RegExp(rule.value)).test(extracted.toString());\n            case '=':\n            case 'eq':\n                return rule.value ===\n                    ((typeof extracted === 'number') ?\n                        extracted : extracted.toString());\n            case '!':\n            case 'not':\n                return !_match(rule.value, extracted);\n            case '&&':\n            case 'and':\n                if (Array.isArray(rule.value)) {\n                    return rule.value.every(function (r) {\n                        return _match(r, extracted);\n                    });\n                } else {\n                    return false;\n                }\n            case '||':\n            case 'or':\n                if (Array.isArray(rule.value)) {\n                    return rule.value.some(function (r) {\n                        return _match(r, extracted);\n                    });\n                } else {\n                    return false;\n                }\n            default:\n                return false;\n        }\n        </evaluateMatch>\n    }\n"], "```"]