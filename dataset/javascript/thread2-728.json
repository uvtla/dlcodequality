[["collectRules", "\nfunction collectRules(category) {\n    return rules.reduce((obj, rule) => {\n        if (!category || rule.meta.docs.category === category) {\n            obj[rule.meta.docs.ruleId] = \"error\"\n        }\n        return obj\n    }, {})\n}\n"], ["anonymousFunction", "\nfunction (column) {\n    if (isString(column.type) && column.type.match(/string/i) && column.text) {\n        delete column[\"default\"];\n    }\n    return this._super(arguments, [column]);\n}\n"], ["anonymousFunction2", "\nfunction () {\n    \n    this.$raiseEvent(\"beforeRemoveContent\");\n    \n    \n    this._removingContent = true;\n    <removeContentLoop>\n    var content = this._content;\n    var contentLength = content.length;\n    for (var i = 0; i < contentLength; i++) {\n        var elt = content[i];\n        if (elt._type == TYPE_BEHAVIOR) {\n            var bhv = elt.behavior;\n            if (elt.id && this.idMap) {\n                this.idMap[elt.id] = null;\n                delete this.idMap[elt.id];\n            }\n            bhv.$dispose();\n        } else {\n            elt.$dispose();\n        }\n    }\n    </removeContentLoop>\n    this._content = [];\n    this._initWidgetsDone = false;\n    this._removingContent = false;\n    this.$raiseEvent(\"afterRemoveContent\");\n}\n"], ["ensureArgsInstanceOf", "\nfunction( arg, instance, defaultValue ) {\n    'use strict';\n    \n    \n    if ( Array.isArray( arg ) ) {\n        for ( var i = arg.length - 1; i >= 0; --i ) {\n            if ( instance !== undefined && arg[ i ] instanceof instance === false ) {\n                return defaultValue;\n            }\n        }\n\n        return arg;\n    }\n    \n    \n    return this.ensureInstanceOf( arg, instance, defaultValue );\n}\n"], ["histogram1D", "\nfunction histogram1D(length, init){\n    var hist1D; \n    if(length instanceof Array){\n        hist1D = length;\n    }else {\n        init = typeof init !== 'undefined' ? init : 0; \n        hist1D = [];\n        for(var x = 0; x< length; ++x){ \n            hist1D[x] = init;   \n        }\n    }\n    hist1D.max = histogram1DFunctions.max;\n    hist1D.min = histogram1DFunctions.min;\n    hist1D.cv = histogram1DFunctions.cv;\n    hist1D.medianSmoothing = histogram1DFunctions.medianSmoothing;\n    hist1D.gaussianSmoothing = histogram1DFunctions.gaussianSmoothing;\n    hist1D.flatten = histogram1DFunctions.flatten;\n    hist1D.findPeaks = histogram1DFunctions.findPeaks;\n    return hist1D;\n}\n"], ["Neo4jKB", "\nfunction Neo4jKB(options) {\n  options = options || {};\n  if (!_.has(options, 'NEO4J_AUTH')) {\n    throw new Error(\"You must at least supply a NEO4J_AUTH: '<username>:<password>' JSON argument.\")\n  };\n  this.options = options;\n  \n  this.query = require('./query')(options)\n\n  \n  this.literalize = literalize\n  this.addNode = addNode\n  this.getNode = getNode\n  this.addEdge = addEdge\n  this.getEdge = getEdge\n  this.pull = pull\n  this.get = get\n  this.push = push\n  this.add = add\n\n  \n  this.cons = cons\n\n  \n  _.assign(this, parse)\n\n  return this\n}\n"], ["equals", "\nfunction equals(value1, value2, traversedValues) {\n  \n  <valueComparison>\n  if (!(value1 instanceof Object)) {\n    return value1 === value2\n  }\n  </valueComparison>\n  \n  <wrappedTypeComparison>\n  for (let wrappedType of WRAPPED_TYPES) {\n    if (value1 instanceof wrappedType) {\n      return (value2 instanceof wrappedType) &&\n          (value1.valueOf() === value2.valueOf())\n    }\n  }\n  </wrappedTypeComparison>\n  \n  <regexComparison>\n  if (value1 instanceof RegExp) {\n    return (value2 instanceof RegExp) &&\n        (value1.source === value2.source) &&\n        (value2.flags === value2.flags)\n  }\n  </regexComparison>\n  \n  <uninspectableTypeComparison>\n  for (let uninspectableType of UNINSPECTABLE_TYPES) {\n    if (value1 instanceof uninspectableType) {\n      return (value2 instanceof uninspectableType) &&\n          (value1 === value2)\n    }\n  }\n  </uninspectableTypeComparison>\n  \n  <arrayBufferComparison>\n  if ((typeof ArrayBuffer === \"function\") && (value1 instanceof ArrayBuffer)) {\n    return (value2 instanceof ArrayBuffer) &&\n        equals(new Int8Array(value1), new Int8Array(value2), traversedValues)\n  }\n  </arrayBufferComparison>\n\n  <dataViewComparison>\n  if ((typeof DataView === \"function\") && (value1 instanceof DataView)) {\n    return (value2 instanceof DataView) &&\n        equals(\n          new Int8Array(value1.buffer, value1.byteOffset, value1.byteLength),\n          new Int8Array(value2.buffer, value2.byteOffset, value2.byteLength),\n          traversedValues\n        )\n  }\n  </dataViewComparison>\n  \n  <typedArrayComparison>\n  for (let arrayType of TYPED_ARRAY_TYPES) {\n    if (value1 instanceof arrayType) {\n      return (value2 instanceof arrayType) &&\n          arrayEquals(value1, value2, traversedValues)\n    }\n  }\n  </typedArrayComparison>\n  \n  <imageDataComparison>\n  if ((typeof ImageData === \"function\") && (value1 instanceof ImageData)) {\n    return (value2 instanceof ImageData) &&\n        (value1.width === value2.width) &&\n        (value1.height === value2.height) &&\n        equals(value1.data, value2.data, traversedValues)\n  }\n  </imageDataComparison>\n  \n  <arrayComparison>\n  if (value1 instanceof Array) {\n    return (value2 instanceof Array) &&\n        arrayEquals(value1, value2, traversedValues)\n  }\n  </arrayComparison>\n  \n  <mapComparison>\n  if (value1 instanceof Map) {\n    return mapEquals(value1, value2, traversedValues)\n  }\n  </mapComparison>\n  \n  <setComparison>\n  if (value1 instanceof Set) {\n    return setEquals(value1, value2, traversedValues)\n  }\n  </setComparison>\n\n  <objectComparison>\n  if (isPlainObjectOrEntity(value1) && isPlainObjectOrEntity(value2)) {\n    return objectEquals(value1, value2, traversedValues)\n  }\n  </objectComparison>\n\n  throw new Error(`Unsupported argument types: ${value1}, ${value2}`)\n}\n"], ["processBlock", "\nasync function processBlock(bn) {\n    \n    let transactions = await golos.golos.api.getOpsInBlockAsync(bn, false);\n    for(let tr of transactions) {\n        let op = tr.op[0];\n        let opBody = tr.op[1];\n        let time = Date.parse(tr.timestamp);\n        switch(op) {\n            \n            case \"vote\":\n                await processVote(opBody, time);\n                break;\n        }\n    }\n}\n"], ["_getUi5AppHash", "\nfunction _getUi5AppHash(sResolvedModulePath, sPreloadPath, oOptions) {\n  \n  const oPreloadFileContent = fs.readFileSync(sPreloadPath, 'utf8')\n\n  \n  \n  const sManifestPath = path.resolve(sResolvedModulePath, 'manifest.json')\n  const oManifestFileContent = fs.existsSync(sManifestPath)\n    ? fs.readFileSync(sManifestPath, 'utf8')\n    : null\n  const oManifestJSON = oManifestFileContent\n    ? JSON.parse(oManifestFileContent)\n    : { 'sap.ui5': {} }\n  <manifestResourceExtraction>\n  const aResourceKeys = oManifestJSON['sap.ui5'].resources\n    ? Object.keys(oManifestJSON['sap.ui5'].resources)\n    : []\n  const aDependedResourceContents = aResourceKeys.reduce(\n    (aContentsList, sResourceKey) => {\n      return aContentsList.concat(\n        oManifestJSON['sap.ui5'].resources[sResourceKey].map(oResource =>\n          fs.readFileSync(\n            path.resolve(sResolvedModulePath, oResource.uri),\n            'utf8'\n          )\n        )\n      )\n    },\n    []\n  )\n  </manifestResourceExtraction>\n\n  <bufferListCreationHashing>\n  const aBufferList = aDependedResourceContents\n    .concat(oPreloadFileContent ? oPreloadFileContent : [])\n    .map(oContent => new Buffer(oContent))\n  const sNewHash = _createHash(aBufferList, oOptions)\n  </bufferListCreationHashing>\n\n  return sNewHash\n}\n"], ["decodeString", "\nfunction decodeString (string) {\n    if (string === values.EMPTY) {\n        return \"\";\n    } else if (string === values.NULL) {\n        return null;\n    } else {\n        return decodeURIComponent(\n            string.replace(/\\+/g,\"%20\"));\n    }\n}\n"], ""]