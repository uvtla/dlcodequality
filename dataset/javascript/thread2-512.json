[["initializeMap", "\nfunction initializeMap() {\n  <checkMapPresence>\n  if($('.map').length) {\n  </checkMapPresence>\n    <mapSetup>\n    var mapCanvas = $('#map-canvas');\n    var myLatlng = new google.maps.LatLng(mapCanvas.data(\"latitude\"),mapCanvas.data(\"longitude\"));\n    var mapOptions = {\n      zoom: mapCanvas.data(\"zoom\"),\n      center: myLatlng\n    }\n    var map = new google.maps.Map(document.getElementById('map-canvas'), mapOptions);\n    </mapSetup>\n    \n    <markerCreation>\n    var marker = new google.maps.Marker({\n      position: myLatlng,\n      map: map\n    });\n    </markerCreation>\n  }\n}\n"], ["execute", "\nfunction execute(req, res) {\n  <delegateOrRespond>\n  if(req.info.command.sub) {\n    this.delegate(req, res);\n  }else{\n    var list = getList.call(this);\n    return res.send(null, list);\n  }\n  </delegateOrRespond>\n}\n"], ["processComputed", "\nfunction processComputed (instance) {\n  const computed = []\n  <getComputedDefinitions>\n  const defs = instance.$options.computed || {}\n  </getComputedDefinitions>\n  \n  <evaluateComputedProperties>\n  for (const key in defs) {\n    const def = defs[key]\n    <determinePropertyType>\n    const type = typeof def === 'function' && def.vuex\n      ? 'vuex bindings'\n      : 'computed'\n    </determinePropertyType>\n    \n    let computedProp = null\n    try {\n      computedProp = {\n        type,\n        key,\n        value: instance[key]\n      }\n    } catch (e) {\n      computedProp = {\n        type,\n        key,\n        value: '(error during evaluation)'\n      }\n    }\n\n    computed.push(computedProp)\n  }\n  </evaluateComputedProperties>\n\n  return computed\n}\n"], ["updateTimeout", "\nfunction(map, delay, nice) {\n  \n  <clearPreviousTimeout>\n  window.clearTimeout(this.tileQueueId[map.id]);\n  </clearPreviousTimeout>\n\n  <queueManagement>\n  var tileQueue = this.tileQueue[map.id];\n  </queueManagement>\n\n  <setNewTimeout>\n  if (!nice || tileQueue.length) {\n    this.tileQueueId[map.id] = window.setTimeout(\n      OpenLayers.Function.bind(function() {\n        this.drawTilesFromQueue(map);\n        if (tileQueue.length) {\n          this.updateTimeout(map, this.frameDelay);\n        }\n      }, this), delay\n    );\n  }\n  </setNewTimeout>\n}\n"], ["hasNextPage", "\nfunction () {\n  <getPageInformation>\n  var currentPage = this.getCurrentPage(),\n      totalPages  = this.getTotalPages();\n  </getPageInformation>\n\n  <checkPagination>\n  return currentPage && (totalPages === Paginator.VALUE_UNLIMITED || currentPage < totalPages);\n  </checkPagination>\n}\n"], ["SequentialParser", "\nfunction SequentialParser(accumulators, callback) {\n  var step = 0;\n  <initializeFields>\n  var fields = {};\n  </initializeFields>\n  \n  return {\n    fields: fields,\n    <addField>\n    addField: function(key, value) {\n      this.fields[key] = value;\n    },\n    </addField>\n    <parseItem>\n    parseItem: function(item) {\n      <parseControlFlow>\n      if (step >= accumulators.length) {\n        return console.warn(\n          \"warning: skipping item, because SequentialParser is done.\"\n        );\n      }\n      var current = accumulators[step];\n      if (current.field) {\n        this.addField(current.field, item);\n        ++step;\n      } else if (current.accumulator) {\n        var doneAccumulating = current.accumulator(item, this);\n        if (doneAccumulating) ++step;\n      } \n      else ++step;\n      if (!item || step >= accumulators.length) {\n        callback && callback(null, this);\n      }\n      </parseControlFlow>\n    }\n    </parseItem>\n  };\n}\n"], ["drawImage", "\nfunction drawImage(canvas, rect, image) {\n  <executeImageContent>\n  if (image && image.content) {\n    try {\n      eval(image.content);\n    } catch (err) {\n      console.log(err);\n    }\n  }\n  </executeImageContent>\n}\n"], ["consumes", "\nfunction consumes(ctx) {\n  <checkMethod>\n  if (['HEAD', 'GET'].indexOf(ctx.operation.spec.method) >= 0) return;\n  </checkMethod>\n\n  <gatherConsumptionInfo>\n  var mimes = ctx.operation.spec.consumes ||\n    ctx.operation.resource.api.spec.consumes || [];\n  var prefix = describe(ctx);\n  </gatherConsumptionInfo>\n\n  <disableMiddlewareIfNeeded>\n  if (!mimes.length) {\n    debug(prefix + 'consumes middleware disabled (no consumes)');\n    return;\n  }\n  <disableMiddlewareIfNeeded>\n\n  <consumesMiddleware>\n  return function(req, res, next) {\n    if (req.sf.text && !is(req, mimes)) {\n      debug(prefix + 'consumes mime not supported: \"%s\" not in \"%s\"',\n            req.headers['content-type'], mimes);\n\n      var err = new Error('Unsupported Content-Type (' +\n                          req.headers['content-type'] + '), supports: ' +\n                          mimes.join(', '));\n      err.statusCode = 415;\n      err.expose = true;\n\n      return res.sf.reply(err);\n    }\n\n    next();\n  };\n  </consumesMiddleware>\n}\n"], ["addRoleToSet", "\nfunction(set, role) {\n  <validForNodeTypeComparison>\n  var validForNodeType = function(implicitNodeTypeSelector) {\n    return axe.utils.matchesSelector(node, implicitNodeTypeSelector);\n  };\n  </validForNodeTypeComparison>\n\n  <addToSetIfValid>\n  if (role.implicit && role.implicit.some(validForNodeType)) {\n    set.push(role.name);\n  }\n  </addToSetIfValid>\n\n  return set;\n}\n"], ["flattenObject", "\nfunction flattenObject(ob) {\n  <objectFlattening>\n  return Object.entries(ob).reduce((accum, el) => {\n    const [key, entry] = el;\n\n    <nestedFlattening>\n    if (typeof entry === 'object' && entry !== null) {\n      const flatObject = Object.entries(flattenObject(entry));\n\n      flatObject.forEach((flattenedEntry) => {\n        const [fkey, fentry] = flattenedEntry;\n        \n        accum[`${key}.${fkey}`] = fentry;\n      });\n    } else {\n      \n      accum[key] = entry;\n    }\n    </nestedFlattening>\n\n    return accum;\n  }, {});\n  </objectFlattening>\n}\n"], "```"]