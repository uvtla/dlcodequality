[["getGroupById", "\nfunction(groupId) {\n    <validateGroupId>\n    if (groupId === null || groupId === undefined) {\n      throw new Error(\"Tried to get group for undefined/null id\");\n    }\n    </validateGroupId>\n    return Promise.resolve(this.get(\"group\" + groupId));\n}\n"], ["updateStateWithInitialArray", "\nfunction () {\n    var curState = this._currentState;\n    var initialArray = this.initialArray;\n    var oldValues; \n    <checkCurrentStateAgainstInitialArray>\n    if (curState.initialArray == initialArray && !(this._changes & this.CHANGED_INITIAL_ARRAY)) {\n        return;\n    }\n    </checkCurrentStateAgainstInitialArray>\n    <createOldValuesStackHashMap>\n    if (curState.initialArray) {\n        oldValues = new ariaUtilsStackHashMap();\n        var oldItems = this.items;\n        var oldItemsLength = oldItems.length, oldElt;\n        for (var i = 0; i < oldItemsLength; i++) {\n            oldElt = oldItems[i];\n            oldValues.push(oldElt.value, oldElt);\n        }\n    }\n    </createOldValuesStackHashMap>\n    <getReturnedItems>\n    var returnedItems;\n    if (ariaUtilsType.isObject(initialArray)) {\n        returnedItems = this._getItemsFromMap(oldValues);\n    } else {\n        returnedItems = this._getItemsFromArray(oldValues);\n    }\n    </getReturnedItems>\n    <disposeOldValues>\n    if (oldValues) {\n        this._removeListenersOnItems(oldValues.removeAll());\n        oldValues.$dispose();\n    }\n    </disposeOldValues>\n    <updateCurrentState>\n    this.items = returnedItems.items;\n    var filteredOutElements = returnedItems.filteredOutElements;\n    var arrayLength = this.items.length;\n    curState.initialArray = initialArray;\n    curState.sortOrder = this.SORT_INITIAL;\n    curState.sortName = null;\n    curState.sortKeyGetter = null;\n    curState.pageSize = -1;\n    this.filteredInCount = arrayLength - filteredOutElements;\n    this.pages = [{ \n        pageIndex : 0,\n        pageNumber : 1,\n        firstItemIndex : 0,\n        lastItemIndex : arrayLength - 1,\n        firstItemNumber : arrayLength > 0 ? 1 : 0,\n        lastItemNumber : this.filteredInCount\n    }];\n    this._changes = this._changes & !this.CHANGED_INITIAL_ARRAY;\n    </updateCurrentState>                \n}\n"], ["describeTileOrEntity", "\nfunction(x, y){\n    <convertMouseCoordsToTile>\n    var coords = this.renderer.mouseToTileCoords(x, y),\n        tile = this.map.get(coords.x, coords.y);\n    </convertMouseCoordsToTile>\n    <checkAndDescribeEntityOrTile>\n    if(!tile){\n        return;\n    }\n    var entityTile = this.entityManager.get(tile.x, tile.y);\n    if(entityTile){\n        this.console.log('Looks like a <strong>' + entityTile.name + '</strong> standing on a <strong>' + tile.name + '</strong> to me.');\n    }\n    else{\n        this.console.log('Looks like a <strong>' + tile.name + '</strong> to me.');\n    }\n    </checkAndDescribeEntityOrTile>\n}\n"], ["loadModel", "\nfunction (options, callback) {\n    <handleArguments>\n    if (arguments.length === 1 && options instanceof Function) {\n        callback = options;\n        options = null;\n    }\n    options = options || {};\n    </handleArguments>\n\n    var self = this;\n\n    <handleModelFetching>\n    if (this._fetch.state === FETCHSTATE.LOADING) {\n        this._fetch.callbacks.push(function (err, model) {\n            modelFetchedComplete(err, model, options, callback);\n        });\n    } else if (this._fetch.state == FETCHSTATE.LOADED && !options.noCache) {\n        modelFetchedComplete(null, this, options, callback);\n    } else {\n        self._fetch.state = FETCHSTATE.LOADING;\n        this.$context.$dataSource.loadModel(this, options, function (err, model) {\n            self._fetch.state = err ? FETCHSTATE.ERROR : FETCHSTATE.LOADED;\n            modelFetchedComplete.call(self, err, model, options, callback);\n            _.each(self._fetch.callbacks, function (cb) {\n                cb.call(self, err, model);\n            });\n        });\n    }\n    </handleModelFetching>\n}\n"], ["resolveOptionCollection", "\nfunction (optionCollection, key, model, collection) {\n    <determineOptionCollection>\n    if (optionCollection) {\n        return strTo(optionCollection, model, Collection) || collection;\n    }\n    return strTo(key, model, Collection) || null;\n    </determineOptionCollection>\n}\n"], ["routerMiddleware", "\nfunction routerMiddleware(history) {\n  return function () {\n    return function (next) {\n      return function (action) {\n        <handleAction>\n        if (action.type !== _actions.CALL_HISTORY_METHOD) {\n          return next(action);\n        }\n        var _action$payload = action.payload,\n            method = _action$payload.method,\n            args = _action$payload.args;\n        history[method].apply(history, _toConsumableArray(args));\n        </handleAction>\n      };\n    };\n  };\n}\n"], ["FPNodeConstructor", "\nfunction FPNode(item, parent) {\n    <initializeDefaults>\n    if (item === void 0) { item = null; }\n    if (parent === void 0) { parent = null; }\n    this.item = item;\n    this.parent = parent;\n    this.support = 1;\n    this.nextSameItemNode = null;\n    this._children = [];\n    </initializeDefaults>\n}\n"], ["throwErrorOnUndefinedColumnName", "\nfunction throwErrorOnUndefinedColumnName(keys, extract) {\n    <validateKeysAgainstRegex>\n    var regexRefs = /([a-zA-Z$_][\\w$]+)(\\s*\\.\\s*[a-zA-Z$_][\\w$]+)*/g, \n        parts, variable;\n    keys = keys.concat(['true', 'false']);\n    while ((parts = regexRefs.exec(extract))) {\n        variable = parts[1];\n        if (keys.indexOf(variable) < 0) {\n            throw new ReferenceError(variable + ' not defined.');\n        }\n    }\n    </validateKeysAgainstRegex>\n}\n"], ["BufStreamConstructor", "\nfunction BufStream(lvlup) {\n  <initializeBufStream>\n  if (!(this instanceof BufStream)) return new BufStream(lvlup)\n  this.pending = []\n  this.open = false\n  <handleLevelUpInstance>\n  if (typeof lvlup == \"object\" && lvlup.db) {\n    if (lvlup.isOpen()) {\n      this.db = lvlup.db\n      this.open = true\n    }\n    else\n      lvlup.once(\"ready\", this._go.bind(this, lvlup))\n  }\n  else\n    throw new Error(\"Please provide a LevelUP instance\")\n  </handleLevelUpInstance>\n  </initializeBufStream>\n}\n"], ["getUnwatchedKeys", "\nfunction getUnwatchedKeys() {\n    <computeDifferenceInKeys>\n    var arr1 = Object.keys(store._store),\n        arr2 = Object.keys(store._key_to_watcher_subscriptions);\n    </computeDifferenceInKeys>\n    <filterUnwatchedKeys>\n    return arr1.filter(function (i) {\n      return arr2.indexOf(i) === -1;\n    });\n    </filterUnwatchedKeys>\n}\n"], "```"]