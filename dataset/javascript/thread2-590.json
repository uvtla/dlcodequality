[["function1", "\nfunction (token, charset) {\n    var arity = [ 1, 1 ];\n    <validateTokenStructure>\n    if (   token.len >= 5\n        && token.peek(0) === \"{\"\n        && token.peek(1).match(/^[0-9]+$/)\n        && token.peek(2) === \",\"\n        && token.peek(3).match(/^(?:[0-9]+|oo)$/)\n        && token.peek(4) === \"}\"          ) {\n        arity = [\n            parseInt(token.peek(1), 10),\n            (  token.peek(3) === \"oo\"\n             ? Number.MAX_VALUE\n             : parseInt(token.peek(3), 10))\n        ];\n        token.skip(5);\n    }\n    </validateTokenStructure>\n    <validateSingleCharacter>\n    else if (\n           token.len >= 1\n        && token.peek().length === 1\n        && charset.indexOf(token.peek()) >= 0) {\n        var c = token.peek();\n        switch (c) {\n            case \"?\": arity = [ 0, 1 ];                break;\n            case \"*\": arity = [ 0, Number.MAX_VALUE ]; break;\n            case \"+\": arity = [ 1, Number.MAX_VALUE ]; break;\n        }\n        token.skip();\n    }\n    </validateSingleCharacter>\n    return arity;\n}\n"], ["function2", "\nfunction (context, authorisationRequest, callback) {\n    <handleAuthorization>\n    try {\n        this._isAuthorized(context, authorisationRequest);\n        callback();\n    } catch (e) {\n        callback(e);\n    }\n    </handleAuthorization>\n}\n"], ["function3", "\nfunction(module, exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    <assert>\n    function assert(condition, message) {\n        \n        if (!condition) {\n            throw new Error('ASSERT: ' + message);\n        }\n    }\n    exports.assert = assert;\n    </assert>\n}\n"], ["function4", "\nfunction(fragment) {\n    <matchAndHandleFragment>\n    if (!this.matchRoot()) return false;\n    fragment = this.fragment = this.getFragment(fragment);\n    return _.some(this.handlers, function(handler) {\n      if (handler.route.test(fragment)) {\n        handler.callback(fragment);\n        return true;\n      }\n    });\n    </matchAndHandleFragment>\n}\n"], ["function5", "\nfunction calculate_encoding_from_tree_position(position_array){\n    <calculateEncoding>\n    if(position_array.length==1){\n        return get_parsed_encodings({\n            numerator:position_array[0],\n            denominator:1\n        });\n    }\n    </calculateEncoding>\n  \n    <prepareData>\n    var data = {\n        parts:_.map(position_array, function(v){return v;}),\n        unityparts:[]\n    };\n    \n    for(var i=0; i<data.parts.length; i++)\n    {   \n        data.unityparts.push(data.parts[i]);\n\n        if(i<data.parts.length-1)\n        {\n            data.unityparts.push(1);\n        }\n    }\n    </prepareData>\n\n    <calculateNumeratorDenominator>\n    data.numerator = data.unityparts.pop();\n    data.denominator = 1;\n  \n    data.integer = 0;\n  \n    while(data.unityparts.length>0)\n    {\n        data.integer = data.unityparts.pop();\n        data = reduce_continued_fraction_step(data);\n    }\n    </calculateNumeratorDenominator>\n  \n    return get_parsed_encodings(data);\n}\n"], ["function6", "\nfunction(iteratee, instance) {\n    <resolveIteratee>\n    if (_.isFunction(iteratee)) return iteratee;\n    if (_.isObject(iteratee) && !instance._isModel(iteratee)) return modelMatcher(iteratee);\n    if (_.isString(iteratee)) return function(model) { return model.get(iteratee); };\n    return iteratee;\n    </resolveIteratee>\n}\n"], ["function7", "\nfunction Queue(parameters) {\n    <configureParameters>\n    parameters = parameters || new composites.Parameters(new Catalog());\n    if (!parameters.getParameter('$type')) parameters.setParameter('$type', '/bali/collections/Queue/v1');\n    abstractions.Collection.call(this, utilities.types.QUEUE, parameters);\n    </configureParameters>\n    \n    <initializeQueue>\n    var capacity = 1024;  \n    if (parameters) {\n        const value = parameters.getParameter('$capacity', 2);\n        if (value) capacity = value.toNumber();\n    }\n    const array = [];\n    </initializeQueue>\n\n    <queueMethods>\n    this.acceptVisitor = function(visitor) {\n        visitor.visitQueue(this);\n    };\n\n    this.toArray = function() {\n        return array.slice();  \n    };\n\n    this.getSize = function() {\n        return array.length;\n    };\n\n    this.addItem = function(item) {\n        if (array.length < capacity) {\n            item = this.convert(item);\n            array.push(item);\n            return true;\n        }\n        throw new utilities.Exception({\n            $module: '/bali/collections/Queue',\n            $procedure: '$addItem',\n            $exception: '$resourceLimit',\n            $capacity: capacity,\n            $text: '\"The queue has reached its maximum capacity.\"'\n        });\n    };\n\n    this.removeItem = function() {\n        if (array.length > 0) return array.splice(0, 1)[0];  \n    };\n\n    this.getHead = function() {\n        return array[0];\n    };\n\n    this.deleteAll = function() {\n        array.splice(0);\n    };\n    </queueMethods>\n\n    return this;\n}\n"], ["function8", "\nfunction (cfg) {\n    <applyStyleTransformations>\n    this.style.transform = (_.isStrictlyObject (cfg) && (\n                                (cfg.translate ? ('translate(' + cfg.translate.x.toFixed (0) + 'px,' + cfg.translate.y.toFixed (0) + 'px) ') : '') +\n                                (cfg.rotate ? ('rotate(' + cfg.rotate + 'rad) ') : '') +\n                                (cfg.scale ? ('scale(' + (new Vec2 (cfg.scale).separatedWith (',')) + ')') : ''))) || ''\n    </applyStyleTransformations>\n}\n"], ["function9", "\nfunction () {\n    <cleanupEvents>\n    var self = this;\n    if (self.boundEvents) {\n      var i = self.boundEvents.length;\n\n      while (i--) {\n        var item = self.boundEvents[i];\n        this.events.unbind(item[0], item[1], item[2]);\n      }\n\n      self.boundEvents = null;\n    }\n    </cleanupEvents>\n\n    <resetSizzle>\n    if (Sizzle.setDocument) {\n      Sizzle.setDocument();\n    }\n    </resetSizzle>\n\n    self.win = self.doc = self.root = self.events = self.frag = null;\n}\n"], ["function10", "\nfunction _checkAnnotation (op) {\n    <handleAnnotationOperation>\n    switch (op.type) {\n        case 'create':\n        case 'delete': {\n            let node = op.val\n            if (node.hasOwnProperty('start') && node.start.path) {\n                updated[getKeyForPath(node.start.path)] = true\n            }\n            if (node.hasOwnProperty('end') && node.end.path) {\n                updated[getKeyForPath(node.end.path)] = true\n            }\n            break\n        }\n        case 'update':\n        case 'set': {\n            let node = doc.get(op.path[0])\n            if (node) {\n                if (node.isPropertyAnnotation()) {\n                    updated[getKeyForPath(node.start.path)] = true\n                } else if (node.isContainerAnnotation()) {\n                    affectedContainerAnnos.push(node)\n                }\n            }\n            break\n        }\n        default:\n            // No specific operations for other types.\n    }\n   </handleAnnotationOperation>\n}\n"], "```"]