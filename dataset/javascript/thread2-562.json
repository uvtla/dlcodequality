[["sortAndCategorizePoints", "\nfunction () {\n  <initializeVariables>\n  var _this = this;\n  var _points = Array.from(this._points);\n  var sortedPoints = [];\n  var sortOrder = {\n      vertical: ['top', 'top', 'bottom', 'bottom'],\n      horizontal: ['left', 'right', 'right', 'left']\n  };\n  </initializeVariables>\n  \n  <sortPointsLoop>\n  var _loop_1 = function (i) {\n      var roles = Array.from([sortOrder.vertical[i], sortOrder.horizontal[i]]);\n      sortedPoints.push(_points.filter(function (point) {\n          return _this.limitsService.compareArray(point.roles, roles);\n      })[0]);\n  };\n  for (var i = 0; i < 4; i++) {\n      _loop_1(i);\n  }\n  </sortPointsLoop>\n  \n  <assignSortedPoints>\n  this._sortedPoints = sortedPoints;\n  </assignSortedPoints>\n}\n"], ["loadIconFromSet", "\nfunction loadFromIconSet(id) {\n  <extractIdAndSetName>\n  var setName = id.substring(0, id.lastIndexOf(':')) || '$default';\n  var iconSetConfig = config[setName];\n  </extractIdAndSetName>\n\n  <loadOrReportNotFound>\n  return !iconSetConfig ? announceIdNotFound(id) : loadByURL(iconSetConfig.url).then(extractFromSet);\n  </loadOrReportNotFound>\n\n  <nested>\n  function extractFromSet(set) {\n    <extractIcon>\n    var iconName = id.slice(id.lastIndexOf(':') + 1);\n    var icon = set.querySelector('#' + iconName);\n    </extractIcon>\n    <constructOrAnnounce>\n    return icon ? new Icon(icon, iconSetConfig) : announceIdNotFound(id);\n    </constructOrAnnounce>\n  }\n\n  function announceIdNotFound(id) {\n    <logWarning>\n    var msg = 'icon ' + id + ' not found';\n    $log.warn(msg);\n    </logWarning>\n    <rejectPromise>\n    return $q.reject(msg || id);\n    </rejectPromise>\n  }\n  </nested>\n}\n"], ["sendMessage", "\nfunction Channel_sendMessage(message) {\n  <checkWebsocketAvailability>\n  if (!this._websocket) return;\n  </checkWebsocketAvailability>\n\n  <serializeAndSendMessage>\n  message = JSON.stringify(message);\n  this._websocket.send(message);\n  </serializeAndSendMessage>\n}\n"], ["setTextPolyfill", "\nfunction(text) {\n  <polyfillSetTextFunction>\n  CKEDITOR.dom.element.prototype.setText = (this.$.innerText != undefined) ?\n    function(text) {\n      <setTextUsingInnerText>\n      return this.$.innerText = text;\n      </setTextUsingInnerText>\n    } :\n    function(text) {\n      <setTextUsingTextContent>\n      return this.$.textContent = text;\n      </setTextUsingTextContent>\n    };\n  </polyfillSetTextFunction>\n\n  <invokeSetText>\n  return this.setText(text);\n  </invokeSetText>\n}\n"], ["convertEulerToQuaternion", "\nfunction fromEuler(q, euler) {\n  <calculateHalfAngles>\n  var x = euler[0];\n  var y = euler[1];\n  var z = euler[2];\n  var cx = Math.cos(x / 2);\n  var cy = Math.cos(y / 2);\n  var cz = Math.cos(z / 2);\n  var sx = Math.sin(x / 2);\n  var sy = Math.sin(y / 2);\n  var sz = Math.sin(z / 2);\n  </calculateHalfAngles>\n  \n  <computeQuaternion>\n  q[0] = sx * cy * cz + cx * sy * sz;\n  q[1] = cx * sy * cz - sx * cy * sz;\n  q[2] = cx * cy * sz + sx * sy * cz;\n  q[3] = cx * cy * cz - sx * sy * sz;\n  </computeQuaternion>\n\n  <returnQuaternion>\n  return q;\n  </returnQuaternion>\n}\n"], ["initializeLink", "\nfunction Link(properties) {\n  <initializeSignatures>\n  this.signatures = [];\n  </initializeSignatures>\n  <assignProperties>\n  if (properties)\n    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n      if (properties[keys[i]] != null)\n        this[keys[i]] = properties[keys[i]];\n  </assignProperties>\n}\n"], ["setCookieOrLocalStorageValue", "\nfunction set(name, value) {\n  <removeIfNoValue>\n  if (!value) {\n      remove(name);\n      return;\n  }\n  </removeIfNoValue>\n\n  <attemptLocalStorageSet>\n  if (localStorage) {\n      try {\n          localStorage.setItem(name, value);\n      }\n      catch (ex) {}\n  }\n  </attemptLocalStorageSet>\n\n  <setCookieValue>\n  _.isFunction($cookies.put) ?\n      $cookies.put(name, value, { domain: cookieDomain }) :\n      $cookies[name] = value;\n  </setCookieValue>\n}\n"], ["getTagsFromDatabase", "\nfunction getTags(params, config, conn) {\n  <setDefaultConfigAndLimit>\n  config = config || require('../config/config.js');\n  params.limit = 100;\n  </setDefaultConfigAndLimit>\n\n  <fetchTagsPromise>\n  return new Promise((resolve, reject) => {\n    <obtainConnection>\n    if (!conn) {\n      var conn = wc_db.getConnection(config.db);\n    }\n    </obtainConnection>\n\n    <constructAndExecuteQuery>\n    if (params.uri) {\n      var sql = 'SELECT t.tag from Media m left join MediaTag mt on m.id = mt.media_id left join Tag t on mt.tag_id = t.id  where m.uri = :uri order by t.tag LIMIT :limit ';\n    } else {\n      var sql = 'SELECT * from Tag order by id LIMIT :limit ';\n    }\n    debug(sql);\n\n    conn.query(sql, { replacements: { \"limit\" : params.limit, \"uri\" : params.uri } }).then(function(ret){\n      <resolvePromiseWithData>\n      return resolve({\"ret\" : ret, \"conn\" : conn});\n      </resolvePromiseWithData>\n    }).catch(function(err) {\n      <rejectPromiseWithError>\n      return reject({\"err\" : err, \"conn\" : conn});\n      </rejectPromiseWithError>\n    })\n    </constructAndExecuteQuery>\n  })\n  </fetchTagsPromise>\n}\n"], ["sortCssClasses", "\nfunction _sortCssClassesValues(cssClasses) {\n  <processAndSortClasses>\n  var classList = (cssClasses || '').split(' ');\n  return _(classList)\n      .filter()\n      .uniq()\n      .sort()\n      .join(' ');\n  </processAndSortClasses>\n}\n"], ["initializeEngine", "\nfunction Engine(opts) {\n  <setDefaultOptions>\n  opts = opts || {};\n  this.ext = opts.ext || 'html';\n  mkdirp = opts.mkdirp || mkdirp;\n  </setDefaultOptions>\n\n  <setEngineVersion>\n  this.version = require('./../package.json').version;\n  </setEngineVersion>\n}\n"], "```"]