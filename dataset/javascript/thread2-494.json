[["shouldRecycleElement", "\nfunction shouldRecycleElement(oldElement, props, tag) {\n  return (\n    !isTextNode(oldElement) &&\n    oldElement.id === \"\" &&\n    !nodeTypeDiffers(oldElement, tag)\n  );\n}\n"], ["buildIdentifier", "\nfunction (aggId, cmd) {\n    <extractAggregate>\n    var aggregate = '';\n    if (dotty.exists(cmd, this.definitions.command.aggregate)) {\n      aggregate = dotty.get(cmd, this.definitions.command.aggregate);\n    }\n    </extractAggregate>\n\n    <extractContext>\n    var context = '';\n    if (dotty.exists(cmd, this.definitions.command.context)) {\n      context = dotty.get(cmd, this.definitions.command.context);\n    }\n    </extractContext>\n\n    return context + aggregate + aggId;\n}\n"], ["mgf", "\nfunction mgf(y, x, n, p, clbk) {\n\tvar len = x.length,\n\t\tfcn,\n\t\tv, i;\n\n    <configurePartialFunction>\n\tfcn = partial(n, p);\n    </configurePartialFunction>\n\tfor (i = 0; i < len; i++) {\n        <computeYValues>\n\t\tv = clbk(x[i], i);\n\t\tif (typeof v === 'number') {\n\t\t\ty[i] = fcn(v);\n\t\t} else {\n\t\t\ty[i] = NaN;\n\t\t}\n        </computeYValues>\n\t}\n\treturn y;\n}\n"], ["_handleKeyEvent", "\nfunction _handleKeyEvent(e) {\n    <normalizeEventKey>\n    if (typeof e.which !== 'number') {\n        e.which = e.keyCode;\n    }\n    </normalizeEventKey>\n\n    <getCharacterFromEvent>\n    var character = _characterFromEvent(e);\n    </getCharacterFromEvent>\n\n    <ignoreUnwantedKeyUp>\n    if (e.type == 'keyup' && _ignoreNextKeyup === character) {\n        _ignoreNextKeyup = false;\n        return;\n    }\n    </ignoreUnwantedKeyUp>\n\n    <delegateHandlingKeyPress>\n    self.handleKey(character, _eventModifiers(e), e);\n    </delegateHandlingKeyPress>\n}\n"], ["findAssociated", "\nfunction findAssociated(id, next, opts) {\n    <setupSearchCondition>\n\tvar where = (id ? {id: id} : null);\n    </setupSearchCondition>\n\n    <setDefaultOptions>\n    opts = opts || {};\n    </setDefaultOptions>\n\n    <findModels>\n\tvar finding = app.models.Table\n\t\t.find()\n\t\t.where(where)\n\t\t.exec(associateScores)\n    </findModels>\n\n    <associateScores>\n\tvar data;\n\tfunction associateScores(err, models) {\n\t\t<dataInitialization>\n\t\tdata = [];\n        </dataInitialization>\n\n\t\t<handleError>\n\t\tif (err)\n\t\t\tnext('Failed to retrieve data');\n        </handleError>\n\n\t\t<prepareAsyncTasks>\n\t\tvar findTasks = [];\n\t\tmodels.forEach(function (table) {\n\t\t\tvar task = function (cb) {\n\t\t\t\tassociateTable(table, function returnToAsync(associated) {\n\t\t\t\t\tcb(null, associated);\n\t\t\t\t});\n\t\t\t};\n\t\t\tfindTasks.push(task);\n\t\t});\n        </prepareAsyncTasks>\n\n\t\t<executeAsyncTasks>\n\t\tasync.parallel(findTasks, afterAssociateScores);\n        </executeAsyncTasks>\n\t}\n    </associateScores>\n\n\t<processTablesAfterAssociation>\n\tfunction afterAssociateScores(err, results) {\n\t\t<dataAggregation>\n\t\tdata = results;\n        </dataAggregation>\n\n\t\t<processResults>\n\t\tprocessTables(opts);\n        </processResults>\n\t}\n    </processTablesAfterAssociation>\n\n\t<processTables>\n\tfunction processTables() {\n\t\t<customizeForViewing>\n\t\tif (opts && opts.isView) {\n\t\t\t_.forEach(data, function (table) {\n\t\t\t\ttable.columns = table.viewColumns || table.columns\n\t\t\t})\n\t\t}\n        </customizeForViewing>\n\n\t\t<invokeMethodsOnData>\n\t\t_.invokeMap(data, 'calculate', null);\n\t\t_.invokeMap(data, 'headers', null);\n        </invokeMethodsOnData>\n\n\t\t<associateTeamData>\n\t\tassociateTeams();\n        </associateTeamData>\n\t}\n    </processTables>\n\n\t<associateTeams>\n\tvar teams;\n\tfunction associateTeams() {\n\t\t<initializeTeams>\n\t\tteams = {};\n        </initializeTeams>\n\n\t\t<associateTablesWithTeams>\n\t\tfunction associateWithTeams(teams, tableModel) {\n\t\t\t_.forEach(tableModel.scores, function (teamRow) {\n\t\t\t\tteamRow['team'] = teams[teamRow.teamId] || {};\n\t\t\t});\n\t\t}\n        </associateTablesWithTeams>\n\n\t\t<findAndProcessTeams>\n\t\tapp.models.Team.find().exec(function (err, collection) {\n\t\t\tfor (var k in collection) {\n\t\t\t\tvar team = collection[k];\n\t\t\t\tteams[team.id] = team;\n\t\t\t}\n\n\t\t\tafterFindTeams();\n\t\t});\n\n\t\tfunction afterFindTeams() {\n\t\t\t_.forEach(data, function (tableModel) {\n\t\t\t\tassociateWithTeams(teams, tableModel);\n\t\t\t});\n\n\t\t\treturnData();\n\t\t}\n        </findAndProcessTeams>\n\t}\n    </associateTeams>\n\n\t<returnFinalData>\n\tfunction returnData() {\n\t\tnext(data);\n\t}\n    </returnFinalData>\n}\n"], ["SessionConstructor", "\nfunction Session(context) {\n    this.context = context\n    <linkCookies>\n    this.cookies = context.cookies\n    </linkCookies>\n    <bindUpdateFunction>\n    this.update = this.update.bind(this)\n    </bindUpdateFunction>\n}\n"], ["removeColumn", "\nfunction removeColumn(values, col, colsPerRow) {\n  <remapValuesWithoutColumn>\n  var n = 0;\n  for (var i = 0, l = values.length; i < l; i++) {\n    if (i % colsPerRow !== col) values[n++] = values[i];\n  }\n  </remapValuesWithoutColumn>\n  <resizeValuesArray>\n  values.length = n;\n  </resizeValuesArray>\n}\n"], ["sortList", "\nfunction (list) {\n    <removeDuplicates>\n    const listNoDuplicate = difference([], list);\n    </removeDuplicates>\n    <sortNumericOrLexicographic>\n    if (typeof list[0] == \"number\") {\n      return listNoDuplicate.sort((a, b) => a - b);\n    }\n    return listNoDuplicate.sort();\n    </sortNumericOrLexicographic>\n}\n"], ["writeAndEndStream", "\nfunction next() {\n\twhile (array.length) {\n\t\t<writeChunks>\n\t\tvalue = array.shift();\n\t\tif (stream.write(value) === false) {\n\t\t\treturn stream.once('drain', next);\n\t\t}\n\t\t</writeChunks>\n\t}\n\t<endStream>\n\tstream.end();\n\t</endStream>\n}\n"], ["getTabIndexValue", "\nfunction getTabIndexValue(element) {\n    <checkValidTabIndex>\n    if (!hasValidTabIndex(element)) {\n        return null;\n    }\n    </checkValidTabIndex>\n\n    <parseTabIndex>\n    var tabIndex = parseInt(element.getAttribute('tabindex'), 10);\n    </parseTabIndex>\n    <returnTabIndex>\n    return isNaN(tabIndex) ? -1 : tabIndex;\n    </returnTabIndex>\n}\n"], "```"]