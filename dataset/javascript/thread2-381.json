[["getTouchList", "\nfunction getTouchList() {\n    var touchlist = [];\n    Utils.each(this.pointers, function(pointer) {\n      touchlist.push(pointer);\n    });\n    return touchlist;\n}\n"], ["getSectionBody", "\nfunction getSectionBody(sectionString) {\n    var sectionBody = {};\n    var sectionBodyData = [];\n    var objectFromBodyRegExp = /-*(\\n){2,}(?!-{4,})[\\S\\s,]+?((?=((\\n){3,}?))|\\n\\n$)/gi;\n    var objectStrings = sectionString.match(objectFromBodyRegExp);\n    for (var obj = 0; obj < objectStrings.length; obj++) {\n        var sectionChild = processSectionChild(objectStrings[obj]);\n        if (!isEmpty(sectionChild)) {\n            if ('source' in sectionChild) {\n                sectionBody.source = sectionChild.source;\n            } else {\n                sectionBodyData.push(sectionChild);\n            }\n        }\n    }\n    sectionBody.data = sectionBodyData;\n    return sectionBody;\n}\n"], ["extractPointerMetrics", "\nfunction (e){\n    var\n      d = document,\n      b = d.body,\n      de = d.documentElement,\n      axes = this.axes,\n      plotOffset = this.plotOffset,\n      lastMousePos = this.lastMousePos,\n      pointer = E.eventPointer(e),\n      dx = pointer.x - lastMousePos.pageX,\n      dy = pointer.y - lastMousePos.pageY,\n      r, rx, ry;\n    if ('ontouchstart' in this.el) {\n      r = D.position(this.overlay);\n      rx = pointer.x - r.left - plotOffset.left;\n      ry = pointer.y - r.top - plotOffset.top;\n    } else {\n      r = this.overlay.getBoundingClientRect();\n      rx = e.clientX - r.left - plotOffset.left - b.scrollLeft - de.scrollLeft;\n      ry = e.clientY - r.top - plotOffset.top - b.scrollTop - de.scrollTop;\n    }\n    return {\n      x:  axes.x.p2d(rx),\n      x2: axes.x2.p2d(rx),\n      y:  axes.y.p2d(ry),\n      y2: axes.y2.p2d(ry),\n      relX: rx,\n      relY: ry,\n      dX: dx,\n      dY: dy,\n      absX: pointer.x,\n      absY: pointer.y,\n      pageX: pointer.x,\n      pageY: pointer.y\n    };\n}\n"], ["getTallest", "\nfunction getTallest(elements) {\n  let tallest = 0;\n  for (let i = elements.length - 1; i >= 0; i--) {\n    if (elements[i].offsetHeight > tallest) {\n      tallest = elements[i].offsetHeight;\n    }\n  }\n  return tallest;\n}\n"], ["contentAssistSetup", "\nfunction(editor, contentAssist, evnt) {\n    // Assisting content based on file type and other parameters\n    var fileContentType = inputManager.getContentType();\n    var fileName = editor.getTitle();\n    var serviceRefs = serviceRegistry.getServiceReferences(\"orion.edit.contentAssist\").concat(serviceRegistry.getServiceReferences(\"orion.edit.contentassist\")); \n    var providerInfoArray = evnt && evnt.providers;\n    if (!providerInfoArray) {\n        providerInfoArray = serviceRefs.map(function(serviceRef) {\n            var contentTypeIds = serviceRef.getProperty(\"contentType\"),\n                pattern = serviceRef.getProperty(\"pattern\"); \n            if ((contentTypeIds && contentTypeRegistry.isSomeExtensionOf(fileContentType, contentTypeIds)) ||\n                    (pattern && new RegExp(pattern).test(fileName))) {\n                var service = serviceRegistry.getService(serviceRef);\n                var id = serviceRef.getProperty(\"service.id\").toString();\n                var charTriggers = serviceRef.getProperty(\"charTriggers\");\n                var excludedStyles = serviceRef.getProperty(\"excludedStyles\");\n                var autoApply = serviceRef.getProperty(\"autoApply\");\n                if (charTriggers) {\n                    charTriggers = new RegExp(charTriggers);\n                }\n                if (excludedStyles) {\n                    excludedStyles = new RegExp(excludedStyles);\n                }\n                return {provider: service, id: id, charTriggers: charTriggers, excludedStyles: excludedStyles, autoApply: autoApply};\n            }\n            return null;\n        }).filter(function(providerInfo) {\n            return !!providerInfo;\n        });\n    }\n\n    var lspServer = languageServerRegistry.getServerByContentType(fileContentType);\n    if (lspServer) {\n        providerInfoArray.push({provider: lspServer, id: lspServer._id, lspServer: true, excludedStyles: new RegExp(\"(string.*)\")});\n    }\n    \n    var boundEditorContext = {};\n    Object.keys(EditorContext).forEach(function(key) {\n        if (typeof EditorContext[key] === \"function\") {\n            boundEditorContext[key] = EditorContext[key].bind(null, serviceRegistry, that.editContextServiceID);\n        }\n    });\n    contentAssist.setEditorContextProvider(boundEditorContext);\n    contentAssist.setProviders(providerInfoArray);\n    contentAssist.setAutoTriggerEnabled(that.settings.contentAssistAutoTrigger);\n    contentAssist.setProgress(progress);\n    contentAssist.setStyleAccessor(that.getStyleAccessor());\n}\n"], ["readNotifyTablesClose", "\nfunction readNotifyTablesClose(message, tokens) {\n    message.sessionId = protocol.decodeString(tokens[1]);\n    readTableInfos(message, tokens.slice(2));\n}\n"], ["jsonPRequest", "\nfunction (uri, success, failure, args) {\n    // Handling JSONP request with deferred promise\n    var defer = deferred(),\n        callback = \"callback\", cbid, s;\n    if (external === undefined) {\n        if (global.abaaso === undefined) {\n            utility.define(\"abaaso.callback\", {}, global);\n        }\n        external = \"abaaso\";\n    }\n    if (args instanceof Object && args.callback !== undefined) {\n        callback = args.callback;\n    }\n    defer.then(function (arg) {\n        if (typeof success === \"function\") {\n            success(arg);\n        }\n    }, function (e) {\n        if (typeof failure === \"function\") {\n            failure(e);\n        }\n        throw e;\n    });\n    do {\n        cbid = utility.genId().slice(0, 10);\n    }\n    while (global.abaaso.callback[cbid] !== undefined);\n    uri = uri.replace(callback + \"=?\", callback + \"=\" + external + \".callback.\" + cbid);\n    global.abaaso.callback[cbid] = function (arg) {\n        clearTimeout(utility.timer[cbid]);\n        delete utility.timer[cbid];\n        delete global.abaaso.callback[cbid];\n        defer.resolve(arg);\n        element.destroy(s);\n    };\n    s = element.create(\"script\", {src: uri, type: \"text/javascript\"}, utility.$(\"head\")[0]);\n    utility.defer(function () {\n        defer.reject(undefined);\n    }, 30000, cbid);\n    return defer;\n}\n"], ["isSubset", "\nfunction (subset, superset) {\n    if (   !Arrays.isArrayLike(subset)\n        || !Arrays.isArrayLike(superset)\n        || subset.length > superset.length )\n        return false;\n    return this._isSubsetOf(subset, superset);\n}\n"], ["numericalConversion", "\nfunction je(ct,pt,ut,bt){...}\n"], ["setDataTipFunction", "\nfunction(value)\n    {\n        if(this._dataTipFunction)\n        {\n            YAHOO.widget.Chart.removeProxyFunction(this._dataTipFunction);\n        }\n        if(value)\n        {\n            this._dataTipFunction = value = YAHOO.widget.Chart.getFunctionReference(value);\n        }\n        this._swf.setDataTipFunction(value);\n    }\n"], "```\n\nNote: The `numericalConversion` function is a little bit of an exception as it is a minified or obscured piece of code that is difficult to determine the responsibilities without context or meaningful variable names. It likely does not adhere to SRP based on its complex and compressed nature."]