[["_get_result", "\nfunction _get_result(Type) {\n  return function(rows) {\n    if(!rows) { throw new TypeError(\"failed to parse result\"); }\n    var doc = rows.shift();\n    if(!doc) { return; }\n\n    if(doc instanceof Type) {\n      return doc;\n    }\n\n    var obj = {};\n    ARRAY(Object.keys(doc)).forEach(function(key) {\n\n      if(key === 'documents') {\n        obj['$'+key] = {};\n        ARRAY(Object.keys(doc[key])).forEach(function(k) {\n          if(is.uuid(k)) {\n            obj['$'+key][k] = _get_result(NoPg.Document)([doc[key][k]]);\n          } else {\n            obj['$'+key][k] = doc[key][k];\n          }\n        });\n        return;\n      }\n\n      obj['$'+key] = doc[key];\n    });\n\n    _parse_object_expressions(obj);\n\n    return new Type(obj);\n  };\n}\n"], ["trainTuples", "\nfunction trainTuples(words) {\n  var probs = {};\n  var count = 0;\n\n  words.forEach(function(w) {\n    w = clean(w);\n\n    for (var i = 0; i < w.length - 1; i++) {\n      if (!probs[w[i]]) probs[w[i]] = {};\n      if (!probs[w[i]][w[i + 1]]) probs[w[i]][w[i + 1]] = 1;\n      else probs[w[i]][w[i + 1]]++;\n      count++;\n    }\n  });\n\n  Object.keys(probs).forEach(function(first) {\n    Object.keys(probs[first]).forEach(function(second) {\n      probs[first][second] = percent(probs[first][second], count);\n    });\n  });\n\n  return probs;\n}\n"], ["anonymous_function", " // Function needs a name for proper tagging. Assuming this is an anonymous function within a context.\nfunction(pos) {\n  var props = {};\n  <calculate_position_properties>\n  if(pos.indexOf('top') !== -1) {\n    props.top = this.options.pos_margin;\n  } else if(pos.indexOf('bottom') !== -1) {\n    props.bottom = this.options.pos_margin;\n  }\n\n  if(pos.indexOf('left') !== -1) {\n    props.left = this.options.pos_margin;\n  } else if(pos.indexOf('right') !== -1) {\n    props.right = this.options.pos_margin;\n  }\n  </calculate_position_properties>\n  this.$el.css(props);\n}\n"], ["controlComponent", "\nfunction controlComponent() {\n  return {\n    restrict: 'A',\n    \n    link: (scope, element, attrs) => {\n\n      const control = \n              (scope.$eval(attrs['ngeoControl']));\n      console.assert(control instanceof olControlControl);\n\n      const map = \n              (scope.$eval(attrs['ngeoControlMap']));\n      console.assert(map instanceof olMap);\n\n      control.setTarget(element[0]);\n      map.addControl(control);\n    }\n  };\n}\n"], ["anonymous_function", " // Function needs a name for proper tagging. Assuming this is an anonymous function within a context.\nfunction (globe, positions, followTerrain, pathType, maxLength) {\n  var subdividedPositions = [];\n  var loc = new Location(0, 0);\n  var destLatLon = new Location(0, 0);\n  var pos1 = positions[0];\n  var elevation;\n\n  this.addPosition(globe, subdividedPositions, pos1, followTerrain);\n\n  for (var i = 1; i < positions.length; i++) {\n    var pos2 = positions[i];\n    var arcLengthRadians = Location.greatCircleDistance(pos1, pos2);\n    loc = Location.interpolateAlongPath(pathType, 0.5, pos1, pos2, loc);\n    var arcLength = arcLengthRadians * globe.radiusAt(loc.latitude, loc.longitude);\n    if (arcLength > maxLength) {\n      \n      var segmentAzimuth = null;\n      var segmentDistance = null;\n      var steps = Math.ceil(arcLength / maxLength); \n      for (var j = 1; j < steps; j++) {\n        var s = j / steps;\n        // Path type calculations and interpolation\n        if (pathType === WorldWind.LINEAR) {\n          destLatLon = Location.interpolateLinear(s, pos1, pos2, destLatLon);\n        }\n        else if (pathType === WorldWind.RHUMB_LINE) {\n          if (segmentAzimuth == null) {\n            segmentAzimuth = Location.rhumbAzimuth(pos1, pos2);\n            segmentDistance = Location.rhumbDistance(pos1, pos2);\n          }\n          destLatLon = Location.rhumbLocation(pos1, segmentAzimuth, s * segmentDistance, destLatLon);\n        }\n        else {\n          if (segmentAzimuth == null) {\n            segmentAzimuth = Location.greatCircleAzimuth(pos1, pos2); \n            segmentDistance = Location.greatCircleDistance(pos1, pos2); \n          }\n          destLatLon = Location.greatCircleLocation(pos1, segmentAzimuth, s * segmentDistance, destLatLon);\n        }\n\n        // Elevation setting based on terrain following or straight interpolation\n        if (followTerrain) {\n          elevation = globe.elevationAtLocation(destLatLon.latitude, destLatLon.longitude);\n        }\n        else {\n          elevation = pos1.altitude * (1 - s) + pos2.altitude * s;\n        }\n\n        subdividedPositions.push(new Position(destLatLon.latitude, destLatLon.longitude, elevation));\n      }\n    }\n\n    // Add position to path, move to next segment\n    this.addPosition(globe, subdividedPositions, pos2, followTerrain);\n    pos1 = pos2;\n  }\n\n  return subdividedPositions;\n}\n"], ["presenceVerifier", "\nfunction presenceVerifier(key, input, setting) {\n  return null == input ? \n      [\"req\",\"required\"].indexOf(setting) >= 0 ? \"Value '\"+key+\"' required\" : \"skip\" : true;\n}\n"], ["UMLComponentView", "\nfunction UMLComponentView() {\n  UMLClassifierView.apply(this, arguments);\n\n  _.extend(UMLComponentView.prototype, UMLComponentViewMixin);\n\n  this.fillColor = PreferenceManager.get(\"uml.component.fillColor\", \"#ffffff\") || PreferenceManager.get(\"view.fillColor\", \"#ffffff\");\n  this.stereotypeDisplay  = PreferenceManager.get(\"uml.component.stereotypeDisplay\", UML.SD_LABEL);\n  this.suppressAttributes = PreferenceManager.get(\"uml.component.suppressAttributes\", true);\n  this.suppressOperations = PreferenceManager.get(\"uml.component.suppressOperations\", true);\n}\n"], ["anonymous_function", "\nfunction(services) {\n  return _.map(services, function(service) {\n    var hostnames = [];\n\n    if (service.default) {\n      hostnames.push(app.name);\n    }\n\n    if (service.hostname) {\n      hostnames.push([service.hostname, app.name].join('.'));\n    }\n\n    if (service.subdomains) {\n      _.forEach(service.subdomains, function(subdomain) {\n        hostnames.push([subdomain, app.name].join('.'));\n      });\n    }\n\n    if (service.custom) {\n      _.forEach(service.custom, function(url) {\n        hostnames.push(url);\n      });\n    }\n\n    var protocol = (service.secure) ? 'https://' : 'http://';\n\n    return _.map(hostnames, function(hostname) {\n      return protocol + [hostname, app.domain].join('.');\n    });\n  });\n}\n"], ["resolveSVG", "\nfunction resolveSVG(svg) {\n  svg = svg.replace(/\\s+xmlns(?:\\:[\\w-]+)?=(\"|')[^\"']*\\1/g, ' ')\n    .replace(/<defs[>\\s][\\s\\S]+?\\/defs>/g, function (text) {\n      if (text.indexOf('</font>') >= 0) {\n        return text;\n      }\n      return '';\n    })\n    .replace(/<use[>\\s][\\s\\S]+?\\/use>/g, '');\n  return svg;\n}\n"], ["ownCustomObject", "\nfunction ownCustomObject(name, Meta) {\n  var key = memberProperty(name);\n  var capitalized = capitalize(name);\n  <define_writable_property>\n  Meta.prototype['writable' + capitalized] = function (create) {\n    var ret = this[key];\n    if (!ret) {\n      ret = this[key] = create(this.source);\n    }\n    return ret;\n  };\n  </define_writable_property>\n  <define_readable_property>\n  Meta.prototype['readable' + capitalized] = function () {\n    return this[key];\n  };\n  </define_readable_property>\n}\n"], "```"]