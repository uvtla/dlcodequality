[["checkBidDuration", "\nfunction checkBidDuration(bidderRequest, bidResponse) {\n  const buffer = 2;\n  <extractBidInformation>\n  let bidDuration = utils.deepAccess(bidResponse, 'video.durationSeconds');\n  let videoConfig = utils.deepAccess(bidderRequest, 'mediaTypes.video');\n  let adUnitRanges = videoConfig.durationRangeSec;\n  adUnitRanges.sort((a, b) => a - b); \n  </extractBidInformation>\n\n  <validateBidDuration>\n  if (!videoConfig.requireExactDuration) {\n    <calculateMaximumDuration>\n    let max = Math.max(...adUnitRanges);\n    if (bidDuration <= (max + buffer)) {\n    </calculateMaximumDuration>\n      <findNextHighestRangeAndAssign>\n      let nextHighestRange = find(adUnitRanges, range => (range + buffer) >= bidDuration);\n      bidResponse.video.durationBucket = nextHighestRange;\n      </findNextHighestRangeAndAssign>\n    } else {\n      <logDurationWarningAndRejectBid>\n      utils.logWarn(`Detected a bid with a duration value outside the accepted ranges specified in adUnit.mediaTypes.video.durationRangeSec.  Rejecting bid: `, bidResponse);\n      return false;\n      </logDurationWarningAndRejectBid>\n    }\n  } else {\n    if (find(adUnitRanges, range => range === bidDuration)) {\n      <assignDurationBucketExactMatch>\n      bidResponse.video.durationBucket = bidDuration;\n      </assignDurationBucketExactMatch>\n    } else {\n      <logExactMatchWarningAndRejectBid>\n      utils.logWarn(`Detected a bid with a duration value not part of the list of accepted ranges specified in adUnit.mediaTypes.video.durationRangeSec.  Exact match durations must be used for this adUnit. Rejecting bid: `, bidResponse);\n      return false;\n      </logExactMatchWarningAndRejectBid>\n    }\n  }\n  </validateBidDuration>\n  return true;\n}\n"], ["createMatch", "\nfunction createMatch(data) {\n  <matchDataCallback>\n  return function(node) {\n    <checkNodeValidity>\n    if (node == root || node == null || node == doc) return null; \n    </checkNodeValidity>\n    <performMatchData>\n    return matchData(node, data);\n    </performMatchData>\n  };\n  </matchDataCallback>\n}\n"], ["ORMObjectBuilder", "\nfunction() {\n\tvar me = {};\n\tvar db = common.config.database;\n\n\tme.act = new NobleMachine();\n\n\treturn _.extend(me, {\n\t\t<createTable>\n\t\tcreate_table: function(name, definer) {\n\t\t\tvar t = new TableDefinition(name, 'create', definer);\n\t\t\tme.act.next(t.act);\n\t\t},\n\t\t</createTable>\n\n\t\t<changeTable>\n\t\tchange_table: function(name, definer) {\n\t\t\tvar t = new TableDefinition(name, 'alter', definer);\n\t\t\tme.act.next(t.act);\n\t\t},\n\t\t</changeTable>\n\n\t\t<dropTable>\n\t\tdrop_table: function(name) {\n\t\t\tme.act.next(db.query(\" DROP TABLE `\" + name + \"`;\"));\n\t\t},\n\t\t</dropTable>\n\n\t\t<renameTable>\n\t\trename_table: function(name, newname) {\n\t\t\tme.act.next(db.query(\" ALTER TABLE `\" + name + \"` RENAME `\" + newname + \"`\"));\n\t\t},\n\t\t</renameTable>\n\t});\n}\n"], ["UnrollSampleLoop", "\nfunction UnrollSampleLoop(samp) {\n  <calculateLoopIterations>\n  var nloops = ((2048 + samp.looplen - 1) / samp.looplen) | 0;\n  var pingpong = samp.type & 2;\n  if (pingpong) {\n    nloops = (nloops + 1) & (~1);\n  }\n  </calculateLoopIterations>\n  <prepareSampleDataBuffer>\n  var samplesiz = samp.loop + nloops * samp.looplen;\n  var data = new Float32Array(samplesiz);\n  </prepareSampleDataBuffer>\n  <copyInitialSampleData>\n  for (var i = 0; i < samp.loop; i++) {\n    data[i] = samp.sampledata[i];\n  }\n  </copyInitialSampleData>\n  <unrollLoop>\n  for (var j = 0; j < nloops; j++) {\n    var k;\n    if ((j&1) && pingpong) {\n      for (k = samp.looplen - 1; k >= 0; k--) {\n        data[i++] = samp.sampledata[samp.loop + k];\n      }\n    } else {\n      for (k = 0; k < samp.looplen; k++) {\n        data[i++] = samp.sampledata[samp.loop + k];\n      }\n    }\n  }\n  </unrollLoop>\n  <logAndFinalizeSampleData>\n  console.log(\"unrolled sample loop; looplen\", samp.looplen, \"x\", nloops, \" = \", samplesiz);\n  samp.sampledata = data;\n  samp.looplen = nloops * samp.looplen;\n  samp.type = 1;\n  </logAndFinalizeSampleData>\n}\n"], ["fadeSeries", "\nfunction(series) {\n  <checkSeriesValidity>\n  if(!series || !series.area) {\n      return;\n  }\n  </checkSeriesValidity>\n  <applyFadedColorToSeries>\n  series.area.attr({'fill': this.fadedElementColor});\n  </applyFadedColorToSeries>\n  <conditionallyApplyFadedColorToGraph>\n  if(this.showLines) {\n      series.graph.attr({'stroke': this.fadedElementColor});\n  }\n  </conditionallyApplyFadedColorToGraph>\n}\n"], ["baseURIFunction", "\nfunction (base) {\n  <handleBaseURIAssignment>\n  if (this.union === undefined) {\n    if (base === undefined) {\n      return this.baseURI;\n    } else {\n      this.baseURI = base;\n      return this;\n    }\n  } \n  </handleBaseURIAssignment>\n  <handleBaseURIFromUnion>\n  else if (base === undefined) {\n    return this.union[0].base();\n  } else {\n    <setBaseURIForUnionMembers>\n    $.each(this.union, function (i, databank) {\n      databank.base(base);\n    });\n    </setBaseURIForUnionMembers>\n    return this;\n  }\n  </handleBaseURIFromUnion>\n}\n"], ["storeWidgetSchema", "\nfunction(widget_title, widget_config) {\n  <preventRedefinition>\n\tif (!Lava.schema.widget.ALLOW_REDEFINITION && (widget_title in this.widgets))\n\t\tLava.t(\"storeWidgetSchema: widget is already defined: \" + widget_title);\n  </preventRedefinition>\n\n  <registerWidgetConfig>\n\tthis.widgets[widget_title] = widget_config;\n  </registerWidgetConfig>\n\n  <createSugarMapping>\n\tif (('sugar' in widget_config) && widget_config.sugar.tag_name) {\n\t\tthis.sugar_map[widget_config.sugar.tag_name] = {widget_title: widget_title};\n\t}\n  </createSugarMapping>\n}\n"], ["arrayEachRight", "\nfunction arrayEachRight(array, callback) {\n  <iterateArrayFromRight>\n  var length = array ? array.length : 0;\n  while (length--) {\n    if (callback(array[length], length, array) === false) {\n      break;\n    }\n  }\n  </iterateArrayFromRight>\n  return array;\n}\n"], ["removeDuplicateObjectsFromArray", "\nfunction removeDuplicateObjectsFromArray(originalArray, prop) {\n  <initializeHelpers>\n  var newArray = [];\n  var lookupObject = {};\n  </initializeHelpers>\n\n  <buildLookupObject>\n  for (var i in originalArray) {\n    lookupObject[originalArray[i][prop]] = originalArray[i];\n  }\n  </buildLookupObject>\n\n  <createNewArrayFromLookup>\n  for (i in lookupObject) {\n    newArray.push(lookupObject[i]);\n  }\n  </createNewArrayFromLookup>\n  return newArray;\n}\n"], ["getMaxLines", "\nfunction getMaxLines(height) {\n  <calculateMaximumLines>\n  var availHeight = height || element.clientHeight,\n    lineHeight = getLineHeight(element);\n  return Math.max(Math.floor(availHeight / lineHeight), 0);\n  </calculateMaximumLines>\n}\n"], ""]