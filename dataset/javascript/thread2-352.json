[["switchTouchEvent", "\nfunction (obj, type, handler, id) {\n\t\tswitch (type) {\n\t\tcase 'touchstart':\n\t\t\treturn this.addPointerListenerStart(obj, type, handler, id);\n\t\tcase 'touchend':\n\t\t\treturn this.addPointerListenerEnd(obj, type, handler, id);\n\t\tcase 'touchmove':\n\t\t\treturn this.addPointerListenerMove(obj, type, handler, id);\n\t\tdefault:\n\t\t\tthrow 'Unknown touch event type';\n\t\t}\n\t}\n"], ["promiseRecursiveScrape", "\nfunction rxs(dyn, obj, urlArr, selector, tailArr, limit) {\n  \n  return new Promise(function(dresolve, dreject) {\n  \n    <performInitialScrape>\n    xs(dyn, urlArr, selector, limit)\n      .then(function(grabbed) {\n        \n        obj.child = grabbed\n    </performInitialScrape>      \n\n        <processChildElements>\n        var promises = []\n    \n        _.map(obj.child, function(o) {\n          \n          <generatePromisesForChildren>\n          var deferG = new Promise(function(resolve, reject) {\n  \n\n            var expectGChild = !_.isEmpty(_.compact(tailArr)) && !_.isEmpty(_.compact(o.hrefs))\n              \n            if (expectGChild) {\n              var hrefs = o.hrefs\n              var newTailArr = _.clone(tailArr)\n              var newSelector = newTailArr.shift()\n    \n              rxs(dyn, o, hrefs, newSelector, newTailArr, limit)\n                .then(resolve)\n                .catch(reject)\n            } else {\n              resolve()\n            }\n          })\n          </generatePromisesForChildren>\n          promises.push(deferG)\n          return deferG\n        })\n        </processChildElements>\n\n        <finalizePromiseChain>\n        return Promise.all(promises)\n          .then(function(res) {\n            return dresolve(obj)\n          })\n          .catch(dreject)\n        </finalizePromiseChain>\n      })\n  })\n}\n"], ["tryReconnect", "\nfunction _tryReconnect(dbInfo) {\n    <deferDatabaseReadiness>\n    _deferReadiness(dbInfo);\n    </deferDatabaseReadiness>\n\n    var dbContext = dbContexts[dbInfo.name];\n    var forages = dbContext.forages;\n\n    <closeAllForages>\n    for (var i = 0; i < forages.length; i++) {\n        var forage = forages[i];\n        if (forage._dbInfo.db) {\n            forage._dbInfo.db.close();\n            forage._dbInfo.db = null;\n        }\n    }\n    </closeAllForages>\n    dbInfo.db = null;\n\n    <establishConnection>\n    return _getOriginalConnection(dbInfo).then(function (db) {\n        dbInfo.db = db;\n        if (_isUpgradeNeeded(dbInfo)) {\n            return _getUpgradedConnection(dbInfo);\n        }\n        return db;\n    }).then(function (db) {\n        dbInfo.db = dbContext.db = db;\n        for (var i = 0; i < forages.length; i++) {\n            forages[i]._dbInfo.db = db;\n        }\n    })[\"catch\"](function (err) {\n        _rejectReadiness(dbInfo, err);\n        throw err;\n    });\n    </establishConnection>\n}\n"], ["createApplicationManager", "\nfunction createManager () {\n  <defineInitialState>\n  const INITIAL_STATE = {\n    content: null,\n    loading: true,\n    currentPathname: null,\n    nextPathname: null\n  }\n  </defineInitialState>\n\n  <constructReduxStore>\n  const store = createStore(reducer)\n  </constructReduxStore>\n\n  <defineReducer>\n  function reducer (state = INITIAL_STATE, action) {\n    switch (action.type) {\n      case 'CONTENT_LOADED':\n        if (!action.asynchronously || action.pathname === state.nextPathname) {\n          return {\n            content: action.content,\n            loading: false,\n            currentPathname: action.pathname,\n            nextPathname: null\n          }\n        } else {\n          return state\n        }\n      case 'CONTENT_LOAD_STARTED':\n        return {\n          content: state.content,\n          loading: true,\n          currentPathname: state.pathname,\n          nextPathname: action.pathname\n        }\n      default:\n        return state\n    }\n  }\n  </defineReducer>\n\n  <createManagerObject>\n  const manager = {\n    subscribe (callback) {\n      return store.subscribe(callback)\n    },\n    getContent () {\n      return store.getState().content\n    },\n    getCurrentPathname () {\n      return store.getState().currentPathname\n    },\n    isLoading () {\n      return store.getState().loading\n    },\n    isReady () {\n      return !!store.getState().content\n    },\n    handleContentLoaded (pathname, content, { asynchronously }) {\n      store.dispatch({ type: 'CONTENT_LOADED', pathname, content, asynchronously })\n    },\n    handleContentLoadStarted (pathname) {\n      store.dispatch({ type: 'CONTENT_LOAD_STARTED', pathname })\n    }\n  }\n  </createManagerObject>\n\n  return manager\n}\n"], ["parseBinaryLambdaCalculus", "\nfunction fromBLC(source){\n  <parseBLCRecursively>\n    var index = 0;\n    return (function go(){\n      if (source[index] === \"0\")\n        return source[index+1] === \"0\"\n          ? (index+=2, Lam(go()))\n          : (index+=2, App(go(), go()));\n      for (var i=0; source[index]!==\"0\"; ++i)\n        ++index;\n      return (++index, Var(i-1));\n    })();\n  </parseBLCRecursively>\n}\n"], ["initializeLayer", "\nfunction(opt) {\n    var opt = opt || {};\n\n    <setLayerAttributes>\n    this.out_sx = opt.in_sx;\n    this.out_sy = opt.in_sy;\n    this.out_depth = opt.in_depth;\n    this.layer_type = 'relu';\n    </setLayerAttributes>\n}\n"], ["createLineFromVector", "\nfunction(vector$$1) {\n    var V = vector$$1.elements || vector$$1;\n    <combineAnchorAndVectorToCreateLine>\n    return Line.create([\n      this.anchor.elements[0] + V[0],\n      this.anchor.elements[1] + V[1],\n      this.anchor.elements[2] + (V[2] || 0)\n    ], this.direction);\n    </combineAnchorAndVectorToCreateLine>\n}\n"], ["compareVectors", "\nfunction equals(v) {\n  <checkVectorEquality>\n  return this._x === v.x && this._y === v.y && this._z === (v.z || this._z);\n  </checkVectorEquality>\n}\n"], ["addModelToCollection", "\nfunction(model, at){\n    model = new this._Model(model, this.options.Model.options);\n\n    <verifyAndAddModel>\n    if (!this.hasModel(model)) {\n        \n        <attachModelEvents>\n        this.attachModelEvents(model);\n        </attachModelEvents>\n\n        <determineInsertionIndex>\n        at = this.length == 0 ? void 0 : at;\n        </determineInsertionIndex>\n\n        <insertModelInCollection>\n        if (at != void 0) {\n            this._models.splice(at, 0, model);\n        } else {\n            this._models.push(model);\n        }\n        </insertModelInCollection>\n\n        this.length = this._models.length;\n\n        this._changed = true;\n\n        <emitAddSignal>\n        this.signalAdd(model, at != void 0 ? at : this.length - 1);\n        </emitAddSignal>\n    }\n    </verifyAndAddModel>\n\n    return this;\n}\n"], ["initializeMesh", "\nfunction Mesh(options) {\n  options = options || {};\n  <initializeMeshBuffers>\n  this.vertexBuffers = {};\n  this.indexBuffers = {};\n  this.addVertexBuffer('vertices', 'gl_Vertex');\n  if (options.coords) this.addVertexBuffer('coords', 'gl_TexCoord');\n  if (options.normals) this.addVertexBuffer('normals', 'gl_Normal');\n  if (options.colors) this.addVertexBuffer('colors', 'gl_Color');\n  if (!('triangles' in options) || options.triangles) this.addIndexBuffer('triangles');\n  if (options.lines) this.addIndexBuffer('lines');\n  </initializeMeshBuffers>\n}\n"], ""]