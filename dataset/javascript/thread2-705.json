[["checkVariableLikeDeclaration", "\nfunction checkVariableLikeDeclaration(node) {\n    <checkDecoratorsAndTypes>\n    checkDecorators(node);\n    checkSourceElement(node.type);</checkDecoratorsAndTypes>\n    \n    <checkComputedPropertyNames>\n    if (node.name.kind === 140 ) {\n        checkComputedPropertyName(node.name);\n        if (node.initializer) {\n            checkExpressionCached(node.initializer);\n        }\n    }</checkComputedPropertyNames>\n    \n    <checkBindingPropertyNamesAndAccess>\n    if (node.kind === 169 ) {\n        \n        if (node.propertyName && node.propertyName.kind === 140 ) {\n            checkComputedPropertyName(node.propertyName);\n        }\n        \n        var parent_11 = node.parent.parent;\n        var parentType = getTypeForBindingElementParent(parent_11);\n        var name_18 = node.propertyName || node.name;\n        var property = getPropertyOfType(parentType, getTextOfPropertyName(name_18));\n        if (parent_11.initializer && property && getParentOfSymbol(property)) {\n            checkClassPropertyAccess(parent_11, parent_11.initializer, parentType, property);\n        }\n    }</checkBindingPropertyNamesAndAccess>\n    \n    <checkBindingPatternSourceElements>\n    if (ts.isBindingPattern(node.name)) {\n        ts.forEach(node.name.elements, checkSourceElement);\n    }</checkBindingPatternSourceElements>\n    \n    <checkParameterInitializerImplementation>\n    if (node.initializer && ts.getRootDeclaration(node).kind === 142  && ts.nodeIsMissing(ts.getContainingFunction(node).body)) {\n        error(node, ts.Diagnostics.A_parameter_initializer_is_only_allowed_in_a_function_or_constructor_implementation);\n        return;\n    }</checkParameterInitializerImplementation>\n    \n    <checkBindingPatternAssignabilityAndInitializer>\n    if (ts.isBindingPattern(node.name)) {\n        \n        if (node.initializer && node.parent.parent.kind !== 207 ) {\n            checkTypeAssignableTo(checkExpressionCached(node.initializer), getWidenedTypeForVariableLikeDeclaration(node), node,  undefined);\n            checkParameterInitializer(node);\n        }\n        return;\n    }</checkBindingPatternAssignabilityAndInitializer>\n    \n    <checkVariableOrPropertyType>\n    var symbol = getSymbolOfNode(node);\n    var type = getTypeOfVariableOrParameterOrProperty(symbol);\n    if (node === symbol.valueDeclaration) {\n        \n        if (node.initializer && node.parent.parent.kind !== 207 ) {\n            checkTypeAssignableTo(checkExpressionCached(node.initializer), type, node,  undefined);\n            checkParameterInitializer(node);\n        }\n    }</checkVariableOrPropertyType>\n    \n    <checkDeclarationConsistencyAndModifiers>\n    else {\n        \n        var declarationType = getWidenedTypeForVariableLikeDeclaration(node);\n        if (type !== unknownType && declarationType !== unknownType && !isTypeIdenticalTo(type, declarationType)) {\n            error(node.name, ts.Diagnostics.Subsequent_variable_declarations_must_have_the_same_type_Variable_0_must_be_of_type_1_but_here_has_type_2, ts.declarationNameToString(node.name), typeToString(type), typeToString(declarationType));\n        }\n        if (node.initializer) {\n            checkTypeAssignableTo(checkExpressionCached(node.initializer), declarationType, node,  undefined);\n        }\n        if (!areDeclarationFlagsIdentical(node, symbol.valueDeclaration)) {\n            error(symbol.valueDeclaration.name, ts.Diagnostics.All_declarations_of_0_must_have_identical_modifiers, ts.declarationNameToString(node.name));\n            error(node.name, ts.Diagnostics.All_declarations_of_0_must_have_identical_modifiers, ts.declarationNameToString(node.name));\n        }\n    }</checkDeclarationConsistencyAndModifiers>\n    \n    <checkExportsMergedDeclarationsAndCollisions>\n    if (node.kind !== 145  && node.kind !== 144 ) {\n        \n        checkExportsOnMergedDeclarations(node);\n        if (node.kind === 218  || node.kind === 169 ) {\n            checkVarDeclaredNamesNotShadowed(node);\n        }\n        checkCollisionWithCapturedSuperVariable(node, node.name);\n        checkCollisionWithCapturedThisVariable(node, node.name);\n        checkCollisionWithRequireExportsInGeneratedCode(node, node.name);\n        checkCollisionWithGlobalPromiseInGeneratedCode(node, node.name);\n    }</checkExportsMergedDeclarationsAndCollisions>\n}\n"], ["parseInt", "\nfunction parseInt (buffer, size) {\n  switch (size) {\n    case 1:\n      return buffer[buffer.read++];\n\n    case 2:\n      return (buffer[buffer.read++] << 8) + buffer[buffer.read++];\n\n    case 4:\n      return (buffer[buffer.read++] << 24) + (buffer[buffer.read++] << 16) +\n             (buffer[buffer.read++] << 8)  + buffer[buffer.read++];\n\n    case 8:\n      return (buffer[buffer.read++] << 56) + (buffer[buffer.read++] << 48) +\n             (buffer[buffer.read++] << 40) + (buffer[buffer.read++] << 32) +\n             (buffer[buffer.read++] << 24) + (buffer[buffer.read++] << 16) +\n             (buffer[buffer.read++] << 8)  + buffer[buffer.read++];\n\n    default:\n      throw new Error(\"cannot parse ints of that size\");\n  }\n}\n"], ["lookup", "\nfunction lookup(obj, type, name) {\n  while (obj) {\n    if (obj[type] && obj[type].hasOwnProperty(name)) {\n      return obj[type][name];\n    }\n    obj = obj.parent;\n  }\n}\n"], ["ListCollectionIdsRequest", "\nfunction ListCollectionIdsRequest(properties) {\n    <initializeProperties>\n    if (properties)\n        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n            if (properties[keys[i]] != null)\n                this[keys[i]] = properties[keys[i]];\n    </initializeProperties>\n}\n"], ["unregister", "\nfunction unregister(win, accelerator) {\n    <processArgumentsAndWindow>\n    let wc;\n    if (typeof accelerator === 'undefined') {\n        wc = ANY_WINDOW;\n        accelerator = win;\n    } else {\n        if (win.isDestroyed()) {\n            debug(`Early return because window is destroyed.`);\n            return;\n        }\n        wc = win.webContents;\n    }</processArgumentsAndWindow>\n    \n    <handleArrayOfAccelerators>\n    if (Array.isArray(accelerator) === true) {\n        accelerator.forEach(accelerator => {\n            if (typeof accelerator === 'string') {\n                unregister(win, accelerator);\n            }\n        });\n        return;\n    }</handleArrayOfAccelerators>\n\n    <unregisterShortcutsDebuggingAndRemoval>\n    debug(`Unregistering callback for ${accelerator} on window ${title(win)}`);\n\n    _checkAccelerator(accelerator);\n\n    debug(`${accelerator} seems a valid shortcut sequence.`);\n\n    if (!windowsWithShortcuts.has(wc)) {\n        debug(`Early return because window has never had shortcuts registered.`);\n        return;\n    }\n\n    const shortcutsOfWindow = windowsWithShortcuts.get(wc);\n\n    const eventStamp = toKeyEvent(accelerator);\n    const shortcutIdx = _findShortcut(eventStamp, shortcutsOfWindow);\n    if (shortcutIdx === -1) {\n        return;\n    }\n\n    shortcutsOfWindow.splice(shortcutIdx, 1);\n\n    if (shortcutsOfWindow.length === 0) {\n        shortcutsOfWindow.removeListener();\n        windowsWithShortcuts.delete(wc);\n    }</unregisterShortcutsDebuggingAndRemoval>\n}\n"], ["indexOfPolyfill", "\nfunction(arr, o) {\n    <polyfillImplementation>\n    if (arr.indexOf) return arr.indexOf(o);\n    for (var i = 0; i < this.length; i++) if (arr[i] === o) return i;\n    return -1;\n    </polyfillImplementation>\n}\n"], ["formatLine", "\nfunction formatLine({ rule, message, location }, metrics) {\n    <formattingOutput>\n    const { line, col } = location;\n    const { line: lineW, col: colW, message: msgW } = metrics;\n    const loc = sprintf(`%${lineW}d:%-${colW}d`, line, col);\n    const msg = sprintf(`%-${msgW}s`, message);\n    return `  ${loc}  ${msg}  ${rule}`;\n    </formattingOutput>\n}\n"], ["off", "\nfunction off(type, listener) {\n    <unbindEventListeners>\n    var me = this,\n        events = me.events;\n\n    events && each(type ? type.split(' ') : events, function(listeners, type) {\n      var index;\n      if (typeof listeners == 'string') {\n        type = listeners;\n        listeners = hasKey(events, type) && events[type];\n      }\n      if (listeners) {\n        if (listener) {\n          index = indexOf(listeners, listener);\n          if (index > -1) {\n            listeners.splice(index, 1);\n          }\n        } else {\n          listeners.length = 0;\n        }\n      }\n    });\n    return me;\n    </unbindEventListeners>\n}\n"], ["setItem", "\nfunction setItem(key, value) {\n    <setupPersistency>\n    var persistency = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;</setupPersistency>\n\n    <handleSessionStorage>\n    if (!persistency) {\n        session.setItem(key, value);\n        return;\n    }</handleSessionStorage>\n\n    <handleLocalStorageAndFallback>\n    if (!hasLocalStorage()) {\n        cookie$1.setItem(key, value);\n        return;\n    }\n\n    try {\n        localstorage.setItem(key, value);\n    } catch (e) {\n        var code = e.code;\n\n        if (code === 22 || code === 1014) {\n            log('Quota exceeded for \"' + key + '\"!', 'error', debug);\n\n            cookie$1.setItem(key, value);\n        }\n    }\n    </handleLocalStorageAndFallback>\n}\n"], ["getNextItemRange", "\nfunction getNextItemRange(model, anchor, getItemRanges) {\n    <findNextNodeInRange>\n    let node = nodeForPoint(model, anchor.start, 'next');</findNextNodeInRange>\n    \n    <locateRangeForNode>\n    let range;\n\n    while (node && !range) {\n        range = getNextRange(getItemRanges(node), anchor);\n        node = node.firstChild || nextSibling(node);\n    }\n\n    return range;\n    </locateRangeForNode>\n}\n"], "```"]