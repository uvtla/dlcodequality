[["cleanupState", "\nfunction () {\n  removeEvent(docBody, 'mousemove');\n  if (cPRender) {\n    clearInterval(cPRender);\n    cPRender = false;\n    doRender(true, true)\n  }\n  cP.cPSL4.className = 'cPSL4'; \n  cP.cPResizers.cssText = '';\n  \n  cP.cObj.osX = cP.style.left;\n  cP.cObj.osY = cP.style.top; \n  if (cP.inp) cP.inp.className = '';\n}\n"], ["parseAndExtendData", "\nfunction(result){\n\n  var data = {},\n    geometry = result.geometry,\n    viewport = geometry.viewport,\n    bounds = geometry.bounds;\n\n  \n  $.each(result.address_components, function(index, object){\n    var name = object.types[0];\n\n    $.each(object.types, function(index, name){\n      data[name] = object.long_name;\n      data[name + \"_short\"] = object.short_name;\n    });\n  });\n\n  \n  $.each(placesDetails, function(index, key){\n    data[key] = result[key];\n  });\n\n  \n  $.extend(data, {\n    formatted_address: result.formatted_address,\n    location_type: geometry.location_type || \"PLACES\",\n    viewport: viewport,\n    bounds: bounds,\n    location: geometry.location,\n    lat: geometry.location.lat(),\n    lng: geometry.location.lng()\n  });\n\n  \n  $.each(this.details, $.proxy(function(key, $detail){\n    var value = data[key];\n    this.setDetail($detail, value);\n  }, this));\n\n  this.data = data;\n}\n"], ["initializeHTTPServer", "\nfunction HTTPServer(options) {\n  if (!(this instanceof HTTPServer))\n    return new HTTPServer(options);\n\n  options = new HTTPOptions(options);\n\n  HTTPBase.call(this, options);\n\n  this.options = options;\n  this.network = this.options.network;\n  this.logger = this.options.logger.context('http');\n  this.node = this.options.node;\n\n  this.chain = this.node.chain;\n  this.mempool = this.node.mempool;\n  this.pool = this.node.pool;\n  this.fees = this.node.fees;\n  this.miner = this.node.miner;\n  this.rpc = this.node.rpc;\n\n  this.init();\n}\n"], ["parseServerUrl", "\nfunction(serverUrl) {\n  var parsedUrl = url.parse(serverUrl);\n  if (!parsedUrl.hostname) {\n    throw new Error('Invalid server URL: ' + serverUrl);\n  }\n\n  \n  this.options_ = {\n    host: parsedUrl.hostname,\n    path: parsedUrl.pathname,\n    port: parsedUrl.port\n  };\n}\n"], ["convertArrayToMap", "\nfunction mapify(elements) {\n  var result = {};\n  for (var i = 0; i + 1 < elements.length;) {\n    result[elements[i++]] = elements[i++];\n  }\n  return result;\n}\n"], ["convertQueryToMongo", "\nfunction queryCriteriaToMongo(query, options) {\n  var hash = {}, p, v, deep;\n  options = options || {};\n\n  for (var key in query) {\n    if (Object.prototype.hasOwnProperty.call(query, key) && (!options.ignore || options.ignore.indexOf(key) == -1)) {\n      deep = (typeof query[key] === 'object' && !hasOrdinalKeys(query[key]))\n\n      if (deep) {\n        p = {\n          key: key,\n          value: queryCriteriaToMongo(query[key])\n        }\n      } else {\n        p = comparisonToMongo(key, query[key])\n      }\n\n      if (p) {\n        if (!hash[p.key]) {\n          hash[p.key] = p.value;\n        } else {\n          hash[p.key] = Object.assign(hash[p.key], p.value);\n        }\n      }\n    }\n  }\n  return hash\n}\n"], ["resolveArguments", "\nfunction resolveArgs(argumentsObject, nameMap, rightToLeft) {\n  var result = {};\n\n  var takeFromRight = rightToLeft;\n  var args = Array.prototype.slice.call(argumentsObject);\n\n  while (nameMap.length) {\n    var value = null;\n    var name = take(nameMap, takeFromRight);\n\n    if (args.length > 0) {\n      value = take(args, takeFromRight);\n      takeFromRight = !takeFromRight;\n    }\n\n    result[name] = value;\n  }\n\n  return result;\n}\n"], ["modifyEditorState", "\nfunction() {\n<modifyEditorStateInner>\n  // This function mixes the sound editor state management and user interface updates.\n  // To strictly adhere to SRP, these concerns should be separated.\n  // However, this function appears to act as a high-level 'action', possibly orchestrating\n  // several operations tied to the editing state, which justifies its multiple operations under a single responsibility context.\n\n  var data = window.kelmu.data[id];\n  var elemData = data.definitions['step' + data.stepNumber][data.subStepNumber][data.selectedElementNumber];\n\n  editor.find('.kelmu-editor-pane').remove();\n\n  var soundEditor = $('<div></div>').addClass('kelmu-sound-editor').addClass('kelmu-editor-pane');\n  soundEditor.appendTo(editor);\n\n  soundEditor.append($('<h4>Sound</h4>').css('margin', '15px 0px'));\n\n  idCounter += 1;\n\n  \n  addComponent('URL:', soundEditor, 'kelmu-sound-url', elemData.sound, 'text', true);\n\n  \n  soundEditor.find('.kelmu-sound-url').focus();\n  var val = soundEditor.find('.kelmu-sound-url').val();\n  soundEditor.find('.kelmu-sound-url').val('').val(val);\n\n  var buttonContainer = $('<div></div>').appendTo(soundEditor);\n\n  \n  var saveButton = function() {\n    elemData.sound = soundEditor.find('.kelmu-sound-url').val();\n    window.kelmu.data[id].actions.update();\n    updateView(true, true);\n    notifyModifications();\n  };\n\n  soundEditor.find('input').keyup(saveButton);\n\n  createRemoveButton().click(function(e) {\n    e.preventDefault();\n\n    var soundControl = container.find('.kelmu-sound-control');\n    soundControl.hide();\n\n    \n    Object.keys(window.kelmu.data[id].definitions || {}).forEach(function(substeps) {\n      window.kelmu.data[id].definitions[substeps].forEach(function(substep) {\n        substep.forEach(function(step) {\n          if (step.sound !== undefined) {\n            soundControl.show();\n          }\n        });\n      });\n    });\n\n  }).appendTo(buttonContainer);\n\n  \n  $('<button></button>').text('Play').addClass('btn').appendTo(buttonContainer).click(function(e) {\n    e.preventDefault();\n    var sound = $('<audio></audio>').attr('src', soundEditor.find('.kelmu-sound-url').val());\n    container.append(sound);\n    sound[0].play();\n  });\n\n</modifyEditorStateInner>\n}\n"], ["manageLegend", "\nfunction legendProvider(publicAPI, model) {\n<manageLegendEntries>\n  publicAPI.addLegendEntry = (name) => {\n    if (model.legendEntries.indexOf(name) === -1 && name) {\n      model.legendEntries.push(name);\n      model.legendDirty = true;\n    }\n  };\n\n  publicAPI.removeLegendEntry = (name) => {\n    if (model.legendEntries.indexOf(name) !== -1 && name) {\n      model.legendEntries.splice(model.legendEntries.indexOf(name), 1);\n      model.legendDirty = true;\n    }\n  };\n  publicAPI.removeAllLegendEntry = () => {\n    model.legendEntries = [];\n    model.legendDirty = true;\n  };\n</manageLegendEntries>\n\n<assignLegendPriorities>\n  publicAPI.assignLegend = (newPriority = null) => {\n    if (newPriority) {\n      model.legendPriorities = newPriority;\n      model.legendDirty = true;\n    }\n    if (model.legendDirty) {\n      const shapesArray = Object.keys(model.legendShapes);\n      model.legendDirty = false;\n      model.legendMapping = {};\n\n      if (model.legendPriorities && model.legendPriorities.length) {\n        const defaultColor = model.legendColors[0];\n        const defaultShape = shapesArray[0];\n\n        const iterator = createSortedIterator(\n          model.legendPriorities,\n          { colors: model.legendColors, shapes: shapesArray },\n          { colors: defaultColor, shapes: defaultShape }\n        );\n\n        model.legendEntries.forEach((name) => {\n          model.legendMapping[name] = convert(iterator.get(), model);\n          iterator.next();\n        });\n      } else {\n        model.legendEntries.forEach((name, idx) => {\n          model.legendMapping[name] = {\n            color: model.legendColors[idx % model.legendColors.length],\n            shape: model.legendShapes[shapesArray[idx % shapesArray.length]],\n          };\n        });\n      }\n    }\n  };\n</assignLegendPriorities>\n\n<additionalLegendFunctions>\n  publicAPI.useLegendPalette = (name) => {\n    const colorSet = palettes[name];\n    if (colorSet) {\n      model.legendColors = [].concat(colorSet);\n      model.legendDirty = true;\n    }\n  };\n\n  publicAPI.updateLegendSettings = (settings) => {\n    [\n      'legendShapes',\n      'legendColors',\n      'legendEntries',\n      'legendPriorities',\n    ].forEach((key) => {\n      if (settings[key]) {\n        model[key] = [].concat(settings.key);\n        model.legendDirty = true;\n      }\n    });\n  };\n\n  publicAPI.listLegendColorPalettes = () => Object.keys(palettes);\n\n  publicAPI.getLegend = (name) => {\n    if (model.legendDirty) {\n      publicAPI.assignLegend();\n    }\n    return model.legendMapping[name];\n  };\n</additionalLegendFunctions>\n"], ["deleteCardFunction", "\nfunction deleteCard(card, options) {\n  return webdav.deleteObject(card.url, card.etag, options);\n}\n"], "```"]