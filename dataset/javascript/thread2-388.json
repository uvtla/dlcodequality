[["report", "\nfunction report(condition) {\n  const node = condition.reference.identifier;\n\n  context.report({\n    node,\n    message: \"'{{name}}' is not modified in this loop.\",\n    data: node\n  });\n}\n"], ["createAttributeSetters", "\nfunction createAttributeSetters(gl, program) {\n  <initializeAttributes>\n  const attribSetters = {};\n  </initializeAttributes>\n\n  <getAttributesFromProgram>\n  const numAttribs = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);\n  for (let ii = 0; ii < numAttribs; ++ii) {\n    const attribInfo = gl.getActiveAttrib(program, ii);\n    if (isBuiltIn(attribInfo)) {\n      continue;\n    }\n    const index = gl.getAttribLocation(program, attribInfo.name);\n    const typeInfo = attrTypeMap[attribInfo.type];\n    const setter = typeInfo.setter(gl, index, typeInfo);\n    setter.location = index;\n    attribSetters[attribInfo.name] = setter;\n  }\n  </getAttributesFromProgram>\n\n  return attribSetters;\n}\n"], ["recompute", "\nfunction recompute() {\n  <defineVariables>\n  var matrix = me.matrix,\n      angle,\n      s, c,\n      m00,\n      m01,\n      m02,\n      m03,\n      m10,\n      m11,\n      m12,\n      m13;\n  </defineVariables>\n\n  <checkForIdentityTransformation>\n  if (!translateX &&\n      !translateY &&\n      !rotation &&\n      !skewX &&\n      !skewY &&\n      scaleX === 1 &&\n      scaleY === 1\n  ) {\n    me.transformed = false;\n    return;\n  }\n  </checkForIdentityTransformation>\n\n  <initializeMatrix>\n  mat4.identity(matrix);\n  </initializeMatrix>\n\n  <performTransformation>\n  translate(translateX + centerX, translateY + centerY);\n  </performTransformation>\n\n  <applySkewing>\n  if (skewX) {\n    matrix[4] = skewX / me.width;\n  }\n  if (skewY) {\n    matrix[1] = skewY / me.height;\n  }\n  </applySkewing>\n\n  <rotateMatrix>\n  if (rotation) {\n    <saveOriginalMatrixState>\n    m00 = matrix[0];\n    m01 = matrix[1];\n    m02 = matrix[2];\n    m03 = matrix[3];\n    m10 = matrix[4];\n    m11 = matrix[5];\n    m12 = matrix[6];\n    m13 = matrix[7];\n    </saveOriginalMatrixState>\n\n    <computeRotation>\n    angle = -(degrees ? rotation * Math.PI / 180 : rotation);\n    </computeRotation>\n\n    <calculateSineCosine>\n    s = Math.sin(angle);\n    c = Math.cos(angle);\n    </calculateSineCosine>\n\n    <updateMatrixForRotation>\n    matrix[0] = m00 * c + m10 * s;\n    matrix[1] = m01 * c + m11 * s;\n    matrix[2] = m02 * c + m12 * s;\n    matrix[3] = m03 * c + m13 * s;\n    matrix[4] = m10 * c - m00 * s;\n    matrix[5] = m11 * c - m01 * s;\n    matrix[6] = m12 * c - m02 * s;\n    matrix[7] = m13 * c - m03 * s;\n    </updateMatrixForRotation>\n  }\n  </rotateMatrix>\n\n  <scaleMatrix>\n  if (scaleX !== 1) {\n    matrix[0] *= scaleX;\n    matrix[1] *= scaleX;\n    matrix[2] *= scaleX;\n    matrix[3] *= scaleX;\n  }\n  if (scaleY !== 1) {\n    matrix[4] *= scaleY;\n    matrix[5] *= scaleY;\n    matrix[6] *= scaleY;\n    matrix[7] *= scaleY;\n  }\n  </scaleMatrix>\n\n  <revertTranslation>\n  translate(-centerX, -centerY);\n  </revertTranslation>\n\n  <setStatus>\n  me.transformed = true;\n  </setStatus>\n}\n"], ["indexCurve", "\nfunction indexCurve (data, start, minX, minY, size) {\n  <initializeNode>\n  var node = start\n  </initializeNode>\n\n  <computeZOrderAndLink>\n  do {\n    if (node.z === null) {\n      node.z = zOrder(data[node.i], data[node.i + 1], minX, minY, size)\n    }\n    node.prevZ = node.prev\n    node.nextZ = node.next\n    node = node.next\n  } while (node !== start)\n  </computeZOrderAndLink>\n\n  <prepareForSorting>\n  node.prevZ.nextZ = null\n  node.prevZ = null\n  </prepareForSorting>\n\n  <sortNodes>\n  sortLinked(node)\n  </sortNodes>\n}\n"], ["parseArgument", "\nfunction (argument) {\n  <initializePosition>\n  var pos;\n  </initializePosition>\n\n  <checkForNegation>\n  if (argument.charAt(0) === \"-\") {\n    argument = argument.substr(1);\n    pos = argument.indexOf(\":\");\n    if (-1 < pos) {\n      return [\n        argument.substr(0, pos),\n        argument.substr(pos + 1)\n      ];\n    } else {\n      return [argument];\n    }\n  }\n  </checkForNegation>\n\n  <findEqualsSign>\n  pos = argument.indexOf(\"=\");\n  if (-1 < pos) {\n    return [\n      argument.substr(0, pos),\n      argument.substr(pos + 1)\n    ];\n  }\n  </findEqualsSign>\n\n  return argument;\n}\n"], ["generatePropertyString", "\nfunction( version ) {\n  <preparePropertyName>\n  var propName = (this.group ? this.group + '.' : '') + capitalDashCase( this._field )\n  </preparePropertyName>\n\n  <gatherParameters>\n  var keys = Object.keys( this )\n  var params = []\n  for( var i = 0; i < keys.length; i++ ) {\n    if (keys[i] === 'group') continue\n    params.push( capitalDashCase( keys[i] ) + '=' + this[ keys[i] ] )\n  }\n  </gatherParameters>\n\n  <composeFinalString>\n  return propName +\n    ( params.length ? ';' + params.join( ';' ) : params ) + ':' +\n    ( Array.isArray( this._data ) ? this._data.join( ';' ) : this._data )\n  </composeFinalString>\n}\n"], ["Checksum", "\nfunction Checksum(type, val) {\n  <initializeProperties>\n  this.type = type;\n  this.val = val || 0;\n  </initializeProperties>\n\n  <assignComputeMethod>\n  switch (this.type) {\n    case 0x00:\n      this._compute = this._computeNone;\n      break;\n    case 0x01:\n      this._compute = this._computeCrc32;\n      break;\n    case 0x02:\n      this._compute = this._computeFarm32;\n      break;\n    case 0x03:\n      this._compute = this._computeCrc32C;\n      break;\n    default:\n      assert(false, 'invalid checksum type ' + this.type);\n  }\n  </assignComputeMethod>\n}\n"], ["getTargets", "\nfunction (vName) {\n  <initializeComponent>\n  var that = this,\n      aResult = [];\n  </initializeComponent>\n\n  <processTargetNames>\n  if (Array.isArray(vName)) {\n    vName.forEach(function (sName) {\n      var oTarget = that._mTargets[sName];\n\n      if (oTarget) {\n        aResult.push(oTarget);\n      } else {\n        Log.error(\"The target you tried to get \\\"\" + sName + \"\\\" does not exist!\", that);\n      }\n    });\n    return aResult;\n  }\n  </processTargetNames>\n\n  return this._mTargets[vName];\n}\n"], ["getValuesList", "\nfunction getValuesList (stateObject, chunkNames) {\n  <resetAccumulator>\n  getValuesList_accumulator.length = 0;\n  </resetAccumulator>\n\n  <collectValues>\n  var chunkNamesLength = chunkNames.length;\n  for (var i = 0; i < chunkNamesLength; i++) {\n    getValuesList_accumulator.push(stateObject[chunkNames[i]]);\n  }\n  </collectValues>\n\n  return getValuesList_accumulator;\n}\n"], ["toSampleArray", "\nfunction toSampleArray(audioBuffer) {\n  <initializeSampleRead>\n  var inSamples = audioBuffer.length;\n  readSamples += inSamples;\n  </initializeSampleRead>\n\n  <calculateExpectedSamples>\n  var expectedWrittenSamples = Math.round(readSamples * format.rate / audioBuffer.sampleRate);\n  var outSamples = expectedWrittenSamples - writtenSamples;\n  </calculateExpectedSamples>\n\n  <updateWrittenSamples>\n  writtenSamples += outSamples;\n  </updateWrittenSamples>\n\n  <createDataArray>\n  var data = new SampleArray(outSamples * format.channels);\n  </createDataArray>\n\n  <processChannels>\n  for (var channel = 0; channel < format.channels; channel++) {\n    var audioData = audioBuffer.getChannelData(channel);\n\n    <writeInterpolatedSamples>\n    var offset = channel;\n    for (var i = 0; i < outSamples; i++) {\n      data[offset] = interpolateSample(audioData, i / (outSamples - 1)) * maxSampleValue;\n      offset += format.channels;\n    }\n    </writeInterpolatedSamples>\n  }\n  </processChannels>\n\n  return data;\n}\n"], ""]