[["buildWebpack", "\nfunction buildWebpack(config, previousFileSizes) {\n  console.log('Creating an optimized production build...');\n\n  let compiler = webpack(config);\n  return new Promise((resolve, reject) => {\n    <runWebpackCompiler>\n    compiler.run((err, stats) => {\n      let messages;\n      if (err) {\n        <handleWebpackError>\n        if (!err.message) {\n          return reject(err);\n        }\n        messages = formatWebpackMessages({\n          errors: [err.message],\n          warnings: [],\n        });\n        </handleWebpackError>\n      } else {\n        <formatWebpackMessages>\n        messages = formatWebpackMessages(\n          stats.toJson({ all: false, warnings: true, errors: true })\n        );\n        </formatWebpackMessages>\n      }\n      <processWebpackMessages>\n      if (messages.errors.length) {\n        \n        <limitErrorMessages>\n        if (messages.errors.length > 1) {\n          messages.errors.length = 1;\n        }\n        </limitErrorMessages>\n        return reject(new Error(messages.errors.join('\\n\\n')));\n      }\n      </processWebpackMessages>\n      <handleCIWarnings>\n      if (\n        process.env.CI &&\n        (typeof process.env.CI !== 'string' ||\n          process.env.CI.toLowerCase() !== 'false') &&\n        messages.warnings.length\n      ) {\n        console.log(\n          chalk.yellow(\n            '\\nTreating warnings as errors because process.env.CI = true.\\n' +\n              'Most CI servers set it automatically.\\n'\n          )\n        );\n        return reject(new Error(messages.warnings.join('\\n\\n')));\n      }\n      </handleCIWarnings>\n\n      const resolveArgs = {\n        stats,\n        previousFileSizes,\n        warnings: messages.warnings,\n      };\n      <writeStatsJson>\n      if (writeStatsJson) {\n        return bfj\n          .write(paths.appBuild + '/bundle-stats.json', stats.toJson())\n          .then(() => resolve(resolveArgs))\n          .catch(error => reject(new Error(error)));\n      }\n      </writeStatsJson>\n\n      return resolve(resolveArgs);\n    });\n    </runWebpackCompiler>\n  });\n}\n"], ["BINDING_anchor", "\nfunction BINDING_anchor($scope, key, element, getControl, bindings) {\n  <watchBinding>\n        bindings.push($scope.$watch(key, function (newValue, oldValue) {\n            <updateAnchorBinding>\n            newValue = typeof newValue === \"string\" ? select(newValue, element) : newValue;\n            oldValue = typeof oldValue === \"string\" ? select(oldValue, element) : oldValue;\n            if (oldValue && oldValue._anchorClick) {\n                oldValue.removeEventListener(\"click\", oldValue._anchorClick);\n                oldValue._anchorClick = null;\n            }\n            if (newValue && !newValue._anchorClick) {\n                newValue._anchorClick = function () { getControl().show(); };\n                newValue.addEventListener(\"click\", newValue._anchorClick);\n            }\n            </updateAnchorBinding>\n            return newValue;\n        }));\n        </watchBinding>\n        var anchor = $scope[key];\n        return typeof anchor === \"string\" ? select(anchor, element) : anchor;\n    }\n"], ["updateResizeLine", "\nfunction updateResizeLine( cell, uetable ) {\n\n  <calculateLinePosition>\n        var line = getResizeLineByUETable.call( this ),\n            table = uetable.table,\n            styles = {\n                top: domUtils.getXY( table ).y + 'px',\n                left: domUtils.getXY( cell).x + cell.offsetWidth - cellBorderWidth + 'px',\n                display: 'block',\n                height: table.offsetHeight + 'px'\n            };\n        </calculateLinePosition>\n\n  <applyStylesToLine>\n        utils.extend( line.style, styles );\n        </applyStylesToLine>\n\n    }\n"], ["isServerHtmlFileExt", "\nfunction isServerHtmlFileExt(filePath) {\n  <checkFilePath>\n        if (!filePath) {\n            return false;\n        }\n        </checkFilePath>\n\n  <determineServerHtmlFileType>\n        return (_serverHtmlFileExts.indexOf(LanguageManager.getLanguageForPath(filePath).getId()) !== -1);\n        </determineServerHtmlFileType>\n    }\n"], ["readCard", "\nfunction readCard() {\n  <scardReadCallback>\n\tpcsc.scardRead( function(evt) {\n\t\tif ( evt ) {\n\t\t\t\n\t\t\t<processReaderType>\n\t\t\tevt.reader.type = getType(evt.reader.name);\n\t\t\t</processReaderType>\n\n\t\t\t<processCardInformation>\n\t\t\tif ( evt.card && evt.card.ATR ) {\n\t\t\t\tvar item = getItem(evt.card.ATR);\n\t\t\t\tif (item && item.name) evt.card.name = item.name;\n\t\t\t\t\n\t\t\t}\n\t\t\t</processCardInformation>\n\n\t\t\t<emitReaderStateChange>\n\t\t\tevt.name = 'readerStateChange';\n\t\t\tprocess.send(evt);\n\t\t\t</emitReaderStateChange>\n\t\t}\n\t});\n  </scardReadCallback>\n}\n"], ["removeViews", "\nfunction (rootNode, viewKey) {\n  <findAllViews>\n            var views = this.getList('view', rootNode);\n            var self = this;\n            </findAllViews>\n\n  <removeEachView>\n            _.each(views, function (view) {\n                view.remove();\n            });\n            </removeEachView>\n\n            return this;\n        }\n"], ["trollStdout", "\nfunction trollStdout(opts, msg) {\n  <trollForStatusInApp>\n  var app = _.get(opts, 'app');\n  if (app && msg) {\n    app.trollForStatus(msg);\n  }\n  </trollForStatusInApp>\n}\n"], ["rotateZ", "\nfunction rotateZ(out, a, b, c){\n  <prepareRotationParameters>\n    var bx = b[0]\n    var by = b[1]\n    var px = a[0] - bx\n    var py = a[1] - by\n    var sc = Math.sin(c)\n    var cc = Math.cos(c)\n    </prepareRotationParameters>\n\n  <performRotation>\n    out[0] = bx + px * cc - py * sc\n    out[1] = by + px * sc + py * cc\n    out[2] = a[2]\n    </performRotation>\n  \n    return out\n}\n"], ["syncEvent", "\nfunction syncEvent(emitters, eventName, context, callback) {\n  var thisKey = '';\n  <initializeEventListener>\n  var eventListener = getListener(eventName, context);\n  </initializeEventListener>\n  <attachListeners>\n  emitters.forEach(function (item) {\n    thisKey += '_' + item.constructor.name;\n    item.on(eventName, eventListener);\n  });\n  </attachListeners>\n  <setUpContextKey>\n  context[thisKey] = {emittersLength: emitters.length};\n  </setUpContextKey>\n  \n  <getListener>\n  function getListener(eventName, context) {\n    return function listener () {\n      <trackEventOccurrence>\n      var argsKey = '_' + eventName + Array.prototype.slice.call(arguments).join('_');\n      var elements = context[thisKey];\n      if (typeof elements[argsKey] === 'undefined') {\n        elements[argsKey] = 0;\n        return;\n      }\n      else if (elements[argsKey] < elements.emittersLength-2){\n        elements[argsKey] = elements[argsKey] + 1;\n        return;\n      }\n      delete elements[argsKey];\n      </trackEventOccurrence>\n      <invokeCallback>\n      callback.apply(context, Array.prototype.slice.call(arguments));\n      </invokeCallback>\n    };\n  }\n  </getListener>\n}\n"], ["Hub", "\nfunction Hub() {\n  <logHubInstantiation>\n        log.info(\"instantiate hub\");\n        </logHubInstantiation>\n        \n  <initializeHub>\n        var self = this;\n        \n        Hub.super_.call(self);\n        \n        self._subscribers = {};\n        \n        self._transport = undefined;\n        self._closed = false;\n        </initializeHub>\n        \n  <setUpCloseListener>\n        self.once('close', function handleClosed() {\n            self._closed = true;\n        });\n        </setUpCloseListener>\n        \n        return undefined;\n    }\n"], "```"]