[["parseBlock", "\nfunction parseBlock(tokens) {\n  if (tokens.type === 'blockquote') {\n    return [getBlockquoteToken(tokens)];\n  } else if (tokens.type === 'bullet_list' && tokens.content.type === 'list_item' ||\n    tokens.type === 'ordered-list' && tokens.content.type === 'list_item') {\n    return [getListToken(tokens)];\n  }\n  return tokens;\n}\n"], ["dup", "\nfunction dup(x) {\n  var i, buff;\n  buff=new Array(x.length);\n  <copyArray>\n  copy_(buff,x);\n  </copyArray>\n  return buff;\n}\n"], ["left", "\nfunction left() {\n  var parentRole = getParentRole();\n\n  if (parentRole == \"tablist\") {\n    <moveFocusTablist>\n    moveFocus(-1, getFocusElements(focusedElement.parentNode));\n    </moveFocusTablist>\n  } else if (focusedControl.parent().submenu) {\n    <cancelSubmenu>\n    cancel();\n    </cancelSubmenu>\n  } else {\n    <moveFocusGeneral>\n    moveFocus(-1);\n    </moveFocusGeneral>\n  }\n}\n"], ["map", "\nfunction map(fn, m) {\n  <validateFunction>\n  if(!isFunction(fn)) {\n    throw new TypeError('map: Function required for first argument')\n  }\n  </validateFunction>\n\n  <mapImplementation>\n  if(isFunction(m)) {\n    return compose(fn, m)\n  }\n\n  if(isArray(m)) {\n    return array.map(fn, m)\n  }\n\n  if(m && isFunctor(m)) {\n    return (m[fl.map] || m.map).call(m, fn)\n  }\n\n  if(isObject(m)) {\n    return object.map(fn, m)\n  }\n  </mapImplementation>\n\n  <throwInvalidArgument>\n  throw new TypeError('map: Object, Function or Functor of the same type required for second argument')\n  </throwInvalidArgument>\n}\n"], ["fill", "\nfunction fill(fillWith, len){\n  var buffer = new Buffer(len);\n  <fillBuffer>\n  buffer.fill(fillWith);\n  </fillBuffer>\n  return buffer.toString();\n}\n"], ["readOptions", "\nfunction readOptions(ctx) {\n  var configFilePath = path.join(ctx.opts.projectRoot, 'config.xml');\n  <readConfigXML>\n  var configXmlContent = xmlHelper.readXmlAsJson(configFilePath, true);\n  </readConfigXML>\n\n  return parseConfig(configXmlContent);\n}\n"], ["webpackModuleExports", "\nfunction(module, exports, __webpack_require__) {\n  'use strict';\n  var React = __webpack_require__(2);\n  var $ = React.DOM;\n  var ou = __webpack_require__(5);\n  var types = __webpack_require__(14);\n  var wrapped = __webpack_require__(15);\n\n  var FileField = React.createClass({\n    displayName: 'FileField',\n\n    loadFile: function(event) {\n      var reader = new FileReader();\n      var file = event.target.files[0];\n      var val = ou.merge(this.props.getValue(this.props.path), {\n        name: file.name,\n        type: file.type,\n        size: file.size\n      });\n\n      this.props.update(this.props.path, val, val);\n\n      reader.onload = function(event) {\n        val.data = event.target.result;\n        this.props.update(this.props.path, val, val);\n      }.bind(this);\n\n      if (file) {\n        if (this.props.mode === 'dataURL') {\n          reader.readAsDataURL(file);\n        }\n        else {\n          reader.readAsText(file);\n        }\n      }\n    },\n    render: function() {\n      var fields = this.props.fields || {};\n      var value = this.props.value || {};\n      var list = [\n        $.input({ key: \"input\", type: \"file\", onChange: this.loadFile }),\n        $.dl({ key: \"fileProperties\" },\n             $.dt(null, \"Name\"), $.dd(null, value.name || '-'),\n             $.dt(null, \"Size\"), $.dd(null, value.size || '-'),\n             $.dt(null, \"Type\"), $.dd(null, value.type || '-'))\n      ];\n\n      return wrapped.section(this.props, list.concat(types.object(fields, this.props)));\n    }\n  });\n\n  module.exports = FileField;\n}\n"], ["getOptionLabel", "\nfunction getOptionLabel(option, labelKey) {\n  if (option.paginationOption || option.customOption) {\n    return option[getStringLabelKey(labelKey)];\n  }\n\n  let optionLabel;\n\n  <determineOptionLabel>\n  if (typeof option === 'string') {\n    optionLabel = option;\n  }\n\n  if (typeof labelKey === 'function') {\n    optionLabel = labelKey(option);\n  } else if (typeof labelKey === 'string' && isPlainObject(option)) {\n    optionLabel = option[labelKey];\n  }\n  </determineOptionLabel>\n\n  <checkInvariant>\n  invariant(\n    typeof optionLabel === 'string',\n    'One or more options does not have a valid label string. Check the ' +\n    '`labelKey` prop to ensure that it matches the correct option key and ' +\n    'provides a string for filtering and display.'\n  );\n  </checkInvariant>\n\n  return optionLabel;\n}\n"], ["reinitializeAppearWatch", "\nfunction (opts) {\n  __init.call(this, opts);\n  this.appearWatchElements.forEach(function(ele) {\n    <clearAppearanceStates>\n    delete ele._hasAppear;\n    delete ele._hasDisAppear;\n    delete ele._appear;\n    </clearAppearanceStates>\n  });\n  return this;\n}\n"], ["setErrorPath", "\nfunction setErrorPath (error) {\n  var path = error.dataPath.split('.')\n  var missingProperty = error.params && error.params.missingProperty\n  <parseErrorPath>\n  if (path.length > 2) {\n    var property = path[2]\n    var propertySegments = property.split(indexRegExp)\n    if (propertySegments.length > 1) {\n      error.baseProperty = propertySegments[0]\n      error.index = parseInt(propertySegments[1])\n      error.property = missingProperty\n          ? missingProperty\n          : path[3]\n    }\n    else {\n      if (missingProperty) {\n        error.baseProperty = property\n        error.property = missingProperty\n      }\n      else {\n        error.property = property\n      }\n    }\n  }\n  </parseErrorPath>\n  <handleMissingProperty>\n  else {\n    error.property = missingProperty\n  }\n  </handleMissingProperty>\n}\n"], "```"]