[["getRemoteBranches", "\nfunction getRemoteBranches(options) {\n    <prepareArguments>\n    options = options || {};\n    var args = [\n      'ls-remote',\n      '--heads',\n      options.remote || 'origin'\n    ];\n    </prepareArguments>\n\n    return git(args)\n        .then(parseRemoteBranches);\n}\n"], ["httpOk", "\nfunction httpOk(req, res, content, fileExt) {\n    <writeResponse>\n    res.writeHead(200, {\n        'Content-Type': Mine.getType(fileExt),\n    });\n    res.write(content, 'binary');\n    res.end();\n    </writeResponse>\n}\n"], ["Path_constructor", "\nfunction Path(type, contours, closed) {\n      var cnt, self, _i, _len;\n\n      <initializePath>\n      if (closed == null) {\n        closed = true;\n      }\n      self = this;\n      self.type = type;\n      self.contours = [];\n      for (_i = 0, _len = contours.length; _i < _len; _i++) {\n        cnt = contours[_i];\n        if (!__is_clockwise(cnt)) {\n          cnt.reverse();\n        }\n        self.contours.push(cnt);\n      }\n      self.closed = closed;\n      </initializePath>\n}\n"], ["parseFeatureFromNode", "\nfunction(node) {\n        \n        var order = [\"MultiPolygon\", \"Polygon\",\n                     \"MultiLineString\", \"LineString\",\n                     \"MultiPoint\", \"Point\", \"Envelope\"];\n        \n        var type, nodeList, geometry, parser;\n        for(var i=0; i<order.length; ++i) {\n            type = order[i];\n            nodeList = this.getElementsByTagNameNS(node, this.gmlns, type);\n            if(nodeList.length > 0) {\n                <parseGeometry>\n                parser = this.parseGeometry[type.toLowerCase()];\n                if(parser) {\n                    geometry = parser.apply(this, [nodeList[0]]);\n                    if (this.internalProjection && this.externalProjection) {\n                        geometry.transform(this.externalProjection, \n                                           this.internalProjection); \n                    }                       \n                } else {\n                    throw new TypeError(\"Unsupported geometry type: \" + type);\n                }\n                </parseGeometry>\n                \n                break;\n            }\n        }\n\n        var bounds;\n        var boxNodes = this.getElementsByTagNameNS(node, this.gmlns, \"Box\");\n        for(i=0; i<boxNodes.length; ++i) {\n            <parseBoundingBox>\n            var boxNode = boxNodes[i];\n            var box = this.parseGeometry[\"box\"].apply(this, [boxNode]);\n            var parentNode = boxNode.parentNode;\n            var parentName = parentNode.localName ||\n                             parentNode.nodeName.split(\":\").pop();\n            if(parentName === \"boundedBy\") {\n                bounds = box;\n            } else {\n                geometry = box.toGeometry();\n            }\n            </parseBoundingBox>\n        }\n        \n        \n        var attributes;\n        if(this.extractAttributes) {\n            attributes = this.parseAttributes(node);\n        }\n        var feature = new OpenLayers.Feature.Vector(geometry, attributes);\n        feature.bounds = bounds;\n        \n        <setGMLProperties>\n        feature.gml = {\n            featureType: node.firstChild.nodeName.split(\":\")[1],\n            featureNS: node.firstChild.namespaceURI,\n            featureNSPrefix: node.firstChild.prefix\n        };\n        </setGMLProperties>        \n                \n        <extractFID>\n        var childNode = node.firstChild;\n        var fid;\n        while(childNode) {\n            if(childNode.nodeType == 1) {\n                fid = childNode.getAttribute(\"fid\") ||\n                      childNode.getAttribute(\"id\");\n                if(fid) {\n                    break;\n                }\n            }\n            childNode = childNode.nextSibling;\n        }\n        feature.fid = fid;\n        return feature;\n        </extractFID>\n    }\n"], ["binarySearch", "\nfunction(object, comparator, left, right)\n    {\n        function defaultComparator(a, b)\n        {\n            return a < b ? -1 : (a > b ? 1 : 0);\n        }\n        <prepareComparatorAndIndices>\n        comparator = comparator || defaultComparator;\n        var l = left || 0;\n        var r = right !== undefined ? right : this.length;\n        </prepareComparatorAndIndices>\n        <searchAlgorithm>\n        while (l < r) {\n            var m = (l + r) >> 1;\n            if (comparator(object, this[m]) > 0)\n                l = m + 1;\n            else\n                r = m;\n        }\n        </searchAlgorithm>\n        return r;\n    }\n"], ["compareAndClassifyFiles", "\nfunction compare (checkDictionary, path, pathContent) {\n        var subPromises = [];\n        <classifyFiles>\n        pathContent.forEach(function (name) {\n            var JS_EXT = \".js\",\n                JS_EXT_LENGTH = JS_EXT.length,\n                contentFullName = path + name,\n                contentFullNameLength = contentFullName.length;\n            if (contentFullNameLength > JS_EXT_LENGTH\n                && contentFullName.indexOf(JS_EXT) === contentFullNameLength - JS_EXT_LENGTH) {\n                contentFullName = contentFullName.substring(START, contentFullNameLength - JS_EXT_LENGTH);\n                if (checkDictionary[contentFullName] === \"obsolete\") {\n                    checkDictionary[contentFullName] = \"exists\";\n                } else {\n                    checkDictionary[contentFullName] = \"new\";\n                }\n            } else if (name.indexOf(\".\") === NOT_FOUND) {\n                </classifyFiles>\n                <processSubdirectories>\n                subPromises.push(gpf.http.get(\"/fs/src/\" + contentFullName)\n                    .then(function (response) {\n                        return JSON.parse(response.responseText);\n                    })\n                    .then(function (subPathContent) {\n                        return compare(checkDictionary, contentFullName + \"/\", subPathContent);\n                    }));\n                </processSubdirectories>\n            }\n        });\n        </classifyFiles> <!-- Closing tag for general classification section -->\n        if (!subPromises.length) {\n            return Promise.resolve();\n        }\n        return Promise.all(subPromises);\n    }\n"], ["renderArrData", "\nfunction renderArrData(data) {\n            <renderHTML>\n            var i = 0,\n                html = '';\n            for (i = 0; i < data.length; i++) {\n                html += Mustache.render(classifyItemTpl, data[i]);\n            }\n            </renderHTML>\n            return html;\n        }\n"], ["NDDBIndex_constructor", "\nfunction NDDBIndex(idx, nddb) {\n        \n        <initializeNDDBIndex>\n        this.idx = idx;\n        \n        this.nddb = nddb;\n        \n        this.resolve = {};\n        \n        this.keys = [];\n        \n        this.resolveKeys = {};\n        </initializeNDDBIndex>\n    }\n"], ["maybeCall", "\nfunction maybeCall ( thing, ctx, args ) {\n     <conditionalInvocation>\n     return typeof thing == 'function' ? thing.apply(ctx, args) : thing\n     </conditionalInvocation>\n   }\n"], ["updatePolygonMarkers", "\nfunction() {\n    var polygon = this._shape;\n    for (var i = 0, len = polygon._latlngs.length; i < len; i++) {\n      <updateResizeMarkers>\n      var marker = this._resizeMarkers[i];\n      marker.setLatLng(polygon._latlngs[i]);\n\n      \n      marker._origLatLng = polygon._latlngs[i];\n      if (marker._middleLeft) {\n        marker._middleLeft.setLatLng(this._getMiddleLatLng(marker._prev, marker));\n      }\n      if (marker._middleRight) {\n        marker._middleRight.setLatLng(this._getMiddleLatLng(marker, marker._next));\n      }\n      </updateResizeMarkers>\n    }\n    \n\n    <updateEditingUI>\n    \n    this._shape._map.addLayer(this._markerGroup);\n    this._updateMoveMarker();\n\n    this._repositionCornerMarkers();\n    this._fireEdit();\n    </updateEditingUI>\n  }\n"], "```"]