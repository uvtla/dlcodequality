[["entitiesToDatastore", "\nfunction entitiesToDatastore(entities, options) {\n    const multiple = is.array(entities);\n    entities = arrify(entities);\n\n    if (entities[0].className !== 'Entity') {\n        return entities;\n    }\n\n    const result = entities.map(e => toDatastore(e, options));\n\n    return multiple ? result : result[0];\n}\n"], ["connectAndInitializeModels", "\nfunction(callback) {\n    self.mongoose.connect(self.config.uri, defaultOpts, function(err) {\n        if (err) {\n            return callback && callback(err);\n        }\n        \n        var modules = (new (require('../../helper/project'))()).listModelsForAllModules(\n            process.cwd(), false\n        );\n\n        var connectionName = 'mongodb.' + self.name;\n        Schema = self.mongoose.Schema;\n\n        <loadModels>\n        Object.keys(modules).forEach(function(module) {\n            if (!modules[module].hasOwnProperty(connectionName)) {\n                return;\n            }\n\n            modules[module][connectionName].forEach(function(model) {\n                var path = process.cwd() + '/modules/' +\n                           module + '/models/' + connectionName + '/' + model;\n                try {\n                    self.mongoose.connection.model(model, require(path));\n                } catch (e) {\n                    logger.error(\n                        'Failed to load model ' + model.bold.green +\n                        ' of ' + connectionName.yellow\n                    );\n                    return callback && callback(e);\n                }\n            });\n        });\n        </loadModels>\n\n        delete Schema;\n\n        <assignOrmInstance>\n        self.orm.instance = self.mongoose.connection;\n        self.orm.models   = self.mongoose.connection.models;\n        </assignOrmInstance>\n\n        callback && callback(null, self.orm);\n    });\n\n    self.mongoose.connection.on('error', function(err) {\n        logger.error('Error occured on ' + self.name.yellow + ' backend. Details: ' + (err.stack || err));\n    });\n}\n"], ["unpack", "\nfunction unpack (bits, offset, length) {\n    var mask = 0xffffffff, shift;\n    mask = mask >>> (32 - bits);\n    mask = mask >>> (bits - length);\n    shift = bits - offset - length;\n    shift = shift ? 'value >>> ' + shift : 'value';\n    return shift + ' & 0x' + mask.toString(16);\n}\n"], ["setDeadzone", "\nfunction setDeadzone(w, h) {\n    if (typeof this.deadzone === \"undefined\") {\n        this.deadzone = new me.Rect(0, 0, 0, 0);\n    }\n\n    this.deadzone.pos.set(~~((this.width - w) / 2), ~~((this.height - h) / 2 - h * 0.25));\n    this.deadzone.resize(w, h);\n\n    <toggleSmoothFollow>\n    this.smoothFollow = false;\n    this.updateTarget();\n    this.smoothFollow = true;\n    </toggleSmoothFollow>\n}\n"], ["logFieldsAndRelationships", "\nfunction logFieldsAndRelationships() {\n    const context = this.context;\n    if (context.fields.length > 0 || context.relationships.length > 0) {\n        this.log(chalk.red(chalk.white('\\n================= ') + context.entityNameCapitalized + chalk.white(' =================')));\n    }\n    <logFields>\n    if (context.fields.length > 0) {\n        this.log(chalk.white('Fields'));\n        context.fields.forEach(field => {\n            const validationDetails = [];\n            const fieldValidate = _.isArray(field.fieldValidateRules) && field.fieldValidateRules.length >= 1;\n            if (fieldValidate === true) {\n                if (field.fieldValidateRules.includes('required')) {\n                    validationDetails.push('required');\n                }\n                // ... Other validation rules ...\n            }\n            this.log(\n                chalk.red(field.fieldName) +\n                    chalk.white(` (${field.fieldType}${field.fieldTypeBlobContent ? ` ${field.fieldTypeBlobContent}` : ''}) `) +\n                    chalk.cyan(validationDetails.join(' '))\n            );\n        });\n        this.log();\n    }\n    </logFields>\n    <logRelationships>\n    if (context.relationships.length > 0) {\n        this.log(chalk.white('Relationships'));\n        context.relationships.forEach(relationship => {\n            // Relationship logging logic ...\n            });\n        this.log();\n    }\n    </logRelationships>\n}\n"], ["getAttributes", "\nfunction getAttributes(attributes) {\n    var t = typeof attributes;\n    if (t === 'string') {\n        return attributes;\n    }\n    if (t === 'object') {\n        return Object.keys(attributes).reduce(function (memo, key) {\n            memo.push(key + '=\"' + attributes[key] + '\"');\n            return memo;\n        }, []).join(' ');\n    }\n    return '';\n}\n"], ["HyperlinkView", "\nfunction HyperlinkView() {\n    NodeView.apply(this, arguments);\n\n    <initializeNameLabel>\n    this.nameLabel = new LabelView();\n    this.nameLabel.parentStyle = true;\n    this.addSubView(this.nameLabel);\n    </initializeNameLabel>\n\n    <initializeTypeLabel>\n    this.typeLabel = new LabelView();\n    this.typeLabel.parentStyle = true;\n    this.addSubView(this.typeLabel);\n    </initializeTypeLabel>\n}\n"], ["IndexToStringConstructor", "\nfunction (jvmObject) {\n    this.logger = Logger.getLogger(\"ml.feature.IndexToString_js\");\n    if (!jvmObject) {\n        jvmObject = new org.apache.spark.ml.feature.IndexToString();\n    }\n    PipelineStage.call(this, jvmObject);\n}\n"], ["extractObjectKeys", "\nfunction (object) {\n    var result = [],\n        key;\n    for (key in object) {\n        if (object.hasOwnProperty(key)) {\n            result.push(key);\n        }\n    }\n    return result;\n}\n"], ["renderBlocks", "\nfunction(blocks, in_tight_list) {\n  var result = [];\n  for (var i=0; i < blocks.length; i++) {\n    if (blocks[i].t !== 'ReferenceDef') {\n      result.push(this.renderBlock(blocks[i], in_tight_list));\n    }\n  }\n  return result.join(this.blocksep);\n}\n"], "```"]