[["forEach", "\nfunction forEach(children, func) {\n  let index = 0;\n  <iterateOverChildren>\n  React.Children.forEach(children, child => {\n    if (React.isValidElement(child)) func(child, index++);\n  });\n  </iterateOverChildren>\n}\n"], ["tag", "\nfunction tag(name, attrs, close, content) {\n  var end = close ? '/>' : '>';\n  var pairs = [];\n  var tag;\n\n  <constructTagAttributes>\n  for (var key in attrs) {\n    if (Object.prototype.hasOwnProperty.call(attrs, key)) {\n      pairs.push(key + '=\"' + escape(attrs[key]) + '\"');\n    }\n  }\n  </constructTagAttributes>\n\n  <createTagString>\n  tag = '<' + name + (pairs.length ? ' ' + pairs.join(' ') : '') + end;\n  if (content) {\n    tag += content + '</' + name + end;\n  }\n  </createTagString>\n  \n  return tag;\n}\n"], ["createRegex", "\nfunction(str, flags) {\n        flags = flags || '';\n        Y.DOM._regexCache = Y.DOM._regexCache || {};\n        \n        <cacheRegex>\n        if (!Y.DOM._regexCache[str + flags]) {\n            Y.DOM._regexCache[str + flags] = new RegExp(str, flags);\n        }\n        </cacheRegex>\n        \n        return Y.DOM._regexCache[str + flags];\n    }\n"], ["makeEntry", "\nfunction makeEntry (entry: any, entries: Array<string> = []): Object {\n  <normalizeEntry>\n  if (typeof entry === 'string') {\n    entry = [entry]\n  }\n  if (Array.isArray(entry)) {\n    entry = { main: entry }\n  }\n  </normalizeEntry>\n\n  <assembleEntries>\n  return Object.keys(entry)\n    .reduce((acc, x) => {\n      const v = entry[x]\n      return {\n        ...acc,\n        [x]: [\n          ...entries,\n          ...(Array.isArray(v) ? v : [v])\n        ]\n      }\n    }, {})\n  </assembleEntries>\n}\n"], ["_loadEntityAttribute", "\nfunction _loadEntityAttribute(attribute) {\n    <validateAttribute>\n    expect(_methods).to.not.have.ownProperty(\n      attribute.name,\n      'failed to load entity attribute \"' + attribute.name + '\" because ' +\n      'there is a method with same name in the current Entity and it cannot ' +\n      'be overloaded'\n    );\n\n    if (_Entity.General) {\n      expect(_Entity.General.attributes).to.not.have.ownProperty(\n        attribute.name,\n        'failed to load entity attribute \"' + attribute.name + '\" because ' +\n        'there is an attribute with same name in a parent of current Entity ' +\n        'and it cannot be overriden'\n      );\n\n      expect(_Entity.General.methods).to.not.respondTo(\n        attribute.name,\n        'failed to load entity attribute \"' + attribute.name + '\" because ' +\n        'there is a method with same name in a parent of current Entity ' +\n        'and it cannot be overriden'\n      );\n    }\n\n    var entitySpecializations = _Entity.specializations;\n    for (var specialization in entitySpecializations) {\n      expect(entitySpecializations[specialization].specification.attributes)\n        .to.not.have.ownProperty(\n        attribute.name,\n        'failed to load entity attribute \"' + attribute.name + '\" because ' +\n        'there is an attribute with same name in a child of current Entity'\n      );\n\n      expect(entitySpecializations[specialization].specification.methods)\n        .to.not.have.ownProperty(\n        attribute.name,\n        'failed to load entity attribute \"' + attribute.name + '\" because ' +\n        'there is a method with same name in a child of current Entity'\n      );\n    }\n    </validateAttribute>\n\n    <loadAttribute>\n    _Entity.adapter.loadEntityAttribute(_Entity, attribute);\n    </loadAttribute>\n  }\n"], ["initializeField", "\nfunction(builder, message, rule, keytype, type, name, id, options, oneof, syntax) {\n            T.call(this, builder, message, name);\n\n            <setProperties>\n            this.className = \"Message.Field\";\n            this.required = rule === \"required\";\n            this.repeated = rule === \"repeated\";\n            this.map = rule === \"map\";\n            this.keyType = keytype || null;\n            this.type = type;\n            this.resolvedType = null;\n            this.id = id;\n            this.options = options || {};\n            this.defaultValue = null;\n            this.oneof = oneof || null;\n            this.syntax = syntax || 'proto2';\n            this.originalName = this.name; \n            this.element = null;\n            this.keyElement = null;\n            </setProperties>\n\n            <convertFieldName>\n            if (this.builder.options['convertFieldsToCamelCase'] && !(this instanceof Message.ExtensionField)) {\n                this.name = ProtoBuf.Util.toCamelCase(this.name);\n            }\n            </convertFieldName>\n        }\n"], ["highlightText", "\nfunction (str, highlight) {\n                if (ariaUtilsType.isString(str) && ariaUtilsType.isString(highlight)) {\n                    var toBeMatched = str.split(\" \");\n                    \n                    <splitAndSortHighlights>\n                    var toBeHighlighted = highlight.split(\" \").sort(function (first, second) {\n                        var aLen = first.length, bLen = second.length;\n                        return aLen === bLen ? 0 : (aLen < bLen ? 1 : -1);\n                    });\n                    </splitAndSortHighlights>\n\n                    <applyHighlighting>\n                    ariaUtilsArray.forEach(toBeMatched, function (value, index, array) {\n                        for (var i = 0, len = toBeHighlighted.length; value && i <= len; i += 1) {\n                            if (toBeHighlighted[i] == null || toBeHighlighted[i] === \"\") {\n                                continue;\n                            }\n                            var frmtdHighlightStr = toBeHighlighted[i].replace(regExSpecials, \"\\\\$1\");\n                            var highlightStr = new RegExp('\\\\b' + frmtdHighlightStr, 'gim');\n                            if (!!frmtdHighlightStr.match(/\\(/)) {\n                                highlightStr = new RegExp('[\\\\b\\\\(]' + frmtdHighlightStr.replace('\\\\(', ''), 'gim');\n                            }\n                            var replaceArr = highlightStr.exec(value);\n                            if (replaceArr != null && replaceArr.length > 0) {\n                                var replaceStr = \"<strong>\" + replaceArr[0] + \"</strong>\";\n                                array[index] = value.replace(highlightStr, replaceStr);\n                                if (!!value.match(highlightStr)) {\n                                    break;\n                                }\n                            }\n                        }\n                    });\n                    </applyHighlighting>\n\n                    return toBeMatched.join(\" \");\n                }\n\n                <returnOriginal>\n                return str;\n                </returnOriginal>\n            }\n"], ["observeObject", "\nfunction observeObject(o, observer) {\n  return o && typeof o === 'object' && <invokeObserve>observe(o, observer, observer.keys)</invokeObserve>;\n}\n"], ["multimixOperation", "\nfunction() {\n            var self = this,\n                args = self.parseRemoveArgs(arguments);\n\n            return self.multimix({\n                remove: args.command\n            }, args.animate, args.callback);\n        }\n"], ["commonDir", "\nfunction commonDir (files) {\n  <processPaths>\n  return files\n    .map(path.dirname)\n    </processPaths>\n    .map(function (dir) {\n      return dir.split(path.sep)\n    })\n    .reduce(commonSequence)\n    .concat([''])\n    .join(path.sep)\n}\n"], ""]