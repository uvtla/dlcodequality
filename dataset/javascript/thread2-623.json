[["createTriggerEvents", "\nfunction(){\n    if (!this.triggers) { return; }\n\n    var triggerEvents = {};\n\n    \n    var triggers = _.result(this, \"triggers\");\n\n    \n    \n    _.each(triggers, function(value, key){\n\n      \n      <createSingleTriggerEvent>\n      triggerEvents[key] = function(e){\n\n        \n        if (e && e.preventDefault){ e.preventDefault(); }\n        if (e && e.stopPropagation){ e.stopPropagation(); }\n\n        \n        var args = {\n          view: this,\n          model: this.model,\n          collection: this.collection\n        };\n\n        \n        this.triggerMethod(value, args);\n      };\n      </createSingleTriggerEvent>\n\n    }, this);\n\n    return triggerEvents;\n}\n"], ["parseRegExp", "\nfunction parseRegExp (str) {\n  if (str instanceof RegExp) return str\n  let arg = String(str).match(/^\\/(.*)\\/(g|i|)$|.*/)\n  return new RegExp(arg[1] || arg[0], arg[2])\n}\n"], ["renderOpenGLScene", "\nfunction() {\n    var gl = this._canvas.gl();\n    gl.clearColor(0.0, 0.0, 0.0, 0.0);\n    gl.disable(gl.BLEND);\n    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n    gl.clearColor(this._options.background[0], this._options.background[1], \n                  this._options.background[2], 1.0);\n    gl.cullFace(gl.FRONT);\n    gl.enable(gl.CULL_FACE);\n    this._drawWithPass('select');\n}\n"], ["getPersistantFacebookToken", "\nfunction _getPersistantFacebookToken(){\n    return facebook.query()\n            .get('/oauth/access_token?' +\n                'grant_type=fb_exchange_token&' +\n                'client_id=' + appId + '&' +\n                'client_secret=' + secret + '&' +\n                'fb_exchange_token=' + this.options.code)\n            .request()\n           .then(function (res) {\n                \n                <handleTokenResponse>\n                if (res[1].error) {\n                    throw new Error(res[1].error.message);\n                }\n\n                this.creds = querystring.parse(res[1]);\n                </handleTokenResponse>\n            }.bind(this));\n}\n"], ["modifiedGramSchmidt", "\nfunction modifiedGramSchmidt (m) {\n  const n = m.dimension;\n\n  const v0 = m.getColumn(0);\n  const u0 = v0;\n  const v1 = m.getColumn(1);\n  const u1 = v1.clone().sub(proj(u0, v1));\n  if (n === 2) {\n    m.setColumns(v0, v1);\n    return;\n  }\n  const v2 = m.getColumn(2);\n  const u2t = v2.clone().sub(proj(u0, v2));\n  const u2 = u2t.sub(proj(u1, u2t));\n  if (n === 3) {\n    m.setColumns(u0, u1, u2);\n    \n  }\n}\n"], ["subscribeAndNotify", "\nfunction(s, args, ef) {\n\n        this.log(this.type + \"->\" + \"sub: \" +  s.id);\n\n        var ret;\n\n        ret = s.notify(args, this);\n\n        if (false === ret || this.stopped > 1) {\n            this.log(this.type + \" cancelled by subscriber\");\n            return false;\n        }\n\n        return true;\n}\n"], ["constructProps", "\nfunction constructProps (fieldNames, feature) {\n  const properties = _.reduce(fieldNames, (tempProps, fieldName, key) => {\n    tempProps[fieldName] = (!isNaN(feature[key])) ? parseFloat(feature[key]) : feature[key]\n    return tempProps\n  }, {})\n  return properties\n}\n"], ["processForEach", "\nfunction processForEach(state, node, data) {\n  state.stack.push('foreach');\n  try {\n    var originalValue = node.getAttribute('foreach');\n    var value = originalValue;\n\n    <parseForEachAttribute>\n    var paramName = 'param';\n    if (value.charAt(0) === '$') {\n      \n      value = stripBraces(state, value);\n    }\n    else {\n      \n      var nameArr = value.split(' in ');\n      paramName = nameArr[0].trim();\n      value = stripBraces(state, nameArr[1].trim());\n    }\n    </parseForEachAttribute>\n    node.removeAttribute('foreach');\n    try {\n      var evaled = envEval(state, value, data, originalValue);\n      var cState = cloneState(state);\n      <handleForEachLoop>\n      handleAsync(evaled, node, function(reply, siblingNode) {\n        processForEachLoop(cState, reply, node, siblingNode, data, paramName);\n      });\n      </handleForEachLoop>\n      node.parentNode.removeChild(node);\n    }\n    catch (ex) {\n      handleError(state, 'Error with \\'' + value + '\\'', ex);\n    }\n  }\n  finally {\n    state.stack.pop();\n  }\n}\n"], ["crawl", "\nfunction crawl (obj, path, $refs, options) {\n  var promises = [];\n\n  if (obj && typeof obj === \"object\") {\n    if ($Ref.isExternal$Ref(obj)) {\n      <resolveRef>\n      promises.push(resolve$Ref(obj, path, $refs, options));\n      </resolveRef>\n    }\n    else {\n      <crawlNested>\n      Object.keys(obj).forEach(function (key) {\n        var keyPath = Pointer.join(path, key);\n        var value = obj[key];\n\n        if ($Ref.isExternal$Ref(value)) {\n          promises.push(resolve$Ref(value, keyPath, $refs, options));\n        }\n        else {\n          promises = promises.concat(crawl(value, keyPath, $refs, options));\n        }\n      });\n      </crawlNested>\n    }\n  }\n\n  return promises;\n}\n"], ["removeFocusListener", "\nfunction(p_sType, p_aArgs) {\n            Event.removeFocusListener(document.documentElement, this._onElementFocus, this);\n\n            if (_currentModal == this) {\n                _currentModal = null;\n            }\n}\n"], "```"]