[["scaleValues", "\nfunction (x, y) {\n  var a = this.val,\n     _x = x,\n     _y = typeof(y) === \"undefined\" ? _x : y;\n\n  a[0] *= _x;\n  a[1] *= _x;\n  a[3] *= _y;\n  a[4] *= _y;\n\n  return this;\n}\n"], ["savePrettyGraphSON", "\nfunction savePrettyGraphSON(graph, filename, callback) {\n    var ByteArrayOutputStream = Tinkerpop.autoImport('ByteArrayOutputStream');\n    var stream = new ByteArrayOutputStream();\n    return Tinkerpop.GraphSONWriter.buildP()\n        .then(function (builder) {\n        return _newGraphSONMapper()\n            .then(function (mapper) { return builder.mapperP(mapper); });\n    })\n        .then(function (builder) { return builder.createP(); })\n        .then(function (writer) { return writer.writeGraphP(stream, graph); })\n        .then(function () { return stream.toStringP(); })\n        .then(function (ugly) {\n        var prettyString = _prettyGraphSONString(ugly);\n        var writeFileP = BluePromise.promisify(fs.writeFile);\n        return writeFileP(filename, prettyString);\n    })\n        .then(function () { return graph; })\n        .nodeify(callback);\n}\n"], ["renderCell", "\nfunction renderCell(cellData, column, rowData, rowNumber, tableData, columns, isBottomData, columnSummary) {\nvar renderer = column.renderer;\nvar renderOnNull = column.renderOnNull;\n\nif (!isBottomData) {\n  \n  if (cellData == null && renderOnNull !== true) {\n    return null;\n    \n  } else if (renderer != null) {\n    return renderer(cellData, { column: column, rowData: rowData, rowNumber: rowNumber, tableData: tableData, columns: columns, columnSummary: columnSummary });\n  }\n}\n\nreturn cellData;\n}\n"], ["getRoutesForCategory", "\nfunction (category) {\n    return _.filter($route.routes, function (route) {\n        return typeof route.category !== 'undefined' && route.category === category && isRouteVisible(route);\n    });\n}\n"], ["getGraphqlName", "\nfunction getGraphqlName(g, iri) {\nconst { prefixes } = g.config;\nconst localName = getIriLocalName(iri);\nconst namespaceIri = iri.slice(0, -localName.length);\n\nconst prefix = Object.keys(prefixes).find(key => prefixes[key] === namespaceIri) || '';\n\nreturn capitalize(prefix + localName).replace(/\\W/g, '_');\n}\n"], ["proxy", "\nfunction proxy(options, format) {\nvar tty = options.tty\n  , method = options.method\n  , re = /(%[sdj])+/g\n  , start\n  , end;\nif(arguments.length === 1) {\n  return method.apply(console, []);\n}\nvar arg, i, replacing, replacements, matches, tag;\nreplacing = (typeof format === 'string')\n  && re.test(format) && arguments.length > 2;\nreplacements = [].slice.call(arguments, 2);\nif(format instanceof AnsiColor) {\n  replacing = true;\n  if(!replacements.length) {\n    replacements.unshift(format); format = '%s';\n  }\n}\nif(!replacing) {\n  replacements.unshift(format);\n  return method.apply(console, replacements);\n}\nmatches = (format && (typeof format.match === 'function')) ?\n  format.match(re) : [];\nif(format instanceof AnsiColor) {\n  if(!tty) {\n    format = format.v;\n  }else{\n    tag = format.start(tty);\n    format = format.valueOf(tty);\n  }\n}\n\nif(tty) {\n  re = /(%[sdj])/g;\n  var fmt, result, j = 0;\n  while((result = re.exec(format))) {\n    if(j === replacements.length) {\n      break;\n    }\n    arg = replacements[j];\n    \n    fmt = result[1];\n    start = format.substr(0, result.index);\n    end = format.substr(result.index + result[0].length);\n    \n    \n    \n    if((arg instanceof AnsiColor)) {\n      \n      if(fmt === '%j') {\n        arg.v = JSON.stringify(arg.v, circular());\n      }\n      format = start + '%s' + end;\n    }\n    j++;\n  }\n}\n\nfor(i = 0;i < replacements.length;i++) {\n  arg = replacements[i];\n  if(arg instanceof AnsiColor) {\n    replacements[i] = arg.valueOf(tty, tag);\n  }\n}\nreplacements.unshift(format);\nreturn method.apply(options.scope ? options.scope : console, replacements);\n}\n"], ["parsePuzzleData", "\nfunction(datastr){\nvar puzzle = this.puzzle, bd = puzzle.board, pzl = pzpr.parser.parseFile(datastr, puzzle.pid);\nvar filetype = this.currentType = pzl.type;\n\nbd.initBoardSize(pzl.cols, pzl.rows);\n\n<this-filever>\nthis.filever = pzl.filever;\n</this-filever>\nif(filetype!==pzl.FILE_PBOX_XML){\n  this.lineseek = 0;\n  this.dataarray = pzl.body.split(\"\\n\");\n}\nelse{\n  this.xmldoc = pzl.body;\n}\n\n<parse-data-switch>\nswitch(filetype){\ncase pzl.FILE_PZPR:\n  this.decodeData();\n  if((this.readLine()||'').match(/TrialData/)){ this.lineseek--; this.decodeTrial();}\n  break;\n\ncase pzl.FILE_PBOX:\n  this.kanpenOpen();\n  break;\n\ncase pzl.FILE_PBOX_XML:\n  this.kanpenOpenXML();\n  break;\n}\n</parse-data-switch>\n\n<this-metadata>\npuzzle.metadata.update(pzl.metadata);\n</this-metadata>\nif(pzl.history && (filetype===pzl.FILE_PZPR)){\n  puzzle.opemgr.decodeHistory(pzl.history);\n}\n\n<this-rebuildInfo>\nbd.rebuildInfo();\n</this-rebuildInfo>\n\nthis.dataarray = null;\n}\n"], ["parseSuggests", "\nfunction _parseSuggests ($containor) {\nconst suggests = []\n\n$containor.find('.typo-rel').each((index, item) => {\n  const $p = $(item)\n  const $word = $p.find('span')\n  const word = removeTagsAndSpaces($word.html())\n\n  \n  $word.remove()\n\n  const translate = removeTagsAndSpaces($p.html())\n  const suggest = new Suggest(word, translate)\n\n  debug('suggest parse object: %O', suggest)\n\n  suggests.push(suggest)\n})\n\nreturn suggests\n}\n"], ["eventPipeline", "\nfunction run(events, payload, callback)\n{\n\n\nif (!callback)\n{\n  callback = payload;\n  payload  = events;\n  events   = null;\n}\n\n<normalizeEvents-wrapper>\nevents = normalizeEvents(events);\n</normalizeEvents-wrapper>\n\n<pipeline-wrapper>\npipeline(events, payload, function(e, data, cb)\n{\n  if (!Array.isArray(this._stack[e]))\n  {\n    this.logger.debug({message: 'Reached end of the stack', event: e, data: data});\n    cb(null, payload);\n    return;\n  }\n\n  pipeline(this._stack[e], data, tryCall, cb);\n}.bind(this), callback);\n</pipeline-wrapper>\n}\n"], ["loadAsset", "\nfunction loadAsset (asset, varName) {\n<asset-existence-check>\nif (varName && typeof window[varName] !== 'undefined') {\n  return Promise.resolve(window[varName]);\n}\n</asset-existence-check>\n\n<asset-type-detection>\nif (typeof asset === 'string') {\n  if (/\\.css$/.test(asset)) {\n    asset = { src: asset, type: 'css' };\n  } else {\n    asset = { src: asset };\n  }\n}\n</asset-type-detection>\n\n<asset-loading>\nvar tag;\nif (asset.type === 'css') {\n  tag = document.createElement('link');\n  tag.setAttribute('rel', 'stylesheet');\n  tag.setAttribute('href', asset.src);\n} else {\n  tag = document.createElement('script');\n  tag.setAttribute('type', 'text/javascript');\n  tag.setAttribute('src', asset.src);\n}\n</asset-loading>\n\n<asset-onload-resolution>\nreturn new Promise(function (resolve) {\n  tag.async = true;\n  tag.onreadystatechange = tag.onload = function () {\n    var state = tag.readyState;\n    if (!state || /loaded|complete/.test(state)) {\n      resolve(varName ? window[varName] : undefined);\n    }\n  };\n  document.getElementsByTagName('head')[0].appendChild(tag);\n});\n</asset-onload-resolution>\n}\n"], "```"]