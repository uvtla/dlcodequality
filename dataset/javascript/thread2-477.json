[["refreshTree", "\nfunction(parent, children) {\n  if (this.myTree) {\n    this.myTree.refresh.bind(this.myTree)(parent, children, true);\n  }\n}\n"], ["ValidationExtension", "\nfunction ValidationExtension() {\n  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n      _ref$reject = _ref.reject,\n      reject = _ref$reject === undefined ? false : _ref$reject;\n\n  _classCallCheck(this, ValidationExtension);\n\n  <extendBaseClass>\n  var _this = _possibleConstructorReturn(this, (ValidationExtension.__proto__ || Object.getPrototypeOf(ValidationExtension)).call(this, {\n    onEntityInstantiate: true,\n    onChangeDetected: true\n  }));\n  </extendBaseClass>\n\n  _this.rejectInvalidValues = reject;\n  return _this;\n}\n"], ["callFunction", "\nfunction call (dataStore, fn, args) {\n  let resources, callback;\n\n  <defineResourceAndCallback>\n  let singleResource = _.first(args) instanceof Resource && (args.length === 0 || _.isFunction(args[1]));\n  if (_.isFunction(_.last(args))) {\n    resources = _.flatten(_.initial(args), true);\n    callback = _.last(args);\n  }\n  else {\n    resources = _.flatten(args, true);\n    callback = _.noop;\n  }\n  </defineResourceAndCallback>\n\n  <validateResources>\n  let collections = {};\n  for (let i = 0; i < resources.length; i++) {\n    let resource = resources[i];\n    if (!(resource instanceof Resource)) {\n      throw ono(\"Expected a Resource object, but parameter %d is a %s.\", i + 1, typeof (resource));\n    }\n    let collectionName = resource.valueOf(dataStore.__router, true);\n    let collection = collections[collectionName] || (collections[collectionName] = []);\n    collection.push(resource);\n  }\n  </validateResources>\n\n  <processCollections>\n  let collectionNames = Object.keys(collections);\n  let collectionIndex = 0, processedResources = [];\n  processNextCollection();\n  </processCollections>\n\n  <processNextCollection>\n  function processNextCollection (err, resources) {\n    if (err) {\n      <handleError>\n      finished(err);\n      </handleError>\n      return;\n    }\n\n    if (resources) {\n      <concatenateResources>\n      processedResources = processedResources.concat(resources);\n      </concatenateResources>\n    }\n\n    if (collectionIndex >= collectionNames.length) {\n      <finishProcessing>\n      finished(null, processedResources);\n      </finishProcessing>\n    }\n    else {\n      <processEachCollection>\n      let collectionName = collectionNames[collectionIndex++];\n      fn(dataStore, collectionName, collections[collectionName], processNextCollection);\n      </processEachCollection>\n    }\n  }\n  </processNextCollection>\n\n  <finishedCallback>\n  function finished (err, resources) {\n    if (err) {\n      callback(err);\n    }\n    else {\n      callback(null, singleResource ? resources[0] : resources);\n    }\n  }\n  </finishedCallback>\n}\n"], ["lookupQualifiedType", "\nfunction lookupQualifiedType(qname) {\n  var t = type_env.get(qname)\n  if (!t)\n    throw new TypeError(\"Unresolved type: \" + qname)\n  return t;\n}\n"], ["getterFunction", "\nfunction(type){\n  return function(prop){\n    <generateAccessor>\n    var accessor = this.getAccessor(prop, type),\n        accessorName = this._accessorName;\n    </generateAccessor>\n\n    <returnAccessorValue>\n    if (accessor && accessorName != prop) {\n      return accessor();\n    }\n    </returnAccessorValue>\n    \n    return this.parent(prop);\n  }.overloadGetter();\n}\n"], ["fadeLinesBut", "\nfunction fadeLinesBut(exceptionItemId) {\n  let classToFade = 'g.legend-entry';\n  let entryLine = svg.select(`[data-item=\"${exceptionItemId}\"]`);\n\n  <fadeEntriesAndHighlight>\n  if (entryLine.nodes().length){\n      svg.select('.legend-group')\n          .selectAll(classToFade)\n          .classed(isFadedClassName, true);\n\n      entryLine.classed(isFadedClassName, false);\n  }\n  </fadeEntriesAndHighlight>\n}\n"], ["createFBO", "\nfunction createFBO(renderState) {\n  m_handle = renderState.m_context.createFramebuffer();\n  renderState.m_context.bindFramebuffer(vgl.GL.FRAMEBUFFER, m_handle);\n\n  var colorBufferHandle, depthBufferHandle;\n\n  <prepareColorAttachment>\n  var colorTexture = m_fboAttachmentMap[vgl.GL.COLOR_ATTACHMENT0];\n  if (!colorTexture) {\n    colorBufferHandle = renderState.m_context.createRenderbuffer();\n    renderState.m_context.bindRenderbuffer(vgl.GL.RENDERBUFFER, colorBufferHandle);\n    renderState.m_context.renderbufferStorage(vgl.GL.RENDERBUFFER,\n      vgl.GL.RGB565, m_width, m_height);\n    renderState.m_context.framebufferRenderbuffer(vgl.GL.FRAMEBUFFER,\n      vgl.GL.COLOR_ATTACHMENT0, vgl.GL.RENDERBUFFER, colorBufferHandle);\n    m_fboAttachmentMap[vgl.COLOR_ATTACHMENT0] = colorBufferHandle;\n  } else {\n    updateTexture(colorTexture, renderState);\n    colorTexture.bind(renderState);\n    renderState.m_context.framebufferTexture2D(vgl.GL.FRAMEBUFFER,\n      vgl.GL.COLOR_ATTACHMENT0, vgl.GL.TEXTURE_2D,\n      colorTexture.textureHandle(), 0);\n  }\n  </prepareColorAttachment>\n\n  <prepareDepthAttachment>\n  var depthTexture = m_fboAttachmentMap[vgl.GL.DEPTH_ATTACHMENT];\n  if (!depthTexture) {\n    depthBufferHandle = vgl.GL.createRenderbuffer();\n    renderState.m_context.bindRenderbuffer(vgl.GL.RENDERBUFFER, depthBufferHandle);\n    renderState.m_context.renderbufferStorage(vgl.GL.RENDERBUFFER,\n      vgl.GL.DEPTH_COMPONENT16, m_width, m_height);\n    renderState.m_context.framebufferRenderbuffer(vgl.GL.FRAMEBUFFER,\n      vgl.GL.DEPTH_ATTACHMENT, vgl.GL.RENDERBUFFER, depthBufferHandle);\n    m_fboAttachmentMap[vgl.DEPTH_ATTACHMENT] = depthBufferHandle;\n  } else {\n    updateTexture(depthTexture, renderState);\n    depthTexture.bind(renderState);\n    renderState.m_context.framebufferTexture2D(vgl.GL.FRAMEBUFFER,\n      vgl.GL.DEPTH_ATTACHMENT, vgl.GL.TEXTURE_2D,\n      depthTexture.textureHandle(), 0);\n  }\n  </prepareDepthAttachment>\n\n  m_fboCreationTime.modified();\n}\n"], ["formatDate", "\nfunction (v) {\n  if (!v)\n      return null;\n  var d = AtomDate.parse(v);\n  var now = new Date();\n\n  <calculateDateDifference>\n  if (now.getFullYear() === d.getFullYear()\n      && now.getMonth() === d.getMonth()) {\n    var diff = now.getDate() - d.getDate();\n    switch(diff){\n      case -1:\n          return \"Tomorrow (\" + AtomDate.toTimeString(d) + \")\";\n      case 0:\n          return \"Today (\" + AtomDate.toTimeString(d) + \")\";\n      case 1:\n          return \"Yesterday (\" + AtomDate.toTimeString(d) + \")\";\n    }\n  }\n  </calculateDateDifference>\n\n  return AtomDate.toDateTimeString(d);\n}\n"], ["ParseMetaData", "\nfunction ParseMetaData(countryCode, md) {\n  <parseAndCacheMetaData>\n  var array = eval(md.replace(BACKSLASH, \"\\\\\\\\\"));\n  md = ParseArray(array,\n                  META_DATA_ENCODING,\n                  { countryCode: countryCode });\n  regionCache[md.region] = md;\n  </parseAndCacheMetaData>\n  return md;\n}\n"], ["iterateParentChain", "\nfunction (iterator, context) {\n  <validateIteratorAndContext>\n  if (!_.isFunction(iterator)) { return; }\n  !context && (context = this);\n  </validateIteratorAndContext>\n\n  var parent = this.__parent,\n      prev;\n\n  <iterateThroughParents>\n  while (parent) {\n    iterator.call(context, parent, prev);\n\n    prev = parent;\n    parent = parent.__parent;\n  }\n  </iterateThroughParents>\n}\n"], "```"]