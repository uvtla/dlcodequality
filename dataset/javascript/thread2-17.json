[["function", "\nfunction(model, options) {\n    <setupErrorHandling>\n    var error = options.error;\n    options.error = function(resp) {\n      if (error) error.call(options.context, model, resp, options);\n      model.trigger('error', model, resp, options);\n    };\n    </setupErrorHandling>\n}\n"], ["report", "\nfunction report(node) {\n    <generateMessage>\n    const message = node.parent.type === \"BlockStatement\" ? \"Nested block is redundant.\" : \"Block is redundant.\";\n    <generateMessage>\n\n    <reportError>\n    context.report({ node, message });\n    </reportError>\n}\n"], ["getFileSize", "\nfunction getFileSize(path) {\n\treturn new Promise(function(resolve, reject) {\n\t\t<fileStatistics>\n\t\tfs.stat(path, function(err, stats) {\n\t\t\tif (err) {\n\t\t\t\tif (err.code === 'ENOENT') {\n\t\t\t\t\tresolve(null);\n\t\t\t\t} else {\n\t\t\t\t\treject(err);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tresolve(stats.size);\n\t\t});\n\t\t</fileStatistics>\n\t});\n}\n"], ["replaceVirtualFields", "\nfunction replaceVirtualFields(options, model) {\n\t\t<handleAttributes>\n\t\tif (options.attributes) {\n\t\t\tfor (var i = 0; i < options.attributes.length; i++) { \n\t\t\t\tvar fieldName = options.attributes[i],\n\t\t\t\t\tfield = model.attributes[fieldName];\n\n\t\t\t\tif (!field) throw new Sequelize.VirtualFieldsError(\"Field '\" + model.name + '.' + fieldName + \"' referenced in a virtual field does not exist\");\n\n\t\t\t\tif (!(field.type instanceof Sequelize.VIRTUAL)) continue;\n\t\t\t\t\n\t\t\t\taddVirtualFieldOptions(options, field, fieldName);\n\n\t\t\t\t\n\t\t\t\toptions.attributes.splice(i, 1);\n\t\t\t\ti--;\n\t\t\t}\n\t\t} else {\n\t\t\t_.forIn(model.attributes, function(field, fieldName) {\n\t\t\t\t\n\t\t\t\tif (field.type instanceof Sequelize.VIRTUAL) addVirtualFieldOptions(options, field, fieldName);\n\t\t\t});\n\t\t}\n\t\t</handleAttributes>\n\n\t\t<processIncludes>\n\t\tvar includes = options.include;\n\t\tif (includes) {\n\t\t\t_.forEach(includes, function(include, index) {\n\t\t\t\t\n\t\t\t\tif (patches.isModel(include)) include = includes[index] = {model: include};\n\n\t\t\t\t\n\t\t\t\treplaceVirtualFields(include, include.model);\n\t\t\t});\n\t\t}\n\t\t</processIncludes>\n}\n"], ["parseHttpResponse", "\nfunction parseHttpResponse(options, filesWithHash) {\n    <logging>\n    if (options.verbose) {\n        _utils.logger.info('Parsing HTTP responses...');\n    }\n    </logging>\n    var promises = [];\n\n    <iterateFilesWithHash>\n    var _iteratorNormalCompletion5 = true;\n    var _didIteratorError5 = false;\n    var _iteratorError5 = undefined;\n\n    try {\n        for (var _iterator5 = filesWithHash[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n            var fileWithHash = _step5.value;\n\n            if (fileWithHash.subtitlesPresent) continue;\n            var p = (0, _utils.XML2JSON)(options, fileWithHash).catch(function (err) {\n                <handleErrors>\n                if (options.verbose) {\n                    _utils.logger.info('Error in HTTP response: ', err.err);\n                }\n                </handleErrors>\n                return err.fileWithHash;\n            });\n            promises.push(p);\n        }\n    } catch (err) {\n        _didIteratorError5 = true;\n        _iteratorError5 = err;\n    } finally {\n        try {\n            if (!_iteratorNormalCompletion5 && _iterator5.return) {\n                _iterator5.return();\n            }\n        } finally {\n            if (_didIteratorError5) {\n                throw _iteratorError5;\n            }\n        }\n    }\n    </iterateFilesWithHash>\n\n    <resolvePromises>\n    return Promise.all(promises);\n    </resolvePromises>\n}\n"], ["init", "\nfunction init(cb) {  \n  <validateCallback>\n  if (typeof cb !== 'function') {\n    throw O.log.error(this, 'Callback must be a function', cb);\n  }\n  </validateCallback>\n\n  <setupStream>\n  this.stream = new Readable();\n  this.stream._read = O._.noop;\n  this.stream.on('error', onError.bind(this));\n  </setupStream>\n\n  <invokeCallback>\n  cb(null, this.stream);\n  </invokeCallback>\n}\n"], ["function", "\nfunction (object) {\n    <deactivateInterfaces>\n    var interfaces = object.__$interfaces;\n    if (!interfaces) {\n        return;\n    }\n    for (var i in interfaces) {\n        if (interfaces.hasOwnProperty(i) && interfaces[i].$destructor) {\n            interfaces[i].$destructor();\n            interfaces[i] = null;\n        }\n    }\n    object.__$interfaces = null;\n    </deactivateInterfaces>\n}\n"], ["function", "\nfunction (symbol, x, y, width, height, options) {\n\t<createSVGorImageObject>\n\tvar obj,\n\t\tsymbolFn = this.symbols[symbol],\n\t\tpath = symbolFn && symbolFn(\n\t\t\tmathRound(x),\n\t\t\tmathRound(y),\n\t\t\twidth,\n\t\t\theight,\n\t\t\toptions\n\t\t),\n\t\timageElement,\n\t\timageRegex = /^url\\((.*?)\\)$/,\n\t\timageSrc,\n\t\timageSize,\n\t\tcenterImage;\n\n\tif (path) {\n\t\tobj = this.path(path);\n\t\textend(obj, {\n\t\t\tsymbolName: symbol,\n\t\t\tx: x,\n\t\t\ty: y,\n\t\t\twidth: width,\n\t\t\theight: height\n\t\t});\n\t\tif (options) {\n\t\t\textend(obj, options);\n\t\t}\n\t} else if (imageRegex.test(symbol)) {\n\t\tcenterImage = function (img, size) {\n\t\t\tif (img.element) {\n\t\t\t\timg.attr({\n\t\t\t\t\twidth: size[0],\n\t\t\t\t\theight: size[1]\n\t\t\t\t});\n\n\t\t\t\tif (!img.alignByTranslate) {\n\t\t\t\t\timg.translate(\n\t\t\t\t\t\tmathRound((width - size[0]) / 2),\n\t\t\t\t\t\tmathRound((height - size[1]) / 2)\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\timageSrc = symbol.match(imageRegex)[1];\n\t\timageSize = symbolSizes[imageSrc];\n\t\tobj = this.image(imageSrc)\n\t\t\t.attr({\n\t\t\t\tx: x,\n\t\t\t\ty: y\n\t\t\t});\n\t\tobj.isImg = true;\n\t\tif (imageSize) {\n\t\t\tcenterImage(obj, imageSize);\n\t\t} else {\n\t\t\tobj.attr({ width: 0, height: 0 });\n\t\t\timageElement = createElement('img', {\n\t\t\t\tonload: function () {\n\t\t\t\t\tcenterImage(obj, symbolSizes[imageSrc] = [this.width, this.height]);\n\t\t\t\t},\n\t\t\t\tsrc: imageSrc\n\t\t\t});\n\t\t}\n\t}\n\t</createSVGorImageObject>\n\treturn obj;\n}\n"], ["parseMultiplicative", "\nfunction parseMultiplicative() {\n\t<parseExpressionElements>\n\tvar token, left, right, r;\n\tleft = parseExponentiation();\n\ttoken = lexer.peek();\n\t</parseExpressionElements>\n\n\t<processMultiplicativeOperations>\n\tif (matchOp(token, '*') || matchOp(token, '/')) {\n\t\ttoken = lexer.next();\n\t\tright = parseMultiplicative();\n\t\tif (right.subtype === 'naryOperator' || right.subtype === 'binaryOperator') {\n\t\t\tr = right;\n\t\t\twhile (r.content[0].subtype === 'naryOperator' || r.content[0].subtype === 'binaryOperator') {\n\t\t\t\tr = r.content[0];\n\t\t\t}\n\t\t\tr.content[0] = new MathLib.Expression({\n\t\t\t\tsubtype: token.value === '*' ? 'naryOperator' : 'binaryOperator',\n\t\t\t\tcontent: [left, r.content[0]],\n\t\t\t\tvalue: token.value,\n\t\t\t\tname: token.value === '*' ? 'times' : 'divide'\n\t\t\t});\n\t\t\treturn right;\n\t\t} else {\n\t\t\treturn new MathLib.Expression({\n\t\t\t\tsubtype: token.value === '*' ? 'naryOperator' : 'binaryOperator',\n\t\t\t\tvalue: token.value,\n\t\t\t\tname: token.value === '*' ? 'times' : 'divide',\n\t\t\t\tcontent: [left, right]\n\t\t\t});\n\t\t}\n\t}\n\t</processMultiplicativeOperations>\n\treturn left;\n}\n"], ["function", "\nfunction (metricType, statsdKey) {\n\t<normalizeStatsdKey>\n\tstatsdKey = statsdKey.replace(/([^a-zA-Z0-9:_])/g, '_');\n\t</normalizeStatsdKey>\n\t<createMetricKey>\n\treturn [prefixes[metricType], '_', statsdKey].join('');\n\t</createMetricKey>\n}\n"], "```\n"]