[["decorateElement", "\nfunction decorateElement(element) {\n  <checkForTabIndex>\n  const hasMissingTabIndex = Boolean(!element.getAttribute('tabindex') && element.tabIndex === -1);\n  </checkForTabIndex>\n\n  if (hasMissingTabIndex) {\n    elementsWithMissingTabIndex.push(element);\n    element.tabIndex = 0;\n  }\n}\n"], ["appendChildrenToElements", "\nfunction(children) {\n  return this.each(function(index, el) {\n    children.each(function(index, child) {\n      el.appendChild(child);\n    });\n  });\n}\n"], ["manageTableDimensions", "\nfunction () {\n  var r, c, rlen, clen, emptyRows = 0, emptyCols = 0, recreateRows = false, recreateCols = false, val;\n\n  <DOMselection>\n  var $tbody = $(priv.tableBody);\n  </DOMselection>\n\n  <adjustRowCount>\n  var dlen = priv.settings.data.length;\n  while (self.rowCount < dlen) {\n    self.view.createRow();\n    recreateRows = true;\n  }\n  while (self.rowCount > dlen) {\n    self.view.removeRow();\n    recreateRows = true;\n  }\n  </adjustRowCount>\n  \n  <adjustColCount>\n  while (self.colCount < self.countCols()) {\n    self.view.createCol();\n    self.view.renderCol(self.colCount - 1);\n    recreateRows = true;\n  }\n  while (self.colCount > self.countCols()) {\n    self.view.removeCol();\n    recreateRows = true;\n  }\n  </adjustColCount>\n\n  <removeEmptyRows>\n  rows : for (r = self.countRows() - 1; r >= 0; r--) {\n    for (c = 0, clen = self.colCount; c < clen; c++) {\n      val = datamap.get(r, datamap.colToProp(c));\n      if (val !== '' && val !== null && typeof val !== 'undefined') {\n        break rows;\n      }\n    }\n    emptyRows++;\n  }\n  </removeEmptyRows>\n\n  <manageMinRows>\n  rlen = self.countRows();\n  if (rlen < priv.settings.minRows) {\n    for (r = 0; r < priv.settings.minRows - rlen; r++) {\n      datamap.createRow();\n    }\n  }\n  </manageMinRows>\n\n  ... (additional code that handles the table dimensions and selections similarly are omitted for brevity)\n\n  <updateSelectionsAfterDimensionChange>\n  if (recreateRows || recreateCols) {\n    selection.refreshBorders();\n    self.blockedCols.update();\n    self.blockedRows.update();\n  }\n  </updateSelectionsAfterDimensionChange>\n\n  return (recreateRows || recreateCols);\n}\n"], ["discardLayer", "\nfunction discardLayer(item) {\n  if (confirm('Remove this layer?')) {\n    scene.destroyLayer(item.layer);\n    layers.remove(item);\n  }\n}\n"], ["checkSymbolGroupStatus", "\nfunction(e) {\n  var status = false, g = e.group;\n  if(g === PL || g === CP) {\n    status = true;\n    for(var s in e.symbols) {\n      var symbol = e.symbols[s], sg = symbol.group;\n      if(sg === FN || sg === EX || sg === CB) { status = false;}\n      else {\n        if(sg === PL || sg === CP) status = __.isLinear(symbol);\n        else {\n          if(symbol.group !== N && symbol.power.toString() !== '1') { status = false; break; }\n        }\n      }\n    }\n  }\n  else if(g === S && e.power === 1) status = true;\n  return status;\n}\n"], ["registerShaderProgram", "\nfunction(compName, shader) {\n  <getShaderProgram>\n  this.program = this._drawLayer.getProgramWrapper(compName, shader);\n  </getShaderProgram>\n  \n  <registerEntity>\n  this.program.registerEntity(this);\n  </registerEntity>\n  \n  this.ready = true;\n}\n"], ["parseQueryString", "\nfunction parseQueryString(string) {\n  return _.transform(_.toString(string).split('&'), (result, segment) => {\n    const split = segment.split('=');\n    result[decodeURIComponent(split[0])] = decodeURIComponent(split[1]);\n  }, {});\n}\n"], ["detachPhysicsEvents", "\nfunction( world ){\n\n  <removePhysicsListeners>      \n  world.off('integrate:positions', this.behave, this);\n  </removePhysicsListeners>\n\n  <removePointerEvents>\n  if ( window.PointerEvent ) {\n\n    this.el.removeEventListener('pointerdown', this.grab);\n    window.removeEventListener('pointermove', this.move);\n    window.removeEventListener('pointerup', this.release);\n\n  } else {\n\n    this.el.removeEventListener('mousedown', this.grab);\n    this.el.removeEventListener('touchstart', this.grab);\n\n    window.removeEventListener('mousemove', this.move);\n    window.removeEventListener('touchmove', this.move);\n\n    window.removeEventListener('mouseup', this.release);\n    window.removeEventListener('touchend', this.release);\n\n  }\n  </removePointerEvents>\n}\n"], ["getBoundingVisibleRect", "\nfunction getBoundingVisibleRect(el) {\n  \n  <calculateRectangle>\n  const rect = getBoundingRect(el);\n  </calculateRectangle>\n\n  <adjustRectForViewportScale>\n  const scale = getPageScaleFactor();\n  const visualViewportX = chrome.gpuBenchmarking.visualViewportX();\n  const visualViewportY = chrome.gpuBenchmarking.visualViewportY();\n  rect.top = (rect.top - visualViewportY) * scale;\n  rect.left = (rect.left - visualViewportX) * scale;\n  rect.width *= scale;\n  rect.height *= scale;\n  </adjustRectForViewportScale>\n\n  <adjustRectWithinWindowConstraints>\n  const windowHeight = getWindowHeight();\n  const windowWidth = getWindowWidth();\n  \n  rect.top = clamp(0, rect.top, windowHeight);\n  rect.left = clamp(0, rect.left, windowWidth);\n  rect.height = clamp(0, rect.height, windowHeight - rect.top);\n  rect.width = clamp(0, rect.width, windowWidth - rect.left);\n  </adjustRectWithinWindowConstraints>\n\n  return rect;\n}\n"], ["retrieveAndProcessMultipleIhales", "\nfunction f_tahta_ihale_takip_tumu(_tahta_id) {\n  return f_tahta_ihale_takip_idler(_tahta_id)\n    .then(function (_ihale_idler) {\n      if (_ihale_idler && _ihale_idler.length > 0) {\n        \n        <dbQueryOptions>\n        var opts = {};\n        opts.bArrKalemleri = true;\n        opts.bYapanKurum = true;\n        opts.bTakip = true;\n        </dbQueryOptions>\n\n        <ihaleDBRetrieval>\n        var db_ihale = require(\"./db_ihale\");\n\n        return db_ihale.f_db_ihale_id(_ihale_idler, _tahta_id, opts);\n        </ihaleDBRetrieval>\n      } else {\n        return [];\n      }\n    });\n}\n"], "```\n\nIn all these annotations, I've only tagged lines or blocks of code with distinct, identifiable responsibilities, following the balanced SRP approach, avoiding over-segmenting and under-segmenting. Each tagged responsibility represents a specific purpose within the function."]