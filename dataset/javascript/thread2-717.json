[["keyOrBlurEventHandling", "\nfunction (event) {\n    this._lastKeyOrBlurEvent = this._currentKeyOrBlurEvent;\n    switch (event.type) {\n        case \"keyup\":\n            if (event.keyCode === Key.shift) {\n                this._currentKeyOrBlurEvent = null;\n            } else {\n                this._currentKeyOrBlurEvent = \"keyboard\";\n            }\n            break;\n        case \"focusout\":\n            this._currentKeyOrBlurEvent = null;\n            break;\n        default:\n            break;\n    }\n}\n"], ["setCustomRetryPolicy", "\nfunction setCustomRetryPolicy() {\n  console.log('Starting Sample 2 - setCustomRetryPolicy.');\n\n  \n  var retryOnContainerBeingDeleted = new RetryPolicyFilter();\n  retryOnContainerBeingDeleted.retryCount = 5;\n  retryOnContainerBeingDeleted.retryInterval = 5000;\n\n  retryOnContainerBeingDeleted.shouldRetry = function (statusCode, retryData) {\n    console.log(' Made the request at ' + new Date().toUTCString() + ', received StatusCode: ' + statusCode);\n\n    var retryInfo = {};\n\n    \n    if (statusCode >= 300 && statusCode !== 409 && statusCode !== 500) {\n      retryInfo.retryable = false;\n    } else {\n      var currentCount = (retryData && retryData.retryCount) ? retryData.retryCount : 0;\n\n      retryInfo = {\n        retryInterval: this.retryInterval + 2000 * currentCount,\n        retryable: currentCount < this.retryCount\n      };\n    }\n\n    return retryInfo;\n  };\n\n  blobService = azure.createBlobService().withFilter(retryOnContainerBeingDeleted);\n\n  \n  createContainer(function () {\n    fetchAttributesContainer(function () {\n      leaseContainer(function () {\n        leaseContainer(function () {\n          deleteContainer(function () {\n            console.log('Ending Sample 2 - setCustomRetryPolicy.');\n          });\n        });\n      });\n    });\n  });\n}\n"], ["validateCommandArguments", "\nfunction validate(cmd, args, info) {\n  AbstractCommand.prototype.validate.apply(this, arguments);\n\n  var source = '' + args[0]\n    , destination = '' + args[1];\n\n  if(!info.db.getKey(args[0], info)) {\n    throw NoSuchKey;\n  } else if(source === destination) {\n    throw SourceDestination;\n  }\n  args[0] = source;\n  args[1] = destination;\n}\n"], ["binManagement", "\nfunction bin (cb) {\n    if (my.args.length === 0) {\n      binlist(cb)\n    }\n    else {\n      var flag = my.args[0]\n      if (flag === '-d' || my.args[0] === 'delete') {\n        if (my.args[1]) {\n          deletebin(my.args[1],cb)\n        }\n        else {\n          cb( erf('Must pass a bin argument to delete'))\n        }\n      }\n      else return cb( erf('Unknown flag: ' + flag) )\n    }\n    function binlist(cb) {\n      var bin, binlist = []\n      for (bin in my.state.bins) {\n        if (bin === getActiveBin( my.state.bins )) {\n          binlist.push('* ' + path.basename(bin))\n        }\n        else {\n          binlist.push('  ' + path.basename(bin))\n        }\n      }\n      cb( erf('', binlist) )\n    } \n\n    function deletebin(delbin, cb) {\n      var bin, found = false\n      for (bin in my.state.bins) {\n        if (path.basename(bin) === path.basename(delbin)) {\n          delete my.state.bins[bin]\n          found = true\n        }\n      }\n      if (!found) {\n        return cb( erf( 'Can not remove ' + path.basename(delbin)\n                        +  '. Bin not recognized'))\n      }\n      cb(null, my.state)\n    } \n}\n"], ["saveStateWithColReorder", "\nfunction ( oState ) {\n\tvar i, iLen, aCopy, iOrigColumn;\n\tvar oSettings = this.s.dt;\n\tvar columns = oSettings.aoColumns;\n\n\toState.ColReorder = [];\n\n\tif ( oState.aaSorting ) {\n\t\tfor ( i=0 ; i<oState.aaSorting.length ; i++ ) {\n\t\t\toState.aaSorting[i][0] = columns[ oState.aaSorting[i][0] ]._ColReorder_iOrigCol;\n\t\t}\n\n\t\tvar aSearchCopy = $.extend( true, [], oState.aoSearchCols );\n\n\t\tfor ( i=0, iLen=columns.length ; i<iLen ; i++ ) {\n\t\t\tiOrigColumn = columns[i]._ColReorder_iOrigCol;\n\t\t\toState.aoSearchCols[ iOrigColumn ] = aSearchCopy[i];\n\t\t\toState.abVisCols[ iOrigColumn ] = columns[i].bVisible;\n\t\t\toState.ColReorder.push( iOrigColumn );\n\t\t}\n\t} else if ( oState.order ) {\n\t\tfor ( i=0 ; i<oState.order.length ; i++ ) {\n\t\t\toState.order[i][0] = columns[ oState.order[i][0] ]._ColReorder_iOrigCol;\n\t\t}\n\n\t\tvar stateColumnsCopy = $.extend( true, [], oState.columns );\n\n\t\tfor ( i=0, iLen=columns.length ; i<iLen ; i++ ) {\n\t\t\tiOrigColumn = columns[i]._ColReorder_iOrigCol;\n\t\t\toState.columns[ iOrigColumn ] = stateColumnsCopy[i];\n\t\t\toState.ColReorder.push( iOrigColumn );\n\t\t}\n\t}\n}\n"], ["getTransformerFromCache", "\nfunction getTransformer(name, clientPlugin, pluginOptions) {\n    if (cache[name]) { return cache[name]; }\n\n    var transformers = clientPlugin.transformers;\n    var templateDir = clientPlugin.templateDir;\n\n    if (!transformers[name]) { throw new Error('No transformer called ' + name); }\n\n    _.each(transformers, function (transformer, transformerName) {\n        cache[transformerName] = generateTransformer(transformerName, transformer, templateDir, pluginOptions);\n    });\n\n    return cache[name];\n}\n"], ["removeDirectory", "\nasync function removeDir(dirPath) {\n  let isExist = await checkDirExist(dirPath)\n  return new Promise((resolve, reject) => {\n    if (!isExist) {\n      resolve()\n    } else {\n      rimraf(dirPath, err => {\n        if (err) reject(err)\n        else resolve()\n      })\n    }\n  })\n}\n"], ["validateDecimalValue", "\nfunction validateDecimal(sValue, sName) {\n\tif (sValue) {\n\t\tif (sValue.match(rDecimal)) {\n\t\t\treturn sValue;\n\t\t}\n\t\tlogWarning(sValue, sName);\n\t}\n}\n"], ["addNodeToDOMSlot", "\nfunction addNodeToSlot (slot, node, insertBefore) {\n  const isInDefaultMode = slot.assignedNodes().length === 0;\n  registerNode(slot, node, insertBefore, eachNode => {\n    if (isInDefaultMode) {\n      slot.__insertBefore(eachNode, insertBefore !== undefined ? insertBefore : null);\n    }\n  });\n}\n"], ["loadPageContent", "\nfunction loadPage({page, parent, params = {}}, done) {\n  internal.getPageHTMLAsync(page).then(html => {\n    const pageElement = util.createElement(html);\n    parent.appendChild(pageElement);\n    done(pageElement);\n  });\n}\n"], "```"]