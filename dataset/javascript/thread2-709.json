[["constructContactInfoNode", "\nfunction(contact) {\n  var node = this.createElementDefaultNS(\"ContactInformation\");\n\n  <appendContactPerson>\n  if (contact.personPrimary) {\n      node.appendChild(this.write_wmc_ContactPersonPrimary(contact.personPrimary));\n  }\n  </appendContactPerson>\n\n  <appendContactPosition>\n  if (contact.position) {\n      node.appendChild(this.createElementDefaultNS(\n          \"ContactPosition\", contact.position\n      ));\n  }\n  </appendContactPosition>\n\n  <appendContactAddress>\n  if (contact.contactAddress) {\n      node.appendChild(this.write_wmc_ContactAddress(contact.contactAddress));\n  }\n  </appendContactAddress>\n\n  <appendContactPhone>\n  if (contact.phone) {\n      node.appendChild(this.createElementDefaultNS(\n          \"ContactVoiceTelephone\", contact.phone\n      ));\n  }\n  </appendContactPhone>\n\n  <appendContactFax>\n  if (contact.fax) {\n      node.appendChild(this.createElementDefaultNS(\n          \"ContactFacsimileTelephone\", contact.fax\n      ));\n  }\n  </appendContactFax>\n\n  <appendContactEmail>\n  if (contact.email) {\n      node.appendChild(this.createElementDefaultNS(\n          \"ContactElectronicMailAddress\", contact.email\n      ));\n  }\n  </appendContactEmail>\n  \n  return node;\n}\n"], ["getListedError", "\nfunction _getListedError (cartoError, errorList) {\n  var errorListkeys = _.keys(errorList);\n  var key;\n\n  <processErrorList>\n  for (var i = 0; i < errorListkeys.length; i++) {\n    key = errorListkeys[i];\n    if (!(errorList[key].messageRegex instanceof RegExp)) {\n      throw new Error('MessageRegex on ' + key + ' is not a RegExp.');\n    }\n    if (errorList[key].messageRegex.test(cartoError.message)) {\n      return {\n        friendlyMessage: _replaceRegex(cartoError, errorList[key]),\n        errorCode: _buildErrorCode(cartoError, key)\n      };\n    }\n  }\n  </processErrorList>\n\n  <handleUnknownError>\n  return {\n    friendlyMessage: cartoError.message || '',\n    errorCode: _buildErrorCode(cartoError, 'unknown-error')\n  };\n  </handleUnknownError>\n}\n"], ["pipeSemigroupoids", "\nfunction pipeS(...ms) {\n  <validateArguments>\n  if(!arguments.length) {\n    throw new TypeError(err)\n  }\n\n  const head =\n    ms[0]\n\n  if(!isSemigroupoid(head)) {\n    throw new TypeError(err)\n  }\n  </validateArguments>\n\n  <shortCircuitSingleArgument>\n  if(ms.length === 1) {\n    return head\n  }\n  </shortCircuitSingleArgument>\n\n  <composeSemigroupoids>\n  return ms.slice().reduce((comp, m) => {\n    if(!isSameType(comp, m)) {\n      throw new TypeError(err)\n    }\n\n    return comp.compose(m)\n  })\n  </composeSemigroupoids>\n}\n"], ["configureLoggingSystem", "\nfunction setup(logs) {\n  const streams = [];\n  <configureDefaultLogs>\n  if (logs == null) {\n    logs = [{ type: 'stdout', format: 'pretty', level: 'http' }];\n  }\n  </configureDefaultLogs>\n\n  <createStreamsForTargets>\n  logs.forEach(function(target) {\n    let level = target.level || 35;\n    if (level === 'http') {\n      level = 35;\n    }\n\n    <validateRotatingFile>\n    if (target.type === 'rotating-file') {\n      if (target.format !== 'json') {\n        throw new Error('Rotating file streams only work with JSON!');\n      }\n      if (cluster.isWorker) {\n        throw new Error('Cluster mode is not supported for rotating-file!');\n      }\n      </validateRotatingFile>\n\n      <createRotatingFileStream>\n      const stream = new VerdaccioRotatingFileStream(\n        _.merge(\n          {},\n          target.options || {},\n          { path: target.path, level }\n        )\n      );\n      </createRotatingFileStream>\n\n      streams.push({\n        type: 'raw',\n        level,\n        stream,\n      });\n    }\n    </validateRotatingFile>\n    \n    <configureStandardOrErrorStream>\n    else {\n      const stream = new Stream();\n      stream.writable = true;\n\n      let destination;\n      let destinationIsTTY = false;\n      if (target.type === 'file') {\n        destination = require('fs').createWriteStream(target.path, { flags: 'a', encoding: 'utf8' });\n        destination.on('error', function(err) {\n          stream.emit('error', err);\n        });\n      } else if (target.type === 'stdout' || target.type === 'stderr') {\n        destination = target.type === 'stdout' ? process.stdout : process.stderr;\n        destinationIsTTY = destination.isTTY;\n      } else {\n        throw Error('wrong target type for a log');\n      }\n      </configureStandardOrErrorStream>\n\n      <writeStreamBasedOnFormat>\n      if (target.format === 'pretty') {\n        stream.write = obj => {\n          destination.write(`${print(obj.level, obj.msg, obj, destinationIsTTY)}\\n`);\n        };\n      } else if (target.format === 'pretty-timestamped') {\n        stream.write = obj => {\n          destination.write(`[${dayjs(obj.time).format('YYYY-MM-DD HH:mm:ss')}] ${print(obj.level, obj.msg, obj, destinationIsTTY)}\\n`);\n        };\n      } else {\n        stream.write = obj => {\n          const msg = fillInMsgTemplate(obj.msg, obj, destinationIsTTY);\n          destination.write(`${JSON.stringify({ ...obj, msg }, Logger.safeCycles())}\\n`);\n        };\n      }\n      </writeStreamBasedOnFormat>\n\n      streams.push({\n        type: 'raw',\n        level,\n        stream: stream,\n      });\n    }\n  });\n  </createStreamsForTargets>\n\n  <initializeLogger>\n  const logger = new Logger({\n    name: pkgJSON.name,\n    streams: streams,\n    serializers: {\n      err: Logger.stdSerializers.err,\n      req: Logger.stdSerializers.req,\n      res: Logger.stdSerializers.res,\n    },\n  });\n  </initializeLogger>\n\n  <setupLoggerReopenOnSignal>\n  process.on('SIGUSR2', function() {\n    Logger.reopenFileStreams();\n  });\n  </setupLoggerReopenOnSignal>\n\n  module.exports.logger = logger;\n}\n"], ["toggleTreeViewNode", "\nfunction (ev) {\n        var self = this,\n            td = this._getEventTargetTdEl(ev),\n            node,\n            target,\n            toggle = function (force) {\n                node.focus();\n                if (force || !node.href) {\n                    node.toggle();\n                    try {\n                        Event.preventDefault(ev);\n                    } catch (e) {                       \n                    }\n                }\n            };\n\n        <checkEventTargetAvailability>\n        if (!td) {\n            return; \n        }\n        </checkEventTargetAvailability>\n\n        <getNodeByEventTarget>\n        node = this.getNodeByElement(td);\n        if (!node) { \n            return; \n        }\n        </getNodeByEventTarget>\n\n        <fireLabelClickEventIfApplicable>\n        target = Event.getTarget(ev);\n        if (Dom.hasClass(target, node.labelStyle) || Dom.getAncestorByClassName(target,node.labelStyle)) {\n            this.fireEvent('labelClick',node);\n        }\n        </fireLabelClickEventIfApplicable>\n\n        <handleToggleOnTreeNode>\n        if (/\\bygtv[tl][mp]h?h?/.test(td.className)) {\n            toggle(true);\n        } else {\n            if (this._dblClickTimer) {\n                window.clearTimeout(this._dblClickTimer);\n                this._dblClickTimer = null;\n            } else {\n                if (this._hasDblClickSubscriber) {\n                    this._dblClickTimer = window.setTimeout(function () {\n                        self._dblClickTimer = null;\n                        if (self.fireEvent('clickEvent', {event:ev,node:node}) !== false) { \n                            toggle();\n                        }\n                    }, 200);\n                } else {\n                    if (self.fireEvent('clickEvent', {event:ev,node:node}) !== false) { \n                        toggle();\n                    }\n                }\n            }\n        }\n        </handleToggleOnTreeNode>\n    }\n"], ["validateOperatorValue", "\nfunction operator(value) {\n    <unwrapOperator>\n    var raw = this.unwrapRaw(value);\n    if (raw) {\n      return raw;\n    }\n    </unwrapOperator>\n\n    <validateOperator>\n    if (operators[(value || '').toLowerCase()] !== true) {\n      throw new TypeError('The operator \"' + value + '\" is not permitted');\n    }\n    </validateOperator>\n\n    return value;\n}\n"], ["endBatchProcessing", "\nfunction _endBatch() {\n  --_batch;\n  _cometd._debug('Ending batch, depth', _batch);\n  \n  <validateBatchBalance>\n  if (_batch < 0) {\n      throw 'Calls to startBatch() and endBatch() are not paired';\n  }\n  </validateBatchBalance>\n\n  <flushBatchIfConditionsMet>\n  if (_batch === 0 && !_isDisconnected() && !_internalBatch) {\n      _flushBatch();\n  }\n  </flushBatchIfConditionsMet>\n}\n"], ["pickPropsFromObject", "\nfunction pick(o, props = []) {\n    <reduceObjectProperties>\n    return props.reduce((acc, k) => {\n        if (o.hasOwnProperty(k)) {\n            acc[k] = o[k];\n        }\n\n        return acc;\n    }, {});\n    </reduceObjectProperties>\n}\n"], ["initializeKeyContainers", "\nfunction () {\n    <incrementObjCount>\n    __objCount++;\n    </incrementObjCount>\n\n    <initializeKeys>\n    this._nextIndex = 0;            \n    this._objectKeys = null;\n    this._stringKeys = null;  \n    this._numberKeys = null;\n    this._otherKeys = null;\n    </initializeKeys>\n    \n    <setMetaDataProperty>\n    this._metaDataName = Aria.FRAMEWORK_PREFIX + \"hash::\" + __objCount;\n    </setMetaDataProperty>\n}\n"], ["drawTexture", "\nfunction draw(texture, width, height) {\n  <initializeIfNeeded>\n  if (!this._.isInitialized || texture._.width != this.width || texture._.height != this.height) {\n    initialize.call(this, width ? width : texture._.width, height ? height : texture._.height);\n  }\n  </initializeIfNeeded>\n\n  <applyTextureAndDraw>\n  texture._.use();\n  this._.texture.drawTo(function() {\n    Shader.getDefaultShader().drawRect();\n  });\n  </applyTextureAndDraw>\n\n  return this;\n}\n"], "```"]