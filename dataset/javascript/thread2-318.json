[["downloadSequence", "\nfunction(onProgress) {\n    <defaultProgressHandler>\n    onProgress = onProgress || function() {}; </defaultProgressHandler>\n    library.autosave(false);\n    let modules_urls = [\n        'https://...moduleA',\n        'https://...moduleB',\n        'https://...moduleC', \n        // ... (not displaying all URLs for brevity)\n    ];\n    return promiseUtils.chain(downloadTA, function(err, data) {\n        if(err instanceof Error) return Promise.reject(err);\n        console.log(err);\n        return false;\n    }, {compact: true, onProgress: onProgress.bind(null, 'ta')})(modules_urls)\n        .then(function() {\n            library.commit();\n            library.autosave(true);\n            return Promise.resolve();\n        })\n        .catch(function(err) {\n            library.autosave(true);\n            return Promise.reject(err);\n        });\n}\n"], ["buildPaginationResponse", "\nfunction buildResponse(data) {\n    var response = {};\n    response.totalItems = data.length;\n    response.itemsPerPage = itemsPerPage;\n    response.totalPages = itemsPerPage === null ? 1 : Math.ceil(data.length / itemsPerPage);\n    response.currentPage = itemsPerPage === null ? 1 : currentPage;\n    response.data = itemsPerPage === null ? data : data.slice(itemsPerPage * (currentPage - 1), itemsPerPage);\n\n    return response;\n}\n"], ["initializeTemporaryDirectory", "\nfunction initTmpDir (dirname, cb) {\n  var dir = path.join(os.tmpDir(), dirname);\n\n  rmrf(dir, function (err) {\n    if (err) return cb(err);\n    mkdir(dir, function (err) {\n      if (err) return cb(err);\n      cb(null, dir);\n    });\n  });\n}\n"], ["createLocaleInfoFiles", "\nfunction getInfoFiles(answers) {\n    const locales = ['en', 'es', 'pt_BR'];\n    return locales\n        .map(locale => ({ filename: path.join(answers.name, `info/${locale}.md`), content: '' }));\n}\n"], ["manageSvgDefinitions", "\nfunction getSvgDefsElement() {\n  \n  <checkExistingDefinitions>\n  const defsElement = document.getElementById('precision-inputs-svg-defs');\n  if (defsElement) { return defsElement; } </checkExistingDefinitions>\n\n  \n  <createSvgDefinitions>\n  const svg = document.createElementNS(svgNS, 'svg');\n  svg.style.position = 'absolute';\n  svg.style.left = 0;\n  svg.style.top = 0;\n  svg.style.width = 0;\n  svg.style.height = 0;\n  svg.style.opacity = 0;\n  const defs = document.createElementNS(svgNS, 'defs');\n  defs.id = 'precision-inputs-svg-defs';\n  svg.appendChild(defs);\n  document.body.appendChild(svg); </createSvgDefinitions>\n\n  return defs;\n}\n"], ["deferredPromiseManagement", "\nfunction PromiseFactory() {\n\tvar deferred = whenjs.defer();\n\t\n    <rejectPromise>\n\tthis.reject = function (err) {\n\t\tdeferred.reject(err);\n\t}; </rejectPromise>\n    <resolvePromise>\n\tthis.resolve = function (val) {\n\t\tdeferred.resolve(val);\n\t}; </resolvePromise>\n    <getPromise>\n\tthis.promise = function () {\n\t\treturn deferred.promise;\n\t}; </getPromise>\n}\n"], ["escapeStringSpecialCharacters", "\nfunction escape (string) {\n  return string\n    .replace(/ /g, '\\\\ ')\n    .replace(/\\n/g, '')\n    .replace(/\\(/g, '\\\\(')\n    .replace(/\\)/g, '\\\\)');\n}\n"], ["processDirectoryFiles", "\nfunction(loc){\n     var path = loc;\n     \n     <listAndProcessFiles>\n     var files = afs.list_directory(loc);\n     files.forEach(function(file){\n         var full_file = loc + '/' + file;\n         _check_and_save(full_file);\n     }); </listAndProcessFiles>\n}\n"], ["parseAndMergeImports", "\nfunction Import(beforeFrom, afterFrom) {\n  let self = this;\n  <cleanupImportSyntax>\n  let cleanup = s => (s||'').replace(/[\\s\\r\\n]+/g, ' ')\n                            .replace(/ +/, ' ')\n                            .replace(/;+$/, '').trim(); </cleanupImportSyntax>\n\n  \n  <parseBeforeAndAfterFrom>\n  if ((beforeFrom||'').indexOf('import ') === 0) {\n    let parts = cleanup(beforeFrom).replace(/^import\\s+/, '').split(/\\s+(?:from)\\s+/);\n    beforeFrom = parts[0];\n    afterFrom = parts[1];\n  }\n  beforeFrom = cleanup(beforeFrom);\n  afterFrom  = cleanup(afterFrom); </parseBeforeAndAfterFrom>\n\n  <extractImportNames>\n  let nameParts = /^\\s*(.*?)(?:,\\s*(\\{[^}]+}))?\\s*$/.exec(beforeFrom) || ['', beforeFrom];\n  this.nameDefault = nameParts[2] ? nameParts[1] : null;\n  this.names = nameParts[ nameParts[2] ? 2 : 1];\n  this.isBraced = this.names.substring(0,1) === '{';\n  this.names = this.names.trim().replace(/^\\{|}$/g, '').split(/,/).map(n => n.trim()).sort();\n  this.path = afterFrom ? afterFrom.trim()\n                            .replace(/^\\s*['\"`]/, '')\n                            .replace(/['\"`]\\s*$/, '')\n                            .replace(/^\\.\\/\\.\\.\\//, '')\n                        : ''; </extractImportNames>\n\n  <mergeOtherImport>\n  this.add = function(otherImport) {\n    if (self.path != otherImport.path) return;\n    let known = {};\n    self.names.forEach(n => known[n]=true);\n    otherImport.names.forEach(n => { if (!known[n]) self.names.push(n); } );\n    if (self.names.length) self.isBraced = true;\n  }; </mergeOtherImport>\n\n  <createImportStatement>\n  this.toString = function(namesLen0) {\n    let joinedNames = this.namesJoined();\n    let namesLen = Math.min(namesLen0, options.maxNamesLength);\n    return \"import \" +\n           (self.path === ''\n             ? joinedNames\n             : (joinedNames.length > options.maxNamesLength\n                 ? joinedNames + (options.maxNamesLength > 0 ? '\\n' + leftPad(\"\", namesLen + \"import \".length) : '')\n                 : rightPad(joinedNames, namesLen)\n               ) +\n               \" from \" + options.pathQuote + self.path + options.pathQuote\n           ) +\n           ';';\n  }; </createImportStatement>\n\n"], ["sortAndCleanFeatures", "\nfunction sortFeatures(features) {\n  return features.map(feature => {\n    <calculatePolygonArea>\n    if (feature.geometry.type === Constants.geojsonTypes.POLYGON) {\n      feature.area = area.geometry({\n        type: Constants.geojsonTypes.FEATURE,\n        property: {},\n        geometry: feature.geometry\n      });\n    } </calculatePolygonArea>\n    return feature;\n  }).sort(comparator).map(feature => {\n    <removeTemporaryProperties>\n    delete feature.area; </removeTemporaryProperties>\n    return feature;\n  });\n}\n"], "```"]