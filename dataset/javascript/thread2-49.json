[["parse", "\nfunction parse(template, options) {\n    <initializeOptions>\n    options = options || {};\n\n    var tags = options.tags || exports.tags,\n        openTag = tags[0],\n        closeTag = tags[tags.length - 1];\n\n    var code = [\n      'var buffer = \"\";', \n      \"\\nvar line = 1;\", \n      \"\\ntry {\",\n      '\\nbuffer += \"'\n    ];\n    </initializeOptions>\n\n    <initializeControlVariables>\n    var spaces = [],      \n        hasTag = false,   \n        nonSpace = false; \n    </initializeControlVariables>\n\n    var stripSpace = function () {\n      <stripSpaceLogic>\n      if (hasTag && !nonSpace && !options.space) {\n        while (spaces.length) {\n          code.splice(spaces.pop(), 1);\n        }\n      } else {\n        spaces = [];\n      }\n      </stripSpaceLogic>\n\n      hasTag = false;\n      nonSpace = false;\n    };\n\n    <initializeSectionControl>\n    var sectionStack = [], updateLine, nextOpenTag, nextCloseTag;\n    </initializeSectionControl>\n\n    <setTags>\n    var setTags = function (source) {\n      tags = trim(source).split(/\\s+/);\n      nextOpenTag = tags[0];\n      nextCloseTag = tags[tags.length - 1];\n    };\n    </setTags>\n\n    <includePartial>\n    var includePartial = function (source) {\n      code.push(\n        '\";',\n        updateLine,\n        '\\nvar partial = partials[\"' + trim(source) + '\"];',\n        '\\nif (partial) {',\n        '\\n  buffer += render(partial,stack[stack.length - 1],partials);',\n        '\\n}',\n        '\\nbuffer += \"'\n      );\n    };\n    </includePartial>\n\n    var openSection = function (source, inverted) {\n      <openSectionLogic>\n      var name = trim(source);\n\n      if (name === \"\") {\n        throw debug(new Error(\"Section name may not be empty\"), template, line, options.file);\n      }\n\n      sectionStack.push({name: name, inverted: inverted});\n\n      code.push(\n        '\";',\n        updateLine,\n        '\\nvar name = \"' + name + '\";',\n        '\\nvar callback = (function () {',\n        '\\n  return function () {',\n        '\\n    var buffer = \"\";',\n        '\\nbuffer += \"'\n      );\n      </openSectionLogic>\n    };\n\n    <openInvertedSection>\n    var openInvertedSection = function (source) {\n      openSection(source, true);\n    };\n    </openInvertedSection>\n\n    <closeSection>\n    var closeSection = function (source) {\n      <closeSectionLogic>\n      var name = trim(source);\n      var openName = sectionStack.length != 0 && sectionStack[sectionStack.length - 1].name;\n\n      if (!openName || name != openName) {\n        throw debug(new Error('Section named \"' + name + '\" was never opened'), template, line, options.file);\n      }\n\n      var section = sectionStack.pop();\n\n      code.push(\n        '\";',\n        '\\n    return buffer;',\n        '\\n  };',\n        '\\n})();'\n      );\n\n      if (section.inverted) {\n        code.push(\"\\nbuffer += renderSection(name,stack,callback,true);\");\n      } else {\n        code.push(\"\\nbuffer += renderSection(name,stack,callback);\");\n      }\n\n      code.push('\\nbuffer += \"');\n      </closeSectionLogic>\n    };\n    </closeSection>\n\n    <sendPlain>\n    var sendPlain = function (source) {\n      code.push(\n        '\";',\n        updateLine,\n        '\\nbuffer += lookup(\"' + trim(source) + '\",stack,\"\");',\n        '\\nbuffer += \"'\n      );\n    };\n    </sendPlain>\n\n    <sendEscaped>\n    var sendEscaped = function (source) {\n      code.push(\n        '\";',\n        updateLine,\n        '\\nbuffer += escapeHTML(lookup(\"' + trim(source) + '\",stack,\"\"));',\n        '\\nbuffer += \"'\n      );\n    };\n    </sendEscaped>\n\n    <mainParsingLoop>\n    var line = 1, c, callback;\n    for (var i = 0, len = template.length; i < len; ++i) {\n      if (template.slice(i, i + openTag.length) === openTag) {\n        <handleTag>\n        i += openTag.length;\n        c = template.substr(i, 1);\n        updateLine = '\\nline = ' + line + ';';\n        nextOpenTag = openTag;\n        nextCloseTag = closeTag;\n        hasTag = true;\n\n        switch (c) {\n        case \"!\": \n          i++;\n          callback = null;\n          break;\n        case \"=\": \n          i++;\n          closeTag = \"=\" + closeTag;\n          callback = setTags;\n          break;\n        case \">\": \n          i++;\n          callback = includePartial;\n          break;\n        case \"#\": \n          i++;\n          callback = openSection;\n          break;\n        case \"^\": \n          i++;\n          callback = openInvertedSection;\n          break;\n        case \"/\": \n          i++;\n          callback = closeSection;\n          break;\n        case \"{\": \n          closeTag = \"}\" + closeTag;\n        case \"&\": \n          i++;\n          nonSpace = true;\n          callback = sendPlain;\n          break;\n        default: \n          nonSpace = true;\n          callback = sendEscaped;\n        }\n\n        var end = template.indexOf(closeTag, i);\n\n        if (end === -1) {\n          throw debug(new Error('Tag \"' + openTag + '\" was not closed properly'), template, line, options.file);\n        }\n\n        var source = template.substring(i, end);\n\n        if (callback) {\n          callback(source);\n        }\n\n        var n = 0;\n        while (~(n = source.indexOf(\"\\n\", n))) {\n          line++;\n          n++;\n        }\n\n        i = end + closeTag.length - 1;\n        openTag = nextOpenTag;\n        closeTag = nextCloseTag;\n        </handleTag>\n      } else {\n        <handleCharacter>\n        c = template.substr(i, 1);\n\n        switch (c) {\n        case '\"':\n        case \"\\\\\":\n          nonSpace = true;\n          code.push(\"\\\\\" + c);\n          break;\n        case \"\\r\":\n          break;\n        case \"\\n\":\n          spaces.push(code.length);\n          code.push(\"\\\\n\");\n          stripSpace(); \n          line++;\n          break;\n        default:\n          if (isWhitespace(c)) {\n            spaces.push(code.length);\n          } else {\n            nonSpace = true;\n          }\n\n          code.push(c);\n        }\n        </handleCharacter>\n      }\n    }\n    </mainParsingLoop>\n\n    <checkUnclosedSections>\n    if (sectionStack.length != 0) {\n      throw debug(new Error('Section \"' + sectionStack[sectionStack.length - 1].name + '\" was not closed properly'), template, line, options.file);\n    }\n    </checkUnclosedSections>\n\n    <stripFinalSpace>\n    stripSpace();\n    </stripFinalSpace>\n\n    <finalizeCode>\n    code.push(\n      '\";',\n      \"\\nreturn buffer;\",\n      \"\\n} catch (e) { throw {error: e, line: line}; }\"\n    );\n    </finalizeCode>\n\n    <debugOutput>\n    var body = code.join(\"\").replace(/buffer \\+= \"\";\\n/g, \"\");\n\n    if (options.debug) {\n      if (typeof console != \"undefined\" && console.log) {\n        console.log(body);\n      } else if (typeof print === \"function\") {\n        print(body);\n      }\n    }\n    </debugOutput>\n\n    return body;\n}\n"], ["callSendAPI", "\nfunction callSendAPI(messageData) {\n    <executeRequest>\n    request({\n        uri: 'https://graph.facebook.com/v2.6/me/messages',\n        qs: {\n            access_token: PAGE_ACCESS_TOKEN\n        },\n        method: 'POST',\n        json: messageData\n\n    }, function(error, response, body) {\n        <handleResponse>\n        if (!error && response.statusCode == 200) {\n            var recipientId = body.recipient_id;\n            var messageId = body.message_id;\n\n            if (messageId) {\n                console.log(\"Successfully sent message with id %s to recipient %s\",\n                    messageId, recipientId);\n            } else {\n                console.log(\"Successfully called Send API for recipient %s\",\n                    recipientId);\n            }\n        } else {\n            console.error(\"Failed calling Send API\", response.statusCode, response.statusMessage, body.error);\n        }\n        </handleResponse>\n    });\n    </executeRequest>\n}\n"], ["examineEvent", "\nfunction examineEvent(target, event) {\n    <eventHandlingLogic>\n        if (spec.templating.isFileName(target) || spec.templating.isEditIcon(target)) {\n            var fileId = spec.templating.getFileId(target),\n                status = spec.onGetUploadStatus(fileId);\n\n            if (status === qq.status.SUBMITTED) {\n                spec.log(qq.format(\"Detected valid filename click event on file '{}', ID: {}.\", spec.onGetName(fileId), fileId));\n                qq.preventDefault(event);\n\n                inheritedInternalApi.handleFilenameEdit(fileId, target, true);\n            }\n        }\n    </eventHandlingLogic>\n}\n"], ["mix", "\nfunction mix(receiver, supplier, overwrite) {\n    <mixObjects>\n    var key;\n\n    if (!receiver || !supplier) {\n        return receiver || {};\n    }\n\n    for (key in supplier) {\n        if (supplier.hasOwnProperty(key)) {\n            if (overwrite || !receiver.hasOwnProperty(key)) {\n                receiver[key] = supplier[key];\n            }\n        }\n    }\n    </mixObjects>\n\n    return receiver;\n}\n"], ["countIdentifiers", "\nfunction countIdentifiers (node) {\n    <recursiveCount>\n    if (!node.children) return 0;\n    var count = 0, i = 0, len = node.children.length, type;\n    for (; i < len; i++) {\n      type = node.children[i].type;\n      if (type === \"identifier\" || type === \"binder\" || type === \"key\") count += 1;\n      else count += countIdentifiers(node.children[i]);\n    }\n    </recursiveCount>\n    return count;\n}\n"], ["getIndexOfItemAtY", "\nfunction getIndexOfItemAtY(items, scrollTarget, y, downward) {\n    <initialSetup>\n    const start = downward ? 0 : items.length - 1;\n    const end = downward ? items.length : 0;\n    const step = downward ? 1 : -1;\n\n    const topOfClientArea = scrollTarget.offsetTop + scrollTarget.clientTop;\n    </initialSetup>\n\n    <iterateItems>\n    let item;\n    let itemIndex = start;\n    let itemTop;\n    let found = false;\n    while (itemIndex !== end) {\n        <findItemConditions>\n        item = items[itemIndex];\n        itemTop = item.offsetTop - topOfClientArea;\n        const itemBottom = itemTop + item.offsetHeight;\n        if (itemTop <= y && itemBottom >= y) {\n            found = true;\n            break;\n        }\n        </findItemConditions>\n        itemIndex += step;\n    }\n    </iterateItems>\n\n    if (!found) {\n        return null;\n    }\n\n    <computeAdjustedIndex>\n    const itemStyle = getComputedStyle(item);\n    const itemPaddingTop = itemStyle.paddingTop ? parseFloat(itemStyle.paddingTop) : 0;\n    const itemPaddingBottom = itemStyle.paddingBottom ? parseFloat(itemStyle.paddingBottom) : 0;\n    const contentTop = itemTop + item.clientTop + itemPaddingTop;\n    const contentBottom = contentTop + item.clientHeight - itemPaddingTop - itemPaddingBottom;\n    if ((downward && contentTop <= y) || (!downward && contentBottom >= y)) {\n        return itemIndex;\n    }\n    else {\n        return itemIndex - step;\n    }\n    </computeAdjustedIndex>\n}\n"], ["exportsFunction", "\nfunction (exports) {\n\n    <findExport>\n    var exp = undefined;\n\n    \n    exports.forEach(function (_export) {\n        if (_export.action && _export.action === 'export') {\n            exp = _export;\n        }\n\n    });\n    </findExport>\n\n    <validateExport>\n    if (!exp) {\n        throw new Error(\"The export was using Linz default export method, yet the model's list.export object could not be found.\");\n    }\n    </validateExport>\n\n    return exp;\n}\n"], ["removePreviousAssociatedDomains", "\nfunction removePreviousAssociatedDomains(preferences, domains) {\n    <generateFilteredDomainsList>\n    const output = [];\n    const linkDomains = preferences.linkDomain;\n\n    if (!domains) return output;\n    for (let i = 0; i < domains.length; i++) {\n      let domain = domains[i];\n      if (domain.indexOf(\"applinks:\") === 0) {\n        domain = domain.replace(\"applinks:\", \"\");\n        if (isBranchAssociatedDomains(domain, linkDomains)) {\n          output.push(`applinks:${domain}`);\n        }\n      } else if (isBranchAssociatedDomains(domain, linkDomains)) {\n        output.push(domain);\n      }\n    }\n    </generateFilteredDomainsList>\n\n    return output;\n}\n"], ["parseJSON", "\nfunction parse(data) {\n  try {\n    <attemptParsing>\n    return JSON.parse(data);\n    </attemptParsing>\n  } catch (e) {\n    <handleParseError>\n    log('Oops! Some problems parsing this ' + (typeof data === 'undefined' ? 'undefined' : _typeof(data)) + '.', 'error', debug);\n    </handleParseError>\n  }\n\n  return null;\n}\n"], ["getParams", "\nfunction getParams(req, all) {\n  <initializeValues>\n  const val = { query: {}, body: {}, params: {}, all: {} };\n  </initializeValues>\n\n  if (all) {\n    <aggregateAllParameters>\n    for (const k in req.query) {\n      val.query[k] = req.query[k];\n      val.all[k] = req.query[k];\n    }\n    for (const k in req.body) {\n      val.body[k] = req.body[k];\n      val.all[k] = req.body[k];\n    }\n    for (const k in req.params) {\n      val.params[k] = req.params[k];\n      val.all[k] = req.params[k];\n    }\n    </aggregateAllParameters>\n  } else {\n    <getRequestBasedParameters>\n    if (req.method === 'GET') {\n      val.query = req.query;\n      val.all = req.query;\n    } else {\n      val.body = req.body;\n      val.all = req.body;\n    }\n    for (const k in req.params) {\n      val.params[k] = req.params[k];\n      val.all[k] = req.params[k];\n    }\n    </getRequestBasedParameters>\n  }\n  return val;\n}\n"], "```"]