[["removeListeners", "function (name, fn) {\n    this._listeners = !name\n        ? []\n        : filter(this._listeners, function (listener) {\n            <compareListenerName>\n            if (listener.name !== name) {\n                return true;\n            } else {\n            </compareListenerName>\n                <compareListenerFunction>\n                if (isFunction(fn)) {\n                    return listener.fn !== fn;\n                } else {\n                    return false;\n                }\n                </compareListenerFunction>\n            }\n        });\n\n    return this;\n}\n"], ["tapFunctionCall", "function tap(fn, x) {\n    <ensureFunction>\n    if(!isFunction(fn)) {\n        throw new TypeError(\n          'tap: Function required for first argument'\n        )\n    }\n    </ensureFunction>\n  \n    return compose(constant(x), fn)(x)\n}\n"], ["parseArguments", "function parseArguments (args, state, babel) {\n  <initializeVariables>\n  const {file: {opts: {filename, plugins}}} = state\n  const {types: t} = babel\n  </initializeVariables>\n\n  let chunkName, source\n  const promises = {}\n  <handleOptions>\n  const options =\n    args.length > 1\n    && args[args.length - 1].type !== 'StringLiteral'\n    && args[args.length - 1].type !== 'TemplateLiteral'\n      ? args[args.length - 1].node\n      : void 0\n  args = options === void 0 ? args : args.slice(0, -1)\n  </handleOptions>\n\n  for (let arg of args) {\n    let value = ''\n\n    <processArguments>\n    switch (arg.type) {\n      case 'StringLiteral':\n\n        value = arg.node.value\n\n        source =\n          value.match(relativePkg) === null\n            ? value\n            : path.join(path.dirname(filename), value)\n        chunkName = chunkNameCache.get(source)\n\n        if (promises[chunkName] !== void 0) {\n          throw new Error(`[Broker Error] duplicate import: ${source}`)\n        }\n\n        promises[chunkName] = t.arrowFunctionExpression(\n          [],\n          t.callExpression(\n            t.identifier('import'),\n            [t.stringLiteral(source)]\n          )\n        )\n      break;\n      default:\n        throw new Error(`[Broker Error] Unrecognized argument type: ${arg.type}`)\n    }\n    </processArguments>\n  }\n\n  return {promises, options}\n}\n"], ["copyCoordinates", "function(c) {\n    c = c.getc(true);\n    this.x = c.x;\n    this.y = c.y;\n}\n"], ["wrapObject", "function _wrapper(originalObject, wrappedObject, provide, injects, isTransientScope) {\n    <copyProperties>\n    wrappedObject.$provide = originalObject.$provide;\n    wrappedObject.$inject = originalObject.$inject;\n    wrappedObject.$transientScope = originalObject.$transientScope;\n    </copyProperties>\n\n    <resolveDependencies>\n    resolveProvide(wrappedObject, provide);\n    resolveInjects(wrappedObject, injects);\n    resolveTransientScope(wrappedObject, isTransientScope);\n    </resolveDependencies>\n\n    return wrappedObject;\n}\n"], ["makeNetworkRequest", "function make_request(params, url_composer = compose_url) {\n    return new Promise(_make_request);\n\n    <networkRequestImplementation>\n    function _make_request(resolve_promise) {\n        const { headers, http_verb, payload } = params;\n        const settings = {\n            headers,\n            method: http_verb,\n            url: url_composer(params),\n        };\n        undefined !== payload && (settings.data = payload);\n        axios.request(settings)\n            .then(process_axios_response)\n            .catch(process_axios_rejection);\n\n        <processResponse>\n        function process_axios_response(axios_response) {\n            const response = {\n                status: {\n                    code: axios_response.status,\n                    text: axios_response.statusText,\n                },\n                headers: axios_response.headers,\n                data: axios_response.data,\n            };\n            if (params.preparer) {\n                const request_metadata = Object.assign({}, params);\n                delete request_metadata.preparer;\n                response.data = params.preparer(request_metadata, response);\n            }\n            return resolve_promise(response);\n        }\n        </processResponse>\n        <handleRejection>\n        function process_axios_rejection(axios_rejection) {\n            return axios_rejection.response\n                ? process_axios_response(axios_rejection.response)\n                : throw_error(axios_rejection);\n        }\n        </handleRejection>\n    }\n    </networkRequestImplementation>\n}\n"], ["camelizeString", "function camelize(str) {\n    return str.replace(/(?:^\\w|[A-Z]|\\b\\w)/g, (letter, index) => {\n        return index === 0 ? letter.toLowerCase() : letter.toUpperCase()\n    }).replace(/[\\s\\-_]+/g, '')\n}\n"], ["searchAndSortPackages", "function () {\n    var matchedItems = packages;\n    <prepareSearchCriteria>\n    var parsed = this.parseQuery(this.query);\n    var query = parsed.query;\n    var fields = parsed.field ? [parsed.field] :\n      _.filter(Object.keys(config.searchField), function (key) {\n        return config.searchField[key];\n      });\n    var exact = !!parsed.field;\n    </prepareSearchCriteria>\n\n    <applySearchFilters>\n    matchedItems = this.filter(matchedItems);\n    matchedItems = this.find(matchedItems, query, fields, exact);\n    matchedItems = this.dedupe(matchedItems);\n    matchedItems = this.sort(matchedItems, this.sorting, this.order);\n    matchedItems = !exact ? this.prioritize(matchedItems, query) : matchedItems;\n    </applySearchFilters>\n\n    <paginateResults>\n    this.count = matchedItems.length;\n    this.pageCount = Math.ceil(this.count / this.limit);\n    this.from = (this.page - 1) * this.limit + 1;\n    this.to =  this.from + this.limit - 1 > this.count ? this.count : this.from + this.limit - 1;\n    this.results = matchedItems.slice(this.from - 1, this.to);\n    </paginateResults>\n}\n"], ["saveDataToFile", "function saveAsFile(editor, data, range) {\n    return new Promise((resolve, reject) => {\n        <showFileSaveDialog>\n        const fileName = atom.getCurrentWindow().showSaveDialog();\n        if (!fileName) {\n            return reject(new Error('User cancelled file dialog'));\n        }\n        </showFileSaveDialog>\n\n        <writeFileToDisk>\n        fs.writeFile(fileName, Buffer.from(data, 'base64'), err => {\n            if (err) {\n                return reject(err);\n            }\n            </writeFileToDisk>\n\n            <updateEditorContent>\n            const editorPath = editor.getPath();\n            let displayPath = editorPath\n                ? path.relative(editorPath, fileName)\n                : `file:\n\n            editor.transact(() => {\n                \n                editor.setTextInBufferRange(range, displayPath.replace(/\\\\+/g, '/'));\n            });\n            </updateEditorContent>\n\n            resolve(fileName);\n        });\n    });\n}\n"], ["loadLevelFromFile", "function load(file, options = {}) {\n    return new Promise((resolve, reject) => {\n\n        <validateInput>\n        var fileName = options.file || file;\n        if (!fileName) {\n            return reject('Must give a file');\n        }\n\n        if (!fs.existsSync(fileName)) {\n            return reject(`No such file, ${fileName}`);\n        }\n        </validateInput>\n\n        <initializeLevelParsing>\n        var level     = new Level();\n        var firstLine = false;\n        var reading   = '';\n        var contents  = '';\n        var bCount    = 0;\n        var bInfo     = [];\n        var rl        = readline.createInterface({\n            input: fs.createReadStream(fileName)\n        });\n        </initializeLevelParsing>\n\n        <parseLevelFile>\n        rl.on('line', line => {\n\n            <processFirstLine>\n            if (!firstLine) {\n                if (line === 'GRMAP001') return reject(`GMAPs aren't supported at the moment`);\n                if (line !== 'GLEVNW01') return reject(`This isn't a level file`);\n                firstLine = true;\n            }\n            </processFirstLine>\n\n            <processReadingSections>\n            else if (reading) {\n                if (line.startsWith(reading)) {\n                    if (reading === 'SIGNEND') {\n                        level.signs.last().text = contents.trim();\n                    } else if (reading === 'NPCEND') {\n                        level.npcs.last().text = contents.trim();\n                    } else if (reading === 'BADDYEND') {\n                        let baddy         = level.baddies.last();\n                        baddy.attackVerse = bInfo[0];\n                        baddy.hurtVerse   = bInfo[1];\n                        baddy.winVerse    = bInfo[2];\n\n                        bCount = 0;\n                        bInfo  = [];\n                    }\n\n                    contents = '';\n                    reading  = false;\n                } else {\n                    if (reading === 'BADDYEND') {\n                        bInfo.push(line);\n                        bCount++;\n                    } else {\n                        contents += `${line}\\n`;\n                    }\n                }\n            }\n            </processReadingSections>\n\n            <processBoard>\n            else if (line.startsWith('BOARD')) {\n                let [dataType, startX, startY, width, layerIndex, tilesData] = line.split(' ');\n\n                for (let i = 0; i < width * 2; i += 2) {\n                    let tileX = startX + i / 2;\n                    level.tiles.push(new Tile(tileX, startY, layerIndex, tilesData.substr(i, 2)));\n                }\n            }\n            </processBoard>\n\n            <processLink>\n            else if (line.startsWith('LINK')) {\n                let [dataType, targetLevel, sourceX, sourceY, width, height, targetX, targetY] = line.split(' ');\n\n                level.links.push(new Link(sourceX, sourceY, width, height, targetX, targetY, targetLevel));\n            }\n            </processLink>\n\n            <processChest>\n            else if (line.startsWith('CHEST')) {\n                let [dataType, x, y, item, signIndex] = line.split(' ');\n\n                level.chest.push(new Chest(x, y, item, signIndex));\n            }\n            </processChest>\n\n            <processSign>\n            else if (line.startsWith('SIGN')) {\n                let [dataType, x, y] = line.split(' ');\n\n                level.signs.push(new Sign(x, y));\n                reading = 'SIGNEND';\n            }\n            </processSign>\n\n            <processNPC>\n            else if (line.startsWith('NPC')) {\n                let [dataType, imageName, x, y] = line.split(' ');\n\n                level.npcs.push(new Npc(x, y, imageName, ''));\n                reading = 'NPCEND';\n            }\n            </processNPC>\n\n            <processBaddy>\n            else if (line.startsWith('BADDY')) {\n                let [dataType, x, y, type] = line.split(' ');\n\n                level.baddies.push(new Baddy(x, y, type));\n                reading = 'BADDYEND';\n            }\n            </processBaddy>\n\n            <handleUnknownLine>\n            else {\n                throw new Error(`Can't read line, ${line}`);\n            }\n            </handleUnknownLine>\n        });\n        </parseLevelFile>\n\n        <finaliseLevelParsing>\n        rl.on('close', () => {\n            resolve(level);\n        });\n        </finaliseLevelParsing>\n    });\n}\n"], "```"]