[["makeRootDir", "\nfunction makeRootDir(dest, cwd, savedir, callback) { // Non-compliant: function handles filesystem manipulation and asynchronous execution.\n  <determineRoot>\n  let root = path.join(cwd, (savedir || ''), dest.split('/')[0]);\n  console.log('delete: ', root)\n  </determineRoot>\n\n  <removeDirectory>\n  let rm = 'if [ -e '+ root +' ]; then rm -rf ' + root + '; fi';\n  let removed = exec(rm, (error, stdout, stderr) => {\n    if (error !== null) throw ('[Error: makeRootDir:] ' + error);\n  }).on('close', () => {\n  </removeDirectory>\n    \n  <createDirectory>\n    let maked = exec('mkdir ' + root).on('close', () => {\n      return callback && callback();\n    });\n  </createDirectory>\n  });\n}\n"], ["getChildren", "\nfunction getChildren(ul, recursive) { // Compliant: function is responsible for traversing and collecting child elements.\n    var children = [];\n    ul.children().children(\"[id^='cd']\")\n      .each(function() {\n        var comment = $(this).data('comment');\n        if (recursive)\n          comment.children = getChildren($(this).find('#cl' + comment.id), true);\n        children.push(comment);\n      });\n    return children;\n}\n"], ["nodecat", "\nfunction nodecat(fileNames, options, callback) { // Non-compliant: function handles argument normalization, promises, and file concatenation.\n  <handleArgumentsAndPromises>\n  if (!callback && typeof options === 'function') {\n    callback = options;\n    options = null;\n  }\n  ...\n  try {\n    ...\n  } catch (err) {\n    ...\n  }\n  </handleArgumentsAndPromises>\n\n  <performConcatenation>\n  let errNodecat = null;\n  let inCleanup;\n  ...\n  let i = 0;\n  function catNext() {\n    ...\n  }\n  catNext();\n  </performConcatenation>\n\n  return undefined;\n}\n"], ["renderContent", "\nfunction renderContent(source, generator, context, options, cb) { // Compliant: function's single responsibility is rendering and processing templates.\n    ejs.renderFile(generator.templatePath(source), context, options, (err, res) => {\n        if (!err) {\n            cb(res);\n        } else {\n            generator.error(`Copying template ${source} failed. [${err}]`);\n        }\n    });\n}\n"], ["loadBatchStateFromDynamoDB", "\nfunction loadBatchStateFromDynamoDB(batch, context) { // Non-compliant: function includes both data loading and error handling from AWS DynamoDB.\n  <initializeAndDefine>\n  const task = this;\n  ...\n  </initializeAndDefine>\n\n  <dynamoDbOperations>\n  try {\n    ...  \n    return dynamoDBDocClient.get(getRequest).promise()\n      ...\n  } catch (err) {\n    ...\n  }\n  </dynamoDbOperations>\n}\n"], ["deeplyExtendPkg", "\nfunction deeplyExtendPkg(a, b) { // Compliant: function's purpose is to deeply extend package configurations.\n\tif(!a.resolutions) {\n\t\ta.resolutions = {};\n\t}\n\tutils.extend(a.resolutions, b.resolutions || {});\n    ...\n\tutils.extend(a.steal, b.steal, true);\n}\n"], ["setupAndLogging", "\n\tif ( this.logging.enabled ) console.time( 'OBJLoader2.Parser.parse' );\n\tthis.configure();\n\t...\n\t"], ["parseAndProcess", "\n    for ( var code, word = '', bufferPointer = 0, slashesCount = 0, i = 0; i < length; i++ ) {\n      ...\n    }\n\t"], ["this.finalizeParsing", "\n\tthis.finalizeParsing();\n\t"], ["logging", "\n\tif ( this.logging.enabled ) console.timeEnd(  'OBJLoader2.Parser.parse' );\n\t"], "}\n```"]