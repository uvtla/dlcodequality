[["wilddogObject", "\nfunction(wilddogRef) {\n<wilddogRefValidation>\n  if (Object.prototype.toString.call(wilddogRef) !== \"[object Object]\") {\n    throw new Error(\"wilddogRef must be an instance of Wilddog\");\n  }\n</wilddogRefValidation>\n<wilddogRefAssignment>\n  var _wilddogRef = wilddogRef;\n</wilddogRefAssignment>\n<refFunction>\n  this.ref = function() {\n    return _wilddogRef;\n  };\n</refFunction>\n<setFunction>\n  this.set = function(keyOrLocations, location) {\n    <inputValidation>\n    var locations;\n    if (typeof keyOrLocations === \"string\" && keyOrLocations.length !== 0) {\n      locations = {};\n      locations[keyOrLocations] = location;\n    } else if (typeof keyOrLocations === \"object\") {\n      if (typeof location !== \"undefined\") {\n        throw new Error(\"The location argument should not be used if you pass an object to set().\");\n      }\n      locations = keyOrLocations;\n    } else {\n      throw new Error(\"keyOrLocations must be a string or a mapping of key - location pairs.\");\n    }\n    </inputValidation>\n\n    <updateDataStructure>\n    var newData = {};\n    Object.keys(locations).forEach(function(key) {\n      validateKey(key);\n      var location = locations[key];\n      if (location === null) {\n        newData[key] = null;\n      } else {\n        validateLocation(location);\n        var geohash = encodeGeohash(location);\n        newData[key] = encodeWildGeoObject(location, geohash);\n      }\n    });\n    </updateDataStructure>\n\n    <wilddogRefUpdate>\n    return new RSVP.Promise(function(resolve, reject) {\n      function onComplete(error) {\n        if (error !== null) {\n          reject(\"Error: Wilddog synchronization failed: \" + error);\n        }\n        else {\n          resolve();\n        }\n      }\n      _wilddogRef.update(newData, onComplete);\n    });\n    </wilddogRefUpdate>\n  };\n</setFunction>\n<getFunction>\n  this.get = function(key) {\n    <validateKey>\n    validateKey(key);\n    </validateKey>\n    <wilddogRefRead>\n    return new RSVP.Promise(function(resolve, reject) {\n      _wilddogRef.child(key).once(\"value\", function(dataSnapshot) {\n        if (dataSnapshot.val() === null) {\n          resolve(null);\n        } else {\n          resolve(decodeWildGeoObject(dataSnapshot.val()));\n        }\n      }, function (error) {\n        reject(\"Error: Wilddog synchronization failed: \" + error);\n      });\n    });\n    </wilddogRefRead>\n  };\n</getFunction>\n<removeFunction>\n  this.remove = function(key) {\n    return this.set(key, null);\n  };\n</removeFunction>\n<queryFunction>\n  this.query = function(queryCriteria) {\n    return new GeoQuery(_wilddogRef, queryCriteria);\n  };\n</queryFunction>\n}\n"], ["carouselInitialization", "\nfunction () {\n  <eventBindings>\n  var carousel = this,\n      cssClass = carousel.CLASSES;\n  carousel.on(\"keydown\", carousel._keyboardEventHandler);\n  carousel.on(afterScrollEvent, syncNavigation);\n  carousel.on(itemAddedEvent, syncUi);\n  carousel.on(itemRemovedEvent, syncUi);\n  carousel.on(itemReplacedEvent, syncUi);\n  carousel.on(itemSelectedEvent, function () {\n      if (carousel._hasFocus) {\n          carousel.focus();\n      }\n  });\n  carousel.on(loadItemsEvent, syncUi);\n  carousel.on(allItemsRemovedEvent, function (ev) {\n      carousel.scrollTo(0);\n      syncNavigation.call(carousel);\n      syncPagerUi.call(carousel);\n  });\n  carousel.on(pageChangeEvent, syncPagerUi, carousel);\n  carousel.on(renderEvent, function (ev) {\n      if (carousel.get(\"selectedItem\") === null ||\n          carousel.get(\"selectedItem\") <= 0) { \n      carousel.set(\"selectedItem\", carousel.get(\"firstVisible\"));\n      }\n      syncNavigation.call(carousel, ev);\n      syncPagerUi.call(carousel, ev);\n      carousel._setClipContainerSize();\n      carousel.show();\n  });\n  carousel.on(\"selectedItemChange\", function (ev) {\n      setItemSelection.call(carousel, ev.newValue, ev.prevValue);\n      if (ev.newValue >= 0) {\n          carousel._updateTabIndex(\n                  carousel.getElementForItem(ev.newValue));\n      }\n      carousel.fireEvent(itemSelectedEvent, ev.newValue);\n  });\n  carousel.on(uiUpdateEvent, function (ev) {\n      syncNavigation.call(carousel, ev);\n      syncPagerUi.call(carousel, ev);\n  });\n  carousel.on(\"firstVisibleChange\", function (ev) {\n      if (!carousel.get(\"selectOnScroll\")) {\n          if (ev.newValue >= 0) {\n              carousel._updateTabIndex(\n                      carousel.getElementForItem(ev.newValue));\n          }\n      }\n  });\n  carousel.on(\"click\", function (ev) {\n      if (carousel.isAutoPlayOn()) {\n          carousel.stopAutoPlay();\n      }\n      carousel._itemClickHandler(ev);\n      carousel._pagerClickHandler(ev);\n  });\n  </eventBindings>\n  <focusEvents>\n  var focussedLi;\n  Event.onFocus(carousel.get(\"element\"), function (ev, obj) {\n      var target = Event.getTarget(ev);\n      if (target && target.nodeName.toUpperCase() == \"A\" &&\n          Dom.getAncestorByClassName(target, cssClass.NAVIGATION)) {\n          if (focussedLi) {\n              Dom.removeClass(focussedLi, cssClass.PAGE_FOCUS);\n          }\n          focussedLi = target.parentNode;\n          Dom.addClass(focussedLi, cssClass.PAGE_FOCUS);\n      } else {\n          if (focussedLi) {\n              Dom.removeClass(focussedLi, cssClass.PAGE_FOCUS);\n          }\n      }\n      obj._hasFocus = true;\n      obj._updateNavButtons(Event.getTarget(ev), true);\n  }, carousel);\n  Event.onBlur(carousel.get(\"element\"), function (ev, obj) {\n      obj._hasFocus = false;\n      obj._updateNavButtons(Event.getTarget(ev), false);\n  }, carousel);\n  </focusEvents>\n}\n"], ["countryCodeConversion", "\nfunction getAbbr(wofData) {\n  <getProperty>\n  const iso2 = getPropertyValue(wofData, 'wof:country');\n  </getProperty>\n  <isoCodeCheck>\n  if (iso2 !== false && iso3166.is2(iso2)) {\n    return iso3166.to3(iso2);\n  }\n  </isoCodeCheck>\n  return null;\n}\n"], ["umbralFilter", "\nfunction(sel) {\n  <lengthCheck>\n  if (!this.length) {\n    return this;\n  }\n  </lengthCheck>\n  <siblingFilter>\n  var el = this[0];\n  return u(array.filter.call(el.parentNode.children, function(child) {\n    return sel ? child !== el && u(child).is(sel) : child !== el;\n  }));\n  </siblingFilter>\n}\n"], ["arrayRemoveItem", "\nfunction (item) {\n  <findIndex>\n  var i = this.indexOf(item);\n  </findIndex>\n  <conditionalSpliceAndEmit>\n  if (!~i) return false;\n  this.source.splice(i, 1);\n  this._updateInfo();\n  this.emit(\"remove\", item, i);\n  this.emit(\"update\", { remove: [item] });\n  </conditionalSpliceAndEmit>\n  return item;\n}\n"], ["preloadConfigSetup", "\nfunction () {\n  <configSet>\n  this.setConfig({components: this.preload});\n  </configSet>\n  <preloadComponents>\n  var preload = this.getConfig().components;\n  if (preload != undefined) {\n    this.setComponents(preload);\n  }\n  </preloadComponents>\n  return this;\n}\n"], ["ipRetrieval", "\nfunction ip() {\n  <networkInterfaceAcquisition>\n  let network = os.networkInterfaces(),\n      keys = Object.keys(network),\n      ips = [];\n  </networkInterfaceAcquisition>\n  <ipCollection>\n  for (let key of keys) {\n      network[key].forEach(ip => {\n          ip.family === 'IPv4' && !ip.internal && ips.push(ip.address);\n      });\n  }\n  </ipCollection>\n  return ips.length ? ips[0] : '127.0.0.1';\n}\n"], ["apiBlueprintResourceBuilder", "\nfunction build(data) {\n  <resourceStructureCreation>\n  const resources = resources_1.ResourcesStructure.create();\n  </resourceStructureCreation>\n  <annotationsStructureCreation>\n  const annotations = annotations_1.AnnotationsStructure.create();\n  </annotationsStructureCreation>\n  <dataTraversal>\n  data.content[0].content.forEach((content) => {\n    if (content.element === 'annotation') {\n      annotations.add(content.content);\n      return;\n    }\n    <resourceAddition>\n    const resource = resources.createResource(content.attributes.href.content);\n    </resourceAddition>\n    <transitionBuilding>\n    content.content.forEach((transition_data) => {\n      const transition = resource.createTransition(transition_data);\n      </transitionBuilding>\n      <httpTransactionBuilding>\n      transition_data.content.forEach((http_transaction_data) => {\n        const http_transaction = transition.createHttpTransaction();\n        http_transaction.setHttpRequest(http_transaction.createHttpRequest(http_transaction_data.content[0]));\n        http_transaction.setHttpResponse(http_transaction.createHttpResponse(http_transaction_data.content[1]));\n        transition.addHttpTransaction(http_transaction);\n      });\n      </httpTransactionBuilding>\n      resource.addTransition(transition);\n    });\n    resources.add(resource);\n  });\n  </dataTraversal>\n  return resources;\n}\n"], ["notifierClosingFunction", "\nfunction(that) {\n  <notifiersLoop>\n  var mNotifiers = that.getNotifiers();\n  for (var i = 0; i < mNotifiers.length; i++) {\n    var oNotifier = mNotifiers[i];\n    oNotifier._oCallout.close();\n  }\n  </notifiersLoop>\n  <messageNotifierClose>\n  if (that.getMessageNotifier()) {\n    that.getMessageNotifier()._oCallout.close();\n  }\n  </messageNotifierClose>\n}\n"], ["reducerToAggregateMapping", "\nfunction make_reducer_agg(target_field, reducer, arg) {\n  <reducerLookup>\n  if (! _.has(REDUCERS_TO_ES_AGGRS, reducer)) {\n    return null;\n  }\n  var aggr_name = REDUCERS_TO_ES_AGGRS[reducer];\n  </reducerLookup>\n  <aggregationDefinition>\n  var aggr = {};\n  aggr[aggr_name] = { field: arg };\n  </aggregationDefinition>\n  return [ target_field, aggr ];\n}\n"], "```\n\nAnnotations are added to each function to identify areas of distinct responsibilities within the functions. As per the SRP, responsibilities are grouped to avoid over-segmentation, with tags placed before and after coherent blocks of code serving specific, identifiable purposes within the functions."]