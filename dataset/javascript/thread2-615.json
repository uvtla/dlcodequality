[["businessRuleApplication", "\nfunction (changed, previous, events, command, callback) {\n\n    var self = this;\n    var callbacked = false;\n\n    <handleErrorDeclaration>\n    function handleError (err) {\n      debug(err);\n\n      if (_.isString(err)) {\n        if (_.isEmpty(err)) {\n          err = self.description;\n        }\n        err = new BusinessRuleError(err);\n      } else if (err instanceof BusinessRuleError) {\n        \n      } else {\n        err = new BusinessRuleError(err.message || self.description);\n      }\n\n      callbacked = true;\n      callback(err);\n    }\n    </handleErrorDeclaration>\n\n    try {\n      if (this.businessRuleFn.length === 5) {\n        this.businessRuleFn(changed, previous, events, command, function (err) {\n          if (err) {\n            return handleError(err);\n          }\n          callbacked = true;\n          callback(null);\n        });\n      } else {\n        var err = this.businessRuleFn(changed, previous, events, command);\n        if (err) {\n          return handleError(err);\n        }\n        callbacked = true;\n        callback(null);\n      }\n    } catch (err) {\n      if (!callbacked) {\n        return handleError(err);\n      }\n      throw err;\n    }\n  }\n"], ["renderFunction", "\nfunction() {\n      var _vm = this;\n      var _h = _vm.$createElement;\n      var _c = _vm._self._c || _h;\n      return _c(\n        \"div\",\n        {\n          staticClass: \"btn-toolbar\",\n          attrs: { \"aria-role\": _vm.ariaRole, \"aria-label\": _vm.ariaLabel }\n        },\n        [_vm._t(\"default\")],\n        2\n      )\n    }\n"], ["writeApiResponse", "\nfunction(req, res) {\n\t\treturn api.writeResponse(200, res, null, {\n\t\t\tCanAddUsers: canAddUsers(options), \n\t\t\tForceEmail: Boolean(options.configParams.get(\"orion.auth.user.creation.force.email\")), \n\t\t\tRegistrationURI:options.configParams.get(\"orion.auth.registration.uri\") || undefined});\n\t}\n"], ["initializeBlockInput", "\nfunction() {\n    this.setHelpUrl(Blockly.Msg.COLOUR_RGB_HELPURL);\n    this.setColour(Blockly.Blocks.colour.HUE);\n    this.appendValueInput('RED')\n        .setCheck('Number')\n        .setAlign(Blockly.ALIGN_RIGHT)\n        .appendField(Blockly.Msg.COLOUR_RGB_TITLE)\n        .appendField(Blockly.Msg.COLOUR_RGB_RED);\n    this.appendValueInput('GREEN')\n        .setCheck('Number')\n        .setAlign(Blockly.ALIGN_RIGHT)\n        .appendField(Blockly.Msg.COLOUR_RGB_GREEN);\n    this.appendValueInput('BLUE')\n        .setCheck('Number')\n        .setAlign(Blockly.ALIGN_RIGHT)\n        .appendField(Blockly.Msg.COLOUR_RGB_BLUE);\n    this.setOutput(true, 'Colour');\n    this.setTooltip(Blockly.Msg.COLOUR_RGB_TOOLTIP);\n  }\n"], ["linkParentAndPrototype", "\nfunction linkParent(original, branch, parentPayload, nextPayload)\n{  \n  var normalized = normalize(branch);\n\n  var result = original(branch, parentPayload, nextPayload);\n  \n  if (normalized)\n  {\n    result.__proto__[normalized] = parentPayload;\n  }\n  \n  if (parentPayload.user)\n  {\n    result.__proto__['user'] = parentPayload.user;\n  }\n\n  return result;\n}\n"], ["jobFileCreation", "\nfunction makeJobFile(config) {\n  var job = {\"espruino\":{}};\n  \n  <collectArguments>\n  for (var key in args) {\n    switch (key) {\n      case 'job': \n      case 'espruinoPrefix':\n      case 'espruinoPostfix':\n        break;\n      default: job[key] = args[key];  \n    }\n  }\n  </collectArguments>\n\n  <mergeConfigurations>\n  for (var k in config) { if (typeof config[k]!=='function') job.espruino[k] = config[k]; };\n  </mergeConfigurations>\n  \n  var jobFile = isNextValidJS(args.file) ? args.file.slice(0,args.file.lastIndexOf('.'))+'.json' : \"job.json\";\n\n  <fileHandling>\n  if (!fs.existsSync(jobFile)) {\n    log(\"Creating job file \"+JSON.stringify(jobFile));\n    fs.writeFileSync(jobFile,JSON.stringify(job,null,2),{encoding:\"utf8\"});\n  } else\n    log(\"WARNING: File \"+JSON.stringify(jobFile)+\" already exists - not overwriting.\");\n  </fileHandling>\n}\n"], ["FormatQRYFunction", "\nfunction FormatQRY(query) { \n\t\t\t\t\t\tvar R = '', Q = query; switch(true) {\n\t\t\t\t\t\t\tcase THS.QisFunction: return CleanQRY(Q.toString());\n\t\t\t\t\t\t\tcase THS.QisArray: return Q.join(\"\\n\").replace(\"\\t\",\"\");\n\t\t\t\t\t\t\tdefault: return R;\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n"], ["addRecordStore", "\nfunction (cfg) {\n            this.log(\"addRecordStore\");\n            var lrs;\n            if (cfg instanceof TinCan.LRS) {\n                lrs = cfg;\n            }\n            else {\n                lrs = new TinCan.LRS (cfg);\n            }\n            this.recordStores.push(lrs);\n        }\n"], ["addAjvKeywordsImplementation", "\nfunction addAjvKeywords() {\n  <addIndividualKeywords>\n  addAjvKeyword.call(this, 'validateAsync');\n  addAjvKeyword.call(this, 'itemsSerial', 'array');\n  this._evalKeywords.objectToAsync = util.objectToPromise;\n  this._evalKeywords.valueToAsync = util.toPromise;\n  addAjvKeyword.call(this, 'objectToAsync', 'object', true);\n  addAjvKeyword.call(this, 'valueToAsync', undefined, true);\n  </addIndividualKeywords>\n  this.ajv.addKeyword('resolvePendingRefs', {\n    validate: evaluationKeywords.resolvePendingRefs,\n    schema: false\n  });\n  this.ajv.addKeyword('expandJsMacro', {\n    compile: compileExpandJsMacro\n  });\n}\n"], ["validateRouteConfig", "\nfunction (config) {\n        if (typeof config !== 'object') {\n            throw new Error('Invalid Route Config');\n        }\n        if (typeof config.route !== 'string') {\n            var name_1 = config.name || '(no name)';\n            throw new Error('Invalid Route Config for \"' + name_1 + '\": You must specify a \"route:\" pattern.');\n        }\n        if (!('redirect' in config || config.moduleId || config.navigationStrategy || config.viewPorts)) {\n            throw new Error('Invalid Route Config for \"' + config.route + '\": You must specify a \"moduleId:\", \"redirect:\", \"navigationStrategy:\", or \"viewPorts:\".');\n        }\n    }\n"], "```"]