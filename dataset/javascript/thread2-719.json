[["localizationLookup", "\nfunction(key, args, fallbackString) {\n    <parseKey>\n    var index = key.lastIndexOf(\".\");\n    var prop = gTextProp;\n    if (index > 0) {\n        prop = key.substr(index + 1);\n        key = key.substring(0, index);\n    }\n    </parseKey>\n\n    <prepareFallback>\n    var fallback;\n    if (fallbackString) {\n        fallback = {};\n        fallback[prop] = fallbackString;\n    }\n    </prepareFallback>\n\n    <retrieveLocalizedData>\n    var data = getL10nData(key, args, fallback);\n    if (data && prop in data) {\n        return data[prop];\n    }\n    </retrieveLocalizedData>\n\n    return \"{{\" + key + \"}}\";\n}\n"], ["extractDigits", "\nfunction(str) {\n    var data = [];\n    str = str.toString();\n    for(var x = 0; x < str.length; x++) {\n        if(str[x].match(/^\\d*$/g)) {\n            data.push(str[x]);    \n        }\n    }\n    return data;\n}\n"], ["selectNearestOption", "\nfunction getNearest($select, value) {\n    var delta = {};\n    <calculateOptionDistances>\n    angular.forEach($select.children('option'), function(opt, i){\n      var optValue = angular.element(opt).attr('value');\n      if(optValue === '') return;\n      var distance = Math.abs(optValue - value); \n      if(typeof delta.distance === 'undefined' || distance < delta.distance) {\n        delta = {value: optValue, distance: distance};\n      } \n    });\n    </calculateOptionDistances>\n    return delta.value;\n}\n"], ["decodeBase64", "\nfunction decode_base64(salt) {\n    <initDecodedArray>\n    var decoded = new Array(16);\n    var i = 0, j = 0, c1, c2;\n    </initDecodedArray>\n    <decodeLoop>\n    while(true) {\n        <decodeBlock>\n        c1 = index_64[salt.charCodeAt(i++)-46];\n        c2 = index_64[salt.charCodeAt(i++)-46];\n        decoded[j++] = (c1 << 2 | c2 >> 4) & 0xff;\n        if (i === 22) break;\n        \n        c1 = c2 << 4;\n        c2 = index_64[salt.charCodeAt(i++)-46];\n        decoded[j++] = (c1 | c2 >> 2) & 0xff;\n\n        c1 = c2 << 6;\n        c2 = index_64[salt.charCodeAt(i++)-46];\n        decoded[j++] = (c1 | c2) & 0xff;\n        </decodeBlock>\n    }\n    </decodeLoop>\n    return decoded;\n}\n"], ["loadCredentials", "\nfunction loadFromPath(path) {\n    this.clear();\n    <parseOptions>\n    var options = JSON.parse(AWS.util.readFileSync(path));\n    var fileSystemCreds = new AWS.FileSystemCredentials(path);\n    </parseOptions>\n    <setupCredentialsChain>\n    var chain = new AWS.CredentialProviderChain();\n    chain.providers.unshift(fileSystemCreds);\n    chain.resolve(function (err, creds) {\n      if (err) throw err;\n      else options.credentials = creds;\n    });\n    </setupCredentialsChain>\n    this.constructor(options);\n    return this;\n}\n"], ["initializeServer", "\nfunction Server(server){\n  <setupEmitter>\n  Emitter.Target.call(this,emitter);\n  </setupEmitter>\n\n  <storeServerReference>\n  this[srv] = server;\n  </storeServerReference>\n  \n  <executePlugins>\n  plugins.give('server',this);\n  </executePlugins>\n}\n"], ["wrappedOperation", "\nfunction operation(cm1, f) {\n    return function() {\n      var cm = cm1 || this, withOp = !cm.curOp;\n      if (withOp) <startOperation>startOperation(cm);</startOperation>\n      try { var result = f.apply(cm, arguments); }\n      finally { if (withOp) <endOperation>endOperation(cm);</endOperation> }\n      return result;\n    };\n}\n"], ["serializeNode", "\nfunction stringifyNode(node){\n    var result = \"<\"+node.nodeName;\n    <accumulateAttributes>\n    var numAttrs = node.attrs.length;\n    for (var i=0; i<numAttrs; i++){\n        result += \" \"+ node.attrs[i].name +'=\"'+ node.attrs[i].value +'\"';\n    }\n    </accumulateAttributes>\n    result += \">\";\n    return result;\n}\n"], ["setAttribute", "\nfunction elementAttribute(index, name, value, sanitizer) {\n    <attributeChangeLogic>\n    if (value !== NO_CHANGE) {\n        <loadElement>\n        var element_1 = loadElement(index);\n        </loadElement>\n\n        <applyAttributeUpdate>\n        if (value == null) {\n            ngDevMode && ngDevMode.rendererRemoveAttribute++;\n            isProceduralRenderer(renderer) ? renderer.removeAttribute(element_1.native, name) :\n                element_1.native.removeAttribute(name);\n        }\n        else {\n            ngDevMode && ngDevMode.rendererSetAttribute++;\n            var strValue = sanitizer == null ? stringify$1(value) : sanitizer(value);\n            isProceduralRenderer(renderer) ? renderer.setAttribute(element_1.native, name, strValue) :\n                element_1.native.setAttribute(name, strValue);\n        }\n        </applyAttributeUpdate>\n\n    }\n    </attributeChangeLogic>\n}\n"], ["copyImageData", "\nfunction copyImageDataWithCanvas(imageData) {\n    <createCanvas>\n    const canvas = new Canvas(imageData.width, imageData.height);\n    </createCanvas>\n\n    <getContextAndPutImageData>\n    const ctx = canvas.getContext('2d');\n    ctx.putImageData(imageData, 0, 0);\n    </getContextAndPutImageData>\n\n    <getImageDataFromCanvas>\n    return ctx.getImageData(0, 0, imageData.width, imageData.height);\n    </getImageDataFromCanvas>\n}\n"], "```\n\nEach function is annotated with tags that represent distinct responsibilities. These tags are applied to coherent blocks of code that serve specific tasks or purposes within the functions."]