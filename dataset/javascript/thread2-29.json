[["parseKey", "\nfunction parseKey(e) {\n  <checkModifierKeys>\n  if (e.ctrlKey || e.metaKey) {\n    return true;\n  }\n  </checkModifierKeys>\n  shift_down = e.shiftKey ? true : false;\n  var nudge = shift_down ? 10 : 1;\n\n  switch (e.keyCode) {\n  case 37:\n    doNudge(e, -nudge, 0);\n    break;\n  case 39:\n    doNudge(e, nudge, 0);\n    break;\n  case 38:\n    doNudge(e, 0, -nudge);\n    break;\n  case 40:\n    doNudge(e, 0, nudge);\n    break;\n  case 27:\n    <handleEscapeKey>\n    if (options.allowSelect) Selection.release();\n    </handleEscapeKey>\n    break;\n  case 9:\n    return true;\n  }\n\n  return false;\n}\n"], ["formatStack", "\nfunction formatStack(stack, options) {\n  var newStack = []\n    , lineFormatter = options.lineFormatter || defaultFormatter\n    , line\n    , i, l, j, m\n\n  <splitErrorStack>\n  stack = stack.split('\\n')\n  </splitErrorStack>\n\n  for (i=0, l=stack.length; i<l; i++) {\n    <formatAndFilterStackLines>\n    line = lineFormatter(stack[i], {colors: options.colors})\n    for (j=0, m=options.filter.length; j<m; j++) {\n      if (line && line.indexOf(options.filter[j]) !== -1) {\n        line = null\n        break\n      }\n    }\n    if (line) {\n      newStack.push(line)\n    }\n    </formatAndFilterStackLines>\n  }\n  return newStack.join('\\n')\n}\n"], ["readNewMessages", "\nfunction readNewMessages(state) {\n  \n  <checkIfStateClosed>\n  if (state.closed) return Promise.resolve();\n  </checkIfStateClosed>\n\n  <checkIfMessagesCallbackExists>\n  if (!state.messagesCallback) return Promise.resolve();\n  </checkIfMessagesCallbackExists>\n\n  <getMessagesHigherThenProcessAndCallback>\n  return getMessagesHigherThen(state.db, state.lastCursorId).then(function (newerMessages) {\n    var useMessages = newerMessages.map(function (msgObj) {\n      if (msgObj.id > state.lastCursorId) {\n        state.lastCursorId = msgObj.id;\n      }\n\n      return msgObj;\n    }).filter(function (msgObj) {\n      return _filterMessage(msgObj, state);\n    }).sort(function (msgObjA, msgObjB) {\n      return msgObjA.time - msgObjB.time;\n    });\n\n    useMessages.forEach(function (msgObj) {\n      if (state.messagesCallback) {\n        state.eMIs.add(msgObj.id);\n        state.messagesCallback(msgObj.data);\n      }\n    });\n    return Promise.resolve();\n  });\n  </getMessagesHigherThenProcessAndCallback>\n}\n"], ["anonymousStoreFunction", "\nfunction(storeName, cb) {\n    var result;\n    <initiateTransactionAndStore>\n    var transaction = this.transaction(storeName, MODE.READ_WRITE, result, cb);\n    var store = this.store(storeName, transaction, cb);\n    </initiateTransactionAndStore>\n    var request;\n    try {\n      <clearStore>\n      request = store.clear();\n      </clearStore>\n    } catch (err) {\n      <handleErrorCallback>\n      if (isFunction(cb)) return cb(err);\n      </handleErrorCallback>\n    }\n    <requestOnSuccess>\n    request.onsuccess = function(event) {\n      result = event.target.result;\n    };\n    </requestOnSuccess>\n    <requestOnError>\n    request.onerror = function(event) {\n      if (isFunction(cb)) return cb(event.target.error);\n    };\n    </requestOnError>\n  }\n"], ["getValidLEDResult", "\nfunction(ledName) {\n  var result = this.isValidLEDName(ledName) ? tessel.port[this.validLEDNames.indexOf(ledName)] : null;\n\n  return result;\n}\n"], ["uploadFile", "\nfunction uploadFile(endpoint, releaseVersion, filePath) {\n  \n  <constantDefinitions>\n  var IGNORE_DOMAIN = '~';\n  var staticBase = process.env.STATIC_BASE;\n  var IGNORE_PATH = staticBase ? url.parse(staticBase).path + '/' : '';\n  var CONFLICT_CODE = 409;\n  </constantDefinitions>\n\n  <parseFilePath>\n  var fileData = path.parse(filePath);\n  </parseFilePath>\n  <prepareFileNameAndPathForSentry>\n  var fileName = fileData.name + fileData.ext;\n  var sentryFilePath = IGNORE_DOMAIN + IGNORE_PATH + fileName;\n  </prepareFileNameAndPathForSentry>\n\n  <uploadProcess>\n  return new Promise(function(resolve, reject) {\n    superagent\n      .post(endpoint)\n      .set(HEADERS)\n      .attach('file', filePath)\n      .field('name', sentryFilePath)\n      .end(function(err, res) {\n        if (!err) {\n          console.log('Sentry (release: ' + releaseVersion +\n            ') - Successfully uploaded ' + fileName);\n          resolve();\n        } if (err && err.response && err.response.statusCode === CONFLICT_CODE) {\n          console.log('Sentry (' + releaseVersion + ') - ' + fileName +\n            ' already exists.');\n          resolve();\n        } else {\n          reject(err);\n        }\n      });\n  });\n  </uploadProcess>\n}\n"], ["removeComments", "\nfunction removeComments() {\n\n  var commentNodes = [];\n\n  <recursiveCommentSearch>\n  function searchForComment(node) {\n    if(node.type == 'comment') {\n      commentNodes.push(node);\n    }\n    if(!_(node.children).isUndefined()) {\n      _.each(node.children, searchForComment);\n    }\n  }\n  </recursiveCommentSearch>\n  \n  <removeCommentNodes>\n  searchForComment($._root);\n  _.each(commentNodes, function(node) {\n    $(node).remove();\n  });\n  </removeCommentNodes>\n}\n"], ["serve", "\nfunction serve(server, req, callback) {\n\t<sourceGetTile>\n\tsource.getTile(req.z, req.x, req.y, function(err, buffer) {\n\t\tif (err) return callback(err);\n\t\tvar headers = {'Content-Type': 'application/x-protobuf'};\n\t\tif (options.compression === 'gzip') {\n\t\t\theaders['Content-Encoding'] = 'gzip';\n\t\t}\n\t\tcallback(null, buffer, headers);\n\t});\n\t</sourceGetTile>\n}\n"], ["handleProgress", "\nfunction handleProgress( e )\n  {\n    <logReminder>\n    console.debug( 'REMINDER : implement handleProgress' );\n    </logReminder>\n    \n    <checkLengthComputableAndOnProgress>\n    if( e.lengthComputable )\n    if( o.onProgress )\n    _.Consequence.Take( o.onProgress,\n    {\n      progress : e.loaded / e.total,\n      options : o,\n    });\n    </checkLengthComputableAndOnProgress>\n  }\n"], ["webhook", "\nfunction webhook() {\n  var opts = {\n    validate: true,\n  };\n\n  <parseArguments>\n  var tokenString;\n  for (var i = 0, l = arguments.length; i < l; i++) {\n    var arg = arguments[i];\n    if (typeof arg === 'string') {\n      tokenString = arg;\n    } else {\n      opts = _.extend(opts, arg);\n    }\n  }\n  </parseArguments>\n\n  <setAuthToken>\n  opts.authToken = tokenString ? tokenString : process.env.TWILIO_AUTH_TOKEN;\n  </setAuthToken>\n\n  <validateRequest>\n  return function hook(request, response, next) {\n    \n    if (opts.validate) {\n      \n      if (!opts.authToken) {\n        <handleMissingAuthToken>\n        console.error('[Twilio]: Error - Twilio auth token is required for webhook request validation.');\n        response.type('text/plain')\n          .status(500)\n          .send('Webhook Error - we attempted to validate this request without first configuring our auth token.');\n        </handleMissingAuthToken>\n      } else {\n        <actualValidation>\n        var valid = validateExpressRequest(request, opts.authToken, {\n          url: opts.url,\n          host: opts.host,\n          protocol: opts.protocol\n        });\n\n        if (valid) {\n            next();\n        } else {\n          return response\n            .type('text/plain')\n            .status(403)\n            .send('Twilio Request Validation Failed.');\n        }\n        </actualValidation>\n      }\n    } else {\n      next();\n    }\n  };\n  </validateRequest>\n}\n"], "```\n\nAll functions are annotated with tags to highlight the distinct responsibilities they contain. This helps determine whether they comply with the Single Responsibility Principle (SRP) or if they contain multiple responsibilities."]