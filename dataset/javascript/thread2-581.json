[["eventAssociationAndErrorLogging", "\nfunction(sortedInputEvents, protoIRs) {\n      var handledEvents = [];\n      protoIRs.forEach(function(protoIR) {\n        protoIR.associatedEvents.forEach(function(event) {\n          if (handledEvents.indexOf(event) >= 0) {\n            console.error('double-handled event', event.typeName, parseInt(event.start), parseInt(event.end), protoIR);\n            return;\n          }\n          handledEvents.push(event);\n        });\n      });\n\n      sortedInputEvents.forEach(function(event) {\n        if (handledEvents.indexOf(event) < 0) {\n          console.error('UNHANDLED INPUT EVENT!', event.typeName, parseInt(event.start), parseInt(event.end));\n        }\n      });\n    }\n"], ["viewInitialization", "\nfunction view(template, options = {}) {\n\n\tif(!template) {\n\t\tthrow new Exception('Please pass a template!');\n\t}\n\n\treturn Class => {\n\n\t\tlet renderedFlag = !(options.renderedFlag === false);\n\n\t\t<coreAndViewMapsInit>\n\t\tinitCoreMap(storage, Class);\n\t\tinitViewMap(storage, Class);\n\t\t</coreAndViewMapsInit>\n\n\t\tlet map = storage.get(Class);\n\n\t\t\n\t\tif(map.get('@view').get('callbacksDefined')){\n\t\t\treturn;\n\t\t}\n\n\t\tmap.get('@callbacks').get('created').push((domNode, createVars = {}) => {\n\n\t\t\t<domAttributesExtraction>\n\t\t\tlet domViewAttributes = extractDomProperties(domNode, /^@view\\.bind\\.(\\S+)$/i, true);\n\t\t\tlet regularDomAttributes = extractDomProperties(domNode);\n\t\t\t</domAttributesExtraction>\n\n\t\t\t<viewBindsPreparation>\n\t\t\tlet viewBinds = {};\n\t\t\tlet entries = map.get('@view').get('bind');\n\t\t\tentries.forEach(([key, value]) => viewBinds[key] = value);\n\n\t\t\tlet viewVars = Object.assign({},\n\t\t\t\tviewBinds,\n\t\t\t\tdomViewAttributes,\n\t\t\t\tcreateVars,\n\t\t\t\tregularDomAttributes\n\t\t\t);\n\t\t\t</viewBindsPreparation>\n\n\t\t\t<viewInstantiation>\n\t\t\tlet $view = new View({\n\t\t\t\tprerenderer: HandlebarsRuntime.template,\n\t\t\t\trootNode: domNode,\n\t\t\t\tvars: viewVars,\n\t\t\t\ttemplate: template,\n\t\t\t});\n\t\t\t</viewInstantiation>\n\n\t\t\t<viewHelpersRegistration>\n\t\t\tview.helper.registerSetGet(\n\t\t\t\tdomNode,\n\t\t\t\tObject.assign({}, viewBinds, domViewAttributes)\n\t\t\t);\n\t\t\t</viewHelpersRegistration>\n\n\t\t\t<viewRendering>\n\t\t\t$view.render(null, {\n\t\t\t\trenderedFlag: renderedFlag,\n\t\t\t});\n\t\t\t</viewRendering>\n\n\t\t\tdomNode.$view = $view;\n\t\t});\n\n\t\tmap.get('@callbacks').get('attached').push(domNode => {\n\n\t\t\tif(domNode.$view.initialized()){\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t<viewReinitialization>\n\t\t\tdomNode.$view.reinit({\n\t\t\t\trootNode: domNode,\n\t\t\t\tprerenderer: HandlebarsRuntime.template,\n\t\t\t});\n\t\t\t</viewReinitialization>\n\t\t});\n\n\t\tmap.get('@callbacks').get('detached').push(domNode => {\n\t\t\t<viewDestruction>\n\t\t\tdomNode.$view.destroy();\n\t\t\t</viewDestruction>\n\t\t});\n\n\t\tmap.get('@view').set('callbacksDefined', true);\n\t}\n}\n"], ["tagExtractionAndModifierCreation", "\nfunction(name, context){\n  var cls = context.cls;\n  var domline = context.domline;\n  var headingType = /(?:^| )heading:([A-Za-z0-9]*)/.exec(cls);\n  var tagIndex;\n  \n  if (headingType) tagIndex = _.indexOf(tags, headingType[1]);\n  \n  if (tagIndex !== undefined && tagIndex >= 0){\n    \n    var tag = tags[tagIndex];\n    <modifierConfiguration>\n    var modifier = {\n      preHtml: '<' + tag + '>',\n      postHtml: '</' + tag + '>',\n      processedMarker: true\n    };\n    </modifierConfiguration>\n    return [modifier];\n  }\n  return [];\n}\n"], ["assemblyAndInitialization", "\nfunction Assemble(options) {\n  if (!(this instanceof Assemble)) {\n    return new Assemble(options);\n  }\n  Core.call(this, options);\n  this.is('assemble');\n  this.initAssemble();\n}\n"], ["objectParsing", "\nfunction parseObject(obj){\n  var ret = { base: {} };\n\n  forEach(objectKeys(obj), function(name){\n    merge(ret, name, obj[name]);\n  });\n\n  return compact(ret.base);\n}\n"], ["renderLayoutOrReturnNull", "\nfunction () {\n            var meta   = getOrDefault( this, 'props.meta', {} )\n              , fields = meta.fields;\n\n            if ( !t.isDefined( fields ) ) \n                return null;\n            else \n                return this.renderLayout( meta.layout.grid );\n        }\n"], ["eventEmitting", "\nfunction(name) {\n        var length = arguments.length;\n        var args = new Array(length - 1);\n\n        for (var i = 1; i < length; i++) {\n          args[i - 1] = arguments[i];\n        }\n\n        sendEvent(this, name, args);\n      }\n"], ["plotLinePathCalculation", "\nfunction (from, to) {\n\n\t\tvar toPath = this.getPlotLinePath(to),\n\t\t\tpath = this.getPlotLinePath(from);\n\t\t\t\n\t\tif (path && toPath) {\n\t\t\tpath.push(\n\t\t\t\ttoPath[4],\n\t\t\t\ttoPath[5],\n\t\t\t\ttoPath[1],\n\t\t\t\ttoPath[2]\n\t\t\t);\n\t\t} else { \n\t\t\tpath = null;\n\t\t}\n\t\t\n\t\treturn path;\n\t}\n"], ["indexRetrieval", "\nfunction getIndexOf(string, find) {\n    \n    if(XRegExp.isRegExp(find)) {\n      return string.search(find);\n    } else {\n      \n      return string.indexOf(find);\n    }\n  }\n"], ["listAddition", "\nfunction checkAdd(list, key, func) {\n    list.push({key: key, func: func});\n  }\n"], "```\n\nAnnotations are applied to each function, designating blocks of code that represent specific responsibilities within the function, in compliance or violation of the Single Responsibility Principle. Simple variable assignments and returns are not considered separate responsibilities, while coherent sections of the function that achieve specific tasks are annotated accordingly."]