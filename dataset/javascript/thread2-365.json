[["setConfigurationAndOptions", "\nfunction setConfigurationAndOptions(pcConfig) {\n\t\n\tthis.pcConfig = merge(true, pcConfig);\n\n\t<fixPeerConnectionConfig>\n\tAdapter.fixPeerConnectionConfig(this.pcConfig);\n\t</fixPeerConnectionConfig>\n\n\tthis.options = {\n\t\ticeTransportsRelay: (this.pcConfig.iceTransports === 'relay'),\n\t\ticeTransportsNone: (this.pcConfig.iceTransports === 'none'),\n\t\tgatheringTimeout: this.pcConfig.gatheringTimeout,\n\t\tgatheringTimeoutAfterRelay: this.pcConfig.gatheringTimeoutAfterRelay\n\t};\n\n\t<cleanupConfig>\n\tdelete this.pcConfig.gatheringTimeout;\n\tdelete this.pcConfig.gatheringTimeoutAfterRelay;\n\t</cleanupConfig>\n\n\tdebug('setConfigurationAndOptions | processed pcConfig: %o', this.pcConfig);\n}\n"], ["cacher", "\nfunction cacher(f, scope, postprocessor) {\n\t<repushFunction>\n\tfunction repush(array, item) {\n\t\tfor (var i = 0, ii = array.length; i < ii; i++)\n\t\t\tif (array[i] === item) {\n\t\t\t\treturn array.push(array.splice(i, 1)[0]);\n\t\t\t}\n\t}\n\t</repushFunction>\n\n\t<cachingFunction>\n\tfunction newf() {\n\t\tvar arg = Array.prototype.slice.call(arguments, 0),\n\t\t\targs = arg.join('\\u2400'),\n\t\t\tcache = newf.cache = newf.cache || {},\n\t\t\tcount = newf.count = newf.count || [];\n\t\tif (cache.hasOwnProperty(args)) {\n\t\t\trepush(count, args);\n\t\t\treturn postprocessor ? postprocessor(cache[args]) : cache[args];\n\t\t}\n\t\tif (count.length >= 1e3) {\n\t\t\tdelete cache[count.shift()];\n\t\t}\n\t\tcount.push(args);\n\t\tcache[args] = f.apply(scope, arg);\n\t\treturn postprocessor ? postprocessor(cache[args]) : cache[args];\n\t}\n\t</cachingFunction>\n\treturn newf;\n}\n"], ["alignTicksCondition", "\nfunction () {\n\tif (this.options.chart.alignTicks !== false) {\n\t\teach(this.axes, function (axis) {\n\t\t\t<adjustTickAmount>\n\t\t\taxis.adjustTickAmount();\n\t\t\t</adjustTickAmount>\n\t\t});\n\t}\n\tthis.maxTicks = null;\n}\n"], ["appendToData", "\nfunction(data){\n\tdata = data || {timestamps:[]};\n\tdata.timestamps.push(new Date().getTime());\n\t<sendPing>\n\tsend(connection, \"Ping\", data);\n\t</sendPing>\n}\n"], ["fromArray", "\nfunction fromArray(data){\n\t<validateData>\n\tvar self = this;\n\n\tif (!Array.isArray(data)){\n\t\tthrow new TypeError('The data argument should be an array of time series values.');\n\t}\n\t</validateData>\n\n\t<processSpikes>\n\tvar spikes = data\n\t\t.map(self.getValueY.bind(self))\n\t\t.map(self.filterDataItem.bind(self))\n\t\t.map(self.algorithm.bind(self, self.config.minPeakDistance))\n\t\t.map(commons.objectMapper.bind(self, data))\n\t\t.filter(commons.cleanEmptyElement.bind(null, self.config.transformedValueProperty));\n\t</processSpikes>\n\t<resolvePromise>\n\treturn new Promise(function(resolve) {\n\t\tresolve(spikes);\n\t});\n\t</resolvePromise>\n}\n"], ["publishAreaVisibility", "\nfunction publishAreaVisibility() {\n\t<calculateVisibility>\n\tconst showing = visibilityIsChanging ? !$scope.model.areaShowing : $scope.model.areaShowing;\n\t</calculateVisibility>\n\t<updateVisibility>\n\treturn visibility.updateAreaVisibility( { [ $scope.features.area.name ]: showing } );\n\t</updateVisibility>\n}\n"], ["normalize", "\nfunction normalize() {\n\t<calculateLength>\n\tvar d = this.length();\n\t</calculateLength>\n\t<setScale>\n\tif (d > 0) {\n\t\treturn this._set(this._x / d, this._y / d, this._z / d);\n\t}\n\t</setScale>\n\n\treturn this;\n}\n"], ["removeBlockSelection", "\nfunction(e) {\n\t<iterateBlocks>\n\tvar blocks = this.workspace_.getTopBlocks(false);\n\tfor (var i = 0, block; block = blocks[i]; i++) {\n\t\tblock.removeSelect();\n\t}\n\t</iterateBlocks>\n}\n"], ["sameArrayCheck", "\nfunction _same_array(one, two){\n\t<compareArraySize>\n\tvar retval = true;\n\tif( one.length != two.length ){\n\t\tretval = false;\n\t}else{\n\t</compareArraySize>\n\t\t<compareArrayElements>\n\t\tfor( var i = 0; i < one.length; i++ ){\n\t\t\tif( one[i] != two[i] ){\n\t\t\t\tretval = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t</compareArrayElements>\n\t}\n\treturn retval;\n}\n"], ["executeTestCallback", "\nfunction (test) {\n\t<checkCallback>\n\tif (test.callback) {\n\t\t<applyCallback>\n\t\ttest.callback.fn.apply(test.callback.scope, test.callback.args);\n\t\t</applyCallback>\n\t}\n\t</checkCallback>\n}\n"], ""]