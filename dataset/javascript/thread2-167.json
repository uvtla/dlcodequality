[["formatSql", "\nfunction formatSql(sqlText, options = {}) {\n    <buildCommandExecution>\n    let command = buildCommand(options);\n    \n    let formatted = child_process_1.execSync(command, {\n        encoding: \"utf8\",\n        input: sqlText\n    });\n    </buildCommandExecution>\n    return formatted;\n}\n"], ["generate", "\nfunction generate(schema) {\n  <validateSchema>\n  const ret = [];\n  if (!validate(schema)) {\n    return ret;\n  }\n  </validateSchema>\n\n  <generateValidSample>\n  const fullSample = jsf(schema);\n  if (!fullSample) {\n    return ret;\n  }\n\n  ret.push({\n    valid: true,\n    data: fullSample,\n    message: 'should work with all required properties'\n  });\n  </generateValidSample>\n\n  <generateSamples>\n  ret.push(...generateFromRequired(schema));\n  ret.push(...generateFromRequired(schema, false));\n  ret.push(...generateForTypes(schema));\n  </generateSamples>\n\n  return ret;\n}\n"], ["indexesOf", "\nfunction indexesOf(a, elt) {\n  <findIndexes>\n  var ret = [], index = 0;\n  while ((index = a.indexOf(elt, index)) !== -1) {\n    ret.push(index++);\n  }\n  </findIndexes>\n  return ret;\n}\n"], ["createTask", "\nfunction createTask(gulp, options, taskFile){\n    <prepareTask>\n\tvar fn;\n\tvar extension = path.extname(taskFile);\n\tvar filename = path.basename(taskFile, extension);\n\tvar task = require(taskFile)(gulp, options.data, loadGulpConfig.util, filename);\n    </prepareTask>\n\n    <registerTask>\n\tif(Array.isArray(task)){\n\t\tfn = isFunction(task[task.length - 1]) ? task.pop() : void(0);\n\t\tgulp.task(filename, task, fn);\n\t}else if(isString(task)){\n\t\tgulp.task(filename, [task]);\n\t}else if(isFunction(task)){\n\t\tgulp.task(filename, task);\n\t}else if(isExotic(task)){\n\t\tkeys(task).map(mapTaskObject.bind(this, filename, task)).forEach(function(task){\n\t\t\tif(task.cmds){\n\t\t\t\tif(isFunction(task.fn)){\n\t\t\t\t\tgulp.task(task.name, task.cmds, task.fn);\n\t\t\t\t}else{\n\t\t\t\t\tgulp.task(task.name, task.cmds);\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tgulp.task(task.name, task.fn);\n\t\t\t}\n\t\t});\n\t}\n    </registerTask>\n}\n"], ["mapHandling", "\nfunction(dx, dy, options) {\n        <applyDefaultOptions>\n        options = OpenLayers.Util.applyDefaults(options, {\n            animate: true,\n            dragging: false\n        });\n        </applyDefaultOptions>\n\n        <handleDragging>\n        if (options.dragging) {\n            if (dx != 0 || dy != 0) {\n                this.moveByPx(dx, dy);\n            }\n        } else {\n        </handleDragging>\n\n        <moveMap>\n            \n            var centerPx = this.getViewPortPxFromLonLat(this.getCachedCenter());\n            var newCenterPx = centerPx.add(dx, dy);\n\n            if (this.dragging || !newCenterPx.equals(centerPx)) {\n                var newCenterLonLat = this.getLonLatFromViewPortPx(newCenterPx);\n                if (options.animate) {\n                    this.panTo(newCenterLonLat);\n                } else {\n                    this.moveTo(newCenterLonLat);\n                    if(this.dragging) {\n                        this.dragging = false;\n                        this.events.triggerEvent(\"moveend\");\n                    }\n                }    \n            }\n        }        \n</moveMap>\n"], ["requireInFrame", "\nasync function requireInFrame(tabId, frameId, modules) {\n    <getActiveTabId>\n\tif (typeof tabId !== 'number') { tabId = (await getActiveTabId()); }\n\t</getActiveTabId>\n\n    <requireModules>\n\treturn (await Frame.get(tabId, frameId || 0)).request('require', modules);\n    </requireModules>\n}\n"], ["_same_hash", "\nfunction _same_hash(hash1, hash2){\n    <compareHashes>\n\tvar same_p = true;\n\tfor( var k1 in hash1 ){\n\t    if( typeof hash2[k1] === 'undefined' ||\n\t\thash1[k1] !== hash2[k1] ){\n\t\tsame_p = false;\n\t\tbreak;\n\t    }\n\t}\n\tif( same_p ){\n\t    for( var k2 in hash2 ){\n\t\tif( typeof hash1[k2] === 'undefined' ||\n\t\t    hash2[k2] !== hash1[k2] ){\n\t\t    same_p = false;\n\t\t    break;\n\t\t}\n\t    }\n\t}\n\treturn same_p;\n    </compareHashes>\n}\n"], ["updateChildBounds", "\nfunction updateChildBounds() {\n    <initializeBounds>\n         this.childBounds.pos.set(Infinity, Infinity);\n         this.childBounds.resize(-Infinity, -Infinity);\n    </initializeBounds>\n\n    <computeChildBounds>\n         var childBounds;\n         for (var i = this.children.length, child; i--, child = this.children[i];) {\n           if (child.isRenderable) {\n             if (child instanceof me.Container) {\n               childBounds = child.childBounds;\n             } else {\n               childBounds = child.getBounds();\n             } \n             if (childBounds !== null) {\n               this.childBounds.union(childBounds);\n             }\n           }\n         }\n    </computeChildBounds>\n\n    <returnBounds>\n         return this.childBounds;\n    </returnBounds>\n}\n"], ["textureBinding", "\nfunction(unit) {\n\t<activateTexture>\n\t\tvar gl = this.gl;\n\t\tif (unit || unit === 0)\n\t\t\tgl.activeTexture(gl.TEXTURE0 + unit);\n\t</activateTexture>\n\t<bindTexture>\n\t\tgl.bindTexture(this.target, this.id);\n\t</bindTexture>\n}\n"], ["_render", "\nfunction() {\n      <setupRender>\n      var _vm = this;\n      var _h = _vm.$createElement;\n      var _c = _vm._self._c || _h;\n      </setupRender>\n      <renderElements>\n      return _c(\n        \"div\",\n        {\n          staticClass: \"d-none\",\n          staticStyle: { display: \"none\" },\n          attrs: { \"aria-hidden\": \"true\" }\n        },\n        [\n          _c(\"div\", { ref: \"title\" }, [_vm._t(\"title\")], 2),\n          _vm._v(\" \"),\n          _c(\"div\", { ref: \"content\" }, [_vm._t(\"default\")], 2)\n        ]\n      )\n      </renderElements>\n}\n"], ""]