[["checkUrlMatchPatterns", "\nfunction (urlStr) {\n  var url,\n      matchAllUrlsPattern,\n      matchedSpecificPattern;\n\n  <matchAllUrls>\n  matchAllUrlsPattern = this.find(function (urlMatchPattern) {\n      return urlMatchPattern.pattern === MATCH_ALL_URLS;\n  });\n\n  if (_.isObject(matchAllUrlsPattern)) {\n      return true;\n  }\n  </matchAllUrls>\n\n  <parseUrl>\n  try {\n      url = new Url(urlStr);\n  }\n  catch (e) {\n      return false;\n  }\n  </parseUrl>\n\n  <matchSpecificPattern>\n  matchedSpecificPattern = this.find(function (urlMatchPattern) {\n      var matchRegexObject = urlMatchPattern._matchPatternObject;\n      \n      if (_.isEmpty(matchRegexObject)) {\n          return false;\n      }\n\n      return (urlMatchPattern.testProtocol(url.protocol) &&\n          urlMatchPattern.testHost(url.getHost()) &&\n          urlMatchPattern.testPort(url.port, url.protocol) &&\n          urlMatchPattern.testPath(url.getPath()));\n  });\n\n  return Boolean(matchedSpecificPattern);\n  </matchSpecificPattern>\n}\n"], ["createVector", "\nfunction() {\n    var A = this.start.elements, B = this.end.elements;\n    return vector.create([B[0] - A[0], B[1] - A[1], B[2] - A[2]]);\n}\n"], ["createClassStructure", "\nfunction create(s, p, root) {\n  var self = this, sp, ns, cn, scn, c, de = 0;\n\n  <parseClassString>\n  s = /^((static) )?([\\w.]+)(:([\\w.]+))?/.exec(s);\n  cn = s[3].match(/(^|\\.)(\\w+)$/i)[2]; \n  </parseClassString>\n\n  <createNamespace>\n  ns = self.createNS(s[3].replace(/\\.\\w+$/, ''), root);\n  </createNamespace>\n\n  <preventRedefinition>\n  if (ns[cn]) {\n    return;\n  }\n  </preventRedefinition>\n\n  <handleStatic>\n  if (s[2] == 'static') {\n    ns[cn] = p;\n\n    <onCreateStatic>\n    if (this.onCreate) {\n      this.onCreate(s[2], s[3], ns[cn]);\n    }\n    </onCreateStatic>\n\n    return;\n  }\n  </handleStatic>\n\n  <createConstructor>\n  if (!p[cn]) {\n    p[cn] = function () { };\n    de = 1;\n  }\n  </createConstructor>\n\n  <assignPrototype>\n  ns[cn] = p[cn];\n  self.extend(ns[cn].prototype, p);\n  </assignPrototype>\n\n  <setupInheritance>\n  if (s[5]) {\n    sp = self.resolve(s[5]).prototype;\n    scn = s[5].match(/\\.(\\w+)$/i)[1];\n\n    c = ns[cn];\n    if (de) {\n      ns[cn] = function () {\n        return sp[scn].apply(this, arguments);\n      };\n    } else {\n      ns[cn] = function () {\n        this.parent = sp[scn];\n        return c.apply(this, arguments);\n      };\n    }\n    ns[cn].prototype[cn] = ns[cn];\n\n    <copySuperclassMethods>\n    self.each(sp, function (f, n) {\n      ns[cn].prototype[n] = sp[n];\n    });\n    </copySuperclassMethods>\n\n    <overrideSuperclassMethods>\n    self.each(p, function (f, n) {\n      if (sp[n]) {\n        ns[cn].prototype[n] = function () {\n          this.parent = sp[n];\n          return f.apply(this, arguments);\n        };\n      } else {\n        if (n != cn) {\n          ns[cn].prototype[n] = f;\n        }\n      }\n    });\n    </overrideSuperclassMethods>\n  }\n  </setupInheritance>\n\n  <assignStaticProperties>\n  self.each(p['static'], function (f, n) {\n    ns[cn][n] = f;\n  });\n  </assignStaticProperties>\n}\n"], ["appendArcToPath", "\nfunction(endpoint, options) {\n  <initializeVariables>\n  var decimals = 100000;\n  if (arguments.length < 2) {\n      options = {};\n  }\n  if (this.closed) {\n      throw new Error(\"Path must not be closed\");\n  }\n  if (this.points.length < 1) {\n      throw new Error(\"appendArc: path must already contain a point (the endpoint of the path is used as the starting point for the arc)\");\n  }\n  var resolution = CSG.parseOptionAsInt(options, \"resolution\", CSG.defaultResolution2D);\n  if (resolution < 4) resolution = 4;\n  var xradius, yradius;\n  if (('xradius' in options) || ('yradius' in options)) {\n      if ('radius' in options) {\n          throw new Error(\"Should either give an xradius and yradius parameter, or a radius parameter\");\n      }\n      xradius = CSG.parseOptionAsFloat(options, \"xradius\", 0);\n      yradius = CSG.parseOptionAsFloat(options, \"yradius\", 0);\n  } else {\n      xradius = CSG.parseOptionAsFloat(options, \"radius\", 0);\n      yradius = xradius;\n  }\n  var xaxisrotation = CSG.parseOptionAsFloat(options, \"xaxisrotation\", 0);\n  var clockwise = CSG.parseOptionAsBool(options, \"clockwise\", false);\n  var largearc = CSG.parseOptionAsBool(options, \"large\", false);\n  var startpoint = this.points[this.points.length - 1];\n  endpoint = new CSG.Vector2D(endpoint);\n  </initializeVariables>\n  \n  <roundValues>\n  xradius = Math.round(xradius*decimals)/decimals;\n  yradius = Math.round(yradius*decimals)/decimals;\n  endpoint = new CSG.Vector2D(Math.round(endpoint.x*decimals)/decimals,Math.round(endpoint.y*decimals)/decimals);\n  </roundValues>\n\n  <calculateArc>\n  var sweep_flag = !clockwise;\n  var newpoints = [];\n  if ((xradius == 0) || (yradius == 0)) {\n      newpoints.push(endpoint);\n  } else {\n      <performArcCalculations>\n      // ... The entire block within the else statement is dedicated \n      // to performing the arc calculations. Omitted for brevity...\n      </performArcCalculations>\n  }\n  </calculateArc>\n\n  <finalizePath>\n  newpoints = this.points.concat(newpoints);\n  var result = new CSG.Path2D(newpoints);\n  return result;\n  </finalizePath>\n}\n"], ["createVAOFromBufferInfo", "\nfunction createVAOFromBufferInfo(gl, programInfo, bufferInfo) {\n  return createVAOAndSetAttributes(gl, programInfo.attribSetters || programInfo, bufferInfo.attribs, bufferInfo.indices);\n}\n"], ["getAllKeysFromObjectArray", "\nfunction getAllKeys (objArray) {\n  <collectKeys>\n  let keys = []\n  _.forEach(objArray, function (row) {\n    if (!row || typeof row === 'string') return\n    keys = keys.concat(Object.keys(row))\n  })\n  </collectKeys>\n  \n  <getUniqueKeys>\n  return _.union(keys)\n  </getUniqueKeys>\n}\n"], ["initializeSession", "\nfunction Session(editor) {\n  this.editor = editor;\n  this.path = editor.document.file.fullPath;\n  this.ternHints = [];\n  this.ternGuesses = null;\n  this.fnType = null;\n  this.builtins = null;\n}\n"], ["calculateErrorFunction", "\nfunction erf( x ) {\n  <initializeVariables>\n  var sign;\n  var ax;\n  var z;\n  var r;\n  var s;\n  var y;\n  var p;\n  var q;\n  </initializeVariables>\n\n  <handleSpecialCases>\n  if ( x !== x ) {\n      return NaN;\n  }\n\n  if ( x === PINF ) {\n      return 1;\n  }\n\n  if ( x === NINF ) {\n      return -1;\n  }\n\n  if ( x === 0 ) {\n      return x;\n  }\n  </handleSpecialCases>\n\n  <normalizeSign>\n  if ( x < 0 ) {\n      sign = true;\n      ax = -x;\n  } else {\n      sign = false;\n      ax = x;\n  }\n  </normalizeSign>\n\n  <calculateForDifferentDomains>\n  if ( ax < 0.84375 ) {\n    // ...\n  } else if ( ax < 1.25 ) {\n    // ...\n  } else if ( ax >= 6 ) {\n    // ...\n  } else {\n    <calculateUsingContinuedFraction>\n    // ...\n    </calculateUsingContinuedFraction>\n  }\n  </calculateForDifferentDomains>\n\n  <finalizeComputation>\n  if ( sign ) {\n      return r/ax - 1;\n  }\n  return 1 - r/ax;\n  </finalizeComputation>\n}\n"], ["tableDoubleClickHandler", "\nfunction tableDbclickHandler(evt) {\n  <initializeClickState>\n  singleClickState = 0;\n  evt = evt || me.window.event;\n  var target = getParentTdOrTh(evt.target || evt.srcElement);\n  </initializeClickState>\n\n  if (target) {\n      <handleTableResize>\n      var h;\n      if (h = getRelation(target, mouseCoords(evt))) {\n          hideDragLine( me );\n\n          if (h == 'h1') {\n              // ...\n          }\n          if (h == 'h') {\n              // ...\n          }\n      }\n      </handleTableResize>\n  }\n}\n"], ["insertNodeToRight", "\nfunction insertRight(parent, node) {\n  var index = parent.length - 1;\n  <updateParent>\n  parent[index] = node;\n  parent.sizes[index] = (0, _util.length)(node) + (index > 0 ? parent.sizes[index - 1] : 0);\n  </updateParent>\n}\n"], "```\n"]