[["Prompt", "\nfunction Prompt() {\n  Base.apply(this, arguments);\n\n  <validateOptChoices>\n  if (!this.opt.choices) {\n    this.throwParamError(\"choices\");\n  } </validateOptChoices>\n\n  <validateInstance>\n  this.validate();\n  </validateInstance>\n\n  <appendHelpChoice>\n  this.opt.choices.push({\n    key: \"h\",\n    name: \"Help, list all options\",\n    value: \"help\"\n  }); </appendHelpChoice>\n\n  <setRenderFunction>\n  this.opt.choices.setRender(renderChoice);\n  </setRenderFunction>\n\n  <setDefaultChoice>\n  var defIndex = 0;\n  if (_.isNumber(this.opt.default) && this.opt.choices.getChoice(this.opt.default)) {\n    defIndex = this.opt.default;\n  }\n  var defStr = this.opt.choices.pluck(\"key\");\n  this.rawDefault = defStr[defIndex];\n  defStr[defIndex] = String(defStr[defIndex]).toUpperCase();\n  this.opt.default = defStr.join(\"\");\n  </setDefaultChoice>\n\n  return this;\n}\n"], ["anonymousFunction", "\nfunction (entries, exchangePrefix, connectionFunc, options) {\n  events.EventEmitter.call(this);\n\n  <assertValidatorOption>\n  assert(options.validator, 'options.validator must be provided');\n  </assertValidatorOption>\n\n  <initializeProperties>\n  this._conn = null;\n  this.__reconnectTimer = null;\n  this._connectionFunc = connectionFunc;\n  this._channel = null;\n  this._connecting = null;\n  this._entries = entries;\n  this._exchangePrefix = exchangePrefix;\n  this._options = options;\n  this._errCount = 0;\n  this._lastErr = Date.now();\n  this._lastTime = 0;\n  this._sleeping = null;\n  this._sleepingTimeout = null;\n  </initializeProperties>\n\n  <handleDeprecatedOptions>\n  if (options.drain || options.component) {\n    console.log('taskcluster-lib-stats is now deprecated!\\n' +\n      'Use the `monitor` option rather than `drain`.\\n' +\n      '`monitor` should be an instance of taskcluster-lib-monitor.\\n' +\n      '`component` is no longer needed. Prefix your `monitor` before use.');\n  }\n  </handleDeprecatedOptions>\n\n  <initializeMonitor>\n  var monitor = null;\n  if (options.monitor) {\n    monitor = options.monitor;\n  }\n  </initializeMonitor>\n\n  <entryInitializers>\n  entries.forEach((entry) => {\n    this[entry.name] = (...args) => {\n\n      <buildMessage>\n      var message = entry.messageBuilder.apply(undefined, args);\n      common.validateMessage(this._options.rootUrl, this._options.serviceName, this._options.version,\n        options.validator, entry, message);\n      </buildMessage>\n\n      <buildRoutingKey>\n      var routingKey = common.routingKeyToString(entry, entry.routingKeyBuilder.apply(undefined, args));\n      </buildRoutingKey>\n\n      <buildCCs>\n      var CCs = entry.CCBuilder.apply(undefined, args);\n      assert(CCs instanceof Array, 'CCBuilder must return an array');\n      </buildCCs>\n\n      <serializePayload>\n      var payload = new Buffer(JSON.stringify(message), 'utf8');\n      </serializePayload>\n\n      <determineExchange>\n      var exchange = exchangePrefix + entry.exchange;\n      </determineExchange>\n\n      <debugMessage>\n      debug('Publishing message on exchange: %s', exchange);\n      </debugMessage>\n\n      <publishMessage>\n      return this._connect().then(channel => {\n        return new Promise((accept, reject) => {\n\n          <monitorStart>\n          var start = null;\n          if (monitor) {\n            start = process.hrtime();\n          }\n          </monitorStart>\n\n          <timeoutHandling>\n          let done = false;\n          this._sleep12Seconds().then(() => {\n            if (!done) {\n              let err = new Error('publish message timed out after 12s');\n              this._handleError(err);\n              reject(err);\n            }\n          });\n          </timeoutHandling>\n\n          <channelPublish>\n          channel.publish(exchange, routingKey, payload, {\n            persistent: true,\n            contentType: 'application/json',\n            contentEncoding: 'utf-8',\n            CC: CCs,\n          }, (err, val) => {\n\n            <monitorFinish>\n            done = true;\n            if (monitor) {\n              var d = process.hrtime(start);\n              monitor.measure(exchange, d[0] * 1000 + d[1] / 1000000);\n              monitor.count(exchange);\n            }\n            </monitorFinish>\n\n            <errorHandling>\n            if (err) {\n              err.methodName = entry.name;\n              err.exchange = exchange;\n              err.routingKey = routingKey;\n              err.payload = payload;\n              err.ccRoutingKeys = CCs;\n              debug('Failed to publish message: %j and routingKey: %s, ' +\n                'with error: %s, %j', message, routingKey, err, err);\n              if (monitor) {\n                monitor.reportError(err);\n              }\n              return reject(err);\n            }\n            </errorHandling>\n            accept(val);\n          });\n          </channelPublish>\n        });\n      });\n      </publishMessage>\n    };\n  });\n  </entryInitializers>\n}\n"], ["handleParamTree", "\nfunction handleParamTree(api, field) {\n  <extractParams>\n  var params = api[field];\n  </extractParams>\n\n  <processParams>\n  if (params && params.length) {\n\n    <filterParams>\n    params.forEach(function(param, k) {\n\n      <splitField>\n      var paramNames = param.field.split('.');\n      </splitField>\n      <nullifyAndHandleBelonging>\n      if (paramNames && paramNames.length > 1) {\n        \n        params[k] = null;\n        handleParamBelong(field, paramNames, params, param)\n      }\n      </nullifyAndHandleBelonging>\n    });\n    </filterParams>\n\n    <cleanParams>\n    api[field] = params.filter(function(param) {\n      return param ? true : false;\n    });\n    </cleanParams>\n  }\n  </processParams>\n}\n"], ["toggleList", "\nfunction(oList) {\n  var jListContRef = oList.$(\"lst\");\n\n  <checkListState>\n  if (jListContRef.hasClass(\"sapUiUx3ExactLstExpanded\")) {\n    <closeListPopup>\n    oList._oPopup.close();\n    </closeListPopup>\n  } else {\n    <openListPopup>\n    oList._oPopup.open();\n    </openListPopup>\n  }\n  </checkListState>\n}\n"], ["validateForm", "\nfunction validateForm(formEl, nativeSubmit) {\n  <checkFormValidity>\n  if (formEl.checkValidity && !formEl.checkValidity()) {\n    <logError>\n    log(\"Form did not pass validation checks - will not upload.\", \"error\");\n    </logError>\n    <invokeNativeSubmit>\n    nativeSubmit();\n    </invokeNativeSubmit>\n  }\n  else {\n    return true;\n  }\n  </checkFormValidity>\n}\n"], ["customModuleCompile", "\nfunction customModuleCompile(content, filename) {\n  <initializeModuleExceptions>\n  var moduleExceptions, parentDefine = global.define;\n  </initializeModuleExceptions>\n\n  <setGlobalDefine>\n  if (!this._globalDefine) {\n    setGlobalDefine(this);\n  }\n  </setGlobalDefine>\n\n  <compileModule>\n  moduleExceptions = originalModuleCompile.call(this, content, filename);\n  </compileModule>\n\n  <restoreDefine>\n  global.define = parentDefine;\n  </restoreDefine>\n\n  return moduleExceptions;\n}\n"], ["formatVersion", "\nfunction (version) {\n  <sanitizeVersion>\n  version = version.toLowerCase();\n  version = version.replace(' ', '');\n  version = version.replace('-', '.');\n  version = version.replace('_', '.');\n  version = version.replace('+', '.');\n  </sanitizeVersion>\n\n  <initializeVersionComponents>\n  var length = version.length;\n  var newVersion = false;\n  newVersion = version[0];\n  </initializeVersionComponents>\n\n  <reformatVersion>\n  for (var i = 1; i < length; i++) {\n    <versionLogic>\n    var a = version[i - 1];\n    var b = version[i];\n    if ('.' === a || '.' === b) {\n      newVersion += b;\n      continue;\n    }\n    var sameType = (isNaN(a) === isNaN(b));\n    if (sameType) {\n      newVersion += b;\n    } else {\n      newVersion += \".\" + b;\n    }\n    </versionLogic>\n  }\n  </reformatVersion>\n\n  <splitToVersionArray>\n  var versionArray = newVersion.split('.');\n  </splitToVersionArray>\n\n  <filterEmptyVersionParts>\n  versionArray = versionArray.filter(function (e) { return (e !== \"\"); });\n  </filterEmptyVersionParts>\n\n  <mapVersionLabels>\n  versionArray = versionArray.map(function (e) {\n    switch (e) {\n      case 'alpha':\n        return 'a';\n      case 'beta':\n        return 'b';\n      case 'pl':\n        return 'p';\n      default:\n        return e;\n    }\n  });\n  </mapVersionLabels>\n\n  <joinVersionParts>\n  return versionArray.join('.');\n  </joinVersionParts>\n}\n"], ["tryCatchWrapper", "\nfunction (func, context, args, callback) {\n  <tryInvokeFunction>\n  try {\n    func.apply(context, args);\n  }\n  catch (err) {}\n  </tryInvokeFunction>\n\n  <invokeCallback>\n  if (callback) {\n    callback();\n  }\n  </invokeCallback>\n}\n"], ["getItem", "\nfunction getItem(key, callback) {\n  var self = this;\n\n  <warnNonStringKey>\n  if (typeof key !== 'string') {\n    globalObject.console.warn(key + ' used as a key, but it is not a string.');\n    key = String(key);\n  }\n  </warnNonStringKey>\n\n  <getItemPromise>\n  var promise = self.ready().then(function () {\n    <initializeDbInfo>\n    var dbInfo = self._dbInfo;\n    </initializeDbInfo>\n    <retrieveItem>\n    var result = localStorage.getItem(dbInfo.keyPrefix + key);\n    </retrieveItem>\n\n    <deserializeResult>\n    \n    if (result) {\n      result = dbInfo.serializer.deserialize(result);\n    }\n    </deserializeResult>\n\n    return result;\n  });\n  </getItemPromise>\n\n  <executeCallback>\n  executeCallback(promise, callback);\n  </executeCallback>\n  return promise;\n}\n"], ["DbfConstructor", "\nfunction Dbf(fileName) {\n\n  <initializeFileName>\n  this._fileName = fileName;\n  </initializeFileName>\n  var self = this;\n  this._promise = new Promise(function (resolve, reject) {\n\n    <openFile>\n    fs.open(fileName, 'r', function (err, fd) {\n      if (err)\n        reject(err);\n      else {\n        <readFileHeader>\n        fs.read(fd, new Buffer(32), 0, 0x20, 0, function (err, bytes, buffer) {\n          if (err)\n            reject(err);\n          else if (bytes === 0x20) {\n            try {\n              self._parse(fd, buffer, resolve, reject);\n            } catch (e) {\n              reject(e);\n            }\n          } else\n            reject(new Error('Invalid file length'));\n        });\n        </readFileHeader>\n      }\n    });\n    </openFile>\n  });\n}\n"], "```"]