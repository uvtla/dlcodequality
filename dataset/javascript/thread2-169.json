[["watch", "\nfunction watch (specs, handler, options) {\n  <validateSpecs>\n  const err = fileOptions.validate(specs)\n  if (err) {\n    return Promise.reject(err)\n  }\n  </validateSpecs>\n\n  <normalizeSpecs>\n  const normalisedSpecs = fileOptions.normalize(specs)\n  </normalizeSpecs>\n\n  const events = new EventEmitter()\n\n  <optionsInitialization>\n  const opts = options || {}\n  const dir = opts.dir || '.'\n  const fileReader = opts.fileReader || readAsFile\n  const loader = opts.loader || defaultLoader\n  const buildConcurrency = opts.concurrency || 1\n  const resolveRoot = path.resolve(opts.resolveRoot || process.cwd())\n  </optionsInitialization>\n\n  <stateInitialization>\n  const fileInfos = {}\n  const affectedFiles = {}\n  const affectedFilesInverse = {}\n  </stateInitialization>\n\n  <linkingLoader>\n  function linkingLoader (filename, parentFilename) {\n    <fileLinking>\n    if (parentFilename) {\n      const file = path.relative(dir, filename)\n      affectedFiles[file] = affectedFiles[file] || new Set()\n      affectedFiles[file].add(parentFilename)\n\n      affectedFilesInverse[parentFilename] = affectedFilesInverse[parentFilename] || new Set()\n      affectedFilesInverse[parentFilename].add(file)\n      watchFile(file)\n    }\n    </fileLinking>\n    return loader(filename, parentFilename)\n  }\n  </linkingLoader>\n\n  <unlinkFile>\n  function unlinkFile (filename) {\n    delete affectedFiles[filename] \n\n    <updateAffectedFiles>\n    if (affectedFilesInverse[filename]) {\n      affectedFilesInverse[filename].forEach((affectorFilename) => {\n        affectedFiles[affectorFilename].delete(filename)\n        if (affectedFiles[affectorFilename].size === 0) {\n          delete affectedFiles[affectorFilename]\n        }\n      })\n\n      delete affectedFilesInverse[filename]\n    }\n    </updateAffectedFiles>\n  }\n  </unlinkFile>\n\n  <watchEventsSetup>\n  const inlinedWatcher = chokidar.watch([], {cwd: dir})\n  inlinedWatcher.on('change', (filename) => {\n    const files = Array.from(getSourceFileObjs(filename))\n    Promise.all(files.map((fileInfo) => handleFile(fileInfo, {rootCause: 'change', cause: 'change'})))\n      .then(() => events.emit('change', filename))\n      .catch(handleFileFailure)\n  })\n\n  inlinedWatcher.on('unlink', (filename) => {\n    const files = Array.from(getSourceFileObjs(filename))\n    unlinkFile(filename)\n    Promise.all(files.map((fileInfo) => handleFile(fileInfo, {rootCause: 'delete', cause: 'change'})))\n      .then(() => events.emit('delete', filename))\n      .catch(handleFileFailure)\n  })\n  </watchEventsSetup>\n\n  <watchFile>\n  function watchFile (filename) {\n    inlinedWatcher.add(filename)\n  }\n  </watchFile>\n\n  <getSourceFileObjs>\n  function getSourceFileObjs (filename, collectorSet) {\n    const results = collectorSet || new Set()\n    if (affectedFiles[filename]) {\n      affectedFiles[filename].forEach((affectedFilename) => {\n        if (fileInfos[affectedFilename]) {\n          results.add(fileInfos[affectedFilename])\n        }\n        getSourceFileObjs(affectedFilename, results)\n      })\n    }\n    return results\n  }\n  </getSourceFileObjs>\n\n  <workHandler>\n  function workHandler (work) {\n    fileInfos[work.fileInfo.src] = work.fileInfo\n    return fileReader(work.fileInfo, { loader: linkingLoader, resolveRoot })\n      .then(file => handler(undefined, file, work.cause))\n      .catch((err) => {\n        if (err instanceof ParseError) {\n          return handler(err, new File({info: work.fileInfo, content: undefined}), work.cause)\n        } else {\n          throw err\n        }\n      })\n      .then((res) => work.resolve(res))\n      .catch((err) => work.reject(err))\n  }\n  </workHandler>\n\n  <workQueueInitialization>\n  const workQueue = new WorkQueue(workHandler, {})\n  </workQueueInitialization>\n\n  <handleFile>\n  function handleFile (fileInfo, cause) {\n    return new Promise((resolve, reject) => {\n      workQueue.add({fileInfo: fileInfo, cause: cause, resolve: resolve, reject: reject})\n    })\n  }\n  </handleFile>\n\n  <handleFileFailure>\n  function handleFileFailure (err) {\n    events.emit('error', err)\n  }\n  </handleFileFailure>\n\n  <build>\n  function build () {\n    return Promise.all(w.files())\n      .map((fileInfo) => {\n        return handleFile(fileInfo, {rootCause: 'build', cause: 'build'})\n      }, {concurrency: buildConcurrency})\n  }\n  </build>\n\n  <watcherSetup>\n  const w = new Watcher(normalisedSpecs, opts)\n\n  w.on('add', (fileInfo) => {\n    return handleFile(fileInfo, {rootCause: 'add', cause: 'add'})\n      .then(() => events.emit('add', fileInfo.src))\n      .catch(handleFileFailure)\n  })\n\n  w.on('change', (fileInfo) => {\n    return handleFile(fileInfo, {rootCause: 'change', cause: 'change'})\n      .then(() => events.emit('change', fileInfo.src))\n      .catch(handleFileFailure)\n  })\n\n  w.on('remove', (fileInfo) => {\n    unlinkFile(fileInfo.src)\n    events.emit('delete', fileInfo.src)\n  })\n  </watcherSetup>\n\n  return w._promise.then(() => ({build: build, events: events}))\n}\n"], ["inspect", "\nfunction inspect(stringsOrOpts, ...values) {\n  <conditionCheck>\n  if (Array.isArray(stringsOrOpts)) {\n    return DEFAULT_INSPECT(stringsOrOpts, ...values);\n  }\n  </conditionCheck>\n  return inspector(stringsOrOpts);\n}\n"], ["getMetadata", "\nfunction getMetadata ($) {\n  <imageExtraction>\n  const image = ($('figure[representativeofpage=true] img').attr('src') ||\n                 $('meta[property=\"og:image\"]').attr('content') ||\n                 '')\n  </imageExtraction>\n\n  <dateExtraction>\n  const dateStr = ($('meta[property=\"article:modified_time\"]').attr('content') ||\n                   $('meta[property=\"article:published_time\"]').attr('content') ||\n                   $('meta[name=\"DC.date.issued\"]').attr('content') ||\n                   $('meta[property=date]').attr('content') ||\n                   $('.news-body-date time').attr('datetime') ||\n                   '').replace(' ', '')\n  </dateExtraction>\n\n  <publishedDateConversion>\n  const publishedDate = new Date(dateStr)\n  </publishedDateConversion>\n\n  <authorExtraction>\n  const author = ($('meta[name=author]').attr('content') ||\n                  $('[itemprop=articleBody] .data [itemprop=author] [itemprop=name]').text().trim() ||\n                  $('article .news-author [itemprop=author] [itemprop=name]').text().trim() ||\n                  $('article [itemprop=name]').text().trim() ||\n                  $('.main [itemprop=author]').text().trim() ||\n                  $('.cuerpo-articulo [href^=\"/autor\"]').text().trim() ||\n                  $('.news-info-box-author [itemprop=author]').text().trim() ||\n                  $('#content address.dateline small').text().trim() ||\n                  $('article .info .thirdparty-logo').text().trim() ||\n                  $('article .info .name.fn').text().trim() ||\n                  $('.detalleFullTexto .author a').text().trim() ||\n                  '')\n  </authorExtraction>\n\n  <titleExtraction>\n  const title = ($('meta[property=\"og:title\"]').attr('content') ||\n                 '')\n  </titleExtraction>\n\n  return {\n    image,\n    publishedDate,\n    source: {\n      author\n    },\n    title\n  }\n}\n"], ["iid", "\nfunction iid(instance, id) {\n  if (id)\n    <formatWithId>\n    return fmt('svc %d.%d', instance, id);\n    </formatWithId>\n  <formatWithInstance>\n  return fmt('svc %d.%d', instance.serverServiceId, instance.id);\n  </formatWithInstance>\n}\n"], ["ReuseS3Object", "\nfunction ReuseS3Object(fileUpload, awsKey) {\n  this.awsKey = awsKey;\n\n  <logAttempt>\n  fileUpload.info('will attempt to verify existence of the file');\n  </logAttempt>\n\n  <requestSetup>\n  var request = {\n    method: 'HEAD',\n    path: '',\n    x_amz_headers: fileUpload.xAmzHeadersCommon,\n    success404: true,\n    step: 'head_object'\n  };\n  </requestSetup>\n\n  <initSignedS3AWSRequestWithRetryLimit>\n  SignedS3AWSRequestWithRetryLimit.call(this, fileUpload, request);\n  </initSignedS3AWSRequestWithRetryLimit>\n}\n"], ["function-changingState", "\nfunction (stateName) {\n  this.$Frame.changeState.call(this, stateName);\n  <computeSize>\n  this._computeSize();\n  </computeSize>\n  var cfg = this._cfg, cssPrefix = this._cssPrefix;\n  var parentSpan = this._domElt;\n  <parentSpanClass>\n  parentSpan.className = ['xFixedHeightFrame_w ', cssPrefix, 'w'].join(\"\");\n  </parentSpanClass>\n  var curSpan;\n  <curSpanClass1>\n  curSpan = domUtils.getDomElementChild(parentSpan, 0);\n  curSpan.className = ['xFixedHeightFrame_bme ', cssPrefix, 'b ', cssPrefix, 'bkgA'].join(\"\");\n  </curSpanClass1>\n  curSpan = domUtils.getDomElementChild(parentSpan, this._mainContentIndex);\n  <curSpanClass2>\n  curSpan.className = ['xFixedHeightFrame_bme ', cssPrefix, 'm ', cssPrefix, 'bkgB'].join(\"\");\n  </curSpanClass2>\n  curSpan = domUtils.getDomElementChild(curSpan, 0);\n  var sizeInfo = {\n    className : ['xFrameContent ', cssPrefix, 'c ', cfg.cssClass].join(\"\")\n  };\n  <appendInnerSizeInfo>\n  this._appendInnerSizeInfo(sizeInfo);\n  </appendInnerSizeInfo>\n  <curSpanStyle>\n  curSpan.style.width = sizeInfo.width;\n  curSpan.style.height = sizeInfo.height;\n  </curSpanStyle>\n  <curSpanClass3>\n  curSpan.className = sizeInfo.className;\n  </curSpanClass3>\n  curSpan = domUtils.getDomElementChildReverse(parentSpan, 0);\n  <curSpanClass4>\n  curSpan.className = ['xFixedHeightFrame_bme ', cssPrefix, 'e ', cssPrefix, 'bkgA'].join(\"\");\n  </curSpanClass4>\n}\n"], ["PluginInitializationError", "\nfunction PluginInitializationError (message, module) {\n    this.message = message;\n    this.stack = new Error().stack;\n    this.module = module;\n}\n"], ["substitute", "\nfunction substitute(str, variables) {\n  <compilationCheck>\n  if (!cache[str]) {\n    <tryCompilation>\n    try {\n      <injectVariables>\n      cache[str] =  new Function(\"obj\",\n        \"var p=[],print=function(){p.push.apply(p,arguments);};\" +\n        \"with(obj){p.push('\" +\n        str.replace(/[\\r\\t\\n]/g, \" \")\n        .split(\"<%\").join(\"\\t\")\n        .replace(/((^|%>)[^\\t]*)'/g, \"$1\\r\")\n        .replace(/\\t=(.*?)%>/g, \"',$1,'\")\n        .split(\"\\t\").join(\"');\")\n        .split(\"%>\").join(\"p.push('\")\n        .split(\"\\r\").join(\"\\\\'\") +\n        \"');}return p.join('');\");\n      </injectVariables>\n    } catch(e) {\n      grunt.fail.fatal(\"Failed to compile template:\\n\" + str);\n    }\n    </tryCompilation>\n  }\n  </compilationCheck>\n  <executeTemplate>\n  return cache[str](variables || {});\n  </executeTemplate>\n}\n"], ["generateListItem", "\nfunction generateListItem(result, hasBlankLine) {\n  <contentCreation>\n  const content = [result[3]];\n  if (hasBlankLine) {\n    content.unshift('\\n');\n  }\n  </contentCreation>\n\n  <returnListItem>\n  return {\n    type: 'ListItem',\n    checked: result[2] === '[x]' ? true : (result[2] === '[ ]' ? false : undefined), \n    content,\n    children: []\n  };\n  </returnListItem>\n}\n"], ["runProgram", "\nasync function runProgram() {\n  <commandParsing>\n  const args = minimist(process.argv.slice(2));\n  </commandParsing>\n\n  <prefixInterception>\n  if (args.prefix) {\n    intercept(function(txt) {\n      return `[${pkg.name}]\\n${txt}`;\n    });\n  }\n  </prefixInterception>\n\n  <checkForUpdates>\n  let latest = await latestVersion(pkg.name, { version: `>${pkg.version}` })\n                      .catch(error => pkg.version);\n  if (semver.gt(latest, pkg.version)) {\n    process.stderr.write(chalk.default.white(`\\n     Update available `));\n    process.stderr.write(chalk.default.grey(`${pkg.version}`));\n    process.stderr.write(chalk.default.white(` -> `));\n    process.stderr.write(chalk.default.greenBright(`${latest}\\n`));\n    process.stderr.write(chalk.default.white(`     Run `));\n    process.stderr.write(chalk.default.blueBright(`npm i -g ${pkg.name} `));\n    process.stderr.write(chalk.default.white(`to update.\\n`));\n  }\n  </checkForUpdates>\n\n  <versionCheck>\n  if (args.version || args.v) {\n    process.stdout.write(pkg.version);\n    return 0;\n  }\n  </versionCheck>\n\n  <helpCheck>\n  if (args.h || args.help) {\n    help(process.stdout);\n    return 0;\n  }\n  </helpCheck>\n\n  <folderProcessing>\n  if (args.f || args.folder) {\n    let inputDir = args.f.trim();\n    let outputDir = (args.o || args.out_folder) ? args.o.trim() : \"./\";\n    if (outputDir.substr(0, 2) === \"./\") {\n      outputDir = path.resolve(process.cwd(), outputDir.substr(2))\n    }\n    const len = await processFiles(inputDir, outputDir);\n    process.stdout.write(chalk`{green Successfully wrote ${len} files}\\n`);\n    return len;\n  }\n  </folderProcessing>\n\n  <fileProcessing>\n  else {\n    const fileContents = await getInput(args);\n    if (fileContents) {\n      const activities = await chatdown(fileContents, args);\n      const writeConfirmation = await writeOut(activities, args);\n\n      if (typeof writeConfirmation === 'string') {\n        process.stdout.write(chalk`{green Successfully wrote file:} {blue ${writeConfirmation}}\\n`);\n      }\n      return 0;\n    }\n    else {\n      help();\n      return -1;\n    }\n  }\n  </fileProcessing>\n}\n"], "```\n\nMost functions have been annotated with responsibilities which might encompass either a single line or a whole block of code. It's important to distinguish cohesive tasks within a function which contributes to the overall goal the function serves. There are some one-liner or very simple statements included in the responsibilities because they contribute to a distinct part of the overall task; these are still essential elements in the larger responsibilities marked in the functions."]