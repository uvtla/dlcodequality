[["dependencyLink", "\nfunction dependencyLink (pkg, cb) {\n  <pathCalculations>\n  var dependencies = path.join(npm.dir, pkg.name, pkg.version, \"node_modules\")\n    , depBin = path.join(npm.dir, pkg.name, pkg.version, \"dep-bin\")</pathCalculations>\n  asyncMap(pkg._resolvedDeps, function (dep, cb) {\n    log.silly(dep, \"dependency\")\n    <dependencyLinkCreation>\n    var fromRoot = path.join(npm.dir, dep.name, dep.version)\n      , dependsOn = path.join( npm.dir, pkg.name, pkg.version\n                             , \"dependson\", dep.name + \"@\" + dep.version\n                             )</dependencyLinkCreation>\n    link(fromRoot, dependsOn, cb)\n  }, function (dep, cb) {\n    <loadDependentPackage>\n    var depDir = path.join(npm.dir, dep.name, dep.version, \"package\")\n    readJson(path.join(depDir, \"package.json\"), function (er, dep) {\n      if (er) return cb(er)\n      loadPackageDefaults(dep, function (er, dep) {\n        if (er) return cb(er)</loadDependentPackage>\n        asyncMap([dep], function (dep) {\n          var toLib = path.join(dependencies, dep.name)\n          linkModules(dep, toLib, cb)\n        }, function (dep, cb) {\n          \n          <linkDependenciesAndBinaries>\n          linkBins(dep, depBin, false, cb)</linkDependenciesAndBinaries>\n        }, cb)\n      })\n    })\n  }, cb)\n}\n"], ["makeEventTarget", "\nfunction makeEventTarget(target) {\n    var listeners = {};\n    <setupListeners>\n    target.on = function(event, func) {\n      if (listeners[event]) {\n        listeners[event].push(func);\n      } else {\n        listeners[event] = [func];\n      }\n    };</setupListeners>\n    <fireListeners>\n    target.fireEvent = function(event, data) {\n      expect(target.on).toHaveBeenCalledWith(event, jasmine.any(Function));\n      listeners[event].forEach(function(listener) {\n        listener(data);\n      });\n    };</fireListeners>\n    <removeListeners>\n    target.removeListeners = function() {\n      listeners = {};\n    };</removeListeners>\n    <spyOnListeners>\n    spyOn(target, \"on\").and.callThrough();</spyOnListeners>\n  }\n"], ["createFragment", "\nfunction (result) {\n  var frag = can.buildFragment(result, document.body);\n  \n  if (!frag.childNodes.length) {\n      frag.appendChild(document.createTextNode(''));\n  }\n  return frag;\n}\n"], ["sliceAndPush", "\nfunction(){\n  var slice = [].splice.call(arguments,0),\n  focus = slice[0],rem  = slice.splice(1,slice.length);\n\n  this.forEach(rem,function pushing(e,i,b){\n    _pusher.call(focus,e);\n  });\n  return;\n}\n"], ["dbSync", "\nfunction(method, model, options) {\n  options = options || {};\n  var self = this;\n  var db;\n  <selectDatabase>\n  if (!(self instanceof Db)) {\n    db = model.db || options.db;\n    debug('using db from model');\n  } else {\n    debug('using self as database');\n    db = self;\n  }</selectDatabase>\n\n  <logSyncStart>\n  debug('sync %s %s %s %s',\n    method,\n    model.type,\n    JSON.stringify(model.toJSON(options)),\n    JSON.stringify(options)\n  );\n\n  var start = Date.now();</logSyncStart>\n\n  function callback(err, res, resp) {\n    <logSyncEnd>\n    debug('callback ' + err + ' ' + JSON.stringify(res));\n    var elapsed = Date.now() - start;\n    var syncInfo = {\n      method: method,\n      type: model.type,\n      elapsed: elapsed,\n      model: model.toJSON(options),\n      res: JSON.stringify(res)\n    };\n    if (err) {\n      syncInfo.error = err;\n    }\n    if (options && options.where) {\n      syncInfo.where = _.clone(options.where);\n    }\n    if (db.trigger) {\n      db.trigger('sync_info', syncInfo);\n    }</logSyncEnd>\n    <errorReporting>\n    if ((err && options.error) || (!err && !res && options.error)) {\n      var errorMsg = pff('%s (%s) not found', model.type, model.id);\n      err = err || new errors.NotFoundError(errorMsg);\n      return options.error(err, resp);\n    }</errorReporting>\n    <successfulResponse>\n    else if (options.success && res) {\n      debug('success %s', JSON.stringify(res));\n      return options.success(res, resp);\n    }</successfulResponse>\n  }\n\n  <syncSwitch>\n  switch (method) {\n    case 'create':\n      return db.create(model, options, callback);\n    case 'update':\n      return db.update(model, options, callback);\n    case 'delete':\n      return db.destroy(model, options, callback);\n    case 'read':\n      if (typeof model.get(model.idAttribute) !== 'undefined') {\n        return db.find(model, options, callback);\n      }\n      return db.findAll(model, options, callback);\n    default:\n      throw new Error('method ' + method + ' not supported');\n  }</syncSwitch>\n}\n"], ["initViewPortData", "\nfunction (needsStitching) {\n  var initData = {\n          viewPort: {},\n          document: {},\n          bodyTransform: {}\n      },\n\n      de = document.documentElement,\n      el = document.createElement('div'),\n      body = document.body;\n\n  <calculateViewPort>\n  initData.viewPort.x = window.pageXOffset || body.scrollLeft || de.scrollLeft;\n  initData.viewPort.y = window.pageYOffset || body.scrollTop || de.scrollTop;\n\n  el.style.position = \"fixed\";\n  el.style.top = 0;\n  el.style.left = 0;\n  el.style.bottom = 0;\n  el.style.right = 0;\n  de.insertBefore(el, de.firstChild);\n  initData.viewPort.width = el.offsetWidth;\n  initData.viewPort.height = el.offsetHeight;\n  de.removeChild(el);</calculateViewPort>\n\n  <calculateDocumentData>\n  initData.document.width = Math.max(body.scrollWidth, body.offsetWidth, de.clientWidth, de.scrollWidth, de.offsetWidth);\n  initData.document.height = Math.max(body.scrollHeight, body.offsetHeight, de.clientHeight, de.scrollHeight, de.offsetHeight);\n  initData.document.cssHeight = body.style.height;\n  initData.document.overflow = body.style.overflow;</calculateDocumentData>\n\n  <determineTransformProperty>\n  if (body.style.webkitTransform !== undefined) {\n      initData.bodyTransform.property = 'webkitTransform';\n  } else if (body.style.mozTransform !== undefined) {\n      initData.bodyTransform.property = 'mozTransform';\n  } else if (body.style.msTransform !== undefined) {\n      initData.bodyTransform.property = 'msTransform';\n  } else if (body.style.oTransform !== undefined) {\n      initData.bodyTransform.property = 'oTransform';\n  } else {\n      initData.bodyTransform.property = 'transform';\n  }</determineTransformProperty>\n  initData.bodyTransform.value = body.style[initData.bodyTransform.property];\n  initData.needsStitching = needsStitching;\n\n  <applyStitching>\n  if (needsStitching) {\n    body.style[initData.bodyTransform.property] = 'translate(' + initData.viewPort.x + 'px, ' + initData.viewPort.y + 'px)';\n  }</applyStitching>\n\n  return JSON.stringify(initData);\n}\n"], ["getFileDetails", "\nfunction (file, parent, type) {\n  var fileDetails = path.parse(file),\n      filePath = (type === 'static') ?\n          path.join(fileDetails.dir, fileDetails.name + fileDetails.ext) :\n          path.join(fileDetails.dir, fileDetails.name);\n\n  return {\n      name: filePath,\n      parentDir: parent,\n      href: parent + filePath\n  };\n}\n"], ["hasTrackedTypes", "\nfunction(type, checks) {\n  var result = false;\n  var list = this._trackedtypes[type];\n  if (list) {\n    result = !checks || this._haschecks(list, checks);\n  }\n  return result;\n}\n"], ["getNetworkInterfaces", "\nfunction getNetworkInterfaces() {\n  const ret = {};\n  for (const macinfo of Object.values(macs)) {\n    if (!macinfo.self) {\n      continue;\n    }\n    <copyInterfaceInformation>\n    ret[macinfo.net] = objCpy(macinfo);</copyInterfaceInformation>\n  }\n  return ret;\n}\n"], ["updateSpaceData", "\nfunction (spaceIdentifier, data) {\n  var path;\n  if (data) {\n    <constructPathAndUpdateSpace>\n    path = this.constructPath(constants.SPACES, spaceIdentifier);\n    return this.Core.PATCH(path, data);</constructPathAndUpdateSpace>\n  } else {\n    <rejectBadRequest>\n    return this.rejectRequest('Bad Request: Space data is required');</rejectBadRequest>\n  }\n}\n"], "```\n\nEach of the functions has been annotated with SRP compliance or violations. Tags have been wrapped around blocks of code that represent distinct responsibilities within the functions."]