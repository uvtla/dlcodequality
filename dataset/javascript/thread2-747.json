[["nestTwoLevels", "\nfunction nestTwoLevels(samples) {\n  return samples.reduce(function(acc, sample) {\n    var page     = sample.hierarchy.length > 0 ? sample.hierarchy[0] : 'API';\n    var heading  = sample.hierarchy.length > 1 ? sample.hierarchy[1] : 'Samples';\n    acc[page] = acc[page] || {};\n    acc[page][heading] = acc[page][heading] || [];\n    acc[page][heading].push(sample);\n    return acc;\n  }, {});\n}\n"], ["functionWithMultipleResponsibilities", "\nfunction(oList, oAttribute, iSelectedIndex, bSkipNotify){\n    <removeSelectedIndex>\n\toList._lb.removeSelectedIndex(iSelectedIndex);\n    </removeSelectedIndex>\n\t<clearSelection>\n\toAttribute._clearSelection();\n\t</clearSelection>\n\t<conditionalNotification>\n\tif (!bSkipNotify) {\n\t\tvar aSubLists = oList.getSubLists();\n\t\tfor (var i = 0; i < aSubLists.length; i++) {\n\t\t\tif (aSubLists[i].getData() === oAttribute.getId()) {\n\t\t\t\tclose(aSubLists[i], true);\n\t\t\t}\n\t\t}\n\t}\n\t</conditionalNotification>\n}\n"], ["getSequentialFilePath", "\nfunction(filepath, index) {\n    index = index || 1;\n    var params = this.get_path_info(filepath);\n    params.index = index;\n    var newpath = Handlebars.compile(this.config.sequential_template)(params);\n    return (fs.existsSync(newpath)) ? this.get_sequential_filepath(filepath, index + 1) : newpath;\n}\n"], ["saveState", "\nfunction saveState () {\n    winston.info('Saving current state');\n    jsonfile.writeFileSync(STATE_FILE, {\n        subscriptions: subscriptions,\n        callback: callback,\n        history: history,\n        version: CURRENT_VERSION\n    }, {\n        spaces: 4\n    });\n}\n"], ["simpleArrayReduce", "\nfunction(reducer, initialValue) {\n  for (var i = 0; i < this.length; i++) {\n    initialValue = reducer(initialValue, this[i]);\n  }\n  return initialValue;\n}\n"], ["findNearest", "\nfunction(latlng, coords, offset) {\n\toffset = offset || 0;\n\tvar ordered = geolib.orderByDistance(latlng, coords);\n\treturn ordered[offset];\n}\n"], ["addToRegistry", "\nfunction(nodeName, objectOrBaseName, objectOrStatic, staticObject) {\n    cache = {};\n\tvar stack = registry[nodeName] || [];\n\tstack.push(Array.prototype.slice.call(arguments, 0));\n\tregistry[nodeName] = stack;\n}\n"], ["inheritPrototype", "\nfunction extender (d, b) {\n  <transferProperties>\n  _.each(b, (p) => {\n    if (Object.prototype.hasOwnProperty.call(b, p)) {\n      d[p] = b[p];\n    }\n  });\n  </transferProperties>\n  <setupFactoryAndPrototype>\n  function Factory () {\n    this.constructor = d;\n  }\n  d.prototype = b === null ? Object.create(b) : (Factory.prototype = b.prototype, new Factory());\n  </setupFactoryAndPrototype>\n}\n"], ["cpFunction", "\nfunction cp() {\n\t<initialChecksAndSetup>\n\tvar args = arguments,\n\t\tnargs = args.length,\n\t\ttmpl = 'default',\n\t\topts = {},\n\t\toptions,\n\t\tfpath,\n\t\tdpath,\n\t\tdest,\n\t\tclbk,\n\t\terr,\n\t\tflg;\n\tif (!nargs) {\n\t\tthrow new Error('insufficient input arguments. Must provide a file destination.');\n\t}\n\t// ...remaining initial checks and setup...\n\t</initialChecksAndSetup>\n\n\t<validationChecks>\n\tif (flg) {\n\t\terr = validate(opts, options);\n\t\tif (err) {\n\t\t\tthrow err;\n\t\t}\n\t}\n\t</validationChecks>\n\n\t<templateProcessing>\n\topts = merge({}, defaults[tmpl], opts);\n\ttmpl = opts.template || tmpl;\n\topts.keywords = keywords(opts.keywords);\n\tfpath = path.join(__dirname, tmpl, 'package.json');\n\tdpath = path.join(dest, 'package.json');\n\t</templateProcessing>\n\n\t<availabilityAndWriteFiles>\n\tif (opts.name) {\n\t\tpackageName(opts.name, isAvailable);\n\t} else {\n\t\tisAvailable(null, true);\n\t}\n\t// ...remaining file operations...\n\t</availabilityAndWriteFiles>\n}\n"], ["sendMsgFunction", "\nfunction sendMsg(that) {\n  <msgPreparation>\n  var msg, to, ids;\n  if (that.isDisabled()) return;\n  msg = that.readTextarea();\n  </msgPreparation>\n\n  <verifyMsgAndRecipients>\n  if (msg === '') {\n      node.warn('Chat: message has no text, not sent.');\n      return;\n  }\n  ids = that.recipientsIds;\n  if (ids.length === 0) {\n      node.warn('Chat: empty recipient list, message not sent.');\n      return;\n  }\n  </verifyMsgAndRecipients>\n\n  <sendMessage>\n  to = ids.length === 1 ? ids[0] : ids;\n  that.writeMsg('outgoing', { msg: msg });\n  node.say(that.chatEvent, to, msg);\n  </sendMessage>\n\n  <clearTextarea>\n  setTimeout(function() { that.textarea.value = ''; });\n  </clearTextarea>\n}\n"], ""]