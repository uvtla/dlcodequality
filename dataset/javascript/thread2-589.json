[["makeTagPolicy", "\nfunction makeTagPolicy(\n    opt_naiveUriRewriter, opt_nmTokenPolicy, opt_logger) {\n    <sanitizeAndLogTags>\n    return function(tagName, attribs) {\n      if (!(html4.ELEMENTS[tagName] & html4.eflags['UNSAFE'])) {\n        return {\n          'attribs': sanitizeAttribs(tagName, attribs,\n            opt_naiveUriRewriter, opt_nmTokenPolicy, opt_logger)\n        };\n      } else {\n        if (opt_logger) {\n          log(opt_logger, tagName, undefined, undefined, undefined);\n        }\n      }\n    };\n    </sanitizeAndLogTags>\n  }\n"], ["addSignatureHeaders", "\nfunction addSignatureHeaders(body, headers, keyId, private_key) {\n  <signFunctionDefinition>\n  var sign = function(str, private_key) {\n    var sign = Crypto.createSign('RSA-SHA256');\n    sign.update(str);\n    return sign.sign(private_key, 'base64');\n  };\n  </signFunctionDefinition>\n\n  <sha256FunctionDefinition>\n  var sha256 = function(str, encoding) {\n    var bodyStr = JSON.stringify(str);\n    var hash = Crypto.createHash('sha256');\n    hash.update(bodyStr);\n    return hash.digest(encoding);\n  };\n  </sha256FunctionDefinition>\n\n  <prepareHeaders>\n  if (!headers) {\n    headers = {};\n  }\n\n  if (!headers.date) {\n    headers.date = (new Date()).toUTCString();\n  }\n\n  if (!headers.digest) {\n    headers.digest = 'SHA256=' + sha256(body, 'base64');\n  }\n  </prepareHeaders>\n\n  <combineFunctionDefinition>\n  var combine = function(names, headers) {\n    var parts = [];\n    names.forEach(function(e) {\n      parts.push(e + ': ' + headers[e]);\n    });\n    return parts.join('\\n');\n  };\n  </combineFunctionDefinition>\n\n  <constructAuthorizationHeader>\n  headers.authorization = 'Signature ' +\n    'keyId=\"' + keyId + '\", ' +\n    'headers=\"date digest\", ' +\n    'algorithm=\"rsa-sha256\", ' +\n    'signature=\"' + sign(combine([ 'date', 'digest' ], headers), private_key) + '\"';\n  </constructAuthorizationHeader>\n\n  return headers;\n}\n"], ["decodeByteVector", "\nfunction decodeByteVector(x, N) {\n  var point = 0;\n  for (var i = 0; i < N; ++i) {\n    point |= x.charCodeAt(i) << (i * 8);\n  }\n  return point;\n}\n"], ["parsePath", "\nfunction parsePath(req) {\n  \n  const path = req.path || (req.url && req.url.split('?')[0]) || '';\n  \n  return path.replace(/^\\/|\\/$/g, '').split('/');\n}\n"], ["determineDateRange", "\nfunction (d, range) {\n  \"use strict\";\n\n  var start = new Date(d.getFullYear(), d.getMonth());\n  var stop = null;\n  if (range instanceof Date) {\n    stop = new Date(range.getFullYear(), range.getMonth());\n  } else {\n    stop = new Date(start);\n    stop = stop.setMonth(stop.getMonth()+range);\n  }\n\n  return d3.time.months(Math.min(start, stop), Math.max(start, stop));\n}\n"], ["handleDatabaseConnection", "\nfunction(db, opt_err) {\n    <checkFired>\n    if (df.hasFired()) {\n      goog.log.warning(me.logger, 'database already set.');\n    </checkFired>\n    <handleError>\n    else if (goog.isDef(opt_err)) {\n      goog.log.warning(me.logger, opt_err ? opt_err.message : 'Error received.');\n      me.idx_db_ = null;\n      df.errback(opt_err);\n    } \n    </handleError>\n    <setupDB>\n    else {\n      goog.asserts.assertObject(db, 'db');\n      me.idx_db_ = db;\n      me.idx_db_.onabort = function(e) {\n        goog.log.finest(me.logger, me + ': abort');\n        var request =  (e.target);\n        me.onError(request.error);\n      };\n      </setupDB>\n      <handleDBError>\n      me.idx_db_.onerror = function(e) {\n        if (ydn.db.con.IndexedDb.DEBUG) {\n          goog.global.console.log(e);\n        }\n        goog.log.finest(me.logger, me + ': error');\n        var request =  (e.target);\n        me.onError(request.error);\n      };\n      </handleDBError>\n\n      <handleVersionChange>\n      me.idx_db_.onversionchange = function(event) {\n        if (ydn.db.con.IndexedDb.DEBUG) {\n          goog.global.console.log([this, event]);\n        }\n        goog.log.finest(me.logger, me + ' closing connection for onversionchange to: ' +\n            event.version);\n        if (me.idx_db_) {\n          me.idx_db_.onabort = null;\n          me.idx_db_.onblocked = null;\n          me.idx_db_.onerror = null;\n          me.idx_db_.onversionchange = null;\n          me.onVersionChange(event);\n          if (!event.defaultPrevented) {\n            me.idx_db_.close();\n            me.idx_db_ = null;\n            var e = new Error();\n            e.name = event.type;\n            me.onFail(e);\n          }\n        }\n      };\n      </handleVersionChange>\n      <reportOldVersion>\n      df.callback(parseFloat(old_version));\n      </reportOldVersion>\n    }\n  }\n"], ["is_same", "\nfunction _is_same(a, b) {\n  var ret = false;\n  <basicEqualityCheck>\n  if (a == b) { \n    ret = true;\n  }\n  </basicEqualityCheck>\n  <complexEqualityCheck>\n  else { \n    if (typeof(a) === 'object' && typeof(b) === 'object') {\n      if (a == null || b == null) {\n        ret = false;\n      } else if (Array.isArray(a) && Array.isArray(b)) { \n        if (a.length == b.length) {\n          if (a.length == 0) {\n            ret = true;\n          } else {\n            ret = true; \n            for (var i = 0; i < a.length; i++) {\n              if (!_is_same(a[i], b[i])) {\n                ret = false;\n                break;\n              }\n            }\n          }\n        }\n      } else { \n        <objectKeyComparison>\n        var a_keys = Object.keys(a);\n        var b_keys = Object.keys(b);\n        var keys = a_keys.concat(b_keys.filter(function(it) {\n          return a_keys.indexOf(it) < 0;\n        }));\n        ret = true;\n        for (var j = 0; j < keys.length; j++) { \n          var k = keys[j];\n          if (!_is_same(a[k], b[k])) {\n            ret = false;\n            break;\n          }\n        }\n        </objectKeyComparison>\n      }\n    }\n  }\n  </complexEqualityCheck>\n  return ret;\n}\n"], ["processArgv", "\nfunction processArgv(argv) {\n  <extractCommand>\n  let command = getCommand(argv);\n  let isInternalCommand = true;\n  </extractCommand>\n\n  <logCommand>\n  logger.info(`SKY UX processing command ${command}`);\n  </logCommand>\n\n  <executeCommand>\n  switch (command) {\n    case 'version':\n      require('./lib/version').logVersion(argv);\n      break;\n    case 'new':\n      require('./lib/new')(argv);\n      break;\n    case 'help':\n      require('./lib/help')(argv);\n      break;\n    case 'install':\n      require('./lib/install')(argv);\n      break;\n    default:\n      isInternalCommand = false;\n  }\n  </executeCommand>\n  \n  <invokeExternalCommand>\n  invokeCommand(command, argv, isInternalCommand);\n  </invokeExternalCommand>\n}\n"], ["executeGit", "\nfunction executeGit(args, options) {\n  <setupOptions>\n  options = options || {};\n  </setupOptions>\n  <promise>\n  return new Promise(function(resolve, reject) {\n    <initialize>\n    var stdo = '';\n    var proc = doSpawn('git', args, { cwd: options.cwd ? options.cwd : process.cwd(), stdio: ['ignore', 'pipe', 'ignore'] });\n    </initialize>\n\n    <unpipeDefinition>\n    function unpipe() {\n    }\n    </unpipeDefinition>\n\n    <captureStdout>\n    if (options.captureStdout) {\n      proc.stdout.on('data', function onStdout(data) {\n              stdo += data.toString();\n            });\n    }\n    </captureStdout>\n    <handleGitError>\n    proc.on('error', function(err) {\n      unpipe();\n      if (options.ignoreError) {\n        resolve({ out: stdo, code: 0 });\n      } else {\n        printError(err, args);\n        reject(err);\n      }\n    });\n    </handleGitError>\n    <handleGitExit>\n    proc.on('exit', function(code) {\n      unpipe();\n    });\n    </handleGitExit>\n    <handleGitClose>\n    proc.on('close', function(code) {\n      unpipe();\n      if (code !== 0 && !options.ignoreError) {\n        if (!options.quiet) {\n          printError('', args);\n        }\n        reject(new Error(\"Error running git\"));\n      } else {\n        resolve({ out: stdo, code: code });\n      }\n    });\n    </handleGitClose>\n  });\n  </promise>\n}\n"], ["getTasksFromYakefile", "\nfunction getTasksFromYakefile(cwd, fileOption) {\n  <initializeTaskCollections>\n  const tc1 = TC.TaskCollection();\n  const tc2 = TASKS.loadPreloadedTasks(tc1);\n  </initializeTaskCollections>\n\n  <determineYakefilePath>\n  const yakefileCandidates = Yakefile.defaultFilenames();\n  if (fileOption !== undefined)\n    yakefileCandidates = [fileOption];\n  const yakeFilePath = Yakefile.recursiveFindFile(cwd, yakefileCandidates);\n  </determineYakefilePath>\n\n  <handleFileNotFound>\n  if (yakeFilePath === undefined) {\n    const msg = yakefileCandidates.join();\n    ERROR.raiseError(`cannot find yakefile among : ${msg}`);\n  }\n  </handleFileNotFound>\n\n  <requireTasksFromYakefile>\n  const collection = TASKS.requireTasks(yakeFilePath, tc2);\n  </requireTasksFromYakefile>\n  return collection;\n}\n"], "```"]