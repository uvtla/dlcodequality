[["retrieveAssociations", "\nfunction retrieveAssociations(req, res) {\n  <handleContentNegotiation>\n  switch(req.accepts(['json', 'html'])) {\n    \n    \n    \n    \n    default:\n  </handleContentNegotiation>\n      var rootUrl = req.protocol + ':\n      var queryPath = req.originalUrl;\n      <getAssociations>\n      req.chickadee.getAssociations(req, rootUrl, queryPath,\n                                    function(response, status) {\n        res.status(status).json(response);\n      });\n      </getAssociations>\n      break;\n  }\n}\n"], ["binarySearch", "\nfunction binarySearch(array, func) {\n    \n    let min = 0,\n        max = array.length;\n\n    <searchAlgorithm>\n    while (min < max) {\n        const mid = (min + max) >> 1;\n        const res = func(array[mid]);\n        if (res > 0) {\n            \n            max = mid;\n        } else {\n            \n            min = mid + 1;\n        }\n    }\n    </searchAlgorithm>\n    \n    return min;\n}\n"], ["addIndexAndRemoveJsExt", "\nfunction addIndexAndRemoveJsExt(s) {\n        <conditionalProcessStringOrArray>\n        if (typeof s === 'string') {\n            return addIndexAndRemoveJsExtFromName(s);\n        } else {\n            var ret = [],\n                i = 0,\n                l = s.length;\n            for (; i < l; i++) {\n                ret[i] = addIndexAndRemoveJsExtFromName(s[i]);\n            }\n            return ret;\n        }\n        </conditionalProcessStringOrArray>\n    }\n"], ["updateNodeContextSelection", "\nfunction updateNodeContextSelection(root, oldSelection, newSelection, rootUpdate, ignoreRootSelection){\n    \n    <checkNoSelectionChange>\n    if (oldSelection === newSelection)\n      return;\n    </checkNoSelectionChange>\n\n    \n    var nextNode;\n    var cursor = root;\n    var selected = [];\n\n    <updateRootNode>\n    if (rootUpdate)\n    {\n      root.contextSelection = newSelection;\n      if (root.selected && !root.selectedRA_)\n        selected.push(root);\n    }\n    </updateRootNode>\n\n    <updateSelectionForChildren>\n    while (cursor)\n    {\n      \n      \n      <findNextNode>\n      nextNode = !cursor.selection || (ignoreRootSelection && cursor === root)\n        ? cursor.firstChild\n        : null;\n      </findNextNode>\n\n      if (nextNode && nextNode.contextSelection !== oldSelection)\n        throw 'Try change wrong context selection';\n\n      <traverseTree>\n      while (!nextNode)\n      {\n        \n        if (cursor === root)\n        {\n          <processSelectedNodes>\n          if (selected.length)\n          {\n            if (oldSelection)\n              oldSelection.remove(selected);\n\n            if (newSelection)\n            {\n              newSelection.add(selected);\n\n              \n              for (var i = 0; i < selected.length; i++)\n              {\n                var node = selected[i];\n                if (node.selected && !newSelection.has(node))\n                {\n                  node.selected = false;\n                  node.emit_unselect();\n                }\n              }\n            }\n          }\n          </processSelectedNodes>\n\n          return;\n        }\n        <findSiblingOrParent>\n        nextNode = cursor.nextSibling;\n\n        \n        if (!nextNode)\n          cursor = cursor.parentNode;\n        </findSiblingOrParent>\n      }\n      </traverseTree>\n\n      <updateCursorAndSelected>\n      cursor = nextNode;\n\n      \n      if (cursor.selected && !cursor.selectedRA_)\n        selected.push(cursor);\n\n      \n      cursor.contextSelection = newSelection;\n      </updateCursorAndSelected>\n    }\n    </updateSelectionForChildren>\n  }\n"], ["prefixMatchLength", "\nfunction prefixMatchLength(name, prefix) {\n  var prefixParts = prefix.split('/');\n  var nameParts = name.split('/');\n  <matchPrefix>\n  if (prefixParts.length > nameParts.length)\n    return 0;\n  for (var i = 0; i < prefixParts.length; i++) {\n    if (nameParts[i] != prefixParts[i])\n      return 0;\n  }\n  </matchPrefix>\n  return prefixParts.length;\n}\n"], ["getResultSeverity", "\nfunction getResultSeverity(messages) {\n  <checkMessagesAndCalculateSeverity>\n  if (!messages) {\n    return 0;\n  }\n\n  return messages\n    .map(it => it.severity)\n    .reduce((maxSeverity, severity) => Math.max(maxSeverity, severity), 0);\n  </checkMessagesAndCalculateSeverity>\n}\n"], ["assignFiberPropertiesInDEV", "\nfunction assignFiberPropertiesInDEV(target, source) {\n  <initializeTargetIfNull>\n  if (target === null) {\n    \n    \n    target = createFiber(IndeterminateComponent, null, null, NoContext);\n  }\n  </initializeTargetIfNull>\n\n  <copySourcePropertiesToTarget>\n  \n  \n  \n  \n  \n\n  target.tag = source.tag;\n  target.key = source.key;\n  target.elementType = source.elementType;\n  target.type = source.type;\n  target.stateNode = source.stateNode;\n  target.return = source.return;\n  target.child = source.child;\n  target.sibling = source.sibling;\n  target.index = source.index;\n  target.ref = source.ref;\n  target.pendingProps = source.pendingProps;\n  target.memoizedProps = source.memoizedProps;\n  target.updateQueue = source.updateQueue;\n  target.memoizedState = source.memoizedState;\n  target.contextDependencies = source.contextDependencies;\n  target.mode = source.mode;\n  target.effectTag = source.effectTag;\n  target.nextEffect = source.nextEffect;\n  target.firstEffect = source.firstEffect;\n  target.lastEffect = source.lastEffect;\n  target.expirationTime = source.expirationTime;\n  target.childExpirationTime = source.childExpirationTime;\n  target.alternate = source.alternate;\n  if (enableProfilerTimer) {\n    target.actualDuration = source.actualDuration;\n    target.actualStartTime = source.actualStartTime;\n    target.selfBaseDuration = source.selfBaseDuration;\n    target.treeBaseDuration = source.treeBaseDuration;\n  }\n  target._debugID = source._debugID;\n  target._debugSource = source._debugSource;\n  target._debugOwner = source._debugOwner;\n  target._debugIsCurrentlyTiming = source._debugIsCurrentlyTiming;\n  target._debugHookTypes = source._debugHookTypes;\n  </copySourcePropertiesToTarget>\n  return target;\n}\n"], ["handlePacketCallback", "\nfunction(pack) {\n    <invokeCallbackIfValid>\n    if (pack.toSource !== false || pack.source !== process.pid) {\n      CALLBACK(pack.message)\n    }\n    </invokeCallbackIfValid>\n  }\n"], ["addonsManager_getSearchFilter", "\nfunction addonsManager_getSearchFilter(aSpec) {\n  <constructFilterSpec>\n    var spec = aSpec || { };\n  </constructFilterSpec>\n\n    <getSearchFilterElements>\n    return this.getElements({\n      type: \"search_filterRadioButtons\",\n      subtype: spec.attribute,\n      value: spec.value\n    });\n    </getSearchFilterElements>\n  }\n"], ["prettyPrint", "\nfunction prettyPrint(json, tabs){\n\t<formatJson>\n\t\tvar result = \"\";\n\t\t\n\t\t<iterateAndFormatProperties>\n\t\tfor (var property in json) {\n\t\t    var value = json[property];\n\t\t    \n\t\t    <skipUndefinedProperty>\n\t\t    if(value === undefined) {\n\t\t\t\tcontinue;\n\t\t    }\n\t\t    </skipUndefinedProperty>\n\t\t    \n\t\t    <processProperty>\n\t\t    if(_isJSON(value)){ result += prettyPrint(value, tabs + 1); }\n\t\t    else { result += _appendTabs(property + \" : \" + value + \"\\n\", tabs); }\n\t\t    </processProperty>\n\t\t}\n\t\t</iterateAndFormatProperties>\n\t\t\n\t\treturn result;\n\t</formatJson>\n\t}\n"], "```"]