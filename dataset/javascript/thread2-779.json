[["getBootSwatchComponent", "\nfunction getBootSwatchComponent( url, done ) {\n\tvar body = \"\";\n\t<makeHttpRequest>\n\tvar req = http.request( url, function ( res ) {\n\t\tres.setEncoding( 'utf8' );\n\t\tres.on( 'data', function ( chunk ) {\n\t\t\tbody += chunk;\n\t\t} );\n\n\t\t<handleResponseEnd>\n\t\tres.on( 'end', function () {\n\t\t\tdone( null, body );\n\t\t} );\n\t\t</handleResponseEnd>\n\n\t\t<handleResponseError>\n\t\tres.on( 'error', function ( e ) {\n\t\t\tdone( 'problem with response: ' + e.message );\n\t\t} );\n\t\t</handleResponseError>\n\t} );\n\n\t<handleRequestError>\n\treq.on( 'error', function ( e ) {\n\t\tdone( 'problem with request: ' + e.message );\n\t} );\n\t</handleRequestError>\n\n\treq.end();\n}\n"], ["createMarkerImage", "\nfunction (markerUrl, markerWidth, markerHeight) {\n\tthis.writeDebug('markerImage',arguments);\n\t<initializeMarkerImage>\n\tvar markerImg;\n\t\n\tif (typeof markerWidth !== 'undefined' && typeof markerHeight !== 'undefined') {\n\t\tmarkerImg = {\n\t\t\turl: markerUrl,\n\t\t\tsize: new google.maps.Size(markerWidth, markerHeight),\n\t\t\tscaledSize: new google.maps.Size(markerWidth, markerHeight)\n\t\t};\n\t}\n\t\n\telse {\n\t\tmarkerImg = {\n\t\t\turl: markerUrl,\n\t\t\tsize: new google.maps.Size(32, 32),\n\t\t\tscaledSize: new google.maps.Size(32, 32)\n\t\t};\n\t}\n\t</initializeMarkerImage>\n\n\treturn markerImg;\n}\n"], ["nativeKeysIn", "\nfunction nativeKeysIn$1(object) {\n\t<getKeyArray>\n\tvar result = [];\n\tif (object != null) {\n\t\tfor (var key in Object(object)) {\n\t\t\tresult.push(key);\n\t\t}\n\t}\n\t</getKeyArray>\n\treturn result;\n}\n"], ["writeFileWithLogging", "\nfunction writeFile(dest, buffer) {\n\t<writeAndLogSuccess>\n\tif (write(dest, buffer)) {\n\t\tg.log.ok(dest + ':' + opt.prefix.green +  '\u524d\u7f00\u6ce8\u5165\u5b8c\u6210\uff01');\n\t}\n\t</writeAndLogSuccess>\n\t\n\t<handleWriteError>\n\telse {\n\t\twriteError(dest + ':' + opt.prefix.red +  '\u524d\u7f00\u6ce8\u5165\u5931\u8d25\uff01');\n\t\tresult = false;\n\t}\n\t</handleWriteError>\n}\n"], ["cacheHandling", "\nfunction() {\n\t<initializeResult>\n\tvar result = Array.isArray(self.input.instance) ? output : (output[0] || null)\n\t</initializeResult>\n\n\t<cacheSaveAndViewHandling>\n\tif (self.method === 'view') {\n\t  self.cache.saveView(result)\n\t  result = Array.isArray(result)\n\t\t? result.map(self.cache.save.bind(self.cache))\n\t\t: self.cache.save(result)\n\t} else {\n\t  result = self.cache.save(result)\n\t}\n\t</cacheSaveAndViewHandling>\n\n\t<endRequest>\n\tself.end(result)\n\t</endRequest>\n}\n"], ["getCollectionByName", "\nfunction(ferret, collection_name, callback) {\n\t<ensureReadyAndProceed>\n\t_ready(ferret, function(err) {\n\t\tif (err) {\n\t\t\t<handleReadyError>\n\t\t\tprocess.nextTick(function() {\n\t\t\t\tcallback(err)  \n\t\t\t})\n\t\t\t</handleReadyError>\n\t\t} else {\n\t\t\t<retrieveOrInitializeCollection>\n\t\t\tif (ferret._collections[collection_name]) {\n\t\t\t\t<returnExistingCollection>\n\t\t\t\tprocess.nextTick(function() {\n\t\t\t\t\tcallback(null, ferret._collections[collection_name])\n\t\t\t\t})\n\t\t\t\t</returnExistingCollection>\n\t\t\t} else {\n\t\t\t\t<createCollection>\n\t\t\t\tferret._db.collection(collection_name, function(err, collection){\n\t\t\t\t\tif (!err) { ferret._collections[collection_name] = collection }\n\t\t\t\t\tcallback(err, collection)\n\t\t\t\t})\n\t\t\t\t</createCollection>\n\t\t\t}\n\t\t\t</retrieveOrInitializeCollection>\n\t\t}\n\t})\n\t</ensureReadyAndProceed>\n}\n"], ["findRelatedCollectionIDsByCriteria", "\nfunction findRelatedCollectionIDsByCriteria(models, junctionTable, subQueryCriteria) {\n\t<performSubQuery>\n\tconst subQueryTable = models[junctionTable.tables[1]]\n\n\treturn subQueryTable\n\t\t.find({\n\t\t\tselect: [\"id\"],\n\t\t\twhere: subQueryCriteria\n\t\t})\n\t\t.then(idObjects => idObjects.map(idObject => idObject.id))\n\t\t.then(ids => {\n\t\t\tconst junctionTableQuery = {}\n\n\t\t\tjunctionTableQuery[junctionTable.columns[0]] = ids\n\n\t\t\treturn junctionTable.collection.find({\n\t\t\t\tselect: [junctionTable.columns[1]],\n\t\t\t\twhere: junctionTableQuery\n\t\t\t})\n\t\t\t.then(idObjects => idObjects.map(idObject => idObject[junctionTable.columns[1]]))\n\t\t})\n\t\t</performSubQuery>\n}\n"], ["mergeAnnotationsInSchema", "\nfunction mergeAnnotations(oSchema, mAnnotations, bPrivileged) {\n\t<processSchemaAnnotations>\n\tvar sTarget;\n\n\tfunction extend(oTarget, oSource) {\n\t\t<extendTargetWithSource>\n\t\tvar sName;\n\n\t\tfor (sName in oSource) {\n\t\t\tif (bPrivileged || !(sName in oTarget)) {\n\t\t\t\toTarget[sName] = oSource[sName];\n\t\t\t}\n\t\t}\n\t\t</extendTargetWithSource>\n\t}\n\n\tfor (sTarget in oSchema.$Annotations) {\n\t\t<createOrExtendAnnotations>\n\t\tif (!(sTarget in mAnnotations)) {\n\t\t\tmAnnotations[sTarget] = {};\n\t\t}\n\t\textend(mAnnotations[sTarget], oSchema.$Annotations[sTarget]);\n\t\t</createOrExtendAnnotations>\n\t}\n\tdelete oSchema.$Annotations;\n\t</processSchemaAnnotations>\n}\n"], ["removeEventListenerForElements", "\nfunction (elements) {\n\t<validateArgumentsAndProcess>\n\tif (!validateArguments(elements, function () {})) return\n\n\tif (!Array.isArray(elements)) {\n\t\telements = [ elements ]\n\t}\n\t</validateArgumentsAndProcess>\n\n\t<deregisterEventHandlers>\n\tliveElements.filter(function (e) {\n\t\treturn elements.indexOf(e.element) !== -1\n\t}).forEach(function (e) {\n\t\te.element.removeEventListener('input', e.handler)\n\t})\n\n\tliveElements = liveElements.filter(function (e) {\n\t\treturn elements.indexOf(e.element) === -1\n\t})\n\t</deregisterEventHandlers>\n\n\treturn this\n}\n"], ["assertNotEqualWithMessage", "\nfunction (value1, value2, optMsg, optAssertId) {\n\t<assertValuesNotEqual>\n\tvar msg = optMsg || (\"First and second value shouldn't be equal but they are both equal to: \" + value1);\n\tthis.assertTrue((value1 !== value2), msg);\n\t</assertValuesNotEqual>\n}\n"], "```"]