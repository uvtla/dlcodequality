[["CodecConfiguration", "\nfunction CodecConfiguration(codecConfigurationDict){\n  <ensureInstance>\n  if(!(this instanceof CodecConfiguration))\n    return new CodecConfiguration(codecConfigurationDict)\n  </ensureInstance>\n\n  <validateConfiguration>\n  checkType('String', 'codecConfigurationDict.name', codecConfigurationDict.name, {required: true});\n  checkType('String', 'codecConfigurationDict.properties', codecConfigurationDict.properties);\n  </validateConfiguration>\n\n  <initializeSuperClass>\n  CodecConfiguration.super_.call(this, codecConfigurationDict)\n  </initializeSuperClass>\n\n  <defineProperties>\n  Object.defineProperties(this, {\n    name: {\n      writable: true,\n      enumerable: true,\n      value: codecConfigurationDict.name\n    },\n    properties: {\n      writable: true,\n      enumerable: true,\n      value: codecConfigurationDict.properties\n    }\n  })\n  </defineProperties>\n}\n"], ["HandleNodePositioning", "\nfunction(node, type, s) {\n  <createComplexCoordinateFunction>\n    var $C = function(a, b) { \n        return function(){\n          return node.pos.add(new Complex(a, b));\n        }; \n      };\n  </createComplexCoordinateFunction>\n  \n  <initialVariables>\n  var dim = this.node;\n  var w = node.getData('width');\n  var h = node.getData('height');\n  </initialVariables>\n\n  <nodePositioningLogic>\n    if(type == 'begin') {\n        // ... logic for begin type\n    } else if(type == 'end') {\n        // ... logic for end type\n    } else throw \"align: not implemented\";\n  </nodePositioningLogic>\n}\n"], ["RecordJumpDefinition", "\nfunction _recordJumpDef(event, selectionObj) {\n    \n  <checkForJumpsInProgress>\n    if (jumpInProgress || (event.target && event.target.document._refreshInProgress)) {\n        return;\n    }\n  </checkForJumpsInProgress>\n    \n  <initializeForwardStack>\n  jumpForwardStack = [];\n  </initializeForwardStack>\n  <manageCaptureTimer>\n    if (captureTimer) {\n        window.clearTimeout(captureTimer);\n        captureTimer = null;\n    }\n  </manageCaptureTimer>\n    \n  <captureJumpEvent>\n    if (selectionObj.origin !== \"+move\" && (!window.event || window.event.type !== \"input\")) {\n        // ...logic to capture the current edit position and validate commands\n    } else {\n        activePosNotSynced = true;\n    }\n  </captureJumpEvent>\n}\n"], ["UpdateComponentView", "\nfunction() {\n    <prepareViewStyles>\n    var styles = {},\n        viewOptions = component.get('viewOptions'),\n        title = viewOptions.get('title') || '',\n        background = viewOptions.get('background'),\n        css = component.get('css');\n    for (var selector in css) {\n      styles['#' + component.id + ' ' + selector] = css[selector];\n    }\n    $.styleSheet(styles, 'nm-cv-css-' + component.id);\n    </prepareViewStyles>\n    \n    <updateComponentCssClasses>\n    t.$('.nm-cv')\n      .toggleClass('background', background === true)\n      .toggleClass('title', title.length > 0);\n    t.$('.nm-cv-title span').text(title);\n    </updateComponentCssClasses>\n  }\n"], ["DoneCallbackWrapper", "\nfunction done(err) {\n  <initialChecks>\n    var ms = self.timeout();\n    if (self.timedOut) {\n      return;\n    }\n\n    if (finished) {\n      return multiple(err);\n    }\n  </initialChecks>\n\n  <finalizeCallback>\n    self.clearTimeout();\n    self.duration = new Date() - start;\n    finished = true;\n    if (!err && self.duration > ms && self._enableTimeouts) {\n      err = self._timeoutError(ms);\n    }\n    fn(err);\n  </finalizeCallback>\n}\n"], ["GetRelativeXCoordinate", "\nfunction getCanvasClickRelativeXCoordinate(canvasElement, event) {\n  <calculateRelativeX>\n  let x;\n  if (event.pageX) {\n    x = event.pageX;\n  } else {\n    x = event.clientX + document.body.scrollLeft +\n        document.documentElement.scrollLeft;\n  }\n  x -= canvasElement.offsetLeft;\n  return x / canvasElement.width;\n  </calculateRelativeX>\n}\n"], ["WriteDiagnostics", "\nfunction diagnostics() {\n    <processArguments>\n    var args = Array.prototype.slice.call(arguments, 0);\n\n    write.call(write, options, process(args, options));\n    </processArguments>\n    return true;\n  }\n"], ["FindAndReplaceInObject", "\nfunction findAndReplace(target, find, replaceWith, config) {\n  <handleInvalidCasesAndStartReplacement>\n    if (config === void 0) { config = { onlyPlainObjects: false }; }\n    if ((config.onlyPlainObjects === false && !isAnyObject(target)) ||\n        (config.onlyPlainObjects === true && !isPlainObject(target))) {\n        if (target === find)\n            return replaceWith;\n        return target;\n    }\n  </handleInvalidCasesAndStartReplacement>\n  <recursiveReplacement>\n    return Object.keys(target)\n        .reduce(function (carry, key) {\n        var val = target[key];\n        carry[key] = findAndReplace(val, find, replaceWith, config);\n        return carry;\n    }, {});\n  </recursiveReplacement>\n}\n"], ["HashInput", "\nfunction hash(input, algo, type){\n    \n  <ensureInputFormat>\n    if (typeof input !== 'string' && !(input instanceof Buffer)){\n        input = JSON.stringify(input);\n    }\n  </ensureInputFormat>\n\n  <initializeHash>\n    var sum = _crypto.createHash(algo);\n  </initializeHash>\n\n  <updateHashWithInput>\n    sum.update(input);\n  </updateHashWithInput>\n\n  <outputHash>\n    if (type && type.toLowerCase().trim() == 'binary'){\n        return sum.digest();\n    }else if (type==='base64-urlsafe'){\n        return base64urlsafe(sum.digest('base64'));\n    }else{\n        return sum.digest(type);\n    }\n  </outputHash>\n}\n"], ["CheckForClassNames", "\nfunction (domObject, toCheck) {\n    <processClassNames>\n        var\n            classNames,\n            len,\n            idx;\n        if (\"string\" === typeof toCheck) {\n            toCheck = [toCheck];\n        }\n        _gpfAssert(toCheck instanceof Array, \"Expected array\");\n        classNames = domObject.className.split(\" \");\n        len = toCheck.length;\n        for (idx = 0; idx < len; ++idx) {\n            if (undefined !== gpf.test(classNames, toCheck[idx])) {\n                return true;\n            }\n        }\n        return false;\n    </processClassNames>\n}\n"], "```"]