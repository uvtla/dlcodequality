[["bundleJsFiles", "\nfunction bundleJsFiles () {\n  return concat(jsFiles)\n    .then((output) => {\n      <bundleJsFiles.minification>\n      const uglified = UglifyJS.minify(output)\n      if (uglified.error) {\n        throw new Error(uglified.error)\n      }\n      return uglified.code\n      </bundleJsFiles.minification>\n    })\n}\n"], ["getBidsForAdpod", "\nfunction getBidsForAdpod(bidsReceived, adPodAdUnits) {\n  let adUnitCodes = adPodAdUnits.map((adUnit) => adUnit.code);\n  return bidsReceived\n    .filter((bid) => adUnitCodes.indexOf(bid.adUnitCode) != -1 && (bid.video && bid.video.context === ADPOD))\n}\n"], ["routeMatchHandling", "\nfunction (oRouteMatch) {\n  var that = this;\n  var mRouteArguments = oRouteMatch.getParameter(\"arguments\");\n  <routeMatchHandling.setup>\n  this.sLayer = mRouteArguments.layer;\n  this.sNamespace = mRouteArguments.namespace || \"\";  \n  var oPage = this.getView().getContent()[0];\n  oPage.setBusy(true);\n  that.sNamespace = decodeURIComponent(that.sNamespace);\n  oPage.setTitle(this._shortenNamespace());\n  </routeMatchHandling.setup>\n\n  <routeMatchHandling.dataRetrieval>\n  LRepConnector.getContent(that.sLayer, that.sNamespace).then(\n    that._onContentReceived.bind(that, oPage),\n    function(){\n      oPage.setBusy(false);\n    }).then(function () {\n      LRepConnector.requestPending = false;\n    });\n  </routeMatchHandling.dataRetrieval>\n}\n"], ["createOutputDirsAsync", "\nfunction createOutputDirsAsync(buildOptions) {\n  var outputDirs = new OutputDirs(buildOptions);\n\n  var tasks = [];\n  <createOutputDirsAsync.taskCreation>\n  tasks.push(makeDirAndParents(outputDirs.tmp));\n  tasks.push(makeDirAndParents(outputDirs.gen));\n  tasks.push(makeDirAndParents(outputDirs.build));\n  </createOutputDirsAsync.taskCreation>\n\n  return kew.all(tasks)\n      .then(function() { return outputDirs; });\n}\n"], ["buildDirectoryPath", "\nfunction (dir, appname, version) {\n  if (appname) {\n    dir = path.join(dir, appname);\n    if (version) {\n      <buildDirectoryPath.version>\n      dir = path.join(dir, version);\n      </buildDirectoryPath.version>\n    }\n  }\n  return dir;\n}\n"], ["composeTaskList", "\nfunction composeTaskList({dev, selfContained, jsdoc, includedTasks, excludedTasks}) {\n\tlet selectedTasks = Object.keys(definedTasks).reduce((list, key) => {\n\t\tlist[key] = true;\n\t\treturn list;\n\t}, {});\n\n\t\n\tselectedTasks.generateManifestBundle = false;\n\tselectedTasks.generateStandaloneAppBundle = false;\n\tselectedTasks.transformBootstrapHtml = false;\n\tselectedTasks.generateJsdoc = false;\n\tselectedTasks.executeJsdocSdkTransformation = false;\n\tselectedTasks.generateCachebusterInfo = false;\n\tselectedTasks.generateApiIndex = false;\n\n\tif (selfContained) {\n\t\t<composeTaskList.selfContained>\n\t\tselectedTasks.generateComponentPreload = false;\n\t\tselectedTasks.generateStandaloneAppBundle = true;\n\t\tselectedTasks.transformBootstrapHtml = true;\n\t\tselectedTasks.generateLibraryPreload = false;\n\t\t</composeTaskList.selfContained>\n\t}\n\n\tif (jsdoc) {\n\t\t<composeTaskList.jsdoc>\n\t\tselectedTasks.generateJsdoc = true;\n\t\tselectedTasks.executeJsdocSdkTransformation = true;\n\t\tselectedTasks.generateApiIndex = true;\n\t\tselectedTasks.buildThemes = true;\n\t\tselectedTasks.replaceCopyright = false;\n\t\tselectedTasks.replaceVersion = false;\n\t\tselectedTasks.generateComponentPreload = false;\n\t\tselectedTasks.generateLibraryPreload = false;\n\t\tselectedTasks.generateLibraryManifest = false;\n\t\tselectedTasks.createDebugFiles = false;\n\t\tselectedTasks.uglify = false;\n\t\tselectedTasks.generateFlexChangesBundle = false;\n\t\tselectedTasks.generateManifestBundle = false;\n\t\t</composeTaskList.jsdoc>\n\t}\n\n\tif (dev) {\n\t\t<composeTaskList.dev>\n\t\tObject.keys(selectedTasks).forEach((key) => {\n\t\t\tif (devTasks.indexOf(key) === -1) {\n\t\t\t\tselectedTasks[key] = false;\n\t\t\t}\n\t\t});\n\t\t</composeTaskList.dev>\n\t}\n\n\tfor (let i = 0; i < excludedTasks.length; i++) {\n\t\t<composeTaskList.exclusion>\n\t\tconst taskName = excludedTasks[i];\n\t\tif (taskName === \"*\") {\n\t\t\tObject.keys(selectedTasks).forEach((sKey) => {\n\t\t\t\tselectedTasks[sKey] = false;\n\t\t\t});\n\t\t\tbreak;\n\t\t}\n\t\tif (selectedTasks[taskName] !== false) {\n\t\t\tselectedTasks[taskName] = false;\n\t\t}\n\t\t</composeTaskList.exclusion>\n\t}\n\n\tfor (let i = 0; i < includedTasks.length; i++) {\n\t\t<composeTaskList.inclusion>\n\t\tconst taskName = includedTasks[i];\n\t\tif (taskName === \"*\") {\n\t\t\tObject.keys(selectedTasks).forEach((sKey) => {\n\t\t\t\tselectedTasks[sKey] = true;\n\t\t\t});\n\t\t\tbreak;\n\t\t}\n\t\tif (selectedTasks[taskName] === false) {\n\t\t\tselectedTasks[taskName] = true;\n\t\t}\n\t\t</composeTaskList.inclusion>\n\t}\n\n\tselectedTasks = Object.keys(selectedTasks).filter((task) => selectedTasks[task]);\n\n\treturn selectedTasks;\n}\n"], ["findReactContainer", "\nfunction(id) {\n    <findReactContainer.init>\n    var reactRootID = ReactInstanceHandles.getReactRootIDFromNodeID(id);\n    var container = containersByReactRootID[reactRootID];\n    </findReactContainer.init>\n\n    if (\"production\" !== process.env.NODE_ENV) {\n      <findReactContainer.checksInDev>\n      var rootElement = rootElementsByReactRootID[reactRootID];\n      if (rootElement && rootElement.parentNode !== container) {\n        (\"production\" !== process.env.NODE_ENV ? invariant(\n          \n          \n          internalGetID(rootElement) === reactRootID,\n          'ReactMount: Root element ID differed from reactRootID.'\n        ) : invariant(\n        \n        internalGetID(rootElement) === reactRootID));\n\n        var containerChild = container.firstChild;\n        if (containerChild &&\n            reactRootID === internalGetID(containerChild)) {\n          \n          \n          \n          \n          rootElementsByReactRootID[reactRootID] = containerChild;\n        } else {\n          (\"production\" !== process.env.NODE_ENV ? warning(\n            false,\n            'ReactMount: Root element has been removed from its original ' +\n            'container. New container:', rootElement.parentNode\n          ) : null);\n        }\n      }\n      </findReactContainer.checksInDev>\n    }\n\n    return container;\n  }\n"], ["tiledRendererInit", "\nfunction init(cols, rows, tilewidth, tileheight) {\n  this._super(me.TMXRenderer, \"init\", [cols, rows, tilewidth, tileheight]);\n  <tiledRendererInit.setup>\n  this.hTilewidth = tilewidth / 2;\n  this.hTileheight = tileheight / 2;\n  this.originX = this.rows * this.hTilewidth;\n  </tiledRendererInit.setup>\n}\n"], ["getOptions", "\nfunction getOptions(opts, cb) {\n  if (typeof opts !== 'object') {\n    throw new Error('Invalid: options is not an object.');\n  }\n  <getOptions.setup>\n  var options = clonedeep(opts || {});\n\n  options.sourceComments = options.sourceComments || false;\n  if (options.hasOwnProperty('file')) {\n    options.file = getInputFile(options);\n  }\n  options.outFile = getOutputFile(options);\n  options.includePaths = buildIncludePaths(options);\n  options.precision = parseInt(options.precision) || 5;\n  options.sourceMap = getSourceMap(options);\n  options.style = getStyle(options);\n  options.indentWidth = getIndentWidth(options);\n  options.indentType = getIndentType(options);\n  options.linefeed = getLinefeed(options);\n  </getOptions.setup>\n\n  \n  <getOptions.contextAndResult>\n  options.context = { options: options, callback: cb };\n\n  options.result = {\n    stats: getStats(options)\n  };\n  </getOptions.contextAndResult>\n\n  return options;\n}\n"], ["generateNextId", "\nfunction nextId() {\n    var maxId = 0;\n    <generateNextId.calculate>\n    for (var i = 0; i < comments.length; i++) {\n      var comment = comments[i];\n      if (maxId < comment.id) {\n        maxId = comment.id;\n      }\n    }\n    </generateNextId.calculate>\n    return maxId + 1;\n  }\n"], "```"]