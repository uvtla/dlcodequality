[["toggleClassesOnElement", "\nfunction(el, value) {\n    <removeClasses>\n    if (el.cbClasses) {\n        __ep(el).removeClass(el.cbClasses);\n    }\n    </removeClasses>\n\n    el.cbClasses = value;\n\n    <addClasses>\n    if (value) {\n        __ep(el).addClass(value);\n    }\n    </addClasses>\n}\n"], ["generateDocumentation", "\nfunction generateFormatterExamples(formatterInfo, prereleaseVersion) {\n    <renderOutput>\n    const output = ejs.render(cat(\"./templates/formatter-examples.md.ejs\"), formatterInfo);\n    </renderOutput>\n    <setupFilenames>\n    let filename = \"../eslint.github.io/docs/user-guide/formatters/index.md\",\n        htmlFilename = \"../eslint.github.io/docs/user-guide/formatters/html-formatter-example.html\";\n    </setupFilenames>\n\n    <adjustForPrerelease>\n    if (prereleaseVersion) {\n        filename = filename.replace(\"/docs\", `/docs/${prereleaseVersion}`);\n        htmlFilename = htmlFilename.replace(\"/docs\", `/docs/${prereleaseVersion}`);\n        if (!test(\"-d\", path.dirname(filename))) {\n            mkdir(path.dirname(filename));\n        }\n    }\n    </adjustForPrerelease>\n\n    <writeOutput>\n    output.to(filename);\n    formatterInfo.formatterResults.html.result.to(htmlFilename);\n    </writeOutput>\n}\n"], ["createBanner", "\nfunction createBanner(generator) {\n   'use strict';\n   var placeholder = generator.placeholder;\n\n   <determineBanner>\n   if(placeholder.banner) {\n      return placeholder.banner;\n   }\n   </determineBanner>\n\n   <createNewBanner>\n   return createBannerFromPrompts(placeholder);\n   </createNewBanner>\n\n   function createBannerFromPrompts(placeholder) {\n      var banner = '';\n      return banner;\n   }\n}\n"], ["getRootDirectory", "\nfunction _getRoot(obj) {\n    return (getCallingDir(((obj && obj.basedir) ? obj.basedir : undefined)) || (obj ? obj.basedir : undefined));\n}\n"], ["calculateProjection", "\nfunction getProjection() {\n    <initializeVariables>\n    let projection = current\n    let speed = currentSpeed\n    </initializeVariables>\n    <projectPosition>\n    for (let i = 0; i < 600; i++) {\n        const targetSpeed = speed * (1 - springK)\n        speed = linearlyApproach(speed, targetSpeed, acceleration)\n        projection += speed\n    }\n    </projectPosition>\n    return projection\n}\n"], ["calculateZoom", "\nfunction(moZoom) {\n    <initializeZoom>\n    var zoom = null;\n    </initializeZoom>\n    <determineZoomLevel>\n    if (moZoom != null) {\n        zoom = moZoom - this.minZoomLevel;\n        if (this.map.baseLayer !== this) {\n            zoom = this.map.baseLayer.getZoomForResolution(\n                this.getResolutionForZoom(zoom)\n            );\n        }\n    }\n    </determineZoomLevel>\n    return zoom;\n}\n"], ["findAllRecords", "\nfunction findAll() {\n    <setup>\n    var _this = this;\n    var options = arguments[0] === undefined ? {} : arguments[0];\n    var forceFetch = arguments[1] === undefined ? false : arguments[1];\n    </setup>\n    <fetchRecords>\n    if (this._hasSynced && !forceFetch) {\n        return Promise.resolve(this.records);\n    } else {\n        return Promise.resolve(this.records.fetch(options)).then(function () {\n            return _this.records;\n        });\n    }\n    </fetchRecords>\n}\n"], ["dereferenceJsonSchema", "\nfunction(schema, field, reference, seenObjects, path, options) {\n\n    <handleRootReference>\n    if (reference == '#') return {$ref: '#'}\n    </handleRootReference>\n\n    <parseReferencePath>\n    var path = reference.substr(1).split('/').slice(1);\n    path = path.map(function (x) {\n        x = x.replace(/~1/g, '/').replace(/~0/g, '~');\n        return decodeURI(x);\n    })\n    </parseReferencePath>\n\n    <navigateSchema>\n    var pointer = schema;\n    for (var i = 0; i < path.length; i++) {\n        pointer = pointer[path[i]];\n    }\n    </navigateSchema>\n\n    <trackSeenObjects>\n    var objects = seenObjects.filter(function (x) {\n        return x.obj === pointer;\n    });\n    if (objects.length == 1) {\n        seenObjects[0].count = objects[0].count + 1;\n    } else {\n        seenObjects.push({ obj: pointer, count: 1 });\n    }\n    </trackSeenObjects>\n\n    <resolveNestedReferences>\n    if (pointer['$ref']) {\n        return deref(schema, field, pointer['$ref'], seenObjects, path, options);\n    } else {\n        extractReferences(schema, pointer, seenObjects, path, options);\n    }\n    </resolveNestedReferences>\n\n    return pointer;\n}\n"], ["runInstallerScript", "\nfunction runInstaller(fileName, cb) {\n    <setupShell>\n    const shell = win ? 'powershell.exe' : 'bash';\n    </setupShell>\n    <resolveFilePath>\n    const filePath = path.resolve(__dirname, fileName);\n    console.log(`Now running: ${shell} ${filePath}`);\n    </resolveFilePath>\n    <executeInstaller>\n    cp.spawnSync(shell, [filePath], { stdio: 'inherit' });\n    </executeInstaller>\n    <callbackInvocation>\n    typeof cb === 'function' && cb();\n    </callbackInvocation>\n}\n"], ["addCoreFormatsToLocale", "\nfunction addCoreFormats() {\n    <iterateFormats>\n    forEach(CoreParsingFormats, function (df) {\n        <initializeFormat>\n        var src = df.src;\n        </initializeFormat>\n        <validateLocale>\n        if (df.localeCheck && !df.localeCheck(loc)) {\n            return;\n        }\n        </validateLocale>\n        <adjustFormatForLocale>\n        if (df.mdy && loc.mdy) {\n            src = df.mdy;\n        }\n        </adjustFormatForLocale>\n        <addTimeFormat>\n        if (df.time) {\n            loc.addFormat(getFormatWithTime(src, true));\n            loc.addFormat(getFormatWithTime(src));\n        } else {\n            loc.addFormat(src);\n        }\n        </addTimeFormat>\n    });\n    </iterateFormats>\n    <addFallbackTimeFormat>\n    loc.addFormat('{time}');\n    </addFallbackTimeFormat>\n}\n"], "```\n\nOverall, the annotated JavaScript functions are aimed at isolating responsibilities to conform with the Single Responsibility Principle. Responsibilities that constitute larger sections performing unique logical operations are wrapped with tags, ensuring that sub-responsibilities within functions are also well categorized when applicable."]