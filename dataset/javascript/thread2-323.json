[["copy", "\nfunction copy(obj) {\n  <checkForNull>\n  if (obj == null) {\n    return obj;\n  }</checkForNull>\n\n  <handleArray>\n  if (array(obj)) {\n    return obj.slice();\n  }</handleArray>\n  <handlePlainObject>\n  else if (plainObject(obj)) {\n    return clone(obj);\n  }</handlePlainObject>\n  <returnObject>\n  else {\n    return obj;\n  }</returnObject>\n}\n"], ["SetResponse", "\nfunction SetResponse(model, args, isJSONGraph, isProgressive) {\n  <initializeProperties>\n  this._model = model;\n  this._isJSONGraph = isJSONGraph || false;\n  this._isProgressive = isProgressive || false;\n  this._initialArgs = args;\n  this._value = [{}];</initializeProperties>\n\n  <setupGroups>\n  var groups = [];\n  var group, groupType;\n  var argIndex = -1;\n  var argCount = args.length;\n\n  while (++argIndex < argCount) {\n    <determineArgumentType>\n    var arg = args[argIndex];\n    var argType;\n    if (isArray(arg) || typeof arg === \"string\") {\n      arg = pathSyntax.fromPath(arg);\n      argType = \"PathValues\";\n    } else if (isPathValue(arg)) {\n      arg.path = pathSyntax.fromPath(arg.path);\n      argType = \"PathValues\";\n    } else if (isJSONGraphEnvelope(arg)) {\n      argType = \"JSONGs\";\n    } else if (isJSONEnvelope(arg)) {\n      argType = \"PathMaps\";\n    }</determineArgumentType>\n\n    <groupArguments>\n    if (groupType !== argType) {\n      groupType = argType;\n      group = {\n        inputType: argType,\n        arguments: []\n      };\n      groups.push(group);\n    }\n    group.arguments.push(arg);\n  }</groupArguments>\n  this._groups = groups;</setupGroups>\n}\n"], ["lintFile", "\nfunction lintFile (linter, fileName) {\n  <readFileAndValidate>\n  const fileContents = fs.readFileSync(fileName, {encoding: 'utf8'}).toString()\n  const report = linter.validate(fileContents)\n  const errors = report.error.count\n  const warnings = report.warn.count</readFileAndValidate>\n\n  <logIssues>\n  if (errors || warnings) {\n    this.printFilePath(fileName)\n\n    report.error.data.forEach(logItem.bind(this))\n    report.warn.data.forEach(logItem.bind(this))\n\n    console.log('') \n  }</logIssues>\n\n  <returnReport>\n  return report</returnReport>\n}\n"], ["generate", "\nfunction generate(initialStateOrOptions, condition, iterate, resultSelectorOrObservable, scheduler) {\n  <parseArguments>\n  var resultSelector;\n  var initialState;\n  if (arguments.length == 1) {\n      var options = initialStateOrOptions;\n      initialState = options.initialState;\n      condition = options.condition;\n      iterate = options.iterate;\n      resultSelector = options.resultSelector || _util_identity__WEBPACK_IMPORTED_MODULE_1__[\"identity\"];\n      scheduler = options.scheduler;\n  }\n  else if (resultSelectorOrObservable === undefined || Object(_util_isScheduler__WEBPACK_IMPORTED_MODULE_2__[\"isScheduler\"])(resultSelectorOrObservable)) {\n      initialState = initialStateOrOptions;\n      resultSelector = _util_identity__WEBPACK_IMPORTED_MODULE_1__[\"identity\"];\n      scheduler = resultSelectorOrObservable;\n  }\n  else {\n      initialState = initialStateOrOptions;\n      resultSelector = resultSelectorOrObservable;\n  }</parseArguments>\n  \n  <createObservable>\n  return new _Observable__WEBPACK_IMPORTED_MODULE_0__[\"Observable\"](function (subscriber) {\n    <observableLogic>\n    var state = initialState;\n    if (scheduler) {\n      return scheduler.schedule(dispatch, 0, {\n          subscriber: subscriber,\n          iterate: iterate,\n          condition: condition,\n          resultSelector: resultSelector,\n          state: state\n      });\n    }\n    do {\n      <conditionalLogic>\n      if (condition) {\n          var conditionResult = void 0;\n          try {\n              conditionResult = condition(state);\n          }\n          catch (err) {\n              subscriber.error(err);\n              return undefined;\n          }\n          if (!conditionResult) {\n              subscriber.complete();\n              break;\n          }\n      }</conditionalLogic>\n      \n      <executionAndErrorHandling>\n      var value = void 0;\n      try {\n          value = resultSelector(state);\n      }\n      catch (err) {\n          subscriber.error(err);\n          return undefined;\n      }\n      subscriber.next(value);\n      if (subscriber.closed) {\n          break;\n      }\n      try {\n          state = iterate(state);\n      }\n      catch (err) {\n          subscriber.error(err);\n          return undefined;\n      }\n      </executionAndErrorHandling>\n    } while (true);\n    return undefined;</observableLogic>\n  });</createObservable>\n}\n"], ["anonymous", "\nfunction(model, settings, objs, options, cb) {\n  <defaultParameters>\n  var m;\n  if (settings == null) {\n    settings = {};\n  }\n  if (objs == null) {\n    objs = {};\n  }\n  if (options == null) {\n    options = {};\n  }\n  if (cb == null) {\n    cb = function() {};\n  }</defaultParameters>\n\n  <validateModel>\n  Hoek.assert(model, i18n.assertModuleRequired);</validateModel>\n  \n  <handleFunctionAsOption>\n  if (_.isFunction(options)) {\n    cb = options;\n    options = {};\n  }</handleFunctionAsOption>\n\n  <createAndSaveModel>\n  m = new model(objs);\n  return m.save(function(err) {\n    if (err) {\n      return cb(err);\n    }\n    return cb(null, m, true);\n  });</createAndSaveModel>\n}\n"], ["calculateScale", "\nfunction( viewportZoom ) {\n  <scaleComputation>\n  var ratio = this._scaleSpring.current.value *\n          this.viewport._containerInnerSize.x / this.source.dimensions.x;\n  return ratio * viewportZoom;</scaleComputation>\n}\n"], ["calculateAdjustedMonth", "\nfunction(year, month) {\n\t<calculate>\n\tvar date = this._validate(year, month, this.minDay,\n\t\t$.calendars.local.invalidMonth || $.calendars.regionalOptions[''].invalidMonth);\n\treturn (date.month() + this.monthsInYear(date) - this.firstMonth) %\n\t\tthis.monthsInYear(date) + this.minMonth;</calculate>\n}\n"], ["applyModelMethods", "\nfunction applyModelMethods (model, definition) {\n\tfor (var i in definition.methods) {\n\t\t<validateMethod>\n\t\tif (i === 'definition') {\n\t\t\tthrow new Error('Invalid model definition provided. \"definition\" is a reserved word');\n\t\t}</validateMethod>\n\n\t\t<assignMethod>\n\t\tmodel.prototype[i] = definition.methods[i];</assignMethod>\n\t}\n}\n"], ["mergeConstraints", "\nfunction mergeConstraints(env, oldConstraints, newConstraints) {\n\t<initializeConstraints>\n\tconst res = {\n\t\tmin: Math.max(oldConstraints.min || 0, newConstraints.min || 0),\n\t\tmax: Math.min(\n\t\t\toldConstraints.max !== undefined ? oldConstraints.max : 2,\n\t\t\tnewConstraints.max !== undefined ? newConstraints.max : 2\n\t\t),\n\t\tforce: oldConstraints.force || newConstraints.force,\n\t};</initializeConstraints>\n\n\t<adjustIncompatibleConstraints>\n\tif (res.min > res.max) {\n\t\t\n\t\tif (!oldConstraints.force) {\n\t\t\t\n\t\t\tif (newConstraints.max !== undefined && newConstraints.max > res.min) {\n\t\t\t\tres.max = newConstraints.max;\n\t\t\t} else if (newConstraints.min && newConstraints.min < res.min) {\n\t\t\t\tres.min = newConstraints.min;\n\t\t\t}\n\t\t}\n\t\tres.max = res.min;\n\t\tenv.log(\"info/html2wt\", 'Incompatible constraints (merge):', res,\n\t\t\tloggableConstraints(oldConstraints), loggableConstraints(newConstraints));\n\t}</adjustIncompatibleConstraints>\n\n\t<returnConstraints>\n\treturn res;</returnConstraints>\n}\n"], ["walk", "\nfunction walk(arr, key, fn) {\n  <walkArray>\n  var l = arr.length,\n      children;\n\n  while (l--) {\n      children = arr[l][key];\n\n      if (children) {\n          walk(children, key, fn);\n      }\n      fn(arr[l]);\n  }</walkArray>\n}\n"], "```"]