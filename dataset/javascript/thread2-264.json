[["record", "\nfunction record(buffer, variable, recordDimension) {\n  \n  const type = types.str2num(variable.type);\n  const width = variable.size ? variable.size / types.num2bytes(type) : 1;\n\n  var size = recordDimension.length;\n  var data = new Array(size);\n  const step = recordDimension.recordStep;\n\n  for (var i = 0; i < size; i++) {\n    var currentOffset = buffer.offset;\n    data[i] = types.readType(buffer, type, width);\n    buffer.seek(currentOffset + step);\n  }\n\n  return data;\n}\n"], ["usageRead", "\nfunction usageRead(opts, cb) {\n  <handleOptsFunction>\n  if (typeof opts === 'function') {\n    cb = opts;\n    opts = {\n      sectorSizeBytes: 512,\n      sampleMs: 1000,\n      device: 'sda',\n      units: 'bytes',\n    };\n  } else {\n    opts.sectorSizeBytes = opts.sectorSizeBytes || 512;\n    opts.sampleMs = opts.sampleMs || 1000;\n    opts.device =  opts.device || 'sda';\n    opts.units =  opts.units || 'bytes';\n  }\n  </handleOptsFunction>\n\n  <measureDiskReadPerformance>\n  var time;\n  var delta1;\n  var delta0 = _parseProcDiskstats()[opts.device].sectorsRead;\n  time = process.hrtime();\n  setTimeout(function() {\n    delta1 = _parseProcDiskstats()[opts.device].sectorsRead;\n\n    var diff = process.hrtime(time);\n    var diffSeconds = diff[0] + diff[1] * 1e-9;\n\n    var totalBytes = (delta1 - delta0) * opts.sectorSizeBytes;\n    var totalBytesPerSecond = totalBytes / (diffSeconds * diffSeconds);\n    var converted = _bytesTo(totalBytesPerSecond, opts.units);\n\n    return cb(converted);\n  }, opts.sampleMs);\n  </measureDiskReadPerformance>\n}\n"], ["contoursTransform", "\nfunction contoursTransform(contours, transforms) {\n  if (!contours || !contours.length || !transforms || !transforms.length) {\n    return contours;\n  }\n\n  contours.forEach(function (p) {\n    <applyTransformsToPath>\n    for (var i = 0, l = transforms.length; i < l; i++) {\n      var transform = transforms[i];\n      var params = transform.params;\n      switch (transform.name) {\n        case 'translate':\n          pathAdjust(p, 1, 1, params[0], params[1]);\n          break;\n        case 'scale':\n          pathAdjust(p, params[0], params[1]);\n          break;\n        case 'matrix':\n          pathTransform(p, params[0], params[1], params[2], params[3], params[4], params[5]);\n          break;\n      }\n    }\n    </applyTransformsToPath>\n  });\n\n  return contours;\n}\n"], ["RequestorCreator", "\nfunction (sServiceUrl, oModelInterface, mHeaders, mQueryParams, sODataVersion) {\n  <createRequestor>\n  var oRequestor = new Requestor(sServiceUrl, mHeaders, mQueryParams, oModelInterface);\n  </createRequestor>\n\n  <adaptToODataVersion>\n  if (sODataVersion === \"2.0\") {\n    asV2Requestor(oRequestor);\n  }\n  </adaptToODataVersion>\n\n  return oRequestor;\n}\n"], ["createGridHelper", "\nfunction () {\n  var scene = this.el.object3D;\n  var data = this.data;\n\n  var size = data.size;\n  var divisions = data.divisions;\n  var colorCenterLine = data.colorCenterLine;\n  var colorGrid = data.colorGrid;\n\n  var gridHelper = new THREE.GridHelper( size, divisions, colorCenterLine, colorGrid );\n  gridHelper.name = \"gridHelper\";\n  scene.add(gridHelper);\n}\n"], ["raycasterCheck", "\nfunction (time) {\n  var el = this.el;\n  var data = this.data;\n  var intersectedEls;\n  var intersections;\n  var prevCheckTime = this.prevCheckTime;\n  var prevIntersectedEls;\n\n  <checkInterval>\n  if (prevCheckTime && (time - prevCheckTime < data.interval)) { return; }\n  </checkInterval>\n\n  <updateState>\n  prevIntersectedEls = this.intersectedEls.slice();\n  this.updateOriginDirection();\n  intersections = this.raycaster.intersectObjects(this.objects, data.recursive);\n  </updateState>\n\n  <filterIntersections>\n  intersections = intersections.filter(function hasEl (intersection) {\n    return !!intersection.object.el;\n  });\n  </filterIntersections>\n\n  <getIntersectedEls>\n  intersectedEls = this.intersectedEls = intersections.map(function getEl (intersection) {\n    return intersection.object.el;\n  });\n  </getIntersectedEls>\n\n  <emitEnterEvents>\n  intersections.forEach(function emitEvents (intersection) {\n    var intersectedEl = intersection.object.el;\n    intersectedEl.addState('hovered');\n    intersectedEl.emit('raycaster-intersected', {el: el, intersection: intersection});\n  });\n  </emitEnterEvents>\n\n  <emitIntersectEvent>\n  if (intersections.length) {\n    el.emit('raycaster-intersection', {\n      els: intersectedEls,\n      intersections: intersections\n    });\n  }\n  </emitIntersectEvent>\n\n  <emitLeaveEvents>\n  prevIntersectedEls.forEach(function checkStillIntersected (intersectedEl) {\n    if (intersectedEls.indexOf(intersectedEl) !== -1) { return; }\n    intersectedEl.removeState('hovered');\n    el.emit('raycaster-intersection-cleared', {el: intersectedEl});\n    intersectedEl.emit('raycaster-intersected-cleared', {el: el});\n  });\n  </emitLeaveEvents>\n}\n"], ["WSMuxChannelConstructor", "\nfunction WSMuxChannel(id, mux) {\n  EventEmitter.call(this);\n  this.id = id;\n  this.mux = mux;\n  this.closed = false;\n  this.url = this.mux.url;\n\n  <defineReadyStateGetter>\n  this.__defineGetter__('readyState', function() {\n    return this.mux._readyState();\n  });\n  </defineReadyStateGetter>\n\n  <setupEventHandlers>\n  var _this = this;\n  this.on('open', function() {\n    _this.onopen && _this.onopen.apply(_this, arguments);\n  });\n\n  this.on('close', function() {\n    _this.onclose && _this.onclose.apply(_this, arguments);\n  });\n\n  this.on('error', function() {\n    _this.onerror && _this.onerror.apply(_this, arguments);\n  });\n\n  this.on('message', function() {\n    arguments[0] = {data: arguments[0]}\n    _this.onmessage && _this.onmessage.apply(_this, arguments);\n  });\n  </setupEventHandlers>\n}\n"], ["moduleInitialization", "\nfunction() {\n  module.debug('Initializing', $module);\n  module.createID();\n  module.bind.events();\n  <createModuleIfNotExists>\n  if(!module.exists() && settings.preserve) {\n    module.create();\n  }\n  </createModuleIfNotExists>\n  <observeChangesIfNecessary>\n  if(settings.observeChanges) {\n    module.observeChanges();\n  }\n  </observeChangesIfNecessary>\n  module.instantiate();\n}\n"], ["getExistingMessage", "\nfunction getExistingMessage(svc, name) {\n  var msg = svc.message(name);\n  if (!msg) {\n    throw new Error(f('unknown message: %s', name));\n  }\n  return msg;\n}\n"], ["BitArrayConstructor", "\nfunction BitArray(x, len, oct) {\n  <parseBits>\n  this.__bits = BitArray.parse(x, oct)\n  </parseBits>\n  <defineLengthGetter>\n  this.__defineGetter__('length', function() {\n    return this.__bits.length\n  })\n  </defineLengthGetter>\n  <fillBitsIfLengthProvided>\n  len && this.fill(len)\n  </fillBitsIfLengthProvided>\n  this.__len = len\n}\n"], "```"]