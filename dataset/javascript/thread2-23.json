[["function1", "\nfunction (serviceName, methodNames, pointCut) {\n    <defineVariables>\n    var fullName, ret = [];</defineVariables>\n\n    <forEachMethodName>\n    methodNames.forEach(function (name) {\n        fullName = serviceName + \".\" + name;\n        <matchChecking>\n        var match = this.match(fullName, pointCut);\n        if (match) {\n            ret.push(name);\n        }</matchChecking>\n    }, this);</forEachMethodName>\n\n    <returnResults>\n    return ret;</returnResults>\n}\n"], ["buildScales", "\nfunction buildScales() {\n    <defineYMax>\n    let yMax = d3Array.max(data.map(getValue));</defineYMax>\n\n    <configureScales>\n    if (isHorizontal) {\n        <horizontalScales>\n        xScale = d3Scale.scaleLinear()\n            .domain([0, yMax])\n            .rangeRound([0, chartWidth - 1]);\n\n        yScale = d3Scale.scaleBand()\n            .domain(data.map(getName))\n            .rangeRound([chartHeight, 0])\n            .padding(0.1);\n\n        yScale2 = d3Scale.scaleBand()\n            .domain(data.map(getGroup))\n            .rangeRound([yScale.bandwidth(), 0])\n            .padding(0.1);</horizontalScales>\n    } else {\n        <verticalScales>\n        xScale = d3Scale.scaleBand()\n            .domain(data.map(getName))\n            .rangeRound([0, chartWidth])\n            .padding(0.1);\n        xScale2 = d3Scale.scaleBand()\n            .domain(data.map(getGroup))\n            .rangeRound([0, xScale.bandwidth()])\n            .padding(0.1);\n\n        yScale = d3Scale.scaleLinear()\n            .domain([0, yMax])\n            .rangeRound([chartHeight, 0])\n            .nice();</verticalScales>\n    }</configureScales>\n\n    <setColors>\n    colorScale = d3Scale.scaleOrdinal()\n        .range(colorSchema)\n        .domain(data.map(getGroup));\n\n    categoryColorMap = colorScale\n        .domain(data.map(getName)).domain()\n        .reduce((memo, item) => {\n            data.forEach(function (v) {\n                if (getName(v) == item) {\n                    memo[v.name] = colorScale(v.group)\n                    memo[v.group] = colorScale(v.group)\n                    memo[v.group + item] = colorScale(v.group)\n                }\n            })\n            return memo;\n        }, {});</setColors>\n}\n"], ["prepareProject", "\nfunction prepareProject(cordovaPlatforms, args, projectPath) {\n    <platformConversion>\n    if (typeof (cordovaPlatforms) == \"string\") {\n        cordovaPlatforms = [cordovaPlatforms];\n    }</platformConversion>\n\n    <setDefaultProjectPath>\n    if (!projectPath) {\n        projectPath = defaultConfig.projectPath;\n    }</setDefaultProjectPath>\n\n    <versionManagement>\n    var appendedVersion = cache.getModuleVersionFromConfig(defaultConfig);\n    if (appendedVersion) {\n        appendedVersion = '@' + appendedVersion;\n    } else {\n        appendedVersion = '';\n    }</versionManagement>\n\n    <checkCompatibility>\n    return utilities.isCompatibleNpmPackage(defaultConfig.nodePackageName + appendedVersion).then(function (compatibilityResult) {\n        switch (compatibilityResult) {\n            case utilities.NodeCompatibilityResult.IncompatibleVersion4Ios:\n            case utilities.NodeCompatibilityResult.IncompatibleVersion5:\n                throw new Error('This Cordova version does not support Node.js ...');\n        }\n\n        return setupCordova();\n    })</checkCompatibility>\n    .then(function (cordova) {\n        <addSupportPlugin>\n        return addSupportPluginIfRequested(cordova, defaultConfig);</addSupportPlugin>\n    })\n    .then(function (cordova) {\n        \n        <preparePlatforms>\n        var promise = _addPlatformsToProject(cordovaPlatforms, projectPath, cordova);\n        \n        cordovaPlatforms.forEach(function (platform) {\n            promise = promise.then(function () {\n                \n                <logAndPreparePlatform>\n                var callArgs = utilities.getCallArgs(platform, args);\n                var argsString = _getArgsString(callArgs.options);\n                console.log('Queueing prepare for platform ' + platform + ' w/options: ' + argsString);\n                return cordova.raw.prepare(callArgs);</logAndPreparePlatform>\n            });\n        });\n\n        return promise;</preparePlatforms>\n    });\n}\n"], ["SearchBar", "\nfunction SearchBar(language){\n    <initializeProperties>\n\tthis.type = \"SearchBar\";\n\tthis.options = {};\n\tthis.element = null;\n\tthis.isNested = false;\n\tthis.language = language ? language : \"en\";</initializeProperties>\n\n\t<defineTranslations>\n\tthis.translations = {\n\t\t\t\t\t\tda: {\n\t\t\t\t\t\t\tsearch: \"S\u00f8g\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\ten: {\n\t\t\t\t\t\t\tsearch: \"Search\"\n\t\t\t\t\t\t}\n\t\t\t\t\t}</defineTranslations>\n}\n"], ["mkdir", "\nfunction mkdir(dir, options) {\n    <sanitizeOptions>\n    options = _.sanitize(options, {owner: null, username: null, group: null});</sanitizeOptions>\n    <checkExistenceAndCreateDirectory>\n    if (!exists(dir)) {\n        fs.mkdirpSync(dir);\n    } else {\n        if (isFile(dir)) {\n            throw new Error(`Path '${dir}' already exists and is a file`);\n        }\n    }</checkExistenceAndCreateDirectory>\n    \n    <ownerGroupUsernameManagement>\n    if (options.owner || options.group || options.username) {\n        let uid = null;\n        let gid = null;\n\n        <extractOwnerAndGroup>\n        if (_.isString(options.owner)) {\n            uid = options.owner;\n        } else if (_.isObject(options.owner)) {\n            uid = (options.owner.uid || options.owner.owner || options.owner.user || options.owner.username);\n            gid = (options.owner.gid || options.owner.group);\n        }\n        if (_.isString(options.username)) {\n            uid = options.username;\n        }\n        if (_.isString(options.group)) {\n            gid = options.group;\n        }</extractOwnerAndGroup>\n\n        <changeOwnership>\n        chown(dir, uid, gid, {abortOnError: false});</changeOwnership>\n    }</ownerGroupUsernameManagement>\n}\n"], ["isAppInstalled", "\nfunction isAppInstalled(app, prefixes) {\n    <asyncCheckAppInstallation>\n    return new Promise((resolve) => {\n        if (!(app in prefixes)) {\n            return resolve(false)\n        }\n\n        Linking.canOpenURL(prefixes[app])\n            .then((result) => {\n                resolve(!!result)\n            })\n            .catch(() => resolve(false))\n    })</asyncCheckAppInstallation>\n}\n"], ["function6", "\nfunction() {\n    <cacheDimensionNames>\n    if (this._aDimensionNames) {\n        return this._aDimensionNames;\n    }</cacheDimensionNames>\n\n    <initializeDimensionNamesList>\n    this._aDimensionNames = [];</initializeDimensionNamesList>\n\n    <populateDimensionNames>\n    for (var sName in this._oDimensionSet) {\n        this._aDimensionNames.push(this._oDimensionSet[sName].getName());\n    }</populateDimensionNames>\n\n    <returnDimensionNamesList>\n    return this._aDimensionNames;</returnDimensionNamesList>\n}\n"], ["function7", "\nfunction (params) {\n\n    <initializeAttrs>\n    var attrs;</initializeAttrs>\n\n    <determineAttrType>\n    if ('object' == typeof params) {\n        attrs = params;\n    }\n    if ('string' == typeof params) {\n        <processStringParam>\n        if (arguments.length > 1) {\n            attrs = {};\n            attrs[params] = arguments[1];\n        }else{\n            <getAttributes>\n            return getElAttributes(this[0],params);</getAttributes>\n        }</processStringParam>\n    }</determineAttrType>\n\n    <setAttributesOnElements>\n    if (attrs) {\n        this.each(function (inx, ele) {\n            setAttributes(ele, attrs);\n        });\n    }</setAttributesOnElements>\n}\n"], ["RouterState", "\nfunction RouterState(root, snapshot) {\n    <callSuperWithRoot>\n    _super.call(this, root);</callSuperWithRoot>\n    <assignSnapshot>\n    this.snapshot = snapshot;</assignSnapshot>\n    <setRouterStateSnapshot>\n    setRouterStateSnapshot(this, root);</setRouterStateSnapshot>\n}\n"], ["scroll", "\nfunction scroll($container, $el, dir, callback) {\n    <initialScrollSetup>\n    var container = $container[0],\n        maxScroll = container.scrollHeight - container.clientHeight;</initialScrollSetup>\n\n    <startScrollInterval>\n    if (maxScroll && dir && !interval) {\n        \n        <defineScrollInterval>\n        interval = window.setInterval(function () {\n            var scrollTop = $container.scrollTop();\n            if ((dir === -1 && scrollTop <= 0) || (dir === 1 && scrollTop >= maxScroll)) {\n                endScroll($el);\n            } else {\n                <performScroll>\n                $container.scrollTop(scrollTop + 7 * dir);</performScroll>\n                <invokeCallback>\n                callback($el);</invokeCallback>\n            }\n        }, 50);</defineScrollInterval>\n    }</startScrollInterval>\n}"], ""]