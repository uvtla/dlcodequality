[["Agent", "\nfunction Agent(file, args, env, cwd, cols, rows, debug) {\n  var self = this;\n\n  <incrementPipeCounter>\n  pipeIncr++;\n  </incrementPipeCounter>\n\n  <generateTimestamp>\n  var timestamp = Date.now();\n  </generateTimestamp>\n\n  <setupDataPipe>\n  this.dataPipe = '\\\\\\\\.\\\\pipe\\\\winpty-data-' + pipeIncr + '' + timestamp;\n  </setupDataPipe>\n\n  <initializePtySocket>\n  this.ptySocket = new net.Socket();\n  </initializePtySocket>\n\n  <createPtyDataPipeServer>\n  this.ptyDataPipe = net.createServer(function (socket) {\n    socket.setEncoding('utf8');\n    socket.pause();\n\n    file = file;\n    args = args.join(' ');\n    cwd = path.resolve(cwd);\n\n    pty.startProcess(self.pid, file, args, env, cwd);\n\n    self.ptySocket.emit('ready_datapipe', socket);\n  }).listen(this.dataPipe);\n  </createPtyDataPipeServer>\n\n  <openPtyTerminal>\n  var term = pty.open(self.dataPipe, cols, rows, debug);\n  </openPtyTerminal>\n\n  <assignPtyProperties>\n  this.pid = term.pid;\n  this.fd = term.fd;\n  this.pty = term.pty;\n  </assignPtyProperties>\n}\n"], ["rotatePixels", "\nfunction rotatePixels(buffer, width, height, degrees) {\n  let loops = degrees / 90\n  while (loops > 0) {\n    <createNewBuffer>\n    const newBuffer = Buffer.alloc(buffer.length)\n    </createNewBuffer>\n    <rotateBuffer>\n    let newOffset = 0\n    for (let x = 0; x < width; x += 1) {\n      for (let y = height - 1; y >= 0; y -= 1) {\n        const offset = (width * y + x) << 2\n        const pixel = buffer.readUInt32BE(offset, true)\n        newBuffer.writeUInt32BE(pixel, newOffset, true)\n        newOffset += 4\n      }\n    }\n    buffer = newBuffer\n    const newHeight = width\n    width = height\n    height = newHeight\n    loops -= 1\n    </rotateBuffer>\n  }\n  return buffer\n}\n"], ["fileFunction", "\nfunction(file, enc, cb) {\n  <checkConditionsAndTapFile>\n  if (\n    !file.isNull() &&\n    !file.isDirectory() &&\n    options.extensions.some(function(ext) {\n      return path.extname(file.path).substr(1).toLowerCase() === ext;\n    })\n  ) {\n    file = retina.tapFile(file, cb);\n  } else {\n    cb();\n  }\n  </checkConditionsAndTapFile>\n  \n  <pushToFile>\n  if (file) this.push(file);\n  </pushToFile>\n}\n"], ["addRectHandles", "\nfunction addRectHandles($canvas, parent) {\n  <calculateAspectRatio>\n  var handlePlacement = parent.handlePlacement;\n  \n  if (parent.aspectRatio === null && parent.height !== 0) {\n    parent.aspectRatio = parent.width / parent.height;\n  }\n  </calculateAspectRatio>\n\n  <addCornersAndSidesHandles>\n  if (handlePlacement === 'corners' || handlePlacement === 'both') {\n    addRectHandle($canvas, parent, -1, -1);\n    addRectHandle($canvas, parent, 1, -1);\n    addRectHandle($canvas, parent, 1, 1);\n    addRectHandle($canvas, parent, -1, 1);\n  }\n  \n  if (handlePlacement === 'sides' || handlePlacement === 'both') {\n    addRectHandle($canvas, parent, 0, -1);\n    addRectHandle($canvas, parent, 1, 0);\n    addRectHandle($canvas, parent, 0, 1);\n    addRectHandle($canvas, parent, -1, 0);\n  }\n  </addCornersAndSidesHandles>\n\n  <addGuides>\n  if (parent.guide) {\n    addRectGuides($canvas, parent);\n  }\n  </addGuides>\n}\n"], ["hasKeyPrev", "\nfunction (key) {                                                         \n    <checkKeyExistence>\n    var self = this;                                                             \n    if (self.has(key)) {                                                         \n      var elt = self._dict[self._k(key)];                                        \n      if (elt.prev)                                                              \n        return elt.prev.key;                                                     \n    }                                                                            \n    </checkKeyExistence>\n    return null;                                                                 \n}\n"], ["isScriptTag", "\nfunction isScriptTag (tagName, scriptTags) {\n    for (var i = 0; i < scriptTags.length; i++) {\n      if (tagName.toLowerCase() == scriptTags[i]) return true\n    }\n    return false\n}\n"], ["registerExtension", "\nfunction registerExtension(ext) {\n  <determineOldHandler>\n  var old = oldHandlers[ext] || oldHandlers[\".js\"] || require.extensions[\".js\"];\n  </determineOldHandler>\n\n  <selectLoader>\n  var loader = normalLoader;\n  if (process.env.running_under_istanbul) loader = istanbulLoader;\n  </selectLoader>\n\n  <setupRequireExtension>\n  require.extensions[ext] = function (m, filename) {\n    if (shouldIgnore(filename)) {\n      old(m, filename);\n    } else {\n      loader(m, filename, old);\n    }\n  };\n  </setupRequireExtension>\n}\n"], ["storeMembershipEvents", "\nasync function(roomId, membershipEvents) {\n  <logBeforeStoringEvents>\n  console.log(`LL: backend about to store ${membershipEvents.length}` +\n      ` members for ${roomId}`);\n  </logBeforeStoringEvents>\n  <createTransaction>\n  const tx = this.db.transaction([\"oob_membership_events\"], \"readwrite\");\n  const store = tx.objectStore(\"oob_membership_events\");\n  </createTransaction>\n  <putMembershipEvents>\n  membershipEvents.forEach((e) => {\n      store.put(e);\n  });\n  </putMembershipEvents>\n  <storeMarkerObject>\n  const markerObject = {\n      room_id: roomId,\n      oob_written: true,\n      state_key: 0,\n  };\n  store.put(markerObject);\n  </storeMarkerObject>\n  <completeTransaction>\n  await txnAsPromise(tx);\n  </completeTransaction>\n  <logAfterStoringEvents>\n  console.log(`LL: backend done storing for ${roomId}!`);\n  </logAfterStoringEvents>\n}\n"], ["parens", "\nfunction parens(node) {\n  <initialSetup>\n  const isAsync = node.async;\n  const firstTokenOfParam = sourceCode.getFirstToken(node, isAsync ? 1 : 0);\n  </initialSetup>\n\n  <fixParamsWithParenthesis>\n  function fixParamsWithParenthesis(fixer) {\n      const paramToken = sourceCode.getTokenAfter(firstTokenOfParam);\n      const closingParenToken = sourceCode.getTokenAfter(paramToken, astUtils.isClosingParenToken);\n      const asyncToken = isAsync ? sourceCode.getTokenBefore(firstTokenOfParam) : null;\n      const shouldAddSpaceForAsync = asyncToken && (asyncToken.range[1] === firstTokenOfParam.range[0]);\n\n      return fixer.replaceTextRange([\n          firstTokenOfParam.range[0],\n          closingParenToken.range[1]\n      ], `${shouldAddSpaceForAsync ? \" \" : \"\"}${paramToken.value}`);\n  }\n  </fixParamsWithParenthesis>\n\n  <reportingAndFixingIssues>\n  // The following are multiple conditions and reports which could be grouped\n  // into a single responsibility of analyzing and reporting code issues\n\n  if (\n      requireForBlockBody &&\n      node.params.length === 1 &&\n      node.params[0].type === \"Identifier\" &&\n      !node.params[0].typeAnnotation &&\n      node.body.type !== \"BlockStatement\" &&\n      !node.returnType\n  ) {\n      if (astUtils.isOpeningParenToken(firstTokenOfParam)) {\n          context.report({\n              node,\n              messageId: \"unexpectedParensInline\",\n              fix: fixParamsWithParenthesis\n          });\n      }\n      return;\n  }\n\n  if (\n      requireForBlockBody &&\n      node.body.type === \"BlockStatement\"\n  ) {\n      if (!astUtils.isOpeningParenToken(firstTokenOfParam)) {\n          context.report({\n              node,\n              messageId: \"expectedParensBlock\",\n              fix(fixer) {\n                  return fixer.replaceText(firstTokenOfParam, `(${firstTokenOfParam.value})`);\n              }\n          });\n      }\n      return;\n  }\n\n  if (asNeeded &&\n      node.params.length === 1 &&\n      node.params[0].type === \"Identifier\" &&\n      !node.params[0].typeAnnotation &&\n      !node.returnType\n  ) {\n      if (astUtils.isOpeningParenToken(firstTokenOfParam)) {\n          context.report({\n              node,\n              messageId: \"unexpectedParens\",\n              fix: fixParamsWithParenthesis\n          });\n      }\n      return;\n  }\n\n  if (firstTokenOfParam.type === \"Identifier\") {\n      const after = sourceCode.getTokenAfter(firstTokenOfParam);\n\n      if (after.value !== \")\") {\n          context.report({\n              node,\n              messageId: \"expectedParens\",\n              fix(fixer) {\n                  return fixer.replaceText(firstTokenOfParam, `(${firstTokenOfParam.value})`);\n              }\n          });\n      }\n  }\n  </reportingAndFixingIssues>\n}\n"], ["moduleRegistration", "\nfunction (module, initialState, onStateChange, obj, overrideContext) {\n  <validateArguments>\n  if (typeof module !== \"string\" || YAHOO.lang.trim(module) === \"\" ||\n      typeof initialState !== \"string\" ||\n      typeof onStateChange !== \"function\") {\n      throw new Error(\"Missing or invalid argument\");\n  }\n  </validateArguments>\n\n  <checkModuleExistence>\n  if (_modules[module]) {               \n      return;\n  }\n  </checkModuleExistence>\n\n  <checkInitialization>\n  if (_initialized) {\n      throw new Error(\"All modules must be registered before calling YAHOO.util.History.initialize\");\n  }\n  </checkInitialization>\n\n  <setupModuleDetails>\n  module = escape(module);\n  initialState = escape(initialState);\n  </setupModuleDetails>\n\n  <wrapStateChangeFunction>\n  scope = null;\n  if (overrideContext === true) {\n      scope = obj;\n  } else {\n      scope = overrideContext;\n  }\n\n  wrappedFn = function (state) {\n      return onStateChange.call(scope, state, obj);\n  };\n  </wrapStateChangeFunction>\n\n  <registerModule>\n  _modules[module] = {\n      name: module,\n      initialState: initialState,\n      currentState: initialState,\n      onStateChange: wrappedFn\n  };\n  </registerModule>\n}\n"], "```"]