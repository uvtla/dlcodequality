[["limitResolution", "\nfunction(size) {\n    return function limitResolution(params) {\n      <calculateMinFov>\n      var height = params.height;\n      if (height) {\n        var requiredPixels = pixelRatio() * height;\n        var minFov = 2 * Math.atan(requiredPixels / size);\n        params.fov = clamp(params.fov, minFov, Infinity);\n      }\n      </calculateMinFov>\n      return params;\n    };\n}\n"], ["loadShader", "\nfunction loadShader(gl, shaderSource, shaderType, opt_errorCallback) {\n  const errFn = opt_errorCallback || error;\n  \n  <createAndCompileShader>\n  const shader = gl.createShader(shaderType);\n  let lineOffset = 0;\n  if (spaceRE.test(shaderSource)) {\n    lineOffset = 1;\n    shaderSource = shaderSource.replace(spaceRE, '');\n  }\n  gl.shaderSource(shader, shaderSource);\n  gl.compileShader(shader);\n  const compiled = gl.getShaderParameter(shader, gl.COMPILE_STATUS);\n  if (!compiled) {\n    const lastError = gl.getShaderInfoLog(shader);\n    errFn(addLineNumbers(shaderSource, lineOffset) + \"\\n*** Error compiling shader: \" + lastError);\n    gl.deleteShader(shader);\n    return null;\n  }\n  </createAndCompileShader>\n\n  return shader;\n}\n"], ["on", "\nfunction on(type, listener) {\n    var me = this,\n        events = me.events || (me.events = {});\n\n    <addListener>\n    forEach(type.split(' '), function(type) {\n      (hasKey(events, type)\n        ? events[type]\n        : (events[type] = [])\n      ).push(listener);\n    });\n    </addListener>\n    return me;\n}\n"], ["setupAxis", "\nfunction (axisModel, ecModel, api) {\n        var dim = this.dimension;\n\n        <createAxis>\n        var axis = new SingleAxis(\n            dim,\n            axisHelper.createScaleByModel(axisModel),\n            [0, 0],\n            axisModel.get('type'),\n            axisModel.get('position')\n        );\n        </createAxis>\n\n        <configureAxisProperties>\n        var isCategory = axis.type === 'category';\n        axis.onBand = isCategory && axisModel.get('boundaryGap');\n        axis.inverse = axisModel.get('inverse');\n        axis.orient = axisModel.get('orient');\n        </configureAxisProperties>\n\n        <assignAxisToModel>\n        axisModel.axis = axis;\n        axis.model = axisModel;\n        axis.coordinateSystem = this;\n        this._axis = axis;\n        </assignAxisToModel>\n}\n"], ["checkAndSetPort", "\nfunction (next) {\n      <checkServerAvailability>\n      if (!server) {\n        if (options.port) {\n          <checkSpecificPortStatus>\n          portscanner.checkPortStatus(options.port, options.host,\n            function (error, status) {\n              if (status === 'closed') {\n                next();\n              } else {\n                fatal('Port ' + options.port + ' is already in use by another process.');\n              }\n            });\n          </checkSpecificPortStatus>\n        } else {\n          <findAvailablePort>\n          portscanner.findAPortNotInUse(8888, 65535, options.host,\n            function (error, foundPort) {\n              options.port = foundPort;\n              next();\n            });\n          </findAvailablePort>\n        }\n      } else {\n        next();\n      }\n      </checkServerAvailability>\n}\n"], ["template", "\nfunction template(templateSpec, env) {\n    <validateParameters>\n            if (!env) {\n                throw new Exception(\"No environment passed to template\");\n            }\n            if (!templateSpec || !templateSpec.main) {\n                throw new Exception('Unknown template object: ' + typeof templateSpec);\n            }\n    </validateParameters>\n\n    <invokePartialImplementation>\n            env.VM.checkRevision(templateSpec.compiler);\n            \n            var invokePartialWrapper = function(partial, indent, name, context, hash, helpers, partials, data, depths) {\n                \n                if (hash) {\n                    context = Utils.extend({}, context, hash);\n                }\n\n                var result = env.VM.invokePartial.call(this, partial, name, context, helpers, partials, data, depths);\n\n                if (result == null && env.compile) {\n                    var options = { helpers: helpers, partials: partials, data: data, depths: depths };\n                    partials[name] = env.compile(partial, { data: data !== undefined, compat: templateSpec.compat }, env);\n                    result = partials[name](context, options);\n                }\n                if (result != null) {\n                    if (indent) {\n                        var lines = result.split('\\n');\n                        for (var i = 0, l = lines.length; i < l; i++) {\n                            if (!lines[i] && i + 1 === l) {\n                                break;\n                            }\n\n                            lines[i] = indent + lines[i];\n                        }\n                        result = lines.join('\\n');\n                    }\n                    return result;\n                } else {\n                    throw new Exception(\"The partial \" + name + \" could not be compiled when running in runtime-only mode\");\n                }\n            };\n    </invokePartialImplementation>\n\n    <setupContainer>\n            var container = {\n                lookup: function(depths, name) {...},\n                lambda: function(current, context) {...},\n                escapeExpression: Utils.escapeExpression,\n                invokePartial: invokePartialWrapper,\n                fn: function(i) {...},\n                programs: [],\n                program: function(i, data, depths) {...},\n                data: function(data, depth) {...},\n                merge: function(param, common) {...},\n                noop: env.VM.noop,\n                compilerInfo: templateSpec.compiler\n            };\n    </setupContainer>\n\n    <returnTemplateFunction>\n            var ret = function(context, options) {...};\n            ret.isTop = true;\n            ret._setup = function(options) {...};\n            ret._child = function(i, data, depths) {...};\n            return ret;\n    </returnTemplateFunction>\n}\n"], ["main", "\nasync function main({ isFragment, needsHelp, showVersion, useTabs }) {\n  <retrieveStdin>\n  const stdin = await getStdin()\n  </retrieveStdin>\n\n  <handleVersion>\n  if (showVersion) {\n    return console.log(version)\n  }\n  </handleVersion>\n\n  <handleHelp>\n  if (needsHelp || !stdin) {\n    return console.log(help)\n  }\n  </handleHelp>\n\n  <convertHtmlToPug>\n  const pug = html2pug(stdin, { isFragment, useTabs })\n  return console.log(pug)\n  </convertHtmlToPug>\n}\n"], ["isAncestor", "\nfunction (element) {\n            var ownerDocument = element ? element.ownerDocument : null;\n            return ownerDocument ? this.isAncestor(element, ownerDocument.body) : false;\n        }\n"], ["requireValidCacheClient", "\nfunction requireValidCacheClient (cacheClient) {\n    <validateCacheClient>\n    if (!cacheClient || typeof cacheClient !== 'object') {\n        throw new Error('cacheClient error: cacheClient must be object')\n    }\n    </validateCacheClient>\n\n    <validateMethods>\n    _.each(requireMethods, method => {\n        if (typeof cacheClient[method] !== 'function') {\n            throw new Error ('cacheClient error: cacheClient must provied '+method+' method')\n        }\n    })\n    </validateMethods>\n}\n"], ["browserReporter", "\nfunction browserReporter (file, errors) {\n\terrors = errors || file.report.errors;\n\tif (file.isStream()) {\n    <handleStreamFile>\n\t\tfile.contents = file.contents.pipe(new BufferStreams((err, buf, done) => {\n\t\t\tif (err) {\n\t\t\t\tdone(err, buf);\n\t\t\t} else {\n\t\t\t\tdone(null, appendReporter(file, errors, buf));\n\t\t\t}\n\t\t}));\n    </handleStreamFile>\n\t} else if (file.isBuffer()) {\n    <handleBufferFile>\n\t\tfile.contents = appendReporter(file, errors);\n    </handleBufferFile>\n\t}\n}\n"], "```"]