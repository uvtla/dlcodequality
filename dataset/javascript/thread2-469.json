[["storeResponse", "\nfunction storeResponse(message, id, dest) {\n  var response = {\n    message: message,\n    timeout: setTimeout(function() {\n      responses.remove(id, dest);\n    },\n    response_timeout)\n  };\n  responses.set(response, id, dest);\n}\n"], ["sortData", "\nfunction sortData(data, columnId, sortDirection, columns) {\n  var column = getColumnById(columns, columnId);\n  \n  if (!column) {\n    if (process.env.NODE_ENV !== 'production') {\n      console.warn('No column found by ID', columnId, columns);\n    }\n    return data;\n  }\n  \n  <determineSortType>\n  var sortType = column.sortType == null ? column.type : column.sortType;\n  </determineSortType>\n\n  <getComparatorAndInitialData>\n  var comparator = getSortComparator(sortType);\n  var dataToSort = data.map(function (rowData, index) {\n    return {\n      rowData: rowData,\n      index: index,\n      sortValue: getSortValue(column, rowData, index, data, columns)\n    };\n  });\n  </getComparatorAndInitialData>\n\n  <performSorting>\n  var sortedData = void 0;\n  if (alreadySorted(!sortDirection, dataToSort, comparator)) {\n    sortedData = dataToSort.reverse();\n  } else {\n    sortedData = (0, _stable2.default)(dataToSort, comparator);\n    if (sortDirection === _SortDirection2.default.Descending) {\n      sortedData.reverse();\n    }\n  }\n  </performSorting>\n\n  <postProcessSortedData>\n  sortedData = sortedData.map(function (sortItem) {\n    return sortItem.rowData;\n  });\n  </postProcessSortedData>\n\n  return sortedData;\n}\n"], ["atom", "\nfunction atom(value, options) {\n  if(isList(value) || (!isPrimitive(value) && value.__isatom)) {\n    return value;\n  }\n  if(!options && value && isToken(value)) {\n    options = {token: value};\n    value = value.text;\n  }\n  options = options || {};\n  var atomized = {};\n  if(options.token) {\n    options.token.category = options.category || options.token.category;\n    utils.mergeInto(atomized, options.token);\n    if(options.tokenType === \"end\") {\n      <simplifyTokenType>\n      atomized.line = options.token.endLine;\n      atomized.col = options.token.endCol;\n      delete atomized.endLine;\n      delete atomized.endCol;\n      </simplifyTokenType>\n    }\n  }\n  <setDefaultAtomProperties>\n  atomized.value = value;\n  atomized.parent = options.parent;\n  atomized.toString = function() { return toString(atomized); };\n  atomized.toQuotedString = function() { return addQuotes(toString(atomized)); };\n  atomized.toUnquotedString = function() { return stripQuotes(toString(atomized)); };\n  atomized.toJSON = function() { return toJSON(atomized); };\n  atomized.error = function(msg, locator) {\n    lexerOf(atomized).error(msg, locator || atomized);\n  };\n  atomized.transform = options.transform;\n  atomized.__isatom = true;\n  </setDefaultAtomProperties>\n  return atomized;\n}\n"], ["calculateCartesianProduct", "\nfunction calculateCartesianProduct(keyRangeSets) {\n  goog.asserts.assert(\n      keyRangeSets.length > 1,\n      'Should only be called for cross-column indices.'\n  );\n  var keyRangeSetsAsArrays = keyRangeSets.map(\n      function(keyRangeSet) {\n        return keyRangeSet.getValues();\n      }\n  );\n  var it = goog.iter.product.apply(null, keyRangeSetsAsArrays);\n  var combinations = [];\n  goog.iter.forEach(it, function(value) {\n    combinations.push(value);\n  });\n  return combinations;\n}\n"], ["transformV1Request", "\nfunction (requestV1, collectionId, skipResponses) {\n  // the function's code has been omitted for brevity\n}\n"], ["applyStyle", "\nfunction (node, selText, cssText) {\n  if(!cssText) return\n  var parent = getParent(node);\n  var parentRule = node.parentRule;\n  <applyOrRemoveCSSRule>\n  if (validParent(node))\n    return node.omRule = addCSSRule(parent, selText, cssText, node)\n  else if (parentRule) {\n    if (parentRule.mediaEnabled) {\n      [].concat(node.omRule).forEach(removeOneRule);\n      return node.omRule = addCSSRule(parent, selText, cssText, node)\n    } else if (node.omRule) {\n      node.omRule.forEach(removeOneRule);\n      delete node.omRule;\n    }\n  }\n  </applyOrRemoveCSSRule>\n}\n"], ["checkDep", "\nfunction (deps, dep, ext) {\n  if (deps.indexOf(dep + ext) !== -1) {\n    return {\n      isPublicDeps : true,\n      dep : dep\n    };\n  }else {\n    return {\n      isPublicDeps : false,\n      dep : null\n    };\n  }\n}\n"], ["vectorLengthsAreEqual", "\nfunction vectorLengthsAreEqual (x, y, eps) {\n  return isZero(x.length() - y.length(), eps);\n}\n"], ["checkColumnTemplate", "\nfunction checkColumnTemplate(fnDoCheck, oScope, sType) {\n  var aTables = SupportHelper.find(oScope, true, \"sap.ui.table.Table\");\n  var aColumns, oTemplate;\n  for (var i = 0; i < aTables.length; i++) {\n    aColumns = aTables[i].getColumns();\n    for (var k = 0; k < aColumns.length; k++) {\n      oTemplate = aColumns[k].getTemplate();\n      if (oTemplate && oTemplate.isA(sType)) {\n        fnDoCheck(aTables[i], aColumns[k], oTemplate);\n      }\n    }\n  }\n}\n"], ["serializeToXML", "\nfunction(o) {\n  if(!XML || !YAHOO.lang.isFunction(XML.ObjTree)) {\n    alert(\"ObjTree.js not loaded.\");\n    return null;\n  }\n  var xotree = new XML.ObjTree();\n  return xotree.writeXML(o);\n}\n"], "```\n\nFor several cases, I've provided the overarching SRP annotation, like `<storeResponse>`, `<atom>`, and `<checkColumnTemplate>`, which captures their core functionalities. For others, more detailed annotations, like `<applyOrRemoveCSSRule>`, highlight specific responsibilities within a function.\n"]