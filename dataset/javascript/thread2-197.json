[["getPaddingPixelValue", "\nfunction (element, which) {\n    var cs = element.currentStyle;\n    var propName = \"padding\" + which;\n    return this.convertToPixels(cs[propName], element, propName);\n}\n"], ["dataStructuresConstructor", "\nfunction(lava_app, config, name) {\n    this._app = lava_app;\n    this._config = config;\n    this._name = name;\n\n    <initializeFields>\n    this._createFields(config);\n    </initializeFields>\n\n    <setupRecordConstructor>\n    this._record_constructor = Lava.ClassManager.getConstructor(config.record_class || Lava.schema.data.DEFAULT_RECORD_CLASS, 'Lava.data');\n    </setupRecordConstructor>\n\n    <configureIdField>\n    if ('id' in this._fields) {\n        this._has_id = true;\n        this._fields['id'].on('changed', this._onRecordIdChanged, this);\n    }\n    </configureIdField>\n}\n"], ["dPadDirectionEvaluation", "\nfunction(dpad, multiBehavior) {\n    var d, dir;\n    var winner;\n\n    <evaluateDirections>\n    for (d in dpad.directions) {\n        dir = dpad.directions[d];\n        dir.active = false;\n\n        if (dir.input.isActive()) {\n            <handleMultipleBehavior>\n            if (multiBehavior === \"all\") {\n                dir.active = true;\n            } else {\n                <determineWinner>\n                if (!winner) {\n                    winner = dir;\n                } else {\n                    if (multiBehavior === \"first\") {\n                        if (winner.input.timeDown > dir.input.timeDown) {\n                            winner = dir;\n                        }\n                    }\n                    if (multiBehavior === \"last\") {\n                        if (winner.input.timeDown < dir.input.timeDown) {\n                            winner = dir;\n                        }\n                    }\n                }\n                </determineWinner>\n            }\n            </handleMultipleBehavior>\n        }\n    }\n    </evaluateDirections>\n    \n    <activateWinner>\n    if (winner) winner.active = true;\n    </activateWinner>\n}\n"], ["bundleInitialization", "\nfunction(opt, project, env, bundle) {\n\n    <validateReservedName>\n    if (reserved.indexOf(bundle) > -1) {\n        console.error('[ ' + bundle + ' ] is a reserved name. Please, try something else.');\n        process.exit(1)\n    }\n    </validateReservedName>\n\n    <validateBundleName>\n    if (!isValidName()) {\n        console.error('[ ' + bundle + ' ] is not a valid bundle name. Please, try something else: [a-Z0-9].');\n        process.exit(1)\n    }\n    </validateBundleName>\n\n    <setupEnvironment>\n    self.root = getPath('root');\n    self.opt = opt;\n    self.project = project;\n    self.projectData = require(project);\n    self.env = env;\n    if (!fs.existsSync(env)) {\n        fs.writeFileSync(env, '{}')\n    }\n    self.envData = require(env);\n    </setupEnvironment>\n\n    <initializeBundle>\n    self.bundle = bundle;\n    console.debug('adding', bundle);\n    </initializeBundle>\n    \n    <errorHandling>\n    try {\n        check()\n    } catch (err) {\n        rollback(err)\n    }\n    </errorHandling>\n}\n"], ["renderViewport", "\nfunction(rect) {\n    rect = rect || this._viewportRect();\n    var gl = this.context;\n    <clearViewport>\n    gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);\n    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n    </clearViewport>\n\n    <updateViewportPrograms>\n    var programs = this.programs;\n    if (this._dirtyViewport) {\n        var view = this._viewportRect();\n        for (var comp in programs) {\n            programs[comp].setViewportUniforms(view, this.options);\n        }\n        this._dirtyViewport = false;\n    }\n    </updateViewportPrograms>\n\n    <collectVisibleEntities>\n    var q = Crafty.map.search(rect),\n        i = 0,\n        l = q.length,\n        current;\n    var visible_gl = this.visible_gl;\n    visible_gl.length = 0;\n    for (i = 0; i < l; i++) {\n        current = q[i];\n        if (\n            current._visible &&\n            current.program &&\n            current._drawLayer === this\n        ) {\n            visible_gl.push(current);\n        }\n    }\n    visible_gl.sort(this._sort);\n    l = visible_gl.length;\n    </collectVisibleEntities>\n\n    <drawEntities>\n    var shaderProgram = null;\n    for (i = 0; i < l; i++) {\n        current = visible_gl[i];\n        if (shaderProgram !== current.program) {\n            if (shaderProgram !== null) {\n                shaderProgram.renderBatch();\n            }\n            shaderProgram = current.program;\n            shaderProgram.index_pointer = 0;\n            shaderProgram.switchTo();\n        }\n        current.draw();\n        current._changed = false;\n    }\n    if (shaderProgram !== null) {\n        shaderProgram.renderBatch();\n    }\n    </drawEntities>\n}\n"], ["registerEventCallback", "\nfunction(event, fn) {\n    <setupCallbacks>\n    var callbacks = this._callbacks[event];\n    if (!callbacks) {\n        callbacks = this._callbacks[event] = (handlers[event] ||\n            (handlers[event] = {}))[this[0]] = [];\n        callbacks.context = this;\n        callbacks.depth = 0;\n    }\n    </setupCallbacks>\n\n    <addCallback>\n    callbacks.push(fn);\n    </addCallback>\n}\n"], ["initializePlugin", "\nfunction(plugin, config) {\n    config = config || {};\n    config.node = this;\n    return localnwt.plugin(plugin, config);\n}\n"], ["channelConstructor", "\nfunction TChannelHTTP(options) {\n    if (!(this instanceof TChannelHTTP)) {\n        return new TChannelHTTP(options);\n    }\n    var self = this;\n    <setLbpoolOption>\n    if (options) {\n        self.lbpool = options.lbpool;\n    }\n    </setLbpoolOption>\n}\n"], ["syncUsersWithBrain", "\nfunction load(robot) {\n    <setupSyncUsersCommand>\n    robot.respond(/^(sync users with brain|sync brain users)/i, async (res) => {\n        const addedUsers = await syncBrainUsers(robot)\n        if (typeof addedUsers === 'undefined') {\n            res.reply(`Sorry I can't do that.`)\n        } else {\n            const names = '@' + addedUsers.join(', @').replace(/,(?!.*,)/gmi, ' and')\n            res.reply(`${names} were added to my brain.`)\n        }\n    })\n    </setupSyncUsersCommand>\n}\n"], ["calculatePageCoordinates", "\nfunction (e) {\n    <computeCoordinates>\n    var doc = document.documentElement,\n        pageX = e.clientX + (window.pageXOffset || doc.scrollLeft) - (doc.clientLeft || 0),\n        pageY = e.clientY + (window.pageYOffset || doc.scrollTop) - (doc.clientTop || 0);\n    return { X: pageX, Y: pageY };\n    </computeCoordinates>\n}\n"], "```\nThis function is SRP compliant, as it computes the page coordinates given a mouse event."]