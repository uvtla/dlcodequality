[["buildViewAttribsInitFire", "\nfunction buildViewAttribsInitFire( attName, code ) {\n    try {\n        code.section.attribs.init\n            .push( `pm.fire(\"${attName}\");` );\n    } catch ( ex ) {\n        bubble(\n            ex,\n            `buildViewAttribsInitFire(${attName})`\n        );\n    }\n}\n"], ["done", "\nfunction done() {\n    \n    route = stack.pop()\n\n    <setupCallback>\n    var callback\n\n    if (stack.length) {\n      callback = done\n    }\n    else {\n      callback = function() {\n        done.end()\n      }\n      callback.redirect = done.redirect\n      callback.render = function() {\n        res.render.apply(res, [req.app._currentRoute].concat(Array.prototype.slice.call(arguments), finalize))\n      }\n    }\n    </setupCallback>\n\n    <executeRoute>\n    route.execute(req.app, req, res, callback)\n    </executeRoute>\n}\n"], ["jqFixedSize", "\nfunction jqFixedSize(sel) {\n  var $ = glb().jQuery;\n  $(sel).each(function () {\n    var t = $(this);\n    t.css({\n      width: t.width() + 'px',\n      height: t.height() + 'px'\n    });\n  });\n}\n"], ["parseDocumentNode", "\nfunction(oDocumentNode, sAnnotationTarget) {\n\t<initializeVariables>\n\tvar i;\n\tvar xPath = AnnotationParser._oXPath;\n\tvar vPropertyValue = oDocumentNode.nodeName === \"Collection\" ? [] : {};\n\t</initializeVariables>\n\n\t<parseDocument>\n\tif (oDocumentNode.hasChildNodes()) {\n\t\t<parsePropertyValues>\n\t\tvar block of code...\n\t\t</parsePropertyValues>\n\t\t...\n\t\t<parseChildNodes>\n\t\tvar block of code...\n\t\t</parseChildNodes>\n\t\t<parseNestedAnnotations>\n\t\tif (oNestedAnnotations.length > 0) {\n\t\t\tfor (i = 0; i < oNestedAnnotations.length; i++) {\n\t\t\t\tvar oNestedAnnotationNode = xPath.nextNode(oNestedAnnotations, i);\n\t\t\t\tAnnotationParser._parseAnnotation(sAnnotationTarget, oNestedAnnotationNode, vPropertyValue);\n\t\t\t}\n\t\t}\n\t\t</parseNestedAnnotations>\n\t} else {\n\t\t<handleNonChildNodes>\n\t\tvar block of code...\n\t\t</handleNonChildNodes>\n\t}\n\t</parseDocument>\n\treturn vPropertyValue;\n}\n"], ["getInputType", "\nfunction(e) {\n\t<evaluateKeyCode>\n    var c = Event.getCharCode(e);\n    if (c === 38) {\n        return 3;\n    } else if (c === 13) {\n        return 6;\n    } else if (c === 40) {\n        return 4;\n    } else if (c >= 48 && c<=57) {\n        return 1;\n    } else if (c >= 97 && c<=102) {\n        return 2;\n    } else if (c >= 65 && c<=70) {\n        return 2;\n    } else if (\"8, 9, 13, 27, 37, 39\".indexOf(c) > -1 ||\n               e.ctrlKey || e.metaKey) {\n        return 5;\n    } else {\n        return 0;\n    }\n\t</evaluateKeyCode>\n}\n"], ["parseProductComponents", "\nfunction parseProductComponents(uaList) {\n\t<filterUAList>\n  uaList = uaList.filter(function(x) { return contains(x, '/') && !isEnclosedInParens(x); });\n  </filterUAList>\n  <mapToProductComponents>\n  var productComponents = {};\n  for(var i in uaList) {\n    var x = uaList[i];\n    <parseComponent>\n    if (contains(x, '/')) {\n      x = x.split('/');\n      if (x.length != 2) throw uaList[i];\n      productComponents[x[0].trim()] = x[1].trim();\n    } else {\n      productComponents[x] = true;\n    }\n    </parseComponent>\n  }\n  </mapToProductComponents>\n  return productComponents;\n}\n"], ["getSelectors", "\nfunction getSelectors(selector){\n\t<initializeVariables>\n\tlet ary = [];\n\tfor ( let i=0,isCls=false,tmp='',len=selector.length,ch; i<len; i++ ) {\n\t</initializeVariables>\n\t\tch = selector.charAt(i);\n\t\t<buildSelectorArray>\n\t\tif ( ch == '.' ) {\n\t\t\tary.push(tmp);\n\t\t\ttmp = ch;\n\t\t\tisCls = true;\t\n\t\t} else {\n\t\t\tif ( BREAKS.indexOf(ch) >= 0 ) {\n\t\t\t\tif ( isCls ) {\n\t\t\t\t\tary.push(tmp);\n\t\t\t\t\ttmp = ch;\n\t\t\t\t\tisCls = false; \n\t\t\t\t} else {\n\t\t\t\t\ttmp += ch;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\ttmp += ch;\n\t\t\t}\n\t\t}\n\t\tif ( i == len-1 ) {\n\t\t\tary.push(tmp);\n\t\t}\n\t\t</buildSelectorArray>\n\t}\n\treturn ary.filter(v => v !== ''); \n}\n"], ["preparedErrorMessage", "\nfunction (e) {\n\t<initializeErrorMessage>\n    var message;\n    var errors = e.errors;\n    var logs = ariaCoreLog;\n\t</initializeErrorMessage>\n\t<constructErrorMessage>\n    if (errors && errors.length > 0 && logs) {\n        var msgs = [];\n        var error;\n        for (var index = 0, len = errors.length; index < len; index += 1) {\n            error = errors[index];\n            msgs[index] = logs.prepareLoggedMessage(error.msgId, error.msgArgs);\n        }\n        message = msgs.join('\\n');\n    }\n    </constructErrorMessage>\n    return {\n        result : false,\n        message : message\n    };\n}\n"], ["assertStringStartsWith", "\nfunction(a, start, msg) {\n    <performAssertion>\n    return assert((this.assertIsString(a, msg) && a.indexOf(start)===0), msg);\n    </performAssertion>\n}\n"], ["applyTemplate", "\nfunction () {\n\t<initializeBindingContext>\n    var bindingContext = (dataOrBindingContext && (dataOrBindingContext instanceof bindingContextConstructor))\n        ? dataOrBindingContext\n        : new bindingContextConstructor(dataOrBindingContext, null, null, null, { \"exportDependencies\": true });\n\t</initializeBindingContext>\n\t<executeRendering>\n    var templateName = resolveTemplateName(template, bindingContext['$data'], bindingContext),\n        renderedNodesArray = executeTemplate(targetNodeOrNodeArray, renderMode, templateName, bindingContext, options);\n\t</executeRendering>\n\t<updateTargetNode>\n    if (renderMode == \"replaceNode\") {\n        targetNodeOrNodeArray = renderedNodesArray;\n        firstTargetNode = getFirstNodeFromPossibleArray(targetNodeOrNodeArray);\n    }\n\t</updateTargetNode>\n}\n"], "```\n\nAnnotations have been made regarding SRP compliance or violations. Each function is wrapped in a tag representing its main purpose, and within some functions, separate blocks of code have been tagged to highlight distinct responsibilities that might warrant refactoring for strict SRP compliance."]