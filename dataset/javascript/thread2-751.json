[["ImmutableCoreComponentInstance", "\nfunction ImmutableCoreComponentInstance (args) {\n    <assertValidArguments>\n    this.assert(typeof args === 'object' && args, 100)\n    \n    var component = args.component\n    \n    this.assert(typeof component === 'object' && component && component.ImmutableCoreComponent, 101)\n    </assertValidArguments>\n    \n    <initComponent>\n    this.component = component\n    \n    this.data = {}\n    </initComponent>\n\n    <handleIdInitialization>\n    if (defined(args.id)) {\n        this.id = args.id\n    }\n    \n    else {\n        \n        this.id = this.component.name\n        \n        <initNewComponent>\n        this.initNew(args)\n        </initNewComponent>\n    }\n    </handleIdInitialization>\n}\n"], ["dispatchEvent", "\nfunction(e) {\n    <findDispatchTarget>\n\tvar c = this.findDispatchTarget(e.target) || this.findDefaultTarget(e);\n    \n\te.dispatchTarget = c;\n    </findDispatchTarget>\n\t\n    <executeFeatures>\n\tfor (var i=0, fn; (fn=this.features[i]); i++) {\n\t\tif (fn.call(this, e) === true) {\n\t\t\treturn;\n\t\t}\n\t}\n    </executeFeatures>\n\n    <dispatchBubble>\n\tif (c && !e.preventDispatch) {\n\t\tthis.dispatchBubble(e, c);\n\t}\n    </dispatchBubble>\n}\n"], ["role", "\nfunction role(value) {\n    <validateRoleValue>\n  if (typeof value === 'boolean')\n    return value;\n\n  if (value !== 'sender' && value !== 'receiver')\n    throw new errors.EncodingError(value, 'invalid role');\n    </validateRoleValue>\n\n    <determineRole>\n  return (value === 'sender') ? false : true;\n    </determineRole>\n}\n"], ["countFilteredItems", "\nfunction() {\n    <reduceItemCount>\n    return _.reduce(this.items, function(n, item) {\n        if (this.applyFilter(item)) {\n            n = n + 1;\n        }\n        return n;\n    }, 0, this);\n    </reduceItemCount>\n}\n"], ["selectIndex", "\nfunction selectIndex(element, index) {\n    <determineBoundedIndex>\n  const count = element.items.length;\n\n  const boundedIndex = (element.selectionWraps) ?\n    ((index % count) + count) % count :\n    Math.max(Math.min(index, count - 1), 0);\n    </determineBoundedIndex>\n\n    <updateSelectedIndex>\n  const previousIndex = element.selectedIndex;\n  if (previousIndex !== boundedIndex) {\n    element.selectedIndex = boundedIndex;\n    return true;\n  } else {\n    return false;\n  }\n  </updateSelectedIndex>\n}\n"], ["resolveInputType", "\nfunction(options) {\n    <determineTypeConstructor>\n    var TypeConstructor, typeOptions, input,\n    type = options.type;\n    \n    <handleDateInputTypes>\n    if(type === 'date') {\n        <handleInlineDateType>\n        if(options.mode === 'inline') {\n            if($.fn.editabletypes.datefield) {\n                type = 'datefield';\n            } else if($.fn.editabletypes.dateuifield) {\n                type = 'dateuifield';\n            }\n        </handleInlineDateType>\n         \n        <handleRegularDateType>\n        } else {\n            if($.fn.editabletypes.date) {\n                type = 'date';\n            } else if($.fn.editabletypes.dateui) {\n                type = 'dateui';\n            }\n        }\n        </handleRegularDateType>\n        \n        <handleFallbackDateType>\n        if(type === 'date' && !$.fn.editabletypes.date) {\n            type = 'combodate';\n        }\n        </handleFallbackDateType>\n    }\n    </handleDateInputTypes>\n    \n    <handleDatetimeInputType>\n    if(type === 'datetime' && options.mode === 'inline') {\n      type = 'datetimefield';  \n    }\n    </handleDatetimeInputType>\n\n    <handleWysihtml5Fallback>\n    if(type === 'wysihtml5' && !$.fn.editabletypes[type]) {\n        type = 'textarea';\n    }\n    </handleWysihtml5Fallback>\n\n    <constructInputType>\n    if(typeof $.fn.editabletypes[type] === 'function') {\n        TypeConstructor = $.fn.editabletypes[type];\n        typeOptions = this.sliceObj(options, this.objectKeys(TypeConstructor.defaults));\n        input = new TypeConstructor(typeOptions);\n        return input;\n    } else {\n        $.error('Unknown type: '+ type);\n        return false; \n    }\n    </constructInputType>\n    </determineTypeConstructor>\n}\n"], ["findMany", "\nfunction findMany(repository, options) {\n    <defineRepositoryColumns>\n    const entityColumns = repository.metadata.columns.map((columnMetadata) => columnMetadata.propertyName);\n    const entityManyToOneRelationColumns = repository\n        .metadata\n        .relations\n        .filter((relationMetadata) => relationMetadata.relationType === 'many-to-one' || relationMetadata.relationType === 'one-to-one')\n        .map((relationMetadata) => relationMetadata.propertyName);\n    </defineRepositoryColumns>\n\n    return function (source, args, context, info) {\n        return __awaiter(this, void 0, void 0, function* () {\n            <querySetup>\n            const selectedColumns = Object.keys(graphqlFields(info));\n            const selectQueryBuilder = repository.createQueryBuilder(repository.metadata.name.toLowerCase());\n            \n            const selectFactory = new select_factory_1.SelectFactory(selectQueryBuilder);\n            selectFactory.select(selectedColumns.filter((select) => entityColumns.includes(select)));\n            \n            const whereFactory = new where_factory_1.WhereFactory(selectQueryBuilder, entityManyToOneRelationColumns);\n            whereFactory.where(lodash_1.get(args, 'filter', {}));\n            \n            const joinsFactory = new joins_factory_1.JoinsFactory(selectQueryBuilder);\n            joinsFactory.join(selectedColumns.filter((select) => entityManyToOneRelationColumns.includes(select)).reduce((selectedRelationColumns, selectedRelationColumn) => {\n                selectedRelationColumns[selectQueryBuilder.alias] = selectedRelationColumn;\n                return selectedRelationColumns;\n            }, {})).join(whereFactory.selectedManyToOneOrOneToOneRelationColumns);\n            \n            const paginateFactory = new paginate_factory_1.PaginateFactory(selectQueryBuilder);\n            paginateFactory.paginate(lodash_1.get(args, 'pagination', {}));\n            \n            const orderFactory = new order_factory_1.OrderFactory(selectQueryBuilder);\n            orderFactory.order(lodash_1.get(args, 'orderBy', []));\n            \n            if (lodash_1.get(options, 'extend')) {\n                yield options.extend(selectQueryBuilder);\n            }\n            \n            return yield selectQueryBuilder.getMany();\n            </querySetup>\n        });\n    };\n}\n"], ["unknownOption", "\nfunction unknownOption (flag, type = 'option') {\n    <handleUnknownOption>\n  if (this._allowUnknownOption) return\n\n  logger.error()\n  logger.error(`  error: unknown ${type}:`, flag)\n  logger.error()\n  this.outputHelp()\n  util.exit(1)\n  </handleUnknownOption>\n}\n"], ["parseNonCrossOriginStylesheet", "\nfunction parseNonCrossOriginStylesheet(sheet, options, priority) {\n    const q = axe.utils.queue();\n\n    <getCssRules>\n\tconst cssRules = sheet.cssRules;\n    </getCssRules>\n\n    <initializeRulesArray>\n\tconst rules = Array.from(cssRules);\n\tif (!rules) {\n\t\treturn q;\n\t}\n    </initializeRulesArray>\n\n    <filterCssImportRules>\n\tconst cssImportRules = rules.filter(r => r.type === 3); \n    </filterCssImportRules>\n\n    <addNoImportsToQueue>\n\tif (!cssImportRules.length) {\n\t\tq.defer(resolve =>\n\t\t\tresolve({\n\t\t\t\tisExternal: false,\n\t\t\t\tpriority,\n\t\t\t\troot: options.rootNode,\n\t\t\t\tshadowId: options.shadowId,\n\t\t\t\tsheet\n\t\t\t})\n\t\t);\n\n\t\t\n\t\treturn q;\n\t}\n    </addNoImportsToQueue>\n\n    <queueCssImportRules>\n\tcssImportRules.forEach((importRule, cssRuleIndex) =>\n\t\tq.defer((resolve, reject) => {\n\t\t\tconst importUrl = importRule.href;\n\t\t\tconst newPriority = [...priority, cssRuleIndex];\n\t\t\tconst axiosOptions = {\n\t\t\t\tmethod: 'get',\n\t\t\t\turl: importUrl,\n\t\t\t\ttimeout: options.timeout\n\t\t\t};\n\t\t\taxe.imports\n\t\t\t\t.axios(axiosOptions)\n\t\t\t\t.then(({ data }) =>\n\t\t\t\t\tresolve(\n\t\t\t\t\t\toptions.convertDataToStylesheet({\n\t\t\t\t\t\t\tdata,\n\t\t\t\t\t\t\tisExternal: true,\n\t\t\t\t\t\t\tpriority: newPriority,\n\t\t\t\t\t\t\troot: options.rootNode,\n\t\t\t\t\t\t\tshadowId: options.shadowId\n\t\t\t\t\t\t})\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t\t.catch(reject);\n\t\t})\n\t);\n    </queueCssImportRules>\n\n    <filterNonImportCSSRules>\n\tconst nonImportCSSRules = rules.filter(r => r.type !== 3);\n    </filterNonImportCSSRules>\n\n    <addNonImportsToQueue>\n\tif (!nonImportCSSRules.length) {\n\t\treturn q;\n\t}\n\n\tq.defer(resolve =>\n\t\tresolve(\n\t\t\toptions.convertDataToStylesheet({\n\t\t\t\tdata: nonImportCSSRules.map(rule => rule.cssText).join(),\n\t\t\t\tisExternal: false,\n\t\t\t\tpriority,\n\t\t\t\troot: options.rootNode,\n\t\t\t\tshadowId: options.shadowId\n\t\t\t})\n\t\t)\n\t);\n    </addNonImportsToQueue>\n\n    return q;\n}\n"], ["monthrange", "\nfunction monthrange(year, month) {\n    <validateMonthRange>\n    if(month < 1 || month > 12) {\n      throw new IllegalMonthError();\n    }\n    </validateMonthRange>\n\n    <calculateMonthRange>\n    var day1 = weekday(year, month, 1);\n    var ndays = _DAYS_IN_MONTH[month] + (month === 2 && isleap(year));\n\n    return [day1, ndays];\n    </calculateMonthRange>\n}\n"], "```"]