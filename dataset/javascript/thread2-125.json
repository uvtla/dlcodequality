[["setClientInfo", "\nfunction setClientInfo(req) {\n  let client = req.client = {};\n  <initUserAgendAndOS>\n  initUserAgendAndOS(req.headers, client);\n  </initUserAgendAndOS>\n  <initClientIp>\n  initClientIp(req, client);\n  </initClientIp>\n}\n"], ["es", "\nfunction es(cb) {\n  const env = process.env.NODE_ENV || 'development';\n  const output = env === 'development' ? './build' : './dist';\n  let cbs = 0;\n\n  <bundleFirstFile>\n  rollup.rollup({\n    input: './src/dom7.js',\n    external: ['ssr-window'],\n  }).then((bundle) => {\n    return bundle.write({\n      // Bundle writing config here\n    });\n  }).then(() => {\n    cbs += 1;\n    if (cb && cbs === 2) cb();\n  });\n  </bundleFirstFile>\n\n  <bundleSecondFile>\n  rollup.rollup({\n    input: './src/dom7.modular.js',\n    external: ['ssr-window'],\n  }).then((bundle) => {\n    return bundle.write({\n      // Bundle writing config here\n    });\n  }).then(() => {\n    cbs += 1;\n    if (cb && cbs === 2) cb();\n  });\n  </bundleSecondFile>\n}\n"], ["unnamed", "\nfunction() {\n  var dimensionModel = this.dimensionModel;\n\n  <getScrollValues>\n  var scrollX = dimensionModel.get('scrollX');\n  var scrollY = dimensionModel.get('scrollY');\n  </getScrollValues>\n\n  <calculateSpaceHeights>\n  var spaceHeights = this._getSpaceHeights(scrollX, scrollY);\n  </calculateSpaceHeights>\n\n  <setScrollbar>\n  this._setScrollbar(scrollX, scrollY, spaceHeights);\n  </setScrollbar>\n\n  if (dimensionModel.get('frozenBorderWidth')) {\n    <setFrozenBorder>\n    this._setFrozenBorder(scrollX);\n    </setFrozenBorder>\n  }\n\n  <resetScrollBorderHeight>\n  this._resetScrollBorderHeight();\n  </resetScrollBorderHeight>\n}\n"], ["getAndCache", "\nfunction getAndCache (url) {\n  var xhr = new XMLHttpRequest();\n\n  <checkCache>\n  if (cache[url]) {\n    return cache[url]\n  }\n  </checkCache>\n\n  <xhrRequest>\n  xhr.open('GET', url, false);\n  xhr.send();\n  var script = xhr.responseText;\n  cache[url] = evalJS(script);\n  </xhrRequest>\n\n  return cache[url]\n}\n"], ["beforeWhere", "\nfunction beforeWhere(array, exp) {\n  if(!isArray(array) || isUndefined(exp))\n    return array;\n\n  <findConditionIndex>\n  var index = array.map(function(elm) {\n    return $parse(exp)(elm);\n  }).indexOf(true);\n  </findConditionIndex>\n\n  <sliceArray>\n  return array.slice(0, (index === -1) ? array.length : ++index);\n  </sliceArray>\n}\n"], ["createContentLeftMultiSelectRow", "\nfunction createContentLeftMultiSelectRow(row, displayFlag) {\n  var displayStr = '';\n  if (!this.options.autoExpand && row.level > 0 && displayFlag != 'block') {\n    <calculateDisplayStyle>\n    displayStr = 'display:none;';\n    </calculateDisplayStyle>\n  }\n  var tmpcheck = row.value[\"$_#_@_id\"];\n  if (!tmpcheck) {\n    <generateCheck>\n    tmpcheck = setTimeout(function () {});\n    </generateCheck>\n  }\n\n  <compareObj>\n  var rootObj = row.value;\n  var objAry = this.selectRows;\n  var re = objCompare(rootObj, objAry);\n  </compareObj>\n  var heightStr = '';\n\n  if (!this.options.needResetHeight) {\n    <calculateHeightStyle>\n    heightStr = 'height:' + (this.options.rowHeight + 1) + 'px;';\n    </calculateHeightStyle>\n  }\n\n  var createFlag = true;\n  <onBeforeCreateCheck>\n  if (typeof this.options.onBeforeCreateLeftMul == 'function') {\n    var obj = {\n      gridObj: this,\n      rowObj: row\n    };\n    createFlag = this.options.onBeforeCreateLeftMul.call(this, obj);\n  }\n  </onBeforeCreateCheck>\n\n  <generateHTML>\n  // Create HTML string based on the above checks\n  </generateHTML>\n\n  return htmlStr;\n}\n"], ["click", "\nfunction click(d) {\n  if (!d.children) {\n    <addAnnotationTag>\n    context.queryLib.addAnnotationTag(d.text);\n    </addAnnotationTag>\n    return;\n  }\n\n  <calculateTransitionValues>\n  kx = (d.y ? w - 40 : w) / (1 - d.y);\n  ky = h / d.dx;\n  x.domain([d.y, 1]).range([d.y ? 40 : 0, w]);\n  y.domain([d.x, d.x + d.dx]);\n  </calculateTransitionValues>\n\n  <performTransition>\n  var t = g.transition()\n      // Transition details and animations here\n  </performTransition>\n\n  <stopEventPropagation>\n  d3.event.stopPropagation();\n  </stopEventPropagation>\n}\n"], ["codeAroundComment", "\nfunction codeAroundComment(token) {\n  let currentToken = token;\n\n  <findPreviousNonCommentToken>\n  do {\n    currentToken = sourceCode.getTokenBefore(currentToken, { includeComments: true });\n  } while (currentToken && astUtils.isCommentToken(currentToken));\n  </findPreviousNonCommentToken>\n\n  <checkTokenOnSameLineBefore>\n  if (currentToken && astUtils.isTokenOnSameLine(currentToken, token)) {\n    return true;\n  }\n  </checkTokenOnSameLineBefore>\n\n  currentToken = token;\n\n  <findNextNonCommentToken>\n  do {\n    currentToken = sourceCode.getTokenAfter(currentToken, { includeComments: true });\n  } while (currentToken && astUtils.isCommentToken(currentToken));\n  </findNextNonCommentToken>\n\n  <checkTokenOnSameLineAfter>\n  if (currentToken && astUtils.isTokenOnSameLine(token, currentToken)) {\n    return true;\n  }\n  </checkTokenOnSameLineAfter>\n\n  return false;\n}\n"], ["setIndexInfo", "\nfunction setIndexInfo(name, origWhere, origSort) {\n  origWhere = origWhere || {};\n  origSort = origSort || {};\n\n  <preventDuplicatingId>\n  if (origWhere._id) {\n    return;\n  }\n  </preventDuplicatingId>\n\n  var whereNames = [], where = {}, whereSorted = {};\n  var sortNames = [], sort = {}, sortSorted = {};\n\n  <prepareWhereConstraints>\n  _.each(origWhere, function (val, key) {\n    whereNames.push(key);\n    where[key] = 1;\n  });\n  _.each(whereNames.sort(), function (key) {\n    whereSorted[key] = 1;\n  });\n  </prepareWhereConstraints>\n\n  <prepareSortConstraints>\n  _.each(origSort, function (val, key) {\n    sortNames.push(key);\n    sort[key] = origSort[key];\n  });\n  _.each(sortNames.sort(), function (key) {\n    sortSorted[key] = origSort[key];\n  });\n  </prepareSortConstraints>\n\n  <prepareIndexInfoQuery>\n  var json = {\n    name: name,\n    where: where,\n    sort: sort\n  };\n  var str = JSON.stringify(json);\n  var query = cache.idxInfo[str] = cache.idxInfo[str] || {\n    str: str,\n    name: name,\n    count: 0\n  };\n  query.count++;\n  </prepareIndexInfoQuery>\n\n  <checkForIndexInfoSave>\n  var now = (new Date()).getTime();\n  if ((now - idxInfoLastSave) > idxInfoInterval) {\n    idxInfoLastSave = now;\n    saveIndexInfo();\n  }\n  </checkForIndexInfoSave>\n}\n"], ["getRefresh", "\nfunction getRefresh (weex) {\n  const { extractComponentStyle } = weex\n  const { dispatchNativeEvent } = weex.utils\n\n  return {\n    <componentDefinition>\n    // Component definition here\n    </componentDefinition>\n  }\n}\n"], "```\n\nFor each function, I've identified blocks of code that represent individual cohesive responsibilities based on the SRP. All the identified responsibilities are bordered by the respective tags indicating the area of the code they pertain to. Single lines of code or variable assignments were not tagged on their own unless they are part of larger blocks constituting an underlying process or operation."]