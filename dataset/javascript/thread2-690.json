[["collect", "\nfunction collect() {\n  <initializeVariables>\n  let arrOfJsFiles = [];\n  let all = {nameToContent: {}, contentToName: {}};\n  </initializeVariables>\n  <collectFiles>\n  let files = getFiles();\n  </collectFiles>\n  <processFiles>\n  for (let file of files) {\n    <filterJsFiles>\n    if (file.endsWith('.js')) {\n      arrOfJsFiles.push(file);\n    }\n    </filterJsFiles>\n    <processFilesToMappings>\n    if (file.endsWith('.jsx') || file.endsWith('.html') || file.endsWith('.htm') || file.endsWith('.js')) {\n      all.nameToContent[file] = fs.readFileSync(file, 'utf-8');\n      all.contentToName[all.nameToContent[file]] = file;\n    }\n    </processFilesToMappings>\n  }\n  </processFiles>\n  return all;\n}\n"], ["loadVideoInSync", "\nfunction loadVideoInSync(url, syncElement, cb) {\n  <setupVideoElement>\n  cb = once(cb);\n  var element = document.createElement('video');\n  element.crossOrigin = 'anonymous';\n  element.autoplay = true;\n  element.loop = true;\n  element.playsInline = true;\n  element.webkitPlaysInline = true;\n\n  element.onerror = function (e) {\n    cb(e.target.error);\n  };\n  </setupVideoElement>\n\n  <prepareSync>\n  var syncTime = 5000;\n  </prepareSync>\n\n  <setSourceAndWait>\n  element.src = url;\n  \n  waitForReadyState(element, element.HAVE_CURRENT_DATA, 0.2, function () {\n    if (syncElement) {\n      <adjustCurrentTime>\n      if (syncElement.paused) {\n        element.currentTime = syncElement.currentTime;\n      } else {\n        element.currentTime = syncElement.currentTime + syncTime / 1000;\n      }\n      </adjustCurrentTime>\n    }\n\n    waitForReadyState(element, element.HAVE_ENOUGH_DATA, 0.2, function () {\n      <handlePlayback>\n      if (!syncElement) {\n        cb(null, element);\n      } else if (syncElement.paused) {\n        cb(null, element);\n      } else {\n        if (element.currentTime <= syncElement.currentTime) {\n          element.play();\n          cb(null, element);\n        } else {\n          setTimeout(function () {\n            element.play();\n            cb(null, element);\n          }, (element.currentTime - syncElement.currentTime) * 1000);\n        }\n      }\n      </handlePlayback>\n    });\n  });\n  </setSourceAndWait>\n}\n"], ["checkGitRepoExistence", "\nfunction checkGitRepoExistence() {\n    <executeGitCommand>\n    return new Promise(function (resolve, reject) {\n        var checkRepoCommand = childProcess.exec('git branch');\n        checkRepoCommand.stderr.on('data', function (err) {\n            reject(err);\n        });\n        checkRepoCommand.on('close', function (code) {\n            if (code === 0) {\n                resolve();\n            }\n        });\n    });\n    </executeGitCommand>\n}\n"], ["arrayContainsArray", "\nfunction arrayContainsArray(superset, subset, some) {\n  <checkInputTypes>\n  if (Array.isArray(superset) !== true) {\n    throw new Error(`[ethjs-util] method arrayContainsArray requires input 'superset' to be an array got type '${typeof superset}'`);\n  }\n  if (Array.isArray(subset) !== true) {\n    throw new Error(`[ethjs-util] method arrayContainsArray requires input 'subset' to be an array got type '${typeof subset}'`);\n  }\n  </checkInputTypes>\n  <determineContainment>\n  return subset[Boolean(some) && 'some' || 'every'](value => (superset.indexOf(value) >= 0));\n  </determineContainment>\n}\n"], ["insertCharacterInText", "\nfunction insertCharacterInText(text, index, character) {\n  <evaluateAndInsert>\n  if (text && text.length > index) {\n    return text.substr(0, index) + character + text.substr(index + character.length);\n  } else {\n    return text;\n  }\n  </evaluateAndInsert>\n}\n"], ["createRule", "\nfunction createRule(name, validator) {\n  <createAndSetupRule>\n  var async = this.isAsync(name);\n  var rule = new Rule(name, rules[name], async);\n  rule.setValidator(validator);\n  </createAndSetupRule>\n  return rule;\n}\n"], ["updateJumpOver", "\nfunction updateJumpOver() {\n  <performUpdates>\n  var updateList = this._jumpOverUpdateList;\n  for (var i = 0; i < updateList.length; i++) {\n      updateList[i].update();\n  }\n  </performUpdates>\n}\n"], ["adminRequest", "\nfunction adminRequest(params, cb) {\n  <parameterSetup>\n  params = params || {};\n  var mbaasConf = params[constants.MBAAS_CONF_KEY];\n  params[constants.MBAAS_CONF_KEY] = undefined;\n  log.logger.debug({params: params}, \"FH-MBAAS-CLIENT: adminRequest \");\n  var fullParams = _.extend(_.clone(params), mbaasConf);\n  </parameterSetup>\n\n  <loggingAndValidation>\n  log.logger.info({\n    env: params.environment,\n    domain: fullParams.domain,\n    mbaasUrl: fullParams.__mbaasUrl\n  }, \"FH-MBAAS-CLIENT.adminRequest - calling mbaas:\");\n  var invalidParamError = validateAdminParams(fullParams);\n\n  if (invalidParamError) {\n    return cb(invalidParamError);\n  }\n  fullParams.data = fullParams.data || {};\n  fullParams.data.notStats = params.notStats;\n  fullParams = _buildAdminMbaasParams(fullParams);\n  log.logger.debug({fullParams: fullParams}, \"FH-MBAAS-CLIENT: adminRequest \");\n  </loggingAndValidation>\n\n  <makingRequest>\n  return doFHMbaaSRequest(fullParams, cb);\n  </makingRequest>\n}\n"], ["isParametersTable", "\nfunction isParametersTable($table) {\n  <checkTableIdentity>\n  const hasParametersHeaders = $table.find('thead').text().replace(/\\s/g, '') === 'NameTypeDescription';\n  const isResponseBodyTable = /Response/.test($table.prevAll('h3').text());\n  </checkTableIdentity>\n  return hasParametersHeaders && !isResponseBodyTable;\n}\n"], ["executeRelationshipModelChange", "\nfunction executeRelationshipModelChange(options) {\n  <enqueueChangeEvent>\n  var dit = this;\n  Backbone.Relational.eventQueue.add(function () {\n    Backbone.Model.prototype.change.apply(dit, arguments);\n  });\n  </enqueueChangeEvent>\n}\n"], "```"]