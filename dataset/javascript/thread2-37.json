[["_isValidCoreURI", "\nfunction _isValidCoreURI(coreURI) {\n  <validateCoreURI>\n  if (_isEmpty(coreURI) || !_isString(coreURI)) return false\n\n  try {\n    return isURL(coreURI, {\n      protocols: ['https'],\n      require_protocol: true,\n      host_whitelist: [/^[a-z]\\.chainpoint\\.org$/]\n    })\n  } catch (error) {\n    return false\n  }\n  </validateCoreURI>\n}\n"], ["noMarkdown", "\nfunction noMarkdown(value, config) {\n  <processConfig>\n  var allow\n\n  if (Array.isArray(config)) {\n    allow = config\n  } else if (config) {\n    allow = config.allow\n  }\n  </processConfig>\n  \n  <applyNoMarkdown>\n  return core(value, makeText(config).use(filter, {allow: allow}))\n  </applyNoMarkdown>\n}\n"], ["calculateContentHeight", "\nfunction calculateContentHeight(jqElement) {\n  <measureElementHeight>\n   jqElement.css('visibility', 'hidden');\n   jqElement.css('overflow', 'visible');\n   jqElement.css('height', 'auto');\n   const height = jqElement.outerHeight(true);\n   jqElement.css('height', '0px');\n   jqElement.css('overflow', '');\n   jqElement.css('visibility', '');\n\n   return height;\n   </measureElementHeight>\n}\n"], ["loadModels", "\nfunction loadModels(mongoose, modelPath) {\n  <checkMongooseInstance>\n    if (mongoose === undefined) {\n        throw new Error('expect a mongoose handle to be passed');\n    }\n  </checkMongooseInstance>\n\n  <loadModelHandle>\n    return getMongoHandle(mongoose).then((modelHandle) => {\n        debuglog(`got a mongo handle for ${modelPath}`);\n        return _loadModelsFull(modelHandle, modelPath);\n    });\n  </loadModelHandle>\n}\n"], ["createMatch", "\nfunction createMatch(m, data) {\n  <ensureNonZeroLengthMatch>\n        if (!m[0]) {\n          throw 'findAndReplaceDOMText cannot handle zero-length matches';\n        }\n  </ensureNonZeroLengthMatch>\n\n  <createMatchObject>\n        return {\n          start: m.index,\n          end: m.index + m[0].length,\n          text: m[0],\n          data: data\n        };\n  </createMatchObject>\n}\n"], ["persistPnode", "\nfunction persistPnode(pnode, validated) {\n  <checkAndPersistNode>\n        if (pnode.exists) return pnode\n        if (!validated && !validPath(pnode.path)) throw error('INVALIDPATH', 'invalid path: ' + pnode.path)\n        Object.defineProperty(pnode, 'path', {enumerable:true, configurable: false, writable: false, value:pnode.path})\n        data[pnode.path] = pnode\n  </checkAndPersistNode>\n\n  <updateNodeTree>\n        if (pnode.parent) {\n            persistPnode(pnode.parent, true)\n            addChild(pnode.parent, pnode)\n        }\n  </updateNodeTree>\n\n  <incrementTrackers>\n        incTransaction()\n        incPnodeVersion(pnode)\n  </incrementTrackers>\n  \n  <notifyCreation>\n        feed('create', pnode)\n  </notifyCreation>\n\n        return pnode\n}\n"], ["clearDOMChildren", "\nfunction() {\n        var child;\n        var root = this.vectorRoot;\n        <removeVectorRootChildren>\n        if (root) {\n            while (child = root.firstChild) {\n                root.removeChild(child);\n            }\n        }\n        </removeVectorRootChildren>\n        \n        <removeTextRootChildren>\n        root = this.textRoot;\n        if (root) {\n            while (child = root.firstChild) {\n                root.removeChild(child);\n            }\n        }\n        </removeTextRootChildren>\n        \n        <clearIndexer>\n        if (this.indexer) {\n            this.indexer.clear();\n        }\n        </clearIndexer>\n}\n"], ["_createTagInfo", "\nfunction _createTagInfo(token, tokenType, offset, exclusionList, tagName, attrName, shouldReplace) {\n  <createTagInformation>\n        return {\n            token: token || null,\n            tokenType: tokenType || null,\n            offset: offset || 0,\n            exclusionList: exclusionList || [],\n            tagName: tagName || \"\",\n            attrName: attrName || \"\",\n            shouldReplace: shouldReplace || false\n        };\n  </createTagInformation>\n}\n"], ["jobServerWorkflow", "\nfunction () {\n        const self = this;\n\n        let _restartCount = 0;\n\n        <startListening>\n        self.startListening = (cronTasks) => {\n            var self = this;\n            self.cronTasks = cronTasks;\n            return JobManagementDbConnector.registerNewServer(Shared.getCurrentHostId(), _restartCount++)\n                .then(result => Q(result._id)).then(serverId => self.initializeJob(serverId));\n        };\n        </startListening>\n\n        <initialize>\n        self.initialize = () => {\n            const promises = [];\n            Shared.cronModules(self.cronTasks).forEach(cronModule => {\n                if (cronModule.identity !== self.identity) {\n                    promises.push(cronModule.initializeJob(self.getUniqueServerId()));\n                }\n            });\n\n            return Q.allSettled(promises).then(() => Q());\n        };\n        </initialize>\n\n        <onServerDeletedHandler>\n        self.onServerDeletedHandler = err => {\n            \n            return Q();\n        };\n        </onServerDeletedHandler>\n\n        <cleanServers>\n        const _cleanServers = () => {\n            const initialServerUniqueId = self.getUniqueServerId();\n            return JobManagementDbConnector.doHeartbeat(initialServerUniqueId).catch(err => {\n                Logger.error(\"Cron heartbeat for server id \" + initialServerUniqueId + \" failed\", err);\n                return JobManagementDbConnector.registerNewServer(Shared.getCurrentHostId(), _restartCount);\n            }).then(newServerInfo => {\n                const newServerUniqueId = newServerInfo._id;\n                if (newServerUniqueId && !newServerUniqueId.equals(initialServerUniqueId)) {\n                    ++_restartCount;\n                    Logger.info(\"This server was assigned a new unique id \" + newServerUniqueId);\n\n                    \n                    self.setUniqueServerId(newServerUniqueId);\n                    Shared.cronModules(self.cronTasks).forEach(cronModule => {\n                        if (cronModule.identity !== self.identity) {\n                            cronModule.setUniqueServerId(newServerUniqueId);\n                        }\n                    });\n                }\n                return Q();\n            }).then(() => {\n                return JobManagementDbConnector.cleanJobsOfDeadServers(_deathInterval).then(deadServersCount => {\n                    if (deadServersCount > 0) {\n                        Logger.info(\"Killed all jobs on \" + deadServersCount + \" server(s) without heartbeat\");\n                    }\n                    return Q();\n                });\n            });\n        };\n        </cleanServers>\n\n        <updateJobConfigs>\n        const _updateJobConfigs = () => {\n            var promises = [];\n            Shared.cronModules(self.cronTasks).forEach(cronModule => {\n                if (cronModule.identity != self.identity) {\n                    promises.push(cronModule.updateJob());\n                }\n            });\n            \n            promises.push(self.updateJob());\n            return Q.allSettled(promises).then(() => Q());\n        };\n        </updateJobConfigs>\n\n        <worker>\n        self.worker = () => {\n            return Q.allSettled([\n                _cleanServers(),\n                _updateJobConfigs()\n            ]);\n        };\n        </worker>\n}\n"], ["simulateEvent", "\nfunction(event) {\n\t<simulateDOMEvent>\n\tjQuery.event.simulate(fix, event.target, jQuery.event.fix(event));\n\t</simulateDOMEvent>\n}\n"], "```\nNote: The `simulateEvent` function is so small that it only has a single responsibility which is compliant with the SRP."]