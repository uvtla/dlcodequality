[["set$$1", "\nfunction set$$1(a, b) {\n  var innerEq,\n      outerEq = true;\n\n  if (a.size !== b.size) {\n    return false;\n  }\n\n  a.forEach(function (aVal) {\n    if (!outerEq) {\n      return;\n    }\n\n    innerEq = false;\n    \n    b.forEach(function (bVal) {\n      var parentPairs;\n\n      if (innerEq) {\n        return;\n      }\n\n      parentPairs = pairs;\n      if (innerEquiv(bVal, aVal)) {\n        innerEq = true;\n      }\n\n      pairs = parentPairs;\n    });\n\n    if (!innerEq) {\n      outerEq = false;\n    }\n  });\n\n  return outerEq;\n}\n"], ["View", "\nfunction View(tplPath, tplFile, data){\n  this.data = data||{};\n  this.defines = {};\n  this.enabled = true;\n  \n  <configureTemplateSettings>\n  this.settings = doT.templateSettings;\n  this.settings.varname = 'it,helpers'; \n  this.settings.cache = true; \n  this.settings.layout = /\\{\\{##\\s*(?:def\\.)?_layout\\s*(?:\\:|=)\\s*([\\s\\S]+?)\\s*#\\}\\}/; \n  </configureTemplateSettings>\n  if(tplPath){ this.path = tplPath; }\n  if(tplFile){\n    this.file = tplFile;\n    \n    <initializeLayout>\n    this.layout();\n    </initializeLayout>\n  }\n}\n"], ["createStylToCss", "\nfunction createStylToCss(stylPath) {\n  return new Promise((resolve, reject) => {\n    try {\n      const stylStr = FS.readFileSync(stylPath, 'utf8');\n      \n      <stylusRendering>\n      stylus(stylStr.toString())\n        .set('filename', stylPath)\n        .set('compress', true)\n        .render((err, css) => {\n          if (err) throw err;\n          resolve(css);\n        });\n      </stylusRendering>\n    } catch (err) {\n      reject(err);\n    }\n  });\n}\n"], ["stripify", "\nfunction stripify(file) {\n  if (/\\.json$/.test(file)) return through();\n\n  var code = '';\n\n  <transform>\n  function transform(chunk, encoding, next) {\n    code += chunk;\n    next();\n  }\n  </transform>\n\n  <flush>\n  function flush(done) {\n    var ast = rocambole.parse(code);\n\n    code = rocambole.moonwalk(ast, function strip(node) {\n      if (/* condition to match nodes */ ) {\n        return remove(node);\n      }\n    });\n\n    this.push(code.toString());\n    done();\n  }\n  </flush>\n\n  return through(transform, flush);\n}\n"], ["processTextContent", "\nfunction processTextContent(text) {\n  if (destroyed) {\n      return;\n  }\n\n  \n  <checkForExcessiveTextBoxes>\n  var numTextBoxes = util.countInStr(text, '<div');\n  \n  if (numTextBoxes > MAX_TEXT_BOXES) {\n      return '';\n  }\n  </checkForExcessiveTextBoxes>\n\n  \n  <removeStylesheetLinks>\n  text = text.replace(/<link rel=\"stylesheet\".*/, '');\n  </removeStylesheetLinks>\n\n  return text;\n}\n"], ["match", "\nfunction match(o, p, strict) {\n\n  var o_type = get_type(o),\n      p_type = get_type(p);\n\n  if (strict) {\n    <strictTypeComparison>\n    if (o_type !== p_type) { return false; }\n    </strictTypeComparison>\n\n    <strictValueComparison>\n    switch (o_type) {\n      // Case checks\n    }\n    </strictValueComparison>\n\n  } else {\n    <looseValueComparison>\n    switch (p_type) {\n      // Case checks\n    }\n    </looseValueComparison>\n  }\n}\n"], ["ImmutableCoreModelFormInstance", "\nfunction ImmutableCoreModelFormInstance(args) {\n  \n  <mergeFormArguments>\n  _.merge(this, args.form)\n  </mergeFormArguments>\n\n  <reinitializeFields>\n  this.fields = _.cloneDeep(args.form.fields)\n  </reinitializeFields>\n\n  <cleanupArguments>\n  delete args.form\n  </cleanupArguments>\n\n  <initializeBasedOnArgs>\n  if (args.record) {\n      this.initRecord(args.record)\n      \n      delete args.record\n  }\n  \n  else if (args.error) {\n      this.initInput(args.input, args.error)\n      \n      delete args.error\n      delete args.input\n  }\n  \n  else if (args.input) {\n      this.initInput(args.input)\n      \n      delete args.input\n  }\n  </initializeBasedOnArgs>\n\n  <mergeRemainingArguments>\n  mergeArgs(this, args)\n  </mergeRemainingArguments>\n\n  <conditionallySetReadonlyAndSubmit>\n  if (args.mode === 'update' && !this.model.columnName('parentId')) {\n      \n      _.each(this.fields, field => {\n          field.readonly = true\n      })\n      \n      this.submit = false\n  }\n  </conditionallySetReadonlyAndSubmit>\n}\n"], ["myOnresizebeforedraw", "\nfunction myOnresizebeforedraw(obj) {\n  var gutterLeft = obj.Get('chart.gutter.left');\n  var gutterRight = obj.Get('chart.gutter.right');\n\n  <setHorizontalMargins>\n  obj.Set('chart.hmargin', (obj.canvas.width - gutterLeft - gutterRight) / (obj.original_data[0].length * 2));\n  </setHorizontalMargins>\n}\n"], ["getAliases", "\nfunction getAliases(obj) {\n  var names = {};\n\n  <addMainName>\n  if (obj.name) {\n    names[obj.name] = true;\n  }\n  </addMainName>\n\n  <addAllAliases>\n  var aliases = obj.aliases;\n  var i, l;\n  for (i = 0, l = aliases.length; i < l; i++) {\n    names[aliases[i]] = true;\n  }\n  </addAllAliases>\n\n  <generateUniqueAliasList>\n  return Object.keys(names);\n  </generateUniqueAliasList>\n}\n"], ["anonymousConfigFunction", "\nfunction(config) {\n  <omitSettings>\n  config = omit(config, 'settings');\n  </omitSettings>\n\n  <cloneAndSubstitute>\n  var subbed = cloneDeep(config);\n  var subFlag = this._applySubstitutions(subbed, null, null);\n  </cloneAndSubstitute>\n\n  <determineConfigVariant>\n  var unsubbed = subFlag ? config : subbed;\n  </determineConfigVariant>\n\n  <returnConfigVariants>\n  return {subbed:subbed, unsubbed:unsubbed};\n  </returnConfigVariants>\n}\n"], "\n---\n\nIn all provided functions, nested tags indicate parts of the code that are handling distinct responsibilities which might be considered violations of the Single Responsibility Principle. Each tagged section shows a separate logical concern, providing clarity on how the larger function is comprised of multiple tasks."]