[["generateColors", "\nfunction generateColors(conf) {\n  for (var key in conf.color) {\n    if (typeof conf.color[key] !== 'string') continue;\n    conf.color[key] = new Color(conf.color[key]);\n  }\n  return conf;\n}\n"], ["calculateElementPosition", "\nfunction (hostEl, targetEl, positionStr, appendToBody) {\n  var positionStrParts = positionStr.split('-');\n  var pos0 = positionStrParts[0], pos1 = positionStrParts[1] || 'center';\n\n  <calculateHostElementPosition>\n  var hostElPos = appendToBody ? this.offset(hostEl) : this.position(hostEl);\n  </calculateHostElementPosition>\n\n  <getTargetElementSize>\n  var targetElWidth = targetEl.prop('offsetWidth');\n  var targetElHeight = targetEl.prop('offsetHeight');\n  </getTargetElementSize>\n\n  <defineShiftWidth>\n  var shiftWidth = {\n    center: function () {\n      return hostElPos.left + hostElPos.width / 2 - targetElWidth / 2;\n    },\n    left: function () {\n      return hostElPos.left;\n    },\n    right: function () {\n      return hostElPos.left + hostElPos.width;\n    }\n  };\n  </defineShiftWidth>\n\n  <defineShiftHeight>\n  var shiftHeight = {\n    center: function () {\n      return hostElPos.top + hostElPos.height / 2 - targetElHeight / 2;\n    },\n    top: function () {\n      return hostElPos.top;\n    },\n    bottom: function () {\n      return hostElPos.top + hostElPos.height;\n    }\n  };\n  </defineShiftHeight>\n\n  <calculateTargetElementPosition>\n  var targetElPos;\n  switch (pos0) {\n    case 'right':\n      targetElPos = {\n        top: shiftHeight[pos1](),\n        left: shiftWidth[pos0]()\n      };\n      break;\n    case 'left':\n      targetElPos = {\n        top: shiftHeight[pos1](),\n        left: hostElPos.left - targetElWidth\n      };\n      break;\n    case 'bottom':\n      targetElPos = {\n        top: shiftHeight[pos0](),\n        left: shiftWidth[pos1]()\n      };\n      break;\n    default:\n      targetElPos = {\n        top: hostElPos.top - targetElHeight,\n        left: shiftWidth[pos1]()\n      };\n      break;\n  }\n  </calculateTargetElementPosition>\n\n  return targetElPos;\n}\n"], ["composeConfigurations", "\nfunction compose(...args) {\n  \n  const crsConfigs = args.slice(0).reverse();\n  <aggregateConfigurations>\n  const crsConfig = {\n    env: pipe(crsConfigs.map(c => c.env)),\n    paths: pipe(crsConfigs.map(c => c.paths)),\n    webpack: pipe(crsConfigs.map(c => c.webpack)),\n    devServer: pipe(crsConfigs.map(c => c.devServer)),\n    jest: pipe(crsConfigs.map(c => c.jest)),\n    scripts: mergeScripts(crsConfigs.map(c => c.scripts)),\n  };\n  </aggregateConfigurations>\n  return crsConfig;\n}\n"], ["numberType", "\nfunction numberType(mname, tpe, options) {\n  const doubles = options.themeDoubles.split(',')\n  if (doubles && doubles.includes(mname)) {\n    return 'Double'\n  } else {\n    return 'Int'\n  }\n}\n"], ["slugify", "\nfunction slugify(str) {\n  return str\n    .replace(/[\u00c0\u00c1\u00c2\u00c3\u00c4\u00c5\u00e0\u00e1\u00e2\u00e3\u00e4\u00e5\u00e6\u00c6]/g, 'a')\n    .replace(/[\u00e7\u00c7]/g, 'c')\n    .replace(/[\u00f0\u00d0]/g, 'd')\n    .replace(/[\u00c8\u00c9\u00ca\u00cb\u00e9\u00e8\u00ea\u00eb]/g, 'e')\n    .replace(/[\u00cf\u00ef\u00ce\u00ee\u00cd\u00ed\u00cc\u00ec]/g, 'i')\n    .replace(/[\u00d1\u00f1]/g, 'n')\n    .replace(/[\u00f8\u00d8\u0153\u0152\u00d5\u00f5\u00d4\u00f4\u00d3\u00f3\u00d2\u00f2]/g, 'o')\n    .replace(/[\u00dc\u00fc\u00db\u00fb\u00da\u00fa\u00d9\u00f9]/g, 'u')\n    .replace(/[\u0178\u00ff\u00dd\u00fd]/g, 'y')\n    .replace(/[^a-z0-9- ]/gi, '')\n    .replace(/ /gi, '-')\n    .toLowerCase();\n}\n"], ["initializeTransports", "\nfunction Transports(oOptions, oLogger) {\n    this._client = new AdtClient(oOptions.conn, oOptions.auth, undefined, oLogger);\n}\n"], ["removeRemoteRepository", "\nasync function removeRemote(name) {\n  try {\n    <executeRemoveRemote>\n    await exec(`git remote remove ${name}`);\n    </executeRemoveRemote>\n    <logRemoval>\n    logger.log(`Removed remote ${name}`);\n    </logRemoval>\n  } catch (error) {\n    throw error;\n  }\n}\n"], ["checkUserPermission", "\nfunction hasPermission (user, modelName, permission, callback) {\n  <retrievePermissions>\n    get(modelName, true).getPermissions(user, function (err, permissions) {\n      if (err) {\n          return callback(false);\n      }\n      return callback(permissions[permission]);\n    });\n  </retrievePermissions>\n}\n"], ["openSTTokenSetup", "\nasync function () {\n  <fetchAndValidate>\n  // Several blocks of code with different concerns are included, like fetching data, validating conditions and logging.\n  // However, as they all pertain to the setup process, I have included them all in one SRP block for the moment.\n  </fetchAndValidate>\n}\n"], ["filterWithInverseCallback", "\nfunction (callback, invert) {\n    var callbackInverse,\n        matches = [],\n        i = 0,\n        length = this.length,\n        callbackExpect = !invert;\n\n    <performFiltering>\n    for (; i < length; i++) {\n        callbackInverse = !callback(this[i], i);\n        if (callbackInverse !== callbackExpect) {\n            matches.push(this[i]);\n        }\n    }\n    </performFiltering>\n\n    return matches;\n}\n"], "```\n\nIn the openSTTokenSetup function, because of its complexity and multiple concerns in a single block of code, this could potentially be a violation of the Single Responsibility Principle if considering discrete operations within it. However, as the overall function is about setting up the ST Token and involves multiple validations and setup steps, I did not sub-divide it further."]