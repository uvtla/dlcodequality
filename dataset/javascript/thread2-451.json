[["updateActionsAndBindings", "\nfunction ( deltaTime ) {\n\tdeltaTime *= this.timeScale;\n\n\tvar actions = this._actions,\n\t\tnActions = this._nActiveActions,\n\n\t\ttime = this.time += deltaTime,\n\t\ttimeDirection = Math.sign( deltaTime ),\n\n\t\taccuIndex = this._accuIndex ^= 1;\n\t\n\t<updateActions>\n\tfor ( var i = 0; i !== nActions; ++ i ) {\n\t\tvar action = actions[ i ];\n\t\taction._update( time, deltaTime, timeDirection, accuIndex );\n\t}\n\t</updateActions>\n\t\n\t<updateBindings>\n\tvar bindings = this._bindings,\n\t\tnBindings = this._nActiveBindings;\n\tfor ( var i = 0; i !== nBindings; ++ i ) {\n\t\tbindings[ i ].apply( accuIndex );\n\t}\n\t</updateBindings>\n\treturn this;\n}\n"], ["baseConfig", "\nfunction baseConfig() {\n\treturn {\n\t\toutput: {\n\t\t\tformat: 'umd',\n\t\t\tsourcemap: true,\n\t\t\tbanner: ``,\n\t\t},\n\t\tplugins: [\n\t\t\tresolve({\n\t\t\t\tjsnext: true,\n\t\t\t\tmain: true,\n\t\t\t\tbrowser: true,\n\t\t\t}),\n\t\t\tcommonjs({\n\t\t\t\textensions: [\n\t\t\t\t\t'.js',\n\t\t\t\t\t'.jsx',\n\t\t\t\t\t'.json',\n\t\t\t\t],\n\t\t\t}),\n\t\t],\n\t}\n}\n"], ["sanitizeLines", "\nfunction sanitizeLines(frame) {\n\tlines = stripAnsi(frame)\n\t\t.replace(/\\r/g, '')\n\t\t.split('\\n')\n\t\t.map(l => l.replace(/\\t/g, '  '))\n\t\n\tvar leftCaretLine = lines.find(l => l.startsWith('>'))\n\tif (leftCaretLine) {\n\t\tlines[lines.indexOf(leftCaretLine)] = leftCaretLine.replace('>', ' ')\n\t}\n\t\n\t<trimLeadingSpaces>\n\twhile (lines.find(l => !l.startsWith(' ')) == undefined) {\n\t\tlines = lines.map(l => l.slice(1))\n\t}\n\t</trimLeadingSpaces>\n\treturn lines\n}\n"], ["popinOpen", "\nfunction popinOpen(name) {\n\tvar $overlay = instance.target.childNodes[0];\n\n\t<overlayClickListener>\n\taddListener(gina, $overlay, 'click', function(event) {\n\t\tif ( /gina-popin-is-active/.test(event.target.className) ) {\n\t\t\tremoveListener(gina, event.target, 'click');\n\t\t\t<closeButtonActions>\n\t\t\tvar $close = [], $buttonsTMP = [];\n\t\t\t// Code block to find and push buttons, divs, and anchors with a certain class into $close array\n\t\t\t// and then remove their listeners and call popinClose.\n\t\t\t</closeButtonActions>\n\t\t\tpopinClose(name);\n\t\t}\n\t});\n\t</overlayClickListener>\n\n\t<initializePopin>\n\tvar id = null, $el = null;\n\t// Code block for setting up the pop-in element's ID and class\n\t</initializePopin>\n\n\t<closeButtonClickLogic>\n\tvar $close = [], $buttonsTMP = [];\n\t// Code block to find close buttons and attach click events to them\n\tfor (var b = 0, len = $close.length; b < len; ++b) {\n\t\t// Code block to ensure the closing functionality on close buttons anchors\n\t}\n\t</closeButtonClickLogic>\n\n\t<additionalCleanUp>\n\tif ( /gina-popin-is-active/.test(event.target.className) ) {\n\t\tremoveListener(gina, event.target, event.target.getAttribute('id'))\n\t}\n\t</additionalCleanUp>\n\n\t$updatePopinState\n\t$popin.isOpen = true;\n\t$popin.target = $el;\n\t</updatePopinState>\n\n\t<updateGinaToolbar>\n\tvar XHRData = document.getElementById('gina-without-layout-xhr-data');\n\tif (gina && typeof(window.ginaToolbar) == \"object\" && XHRData) {\n\t\ttry {\n\t\t\tif (typeof(XHRData.value) != 'undefined' && XHRData.value) {\n\t\t\t\tXHRData = JSON.parse(decodeURIComponent(XHRData.value));\n\t\t\t\tginaToolbar.update(\"data-xhr\", null);\n\t\t\t\tginaToolbar.update(\"data-xhr\", XHRData);\n\t\t\t}\n\t\t} catch (err) {\n\t\t\tthrow err\n\t\t}\n\t}\n\t</updateGinaToolbar>\n\n\t<triggerPopinEvent>\n\ttriggerEvent(gina, instance.target, 'open.'+ $popin.id, $popin);\n\t</triggerPopinEvent>\n}\n"], ["renewNodeLease", "\nfunction(cb0) {\n\ttry {\n\t\tif (nodeId) {\n\t\t\t$._.$[ns].renewNodeLease(privateNodeId, leaseTimeout, cb0);\n\t\t} else {\n\t\t\tcb0(null);\n\t\t}\n\t} catch (err) {\n\t\tcb0(err);\n\t}\n}\n"], ["getNextSiblingNode", "\nfunction( evaluator ) {\n\tvar next = this.$, retval;\n\tdo {\n\t\tnext = next.nextSibling;\n\t\tretval = next && new CKEDITOR.dom.node( next );\n\t}\n\twhile ( retval && evaluator && !evaluator( retval ) )\n\treturn retval;\n}\n"], ["getStorage", "\nfunction getStorage() {\n\tconst storageChoice = config.get('storage:active');\n\tlet storageConfig,\n\t\tCustomStorage,\n\t\tcustomStorage;\n\n\tstorageConfig = config.get('storage')[storageChoice];\n\n\t<validateStorageChoice>\n\tif (!storageChoice) {\n\t\tthrow new common.errors.IncorrectUsageError({\n\t\t\tmessage: 'No adapter found'\n\t\t});\n\t}\n\t</validateStorageChoice>\n\n\t<storageRetrieval>\n\tif (storage[storageChoice]) {\n\t\treturn storage[storageChoice];\n\t}\n\t</storageRetrieval>\n\n\t<customStorageLoading>\n\ttry {\n\t\tCustomStorage = require(`${config.getContentPath('storage')}${storageChoice}`);\n\t} catch (err) {\n\t\t// Catch block code handling various errors in module loading\n\t}\n\ttry {\n\t\tCustomStorage = CustomStorage || require(`${config.get('paths').internalStoragePath}${storageChoice}`);\n\t} catch (err) {\n\t\t// Catch block code handling errors in module loading from a different path\n\t}\n\t</customStorageLoading>\n\n\t<storageInstantiation>\n\tcustomStorage = new CustomStorage(storageConfig);\n\t// Various checks for correctness of the custom storage following its instantiation\n\t</storageInstantiation>\n\n\tstorage[storageChoice] = customStorage;\n\treturn storage[storageChoice];\n}\n"], ["getRoute", "\nfunction getRoute(exportFuncs, cb, ctrlpath, curCtrlname) {\n\tctrlpath = ctrlpath || [];\n\t<earlyReturnConditions>\n\t// Code block for early return conditions\n\t</earlyReturnConditions>\n\n\t<handleRoute>\n\tlet totalCtrlname = curCtrlname ? ctrlpath.concat([curCtrlname]) : ctrlpath;\n\tif (typeof exportFuncs === 'function') {\n\t\tcb(exportFuncs, totalCtrlname);\n\t} else {\n\t\t// Code block for handling the route recursion\n\t}\n\t</handleRoute>\n}\n"], ["MatrixInitialization", "\nfunction Matrix(arg) {\n\tif (arg && arguments.length === 1) {\n\t\tif (arg instanceof window.SVGMatrix) this.mtx = arg.scale(1);\n\t\telse if (arg instanceof Matrix) this.mtx = arg.mtx.scale(1);\n\t\telse if (typeof arg == \"string\") return Matrix.parse(arg);\n\t\telse throw new Error(arg + \" : argument incorrect pour Matrix.\");\n\t}\n\telse {\n\t\tthis.mtx = svg && svg.createSVGMatrix();\n\t\tif (arguments.length === 6) {\n\t\t\tvar a = arguments, that = this;\n\t\t\t['a', 'b', 'c', 'd', 'e', 'f'].forEach(function(prop, ind) { that[prop] = a[ind]; });\n\t\t}\n\t}\n}\n"], ["ProblemsViewConstructor", "\nfunction ProblemsView(options, slideout) {\n\tif (slideout) {\n\t\t<extendSlideoutViewMode>\n\t\tSlideoutViewMode.call(this, slideout);\n\t\t</extendSlideoutViewMode>\n\t}\n\tthis._parent = lib.node(options.parentId ? options.parentId : \"orion.PropertyPanel.container\");\n\tthis.serviceRegistry = options.serviceRegistry;\n\tthis.commandRegistry = options.commandRegistry;\n\tthis.preferences = options.preferences;\n\tthis.fileClient = options.fileClient;\n\tthis.contentTypeRegistry = options.contentTypeRegistry;\n\t<initializeProblemsView>\n\tthis._init(slideout);\n\t</initializeProblemsView>\n}\n"], "```\n\nThe functions are all wrapped in tags based on their primary responsibility, with subsections within the functions tagged if they carry out distinct tasks that could be considered separate responsibilities. These sub-tags assist in identifying complex elements that might be a violation of the Single Responsibility Principle."]