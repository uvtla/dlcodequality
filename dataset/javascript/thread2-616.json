[["start", "\nfunction start() {\n    <initializeFingers>\n    if (fingers.length === 0) fingers.push(new Finger(), new Finger()); \n    </initializeFingers>\n\n    <setupEventListeners>\n    document.addEventListener('mousedown', phantomTouchStart, true);\n    document.addEventListener('mousemove', phantomTouchMove, true);\n    document.addEventListener('mouseup', phantomTouchEnd, true);\n    document.addEventListener('click', phantomClick, true);\n    document.documentElement.classList.add('_phantom-limb');\n    </setupEventListeners>\n}\n"], ["getDependency", "\nfunction getDependency(dependency) {\n    <resolveDependency>\n    if (dependency) {\n        return angular.isString(dependency) ? $injector.get(dependency) : dependency;\n    }\n    return undefined;\n    </resolveDependency>\n}\n"], ["textStream", "\nfunction textStream() {\n    <generateStart>\n    var start = randomInt(0, config.size - bufferSize)\n    </generateStart>\n    \n    <createReadStream>\n    return fs.createReadStream(dictPath, {\n        encoding: config.encoding,\n        start: start,\n        end: start + bufferSize\n    })\n    </createReadStream>\n}\n"], ["pollUntilDone", "\nfunction pollUntilDone(id, done) {\n    <checkDropletStatus>\n    client.droplets.get(id, function(err, droplet) {\n        if (!err && droplet.locked === false) {\n            done.call();\n        } else if (!err && droplet.locked === true) {\n            setTimeout(function() {\n                pollUntilDone(id, done);\n            }, (10 * 1000));\n        } else {\n            pollUntilDone(id, done);\n        }\n    });\n    </checkDropletStatus>\n}\n"], ["function", "\nfunction(options, filename){\t    \n    <validateArguments>\n    Joi.assert(filename, Joi.string())\n    </validateArguments>\n    \n    <streamFileDownload>\n    return new Promise(function(resolve, reject){\n        try{\t            \n            var writestream = fs.createWriteStream(filename);\n            request(options).pipe(writestream);\n\n            writestream.on('finish', function(err){                 \n                if(err){\n                    reject({\n                        \"path\" : filename,\n                        \"status\" : false,\n                        \"error\": err\n                    });\n                }else{\n                    resolve({\n                        \"path\" : filename,\n                        \"status\" : true\n                    });\n                }\n            });\n        }catch(e){\n            reject(e);\n        }\n    });\n    </streamFileDownload>\n}\n"], ["updateBidQueue", "\nfunction updateBidQueue(auctionInstance, bidResponse, afterBidAdded) {\n    <retrieveBidAddToQueue>\n    let bidListIter = bidCacheRegistry.getBids(bidResponse);\n\n    if (bidListIter) {\n        let bidListArr = from(bidListIter);\n        let callDispatcher = bidCacheRegistry.getQueueDispatcher(bidResponse);\n        let killQueue = !!(auctionInstance.getAuctionStatus() !== AUCTION_IN_PROGRESS);\n        callDispatcher(auctionInstance, bidListArr, afterBidAdded, killQueue);\n    </retrieveBidAddToQueue>\n    \n    <logWarningForUnknownAuction>\n    else {\n        utils.logWarn('Attempted to cache a bid from an unknown auction. Bid:', bidResponse);\n    }\n    </logWarningForUnknownAuction>\n}\n"], ["parseQueryString", "\nfunction parseQueryString(query, options) {\n    <parseAndValidateQuery>\n    const result = {};\n    let parsedQueryString = qs.parse(query);\n\n    for (const key in parsedQueryString) {\n        const value = parsedQueryString[key];\n        if (value === '' || value == null) {\n            throw new MongoParseError('Incomplete key value pair for option');\n        }\n        \n        const normalizedKey = key.toLowerCase();\n        const parsedValue = parseQueryStringItemValue(normalizedKey, value);\n        applyConnectionStringOption(result, normalizedKey, parsedValue, options);\n    }\n    </parseAndValidateQuery>\n\n    <handleConflictingOptions>\n    if (result.wtimeout && result.wtimeoutms) {\n        delete result.wtimeout;\n        console.warn('Unsupported option `wtimeout` specified');\n    }\n    </handleConflictingOptions>\n\n    <returnResult>\n    return Object.keys(result).length ? result : null;\n    </returnResult>\n}\n"], ["id", "\nfunction(id) {\n    <initializeWidget>\n    this._el = Dom.get(id);\n    this.id = Dom.generateId(this._el,\"yui-tv-auto-id-\");\n    </initializeWidget>\n\n    <createEvents>\n    this.createEvent(\"animStart\", this);\n    this.createEvent(\"animComplete\", this);\n    this.createEvent(\"collapse\", this);\n    this.createEvent(\"collapseComplete\", this);\n    this.createEvent(\"expand\", this);\n    this.createEvent(\"expandComplete\", this);\n    this.createEvent(\"enterKeyPressed\", this);\n    this.createEvent(\"clickEvent\", this);\n    this.createEvent('focusChanged',this);\n    this.createEvent(\"dblClickEvent\", {\n        scope:this,\n        onSubscribeCallback: function() {\n            self._hasDblClickSubscriber = true;\n        }\n    });\n    this.createEvent(\"labelClick\", this);\n    this.createEvent(\"highlightEvent\",this);\n    </createEvents>\n    \n    <treeInitialization>\n    this._nodes = [];\n    TV.trees[this.id] = this;\n    this.root = new Widget.RootNode(this);\n    </treeInitialization>\n    \n    <optionalLoggerAndEditorInitialization>\n    var LW = Widget.LogWriter;\n\tif (this._initEditor) {\n\t\tthis._initEditor();\n\t}\n    </optionalLoggerAndEditorInitialization>\n}\n"], ["suspendXPCService", "\nfunction (xpcKey) {\n    <interactWithXPCService>\n    if ($bc_.pN) {\n      try {\n        $bc_.pN.app.suspendXPCService(xpcKey)\n      } catch (e) {\n        console.error(e)\n      }\n    }\n    </interactWithXPCService>\n}\n"], ["pxBounds_maxBounds_zoom", "\nfunction (pxBounds, maxBounds, zoom) {\n    <calculateOffsets>\n    var nwOffset = this.project(maxBounds.getNorthWest(), zoom).subtract(pxBounds.min),\n        seOffset = this.project(maxBounds.getSouthEast(), zoom).subtract(pxBounds.max),\n        dx = this._rebound(nwOffset.x, -seOffset.x),\n        dy = this._rebound(nwOffset.y, -seOffset.y);\n        </calculateOffsets>\n    \n    <returnPoint>\n    return new L.Point(dx, dy);\n    </returnPoint>\n}\n"], ""]