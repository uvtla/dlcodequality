[["createSearchIndex", "\nfunction (config) {\n  var idx = new lunr.Index\n\n  idx.pipeline.add(\n    lunr.trimmer,\n    lunr.stopWordFilter,\n    lunr.stemmer\n  )\n\n  if (config) config.call(idx, idx)\n\n  return idx\n}\n"], ["startCronJobs", "\nfunction () {\n    const cronJobsToStart = _getNamesOfCronJobsToStart();\n    if (!cronJobsToStart && _shouldStartCrons() && Shared.isDbConnectionAvailable() === true) {\n        return CronJobManagerJob.startListening().then(function () {\n            Logger.tag('Cron').info('Cron Job Manager is started. Starting all available cron jobs');\n            return Q();\n        }, function (err) {\n            Logger.tag('Cron').error('Error starting Cron Job Manager ');\n            return Q.reject(err);\n        });\n    } else if (cronJobsToStart && _shouldStartCrons()) {\n\n        Logger.tag('Cron').info('Starting specific cron jobs \"' + cronJobsToStart.join(', ') + '\"');\n\n        try {\n            const cronJobs = Shared.cronModules(cronJobsToStart);\n            let promises = [];\n            for (let cron of cronJobs) {\n                \n                cron.forceRun = true;\n                promises.push(cron.worker(cron, cron));\n            }\n            return Q.all(promises)\n                .then(() => process.exit())\n                .catch(() => process.exit(1));\n        } catch (err) {\n            process.exit(1);\n        }\n    } else {\n        Logger.tag('Cron').warn('Cron Manager is disabled for this environment.');\n        return Q();\n    }\n}\n"], ["determineOrientation", "\nfunction() {\n\tif (!gui.hosted) {\n\t\tgui.orientation = window.innerWidth > window.innerHeight ? 1 : 0;\n\t\tgui.broadcastGlobal(gui.BROADCAST_ORIENTATIONCHANGE, gui.orientation);\n\t}\n}\n"], ["runAfterSuccessScripts", "\nfunction runAfterSuccessScripts() {\n  const autorelease =\n    pkg.version === '0.0.0-semantically-released' &&\n    parseEnv('TRAVIS', false) &&\n    process.env.TRAVIS_BRANCH === 'master' &&\n    !parseEnv('TRAVIS_PULL_REQUEST', false)\n\n  const reportCoverage = hasFile('coverage') && !parseEnv('SKIP_CODECOV', false)\n\n  if (!autorelease && !reportCoverage) {\n    console.log(\n      'No need to autorelease or report coverage. Skipping travis-after-success script...',\n    )\n  } else {\n    const result = spawn.sync(\n      resolveBin('concurrently'),\n      getConcurrentlyArgs(\n        {\n          codecov: reportCoverage\n            ? `echo installing codecov && npx -p codecov@3 -c 'echo running codecov && codecov'`\n            : null,\n          release: autorelease\n            ? `echo installing semantic-release && npx -p semantic-release@15 -c 'echo running semantic-release && semantic-release'`\n            : null,\n        },\n        {killOthers: false},\n      ),\n      {stdio: 'inherit'},\n    )\n\n    process.exit(result.status)\n  }\n}\n"], ["printKeyInfo", "\nfunction printKey () {\n  let keyid = printKeyid(this.primaryKey.getKeyId())\n  let userid = printUser(this.getPrimaryUser().user)\n  return keyid + ' ' + userid\n}\n"], ["traversalToJson", "\nfunction traversalToJson(traversal) {\n  var array = traversal.toList().toArray().map(function (elem) { return asJSON(elem); });\n  return JSON.parse(JSON.stringify(array));\n}\n"], ["processMessages", "\nfunction task () {\n  run = true;\n  var item = messages.shift();\n  if (!item) {\n    run = false;\n  } else if ('message' in item) {\n    if (output_) {\n      write(item);\n    } else {\n      task();\n    }\n  } else if (item.path) {\n    p_ = path.resolve(p_, item.path);\n    task();\n  } else if ('output' in item) {\n    output_ = item.output;\n    task();\n  } else {\n    task();\n  }\n}\n"], ["refreshAuthentication", "\nfunction(refreshToken, callback) {\n  return postParams(this.tokenServiceUrl, {\n    grant_type : \"refresh_token\",\n    refresh_token : refreshToken,\n    client_id : this.clientId,\n    client_secret : this.clientSecret\n  }, callback);\n}\n"], ["bindSocketEvents", "\nfunction bindSocket(io, indicator) {\n  Object.keys(indicator.watch).forEach((key) => {\n    let eventName = indicator.watch[key];\n    indicator.on(eventName, (msg) => io.emit(eventName, msg));\n  });\n}\n"], ["unsuspendSubscription", "\nfunction unsuspendSubscriber (topic, token) {\n  if (typeof token === 'string') {\n    return !!applyTopicDescendents(\n      unsuspendTopic, 'subscriptions', token, topic\n    );\n  }\n\n  var node = ancestorTopicSearch(token.topic, topic);\n  if (node.topic !== token.topic) {\n    return false;\n  }\n\n  var i = searchAround(\n    getId, getPriority,\n    token.id, token.priority,\n    binaryIndexBy(getPriority, token.priority, node.subscriptions),\n    node.subscriptions\n  );\n\n  if (i === -1) {\n    return false;\n  }\n\n  return !!unsuspendNode(node.subscriptions[i]);\n}\n"], "This function is responsible for unsuspending a subscription and appears to be SRP compliant."]