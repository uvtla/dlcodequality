[["normalizeLevel", "\nfunction normalizeLevel(level) {\n  if (level.value <= Logger.Level.ALL.value) {          \n    return Logger.Level.ALL;\n\n  } else if (level.value === Logger.Level.OFF.value) {  \n    return Logger.Level.OFF;\n\n  } else if (level.value < Logger.Level.INFO.value) {\n    return Logger.Level.DEBUG;\n\n  } else if (level.value < Logger.Level.WARNING.value) {\n    return Logger.Level.INFO;\n\n  } else if (level.value < Logger.Level.SEVERE.value) {\n    return Logger.Level.WARNING;\n\n  } else {\n    return Logger.Level.SEVERE;\n  }\n}\n"], ["handlePackageResponse", "\nfunction(err, pkg) {\n  if (!err) {\n    <constructPurl>\n    var purl = undefined;\n    if (pkg.scope) {\n      purl = \"pkg.\" + pkg.format + \".\" + pkg.scope + \".\" + pkg.name + \"@\" + pkg.version;\n    } else {\n      purl = \"pkg.\" + pkg.format + \".\" + pkg.name + \"@\" + pkg.version;\n    }\n    </constructPurl>\n    <cachePackage>\n    myCache.putSync(purl, pkg);\n    </cachePackage>\n  }\n  <executeCallback>\n  callback(err, pkg);\n  </executeCallback>\n}\n"], ["getWiringCollection", "\nfunction get_wiring_collection(req, res, next) {\n  <retrieveCollection>\n\tapp.db.collection('wirings', function(error, wiring_collection) {\n\t\tif(error) { throw error; }\n\t\telse {\n\t\t\treq.wiring_collection = wiring_collection;\n\t\t\tnext();\n\t\t}\n\t});\n  </retrieveCollection>\n}\n"], ["configureChartTitle", "\nfunction() {\n  var chartOpts = this.chart.options;\n  if (chartOpts && chartOpts.title) {\n    this.options = helpers.configMerge(Chart.defaults.global.title, chartOpts.title);\n  }\n}\n"], ["createClause", "\nfunction createClause (options = {}, idField = null) {\n  \n  let clause = `type, properties as properties`\n  <processDateFields>\n  let dateFields = options.dateFields.join(',')\n  </processDateFields>\n  <toggleObjectIdRequirement>\n  let requiresObjectId = !!options.returnIdsOnly || !(options.fields instanceof Array && !options.fields.includes('OBJECTID'))\n  </toggleObjectIdRequirement>\n\n  <buildClause>\n  if (options.fields) {\n    let fields = (options.fields instanceof Array) ? options.fields.join(',') : options.fields.replace(/,\\s+/g, ',')\n    clause = (options.toEsri) ? `pickAndEsriFy(properties, geometry, \"${fields}\", \"${dateFields}\", \"${requiresObjectId}\", \"${options.idField}\") as attributes` : `pick(properties, \"${fields}\") as properties`\n  } else if (options.toEsri) {\n    clause = `esriFy(properties, geometry, \"${dateFields}\", \"${requiresObjectId}\", \"${options.idField}\") as attributes`\n  }\n  </buildClause>\n  return clause\n}\n"], ["urlToRoutesFilePath", "\nfunction urlToRoutesFilePath (state, endpoint) {\n  <extractScopeAndFilePath>\n  const [, scope] = endpoint.documentationUrl.match(/\\/v3\\/([^/#]+)((\\/[^/#]+)*)/)\n  return joinPath(\n    __dirname,\n    '..',\n    'routes',\n    state.folderName,\n    kebabCase(scope),\n    `${endpoint.idName}.json`\n  )\n  </extractScopeAndFilePath>\n}\n"], ["safeAdd_64_5", "\nfunction safeAdd_64_5(a, b, c, d, e) {\n  var lsw, msw, lowOrder, highOrder;\n\n  lsw = (a.lowOrder & 0xFFFF) + (b.lowOrder & 0xFFFF) +\n    (c.lowOrder & 0xFFFF) + (d.lowOrder & 0xFFFF) +\n    (e.lowOrder & 0xFFFF);\n  msw = (a.lowOrder >>> 16) + (b.lowOrder >>> 16) +\n    (c.lowOrder >>> 16) + (d.lowOrder >>> 16) + (e.lowOrder >>> 16) +\n    (lsw >>> 16);\n  lowOrder = ((msw & 0xFFFF) << 16) | (lsw & 0xFFFF);\n\n  lsw = (a.highOrder & 0xFFFF) + (b.highOrder & 0xFFFF) +\n    (c.highOrder & 0xFFFF) + (d.highOrder & 0xFFFF) +\n    (e.highOrder & 0xFFFF) + (msw >>> 16);\n  msw = (a.highOrder >>> 16) + (b.highOrder >>> 16) +\n    (c.highOrder >>> 16) + (d.highOrder >>> 16) +\n    (e.highOrder >>> 16) + (lsw >>> 16);\n  highOrder = ((msw & 0xFFFF) << 16) | (lsw & 0xFFFF);\n\n  return new Int_64(highOrder, lowOrder);\n}\n"], ["updateClosableProperty", "\nfunction() {\n  var isClosable,\n    len,\n    i;\n\n  <checkHeaderClosability>\n  isClosable = this.header._isClosable();\n  </checkHeaderClosability>\n\n  <iterateContentItems>\n  for( i = 0, len = this.contentItems.length; i < len; i++ ) {\n    if( !isClosable ) {\n      break;\n    }\n    isClosable = this.contentItems[ i ].config.isClosable;\n  }\n  </iterateContentItems>\n\n  <setClosable>\n  this.header._$setClosable( isClosable );\n  </setClosable>\n}\n"], ["manageNodeVisibility", "\nfunction(node, canvas, callback) {\n  <determineVisibilityLevel>\n  var level = this.getRightLevelToShow(node, canvas), \n  </determineVisibilityLevel>\n  <initializeOptions>\n  fx = this.viz.labels,\n  opt = $.merge({\n    execShow:true,\n    execHide:true,\n    onHide: $.empty,\n    onShow: $.empty\n  }, callback || {});\n  </initializeOptions>\n\n  <updateNodeState>\n  node.eachLevel(0, this.config.levelsToShow, function(n) {\n      var d = n._depth - node._depth;\n      if(d > level) {\n          opt.onHide(n);\n          if(opt.execHide) {\n            n.drawn = false; \n            n.exist = false;\n            fx.hideLabel(n, false);\n          }\n      } else {\n          opt.onShow(n);\n          if(opt.execShow) {\n            n.exist = true;\n          }\n      }\n  });\n  </updateNodeState>\n  node.drawn= true;\n}\n"], ["emitEvent", "\nfunction emit (route) {\n  <matchRoute>\n  var matched = match(route);\n  </matchRoute>\n\n  <prepareArguments>\n  var args = new Array(arguments.length);\n  args[0] = matched.params;\n  for (var i = 1; i < args.length; i++) {\n    args[i] = arguments[i];\n  }\n  </prepareArguments>\n\n  <invokeCallback>\n  return matched.cb.apply(matched.cb, args);\n  </invokeCallback>\n}\n"], ""]