[["functionUnnamed", "\nfunction(languageSlug, projectSlug, resourceSlug) {\n    <queryDatabase>\n    let result = query('select r.*, lri.translation_words_assignments_url from resource as r' +\n        ' left join legacy_resource_info as lri on lri.resource_id=r.id' +\n        ' where r.slug=? and r.project_id in (' +\n        '  select id from project where slug=? and source_language_id in (' +\n        '   select id from source_language where slug=?)' +\n        ' )' +\n        ' limit 1', [resourceSlug, projectSlug, languageSlug]);\n    </queryDatabase>\n    if(result.length > 0) {\n        let res = result[0];\n        \n        <restructureResult>\n        res.status = {\n            translate_mode: res.translate_mode,\n            checking_level: res.checking_level,\n            comments: res.comments,\n            pub_date: res.pub_date,\n            license: res.license,\n            version: res.version\n        };\n        delete res.translate_mode;\n        delete res.checking_level;\n        delete res.comments;\n        delete res.pub_date;\n        delete res.license;\n        delete res.version;\n        </restructureResult>\n\n        <setLanguageAndProjectSlugs>\n        res.source_language_slug = languageSlug;\n        res.project_slug = projectSlug;\n        </setLanguageAndProjectSlugs>\n\n        <formatResultsRetrievalAndProcessing>\n        res.formats = [];\n        let formatResults = query('select * from resource_format' +\n            ' where resource_id=?', [res.id]);\n        res.imported = false;\n        for(let format of formatResults) {\n            delete format.id;\n            delete format.resource_id;\n            format.imported = !!format.imported;\n            res.formats.push(format);\n            \n            if(format.imported) res.imported = true;\n        }\n        </formatResultsRetrievalAndProcessing>\n\n        return res;\n    }\n    return null;\n}\n"], ["swap", "\nfunction swap(cpu, n) {\n    <bitwiseOperations>\n    const r = n << 4 | n >> 4;\n    </bitwiseOperations>\n\n    <cpuFlagsUpdate>\n    cpu.f = 0;\n    if ((r & 0xff) == 0) cpu.f |= FLAG_Z;\n    </cpuFlagsUpdate>\n\n    return r;\n}\n"], ["getTilesetByGid", "\nfunction getTilesetByGid(gid) {\n    <initializeInvalidRange>\n    var invalidRange = -1; \n    </initializeInvalidRange>\n\n    <clearGidMask>\n    gid &= TMX_CLEAR_BIT_MASK; \n    </clearGidMask>\n\n    <searchForTileset>\n    for (var i = 0, len = this.tilesets.length; i < len; i++) {\n        if (this.tilesets[i].contains(gid)) {\n            return this.tilesets[i];\n        }\n\n        if (this.tilesets[i].firstgid === this.tilesets[i].lastgid && gid >= this.tilesets[i].firstgid) {\n            invalidRange = i;\n        }\n    }\n    </searchForTileset>\n\n    <processInvalidRange>\n    if (invalidRange !== -1) {\n        return this.tilesets[invalidRange];\n    } else {\n        throw new Error(\"no matching tileset found for gid \" + gid);\n    }\n    </processInvalidRange>\n}\n"], ["Toast", "\nfunction Toast(beyond) {\n    \"use strict\";\n\n    <setupVariables>\n    var events = new Events({'bind': this});\n    const MESSAGE_TYPE = Object.freeze({\n        'GENERAL_MESSAGE': 1,\n        'GENERAL_ERROR': 2,\n        'CONNECTION_ERROR': 3,\n        'WARNING': 4\n    });\n    const DURATION_DEFAULT = 3000;\n    var messages = new Messages();\n    var autoincrement = 0;\n    </setupVariables>\n\n    <exposeMessageType>\n    Object.defineProperty(this, 'MESSAGE_TYPE', {\n        'get': function () {\n            return MESSAGE_TYPE;\n        }\n    });\n    </exposeMessageType>\n\n    <showMessage>\n    beyond.showMessage = function (specs, duration) { \n        // code removed for brevity\n    };\n    </showMessage>\n\n    <helperMethods>\n    beyond.showConnectionError = function (callback) {\n        // code removed for brevity\n    };\n    beyond.showWarning = function (text, duration) {\n        // code removed for brevity\n    };\n    this.removeMessage = function (id) {\n        // code removed for brevity\n    };\n    beyond.removeMessage = this.removeMessage;\n    this.retry = function () {\n        // code removed for brevity\n    };\n    this.close = function () {\n        // code removed for brevity\n    };\n    </helperMethods>\n\n    <accessMessage>\n    Object.defineProperty(this, 'message', {\n        'get': function () {\n            // code removed for brevity\n        }\n    });\n    </accessMessage>\n}\n"], ["generateTableDataInsideScores", "\nfunction generateTableDataInsideScores(table) {\n    <initializeVariables>\n    table = table || this;\n    var columns = table.columns*1;\n    </initializeVariables>\n\n    <validateScores>\n    var scores = table.scores;\n    if(!scores)\n        console.log('Table is empty!');\n    </validateScores>\n\n    <evaluationMethodExtraction>\n    var evalMethod = getMethodFor(table.evaluateMethod);\n    </evaluationMethodExtraction>\n\n    <initializeKeysToSort>\n    var keysToSort = ['final'];\n    </initializeKeysToSort>\n\n    <processingScores>\n    _(scores).forEach(function(score) {\n        // code removed for brevity\n    });\n    </processingScores>\n\n    <sortingAndRanking>\n    var finalData = _.sortBy(scores, keysToSort);\n    if(table.sort == 'desc')\n        finalData = finalData.reverse();\n    // code removed for brevity\n    </sortingAndRanking>\n\n    <applyFinalData>\n    this.scores = finalData;\n    </applyFinalData>\n\n    <returnScores>\n    return this.scores;\n    </returnScores>\n}\n"], ["getConf", "\nfunction getConf(app, mod) {\n    <setupPathsAndConfigs>\n    var appConf = null;\n    var moduleConf = null;\n    var buildType = '';\n    app = app ? app : '';\n    mod = (mod && typeof mod === 'string') ? mod : '';\n    var appPath = path.join(rootPath, app);\n    var appConfPath = path.join(appPath, 'app-conf.js');\n    var modulePath = path.join(rootPath, app, mod);\n    var moduleConfPath = path.join(modulePath, 'module-conf.js');\n    // ... code removed for readability ...\n    </setupPathsAndConfigs>\n\n    <determineBuildTypeAndPaths>\n    // Conditional logic for determining build type based on\n    // existing configurations is wrapped by these tags.\n    // ... code removed for readability ...\n    </determineBuildTypeAndPaths>\n\n    <returnConfiguration>\n    return {\n        appConf: appConf,\n        moduleConf: moduleConf,\n        buildType: buildType,\n        appPath: appPath,\n        modulePath: modulePath\n    };\n    </returnConfiguration>\n}\n"], ["functionUnnamed_2", "\nfunction(sHTML, sClassName) {\n    <updateMessageContent>\n    var elCell = this._elMsgTd;\n    if(lang.isString(sHTML)) {\n        elCell.firstChild.innerHTML = sHTML;\n    }\n    if(lang.isString(sClassName)) {\n        Dom.addClass(elCell.firstChild, sClassName);\n    }\n    </updateMessageContent>\n\n    <adjustTableWidth>\n    var elThead = this.getTheadEl();\n    var elTable = elThead.parentNode;\n    var newWidth = elTable.offsetWidth;\n    this._elMsgTbody.parentNode.style.width = this.getTheadEl().parentNode.offsetWidth + \"px\";\n    </adjustTableWidth>\n\n    <displayMessage>\n    this._elMsgTbody.style.display = \"\";\n    </displayMessage>\n\n    <fireEvent>\n    this.fireEvent(\"tableMsgShowEvent\", {html:sHTML, className:sClassName});\n    YAHOO.log(\"DataTable showing message: \" + sHTML, \"info\", this.toString());\n    </fireEvent>\n}\n"], ["updateDependency", "\nasync function updateDependency(content, upgrade) {\n  logger.trace('updateDependency()');\n  <initializeVariables>\n  let newContent = content;\n  let newUrl;\n  let file;\n  </initializeVariables>\n\n  <parseOldUrl>\n  const oldParsedUrlPath = parseUrlPath(upgrade.url);\n  if (!oldParsedUrlPath) {\n    logger.debug(\n      `Failed to update - upgrade.url is invalid ${upgrade.depName}`\n    );\n    return content;\n  }\n  </parseOldUrl>\n\n  <downloadAndParseNewUrl>\n  try {\n    newUrl = `https://github.com/${upgrade.depName}/releases/download/${upgrade.newValue}/${upgrade.repoName}-${coerce(upgrade.newValue)}.tar.gz`;\n    file = (await got(newUrl, { encoding: null })).body;\n  } catch (errOuter) {\n    logger.debug(\n      `Failed to download release download for ${upgrade.depName} - trying archive instead`\n    );\n    try {\n      newUrl = `https://github.com/${upgrade.depName}/archive/${upgrade.newValue}.tar.gz`;\n      file = (await got(newUrl, { encoding: null })).body;\n    } catch (errInner) {\n      logger.debug(\n        `Failed to download archive download for ${upgrade.depName} - update failed`\n      );\n      return content;\n    }\n  }\n  </downloadAndParseNewUrl>\n\n  <parseNewUrlAndUpdateContent>\n  const newParsedUrlPath = parseUrlPath(newUrl);\n  if (!newParsedUrlPath) {\n    logger.debug(`Failed to update url for dependency ${upgrade.depName}`);\n    return content;\n  }\n  if (upgrade.newValue !== newParsedUrlPath.currentValue) {\n    logger.debug(`Failed to update url for dependency ${upgrade.depName}`);\n    return content;\n  }\n  const newSha256 = crypto\n    .createHash('sha256')\n    .update(file)\n    .digest('hex');\n  newContent = updateUrl(content, upgrade.url, newUrl);\n  if (!newContent) {\n    logger.debug(`Failed to update url for dependency ${upgrade.depName}`);\n    return content;\n  }\n  newContent = updateSha256(newContent, upgrade.sha256, newSha256);\n  if (!newContent) {\n    logger.debug(`Failed to update sha256 for dependency ${upgrade.depName}`);\n    return content;\n  }\n  </parseNewUrlAndUpdateContent>\n\n  <returnNewContent>\n  return newContent;\n  </returnNewContent>\n}\n"], ["postRevocRegDefRequestToLedger", "\nasync function postRevocRegDefRequestToLedger(poolHandle, wallet, did, revRegDef) {\n    <buildAndSubmitRequest>\n    const revocRegRequest = await indy.buildRevocRegDefRequest(did, revRegDef)\n    await ensureSignAndSubmitRequest(poolHandle, wallet, did, revocRegRequest)\n    </buildAndSubmitRequest>\n}\n"], ["functionUnnamed_3", "\nfunction(src, dst) {\n    <setBlendFunc>\n    this._dat[0 | BLEND_FUNC_C_SRC] = src;\n    this._dat[0 | BLEND_FUNC_C_DST] = dst;\n    this._set = this._set & ~BLEND_FUNC_A_SET | (~~BLEND_FUNC_SET);\n    </setBlendFunc>\n    return this;\n}\n"], "```\n\nEach function has been annotated to highlight separate responsibilities within the functions. The tags denote separate block actions and are indicative of SRP adherence or violations. Note that simple variable assignments and condition checks are not annotated as separate responsibilities since, in the context of these functions, they are part of a larger cohesive operation unless they distinctly serve a different specific purpose."]