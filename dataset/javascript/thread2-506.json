[["findValuesInRange", "\nfunction(startX, startY, settings) {\n    settings = settings || {};\n\n    var maxRadius   = settings.maxRadius    || 1,\n        filter      = settings.filter       || false,\n        withCoords  = settings.withCoords   || false;\n\n    var currentDistance = 1,\n        results = [],\n        x, y;\n\n    <checkValDefinition>\n    var checkVal = function(val, x, y) {\n        var result;\n        if ((filter && filter(val, x, y)) || (!filter && val)) {\n            if (withCoords) {\n                results.push({\n                    x: x,\n                    y: y,\n                    value: val\n                });\n            } else {\n                return results.push(val);\n            }\n        }\n    };\n    </checkValDefinition>\n\n    while (currentDistance <= maxRadius) {\n        var minX = startX - currentDistance,\n            maxX = startX + currentDistance,\n            minY = startY - currentDistance,\n            maxY = startY + currentDistance,\n            len = currentDistance * 2 + 1;\n\n        for (var i = len - 1; i >= 0; i--) {\n            var val;\n            <calculateValuesInRange>\n            \n            if (i < len - 1 && i > 0) {\n                if (minY >= 0) {\n                    x = minX + i;\n                    y = minY;\n                    val = this.get(x, y);\n                    checkVal(val, x, y);\n                }\n                if (maxY < this.height) {\n                    x = minX + i;\n                    y = maxY;\n                    val = this.get(x, y);\n                    checkVal(val, x, y);\n                }\n            }\n            if (minX >= 0) {\n                x = minX;\n                y = minY + i;\n                val = this.get(x, y);\n                checkVal(val, x, y);\n            }\n            if (maxX < this.width) {\n                x = maxX;\n                y = minY + i;\n                val = this.get(x, y);\n                checkVal(val, x, y);\n            }\n            </calculateValuesInRange>\n        }\n        if (results.length) {\n            return results;\n        }\n        currentDistance++;\n    }\n    return false;\n}\n"], ["configureBook", "\nfunction() {\n    if (!Object.keys(this.book.config.get('pluginsConfig.uml', {})).length) {\n        var book = this;\n        var output = book.output;\n        var name = output.name.toString();\n        <configurePluginSettings>\n        if (name == 'website') {\n            this.book.config.set('pluginsConfig.uml', {\n                format: 'svg'\n            });\n        } else {\n            this.book.config.set('pluginsConfig.uml', {\n                format: 'png'\n            });\n        }\n        </configurePluginSettings>\n    }\n    <startNailgunProcess>\n    var startNailgun = this.book.config.get('pluginsConfig.uml.nailgun', false);\n    if (startNailgun && !nailgunRunning) {\n        plantuml.useNailgun(function() {\n            nailgunRunning = true;\n        });\n    }\n    </startNailgunProcess>\n    \n    <copyAssets>\n    var book = this;\n    var output = book.output;\n    var rootPath = output.root();\n    if (fs.existsSync(ASSET_PATH)) {\n        fs.mkdirs(path.join(rootPath, ASSET_PATH));\n        fs.copySync(ASSET_PATH, path.join(rootPath, ASSET_PATH));\n    }\n    </copyAssets>\n}\n"], ["resetBenchmark", "\nfunction reset() {\n    var bench = this;\n    if (bench.running && !calledBy.abort) {\n        <handleRunningBench>\n        calledBy.reset = true;\n        bench.abort();\n        delete calledBy.reset;\n        return bench;\n        </handleRunningBench>\n    }\n    var event,\n        index = 0,\n        changes = [],\n        queue = [];\n    \n    <cloneDefaultData>\n    var data = {\n        'destination': bench,\n        'source': _.assign({}, cloneDeep(bench.constructor.prototype), cloneDeep(bench.options))\n    };\n    </cloneDefaultData>\n\n    <evaluateChanges>\n    do {\n        _.forOwn(data.source, function(value, key) {\n            var changed,\n                destination = data.destination,\n                currValue = destination[key];\n\n            if (key.charAt(0) == '_') {\n                return;\n            }\n            if (value && typeof value == 'object') {\n                if (_.isArray(value)) {\n                    if (!_.isArray(currValue)) {\n                        changed = currValue = [];\n                    }\n                    if (currValue.length != value.length) {\n                        changed = currValue = currValue.slice(0, value.length);\n                        currValue.length = value.length;\n                    }\n                }\n                else if (!currValue || typeof currValue != 'object') {\n                    changed = currValue = {};\n                }\n                if (changed) {\n                    changes.push({ 'destination': destination, 'key': key, 'value': currValue });\n                }\n                queue.push({ 'destination': currValue, 'source': value });\n            }\n            else if (value !== currValue && !(value == null || _.isFunction(value))) {\n                changes.push({ 'destination': destination, 'key': key, 'value': value });\n            }\n        });\n    }\n    while ((data = queue[index++]));\n    </evaluateChanges>\n\n    <applyChangesAndEmitReset>\n    if (changes.length && (bench.emit(event = Event('reset')), !event.cancelled)) {\n        _.each(changes, function(data) {\n            data.destination[data.key] = data.value;\n        });\n    }\n    </applyChangesAndEmitReset>\n    \n    return bench;\n}\n"], ["ajaxRequest", "\nfunction(uri, options, cb) {\n    <handleArguments>\n    var al = arguments.length;\n    if (al === 3) {}\n    else if (al === 2) {\n        cb = options;\n        options = {};\n    }\n    else {\n        throw new TypeError('ajax expects arguments: ({String}uri, [{Object}options], {Function}cb');\n    }\n    </handleArguments>\n\n    <setDefaultOptions>\n    if (!('method'     in options)) { options.method     = 'GET'; }\n    if (!('parameters' in options)) { options.parameters = {};    }\n    if (!('headers'    in options)) { options.headers    = {};    }\n    </setDefaultOptions>\n\n    <composeUriWithParameters>\n    var hasQM = uri.lastIndexOf('?') !== -1;\n    var k, v, p = [];\n    for (k in options.parameters) {\n        v = options.parameters[k];\n        p.push( [k, encodeURIComponent(v)].join('=') );\n    }\n    p = p.join('&');\n    uri = [uri, p].join(hasQM ? '&' : '?');\n    </composeUriWithParameters>\n\n    <setupXhrAndSendRequest>\n    var xhr = new XMLHttpRequest();\n    if ('withCredentials' in xhr) { \n        xhr.open(options.method, uri, true);\n    }\n    else if (XDomainRequest) { \n        xhr = new XDomainRequest();\n        xhr.open(options.method, uri);\n    }\n    else {\n        return cb('unsupported browser');\n    }\n\n    \n    for (k in options.headers) {\n        v = options.headers[k];\n        xhr.setRequestHeader(k, v);   \n    }\n\n    \n    var cbInner = function() {\n        if (xhr.readyState === 4 && xhr.status === 200) {\n            return cb(null, JSON.parse(xhr.response));\n        }\n        cb('error requesting ' + uri);\n    };\n    xhr.onload  = cbInner;\n    xhr.onerror = cbInner;\n\n    \n    xhr.send(null);\n    </setupXhrAndSendRequest>\n}\n"], ["getRoleWithParameters", "\nfunction getRole (args) {\n  var roles = args.roles;\n  var rank = args.rank;\n  var name = args.name;\n  var id = args.id;\n  <initializeSearchParameters>\n  var search = rank || name || id;\n  var found = {};\n  var result = [];\n  var isObject = search instanceof Object;\n  </initializeSearchParameters>\n  for (var i = 0; i < roles.length; i++) {\n    var role = roles[i];\n    var find;\n    <determineRoleAttribute>\n    if (rank) {\n      find = role.Rank;\n    } else if (name) {\n      find = entities.decodeHTML(role.Name);\n    } else if (id) {\n      find = role.ID;\n    }\n    </determineRoleAttribute>\n    <checkForDuplicateRoles>\n    if (found[find]) {\n      throw new Error('There are two or more roles with the rank ' + rank + '. You must specify the role name.');\n    }\n    </checkForDuplicateRoles>\n    <searchAndStoreResults>\n    var index = isObject ? search.indexOf(find) : 0;\n    if (isObject ? index > -1 : search === find) {\n      found[find] = true;\n      result[index] = role;\n    }\n    </searchAndStoreResults>\n  }\n  return isObject ? result : (result[0] || false);\n}\n"], ["countNeighboringPixelsLuminosity", "\nfunction (idx, funcName) {\n\n    var colors = 0,\n        colorCounter = 0,\n        fn,\n        width = this._image.width,\n        height = this._image.height,\n        dim = width * height,\n        spaceOnRight,\n        spaceOnLeft,\n        spaceOnTop,\n        spaceOnBottom;\n\n    <defineFunctionForColorCollection>\n    funcName = funcName || \"getLuminosityAtIndex\";\n\n    fn = function (idx) {\n        colors += this[funcName](idx);\n        colorCounter++;\n    }.bind(this);\n    </defineFunctionForColorCollection>\n\n    <calculateSpaceAvailability>\n    spaceOnRight = (idx % width < width - 1);\n    spaceOnLeft = (idx % width > 0);\n    spaceOnTop = (idx >= width);\n    spaceOnBottom = (idx <= dim - width);\n    </calculateSpaceAvailability>\n\n    <collectPixelColors>\n    if (spaceOnTop) {\n        if (spaceOnLeft) {\n            fn(idx - this._image.width - 1);\n        }\n        fn(idx - this._image.width);\n        if (spaceOnRight) {\n            fn(idx - this._image.width + 1);\n        }\n    }\n\n    if (spaceOnLeft) {\n        fn(idx - 1);\n    }\n    fn(idx);\n    if (spaceOnRight) {\n        fn(idx + 1);\n    }\n\n    if (spaceOnBottom) {\n        if (spaceOnLeft) {\n            fn(idx + this._image.width - 1);\n        }\n        fn(idx + this._image.width);\n        if (spaceOnRight) {\n            fn(idx + this._image.width + 1);\n        }\n    }\n    </collectPixelColors>\n\n    return Math.floor(colors / colorCounter);\n}\n"], ["updateNavigationStack", "\nfunction( url, data ) {\n    data = data || {};\n\n    <handleNewNavigationLink>\n    if ( this.getNext() ) {\n        this.clearForward();\n    }\n    </handleNewNavigationLink>\n\n    <appendDataToStack>\n    if ( data.hash && data.hash.indexOf( \"#\" ) === -1) {\n        data.hash = \"#\" + data.hash;\n    }\n    data.url = url;\n    this.stack.push( data );\n    this.activeIndex = this.stack.length - 1;\n    </appendDataToStack>\n}\n"], ["createAnonymousObject", "\nfunction(list, prefix, postfix) {\n    <definePrefixAndPostfix>\n    prefix  = prefix  ? prefix.value  : \"[\";\n    postfix = postfix ? postfix.value : \"]\";\n    </definePrefixAndPostfix>\n    return new Anonymous(toString(list, prefix, postfix));\n}\n"], ["rawBufferToHeader", "\nfunction readHeader(buffer, header) {\n  <readSaltAndRS>\n  var idsz = buffer.readUIntBE(20, 1);\n  header.salt = buffer.slice(0, KEY_LENGTH);\n  header.rs = buffer.readUIntBE(KEY_LENGTH, 4);\n  </readSaltAndRS>\n  <readKeyId>\n  header.keyid = buffer.slice(21, 21 + idsz);\n  </readKeyId>\n  return 21 + idsz;\n}\n"], ["compareListsAndReport", "\nfunction countingPoint(withPointList, withoutPointList) {\n    if (withPointList.length === 0 || withoutPointList.length === 0) {\n        return;\n    }\n    if (withPointList.length > withoutPointList.length) {\n        <reportWithPointList>\n        reportPointResult(withoutPointList, {\n            shouldUsePoint: true\n        });\n        </reportWithPointList>\n    } else if (withPointList.length < withoutPointList.length) {\n        <reportWithoutPointList>\n        reportPointResult(withPointList, {\n            shouldUsePoint: false\n        });\n        </reportWithoutPointList>\n    } else {\n        <reportEqualListSize>\n        reportPointResult(withoutPointList, {\n            shouldUsePoint: true\n        });\n        </reportEqualListSize>\n    }\n}\n"], "```\n\nNote: With the `<createAnonymousObject>` function, it seems like a single responsibility, but since there's a transformation of inputs (`prefix` and `postfix`), I've identified this section separately as `<definePrefixAndPostfix>` to highlight the individual responsibility of defining these variables, which supports the function's overall purpose."]