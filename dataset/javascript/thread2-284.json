[["findVariables", "\nfunction findVariables(string, syntax, options) {\n  <preprocessing>\n  string = ignoreBlock.removeIgnoredBlocks(string);\n  </preprocessing>\n  <parserDetermination>\n  var parser = getParserForSyntax(syntax, options);\n  if (parser) {\n    return parser.findVariables(string);\n  }\n  </parserDetermination>\n  return [];\n}\n"], ["coerceElementMatchingCallback", "\nfunction coerceElementMatchingCallback(value) {\n  \n  <stringCheck>\n  if (typeof value === 'string') {\n    return element => element.element === value;\n  }\n  </stringCheck>\n\n  \n  <constructorCheck>\n  if (value.constructor && value.extend) {\n    return element => element instanceof value;\n  }\n  </constructorCheck>\n\n  return value;\n}\n"], ["getHeaders", "\nfunction getHeaders(id, uploadId) {\n        <headerInitialization>\n        var headers = {},\n        </headerInitialization>\n            <promiseSetup>\n            promise = new qq.Promise(),\n            </promiseSetup>\n            <bucketHostRetrieval>\n            bucket = options.getBucket(id),\n            host = options.getHost(id),\n            </bucketHostRetrieval>\n            <signatureConstruction>\n            signatureConstructor = getSignatureAjaxRequester.constructStringToSign\n                (getSignatureAjaxRequester.REQUEST_TYPE.MULTIPART_ABORT, bucket, host, options.getKey(id))\n                .withUploadId(uploadId);\n            </signatureConstruction>\n\n        \n        <signatureRequest>\n        getSignatureAjaxRequester.getSignature(id, {signatureConstructor: signatureConstructor}).then(promise.success, promise.failure);\n        </signatureRequest>\n\n        return promise;\n    }\n"], ["parseObject", "\nfunction parseObject( str ) {\n\t<preparsedObject>\n\tvar obj = parseJSON( str );\n\tif ( obj instanceof Error ) {\n\t\treturn new TypeError( 'invalid value. Unable to parse string as a JSON object. Value: `' + str + '`. Error: `' + obj.message + '`.' );\n\t}\n\t</preparsedObject>\n\treturn obj;\n}\n"], ["anonymousFunction1", "\nfunction (cb) {\n      <setup>\n      var cmd = params.main.cmd;\n      var cmdStr = runner.cmdStr;\n      var opts = _.extend({ tracker: self._tracker }, params.main.opts);\n      var taskEnvs = clone(envsList);\n      var queue = opts.queue;\n\n      log.debug(\"envs\", \"Starting with queue size: \" + chalk.magenta(queue || \"unlimited\"));\n      </setup>\n      <mapping>\n      async.mapLimit(taskEnvs, queue || Infinity, function (taskEnv, envCb) {\n        \n        \n        <taskConfiguration>\n        var taskShOpts = _.merge(clone(shOpts), { env: taskEnv });\n        var taskOpts = _.extend({ taskEnv: taskEnv }, opts);\n        </taskConfiguration>\n\n        <logging>\n        log.info(\"envs\", \"Starting \" + cmdStr(cmd, taskOpts));\n        </logging>\n        <taskExecution>\n        runner.retry(cmd, taskShOpts, taskOpts, self._errOrBail(taskOpts, envCb));\n        </taskExecution>\n      }, cb);\n      </mapping>\n    }\n"], ["anonymousFunction2", "\nfunction(){\n\t\t\t<setup>\n\t\t\tvar plugin = $(this.element).data(\"ui-\" + this.options.pluginName) || $(this.element).data(this.options.pluginName),\n\t\t\t\topts = this.options,\n\t\t\t\tactualOpts = plugin.options,\n\t\t\t\tavailOptList = opts.optionList,\n\t\t\t\tlines = [],\n\t\t\t\theader = opts.header || '$(\"#selector\").' + opts.pluginName + \"({\",\n\t\t\t\tfooter = \"});\",\n\t\t\t\ti;\n\t\t\t\n\t\t\tif(this.options.hideDefaults){\n\t\t\t\t<hideDefaults>\n\t\t\t\tavailOptList = [];\n\t\t\t\tfor(i=0; i<this.options.optionList.length; i++){\n\t\t\t\t\tvar o = this.options.optionList[i],\n\t\t\t\t\t\tn = o.name,\n\t\t\t\t\t\tdefVal = o.value;\n\t\t\t\t\tif($.isArray(defVal)){\n\t\t\t\t\t\tdefVal = $.map(defVal, function(e){ return e.selected ? e.value : null;})[0];\n\t\t\t\t\t}\n\t\t\t\t\tif( actualOpts[n] !== defVal ){\n\t\t\t\t\t\tavailOptList.push(o);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t</hideDefaults>\n\t\t\t}\n\t\t\t</setup>\n\n\t\t\t<buildConfigLines>\n\t\t\tlines.push(header);\n\t\t\tfor(i=0; i<availOptList.length; i++){\n\t\t\t\tvar o = availOptList[i],\n\t\t\t\t\tactualVal = actualOpts[o.name],\n\t\t\t\t\tline = \"    \" + o.name + \": \";\n\t\t\t\tif(typeof actualVal === \"string\"){\n\t\t\t\t\tline += '\"' + actualVal + '\"';\n\t\t\t\t}else if($.isPlainObject(actualVal)){\n\t\t\t\t\tline += JSON.stringify(actualVal);\n\t\t\t\t}else{\n\t\t\t\t\tline += \"\" + actualVal;\n\t\t\t\t}\n\t\t\t\tif( i < (availOptList.length - 1) ){\n\t\t\t\t\tline += \",\";\n\t\t\t\t}\n\t\t\t\tif( opts.showComments ){\n\t\t\t\t\tline += \" // \" + o.comment;\n\t\t\t\t}\n\t\t\t\tlines.push(line);\n\t\t\t}\n\t\t\tlines.push(footer);\n\t\t\t</buildConfigLines>\n\n\t\t\t<renderConfig>\n\t\t\t$(opts.sourceTarget).addClass(\"ui-configurator-source\").text(lines.join(\"\\n\"));\n\t\t\tthis._trigger(\"render\");\n\t\t\t</renderConfig>\n\t\t}\n"], ["ending", "\nfunction ending (count, one, some, many) {\n    <countCalculation>\n    if (count % 10 == 1 && count % 100 != 11) {\n      return one;\n    }\n\n    if (count % 10 >= 2 && count % 10 <= 4 &&\n      (count % 100 < 12 || count % 100 > 14)) {\n        return some;\n    }\n    </countCalculation>\n\n    return many;\n}\n"], ["anonymousFunction3", "\nfunction( targets, options, callback ) {\n\t<optionCallbackAdaptation>\n\tif ( typeof options === 'function' ) {\n\t\tcallback = options;\n\t\toptions = null;\n\t}\n\tif ( !Array.isArray( targets ) ) {\n\t\ttargets = [targets];\n\t}\n\t</optionCallbackAdaptation>\n\t<defaultOptions>\n\toptions = options || {};\n\taddExtraOptions( [ 'force' ], options );\n\t</defaultOptions>\n\t<svnCommandExecution>\n\texecuteSvn( [ 'unlock' ].concat( targets ), options, callback );\n\t</svnCommandExecution>\n}\n"], ["Store", "\nfunction Store (options) {\n  <optionsDefaulting>\n  if ( options === void 0 ) options = {};\n  </optionsDefaulting>\n\n  <environmentVerification>\n  assert(Vue, \"must call Vue.use(Vuex) before creating a store instance.\");\n  assert(typeof Promise !== 'undefined', \"vuex requires a Promise polyfill in this browser.\");\n  </environmentVerification>\n\n  <stateInitialization>\n  var state = options.state; if ( state === void 0 ) state = {};\n  </stateInitialization>\n  <pluginInitialization>\n  var plugins = options.plugins; if ( plugins === void 0 ) plugins = [];\n  </pluginInitialization>\n  <strictModeInitialized>\n  var strict = options.strict; if ( strict === void 0 ) strict = false;\n  </strictModeInitialized>\n\n  \n  <propertyInitialization>\n  this._committing = false;\n  this._actions = Object.create(null);\n  this._mutations = Object.create(null);\n  this._wrappedGetters = Object.create(null);\n  this._modules = new ModuleCollection(options);\n  this._modulesNamespaceMap = Object.create(null);\n  this._subscribers = [];\n  this._watcherVM = new Vue();\n  </propertyInitialization>\n\n  \n  <boundFunctionSetup>\n  var store = this;\n  var ref = this;\n  var dispatch = ref.dispatch;\n  var commit = ref.commit;\n  this.dispatch = function boundDispatch (type, payload) {\n    return dispatch.call(store, type, payload)\n  };\n  this.commit = function boundCommit (type, payload, options) {\n    return commit.call(store, type, payload, options)\n  };\n  </boundFunctionSetup>\n\n  \n  <storeConfiguration>\n  this.strict = strict;\n  </storeConfiguration>\n\n  \n  \n  <moduleInstallation>\n  installModule(this, state, [], this._modules.root);\n  </moduleInstallation>\n\n  \n  \n  <storeVMReset>\n  resetStoreVM(this, state);\n  </storeVMReset>\n\n  \n  <pluginApplication>\n  plugins.concat(devtoolPlugin).forEach(function (plugin) { return plugin(this$1); });\n  </pluginApplication>\n}\n"], ["buildNav", "\nfunction buildNav(members) {\n    <navigationInitialization>\n    var nav = [];\n    </navigationInitialization>\n\n    <processNamespaces>\n    if (members.namespaces.length) {\n        _.each(members.namespaces, function (v) {\n            nav.push({\n                type: 'namespace',\n                longname: v.longname,\n                name: v.name,\n                members: find({\n                    kind: 'member',\n                    memberof: v.longname\n                }),\n                methods: find({\n                    kind: 'function',\n                    memberof: v.longname\n                }),\n                typedefs: find({\n                    kind: 'typedef',\n                    memberof: v.longname\n                }),\n                events: find({\n                    kind: 'event',\n                    memberof: v.longname\n                })\n            });\n        });\n    }\n    </processNamespaces>\n\n    <processClasses>\n    if (members.classes.length) {\n        _.each(members.classes, function (v) {\n            nav.push({\n                type: 'class',\n                longname: v.longname,\n                name: v.name,\n                members: find({\n                    kind: 'member',\n                    memberof: v.longname\n                }),\n                methods: find({\n                    kind: 'function',\n                    memberof: v.longname\n                }),\n                typedefs: find({\n                    kind: 'typedef',\n                    memberof: v.longname\n                }),\n                events: find({\n                    kind: 'event',\n                    memberof: v.longname\n                })\n            });\n        });\n    }\n    </processClasses>\n\n    return nav;\n}\n"], ""]