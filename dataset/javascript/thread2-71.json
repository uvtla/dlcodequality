[["removeChildNodes", "\nfunction () {\n  var element = this.element,\n      childNodes = element.childNodes,\n      i = childNodes.length;\n\n  while (i--) {\n    element.removeChild(childNodes[i]);\n  }\n}\n"], ["validateAndInitialize", "\nfunction init(opts) {\n  if (!opts || !opts.appData) throw new Error(path.basename(__filename)+ ':' + arguments.callee.name + ': bad opts argument')\n\n  var apiOpts = opts.apiOpts || {}\n  state.apiConfigs = apiOpts.apiMap || {}\n  if (Array.isArray(apiOpts.path)) state.apiPath = apiOpts.path\n\n  state.deployFolder = opts.appData.launchFolder\n}\n"], ["update", "\nfunction(sChangeReason) {\n  <updateStateAndNotifyControl>\n  this._bLoading = false;\n  this._updateTriggerDelayed(false);\n  this._oControl.onAfterPageLoaded(this.getInfo(), sChangeReason);\n  </updateStateAndNotifyControl>\n  \n  <updateBusyIndicator>\n  if (this._oControl.setEnableBusyIndicator) {\n    this._oControl.setEnableBusyIndicator(this._bParentEnableBusyIndicator);\n  }\n  </updateBusyIndicator>\n}\n"], ["getLetterTime", "\nfunction getLetterTime(timeString) {\n  <parseTimeToSeconds>\n  var totalSeconds = 0;\n  var timeValues = {\n    's': 1,\n    'm': 1 * 60,\n    'h': 1 * 60 * 60,\n    'd': 1 * 60 * 60 * 24,\n    'w': 1 * 60 * 60 * 24 * 7,\n  };\n  var timePairs;\n\n  timeString = timeString.replace(/([smhdw])/g, ' $1 ').trim();\n  timePairs = timeString.split(' ');\n\n  for (var i = 0; i < timePairs.length; i += 2) {\n    totalSeconds += parseInt(timePairs[i], 10) *\n      timeValues[timePairs[i + 1] || 's'];\n  }\n  return totalSeconds;\n  </parseTimeToSeconds>\n}\n"], ["sendEvent", "\nfunction send() {\n  var args = slice.call(arguments), events = this.events, handled;\n\n  if (!this.__isCurrent__) {\n    throw new Error('State#send: attempted to send an event to a state that is not current: ' + this);\n  }\n\n  if (this === this.root()) {\n    trace.call(this, 'State: [EVENT]  : ' + args[0]);\n  }\n\n  handled = this.concurrent ? sendConcurrent.apply(this, arguments) :\n    sendClustered.apply(this, arguments);\n\n  if (!handled && typeof events[args[0]] === 'function') {\n    this.__isSending__ = true;\n    handled = !!events[args[0]].apply(this, args.slice(1));\n    this.__isSending__ = false;\n  }\n\n  if (!this.superstate) { transition.call(this); }\n\n  return handled;\n}\n"], ["transformAST", "\nfunction cleanUpAST(ast) {\n  return walk(ast, function(node, replace) {\n    if (node.type === 'Block') {\n      var lastIdx = 0;\n      var newNodes = [];\n      node.nodes.forEach(function(innerNode, i) {\n        if (innerNode.type === 'Block' && !innerNode.yield) {\n          if (i > 0) newNodes = newNodes.concat(node.nodes.slice(lastIdx, i));\n          lastIdx = i + 1;\n          newNodes = newNodes.concat(cleanUpAST(innerNode).nodes);\n        }\n      });\n      node.nodes = newNodes.concat(node.nodes.slice(lastIdx));\n    }\n  });\n}\n"], ["computePreviousVisibleNode", "\nfunction getPreviousVisibleNode(self) {\n  var prev = self.prev();\n  if (!prev) {\n      prev = self.get('parent');\n  } else {\n      prev = getLastVisibleDescendant(prev);\n  }\n  return prev;\n}\n"], ["checkParenthesisInNewExpression", "\nfunction isNewExpressionWithParens(newExpression) {\n  const lastToken = sourceCode.getLastToken(newExpression);\n  const penultimateToken = sourceCode.getTokenBefore(lastToken);\n\n  return newExpression.arguments.length > 0 || astUtils.isOpeningParenToken(penultimateToken) && astUtils.isClosingParenToken(lastToken);\n}\n"], ["mapFunctionOverMatrix", "\nfunction(fn) {\n  var els = [], i = this.elements.length, nj = this.elements[0].length, j;\n  while (i--) { j = nj;\n            els[i] = [];\n            while (j--) {\n              els[i][j] = fn(this.elements[i][j], i + 1, j + 1);\n            }\n          }\n  return Matrix$b.create(els);\n}\n"], ["collectInheritedCollections", "\nfunction getInheritedCollectionNames(node) {\n  var names = [],\n      startNode = node,\n      actualNode = node,\n      endNode,\n      inverseOverlays,\n      name,\n      target;\n\n  while (startNode) {\n      actualNode = self.getBase(startNode);\n      endNode = self.getBase(getInstanceRoot(startNode));\n      target = '';\n      if (actualNode && endNode) {\n          while (actualNode && actualNode !== self.getParent(endNode)) {\n              inverseOverlays = innerCore.getInverseOverlayOfNode(actualNode);\n              if (inverseOverlays[target]) {\n                  for (name in inverseOverlays[target]) {\n                      if (names.indexOf(name) === -1) {\n                          names.push(name);\n                      }\n                  }\n              }\n              target = CONSTANTS.PATH_SEP + self.getRelid(actualNode) + target;\n              actualNode = self.getParent(actualNode);\n          }\n      }\n      startNode = self.getBase(startNode);\n  }\n\n  return names;\n}\n"], "```\n"]