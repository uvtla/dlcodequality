[["genericEventTrigger", "\nfunction() {\n    this.lastError = null;\n    var errors = [],\n        len = this.subscribers.length;\n    var args = [].slice.call(arguments, 0), ret = true, i, rebuild = false;\n\n    <checkFireOnce>\n    if (this.fireOnce) {\n        if (this.fired) {\n            return true;\n        } else {\n            this.firedWith = args;\n        }\n    }\n    this.fired = true;\n    </checkFireOnce>\n\n    <earlyExitConditions>\n    if (!len && this.silent) {\n        return true;\n    }\n    </earlyExitConditions>\n\n    var subs = this.subscribers.slice();\n\n    <notifySubscribersLoop>\n    for (i = 0; i < len; ++i) {\n        var s = subs[i];\n        if (!s) {\n            rebuild = true;\n        } else {\n            ret = this.notify(s, args);\n            if (false === ret) {\n                if (!this.silent) {\n                }\n                break;\n            }\n        }\n    }\n    </notifySubscribersLoop>\n\n    return (ret !== false);\n}\n"], ["printToPDF", "\nfunction (jsonObj, cb) {\n    <checkPlugin>\n    if ($bc_$4.pN) {\n    </checkPlugin>\n\n        try {\n            var params = jsonObj || {};\n            params['callback'] = params['callback'] || $bc_$4._get_callback(function (obj) {\n                cb && cb(obj);\n            }, true);\n            params['marginsType'] = params['marginsType'] || 0;\n            params['pageSize'] = params['pageSize'] || 'A4';\n            params['printBackground'] = params['printBackground'] || false;\n            params['printSelectionOnly'] = params['printSelectionOnly'] || false;\n            params['landscape'] = params['landscape'] || false;\n            params['filePath'] = params['filePath'] || ($bc_$4.pN.path.tempDir() + '/' + Date.now() + '.pdf');\n\n            <overrideParameters>\n            for (var key in jsonObj) {\n                if (jsonObj.hasOwnProperty(key)) {\n                    params[key] = jsonObj[key];\n                }\n            }\n            </overrideParameters>\n\n            <printPDF>\n            return $bc_$4.pN.window.printToPDF(JSON.stringify(params))\n            </printPDF>\n        } catch (e) {\n            <handleError>\n            console.error(e);\n            </handleError>\n        }\n    }\n}\n"], ["createUpwardable", "\nfunction make(x, options = {}) {\n    var { debug = DEBUG_ALL } = options;\n    var u;\n\n    debug = DEBUG && debug;\n\n    <initializeUpwardable>\n    if (x === undefined) u = makeUndefined();\n    else if (x === null) u = makeNull();\n    else {\n        u = Object(x);\n        if (!is(u)) {\n            add(u, debug);\n            defineProperty(u, 'change', { value: change });\n        }\n    }\n    </initializeUpwardable>\n\n    <debugNewUpwardable>\n    if (debug) console.debug(...channel.debug(\"Created upwardable\", u._upwardableId, \"from\", x));\n    </debugNewUpwardable>\n\n    return u;\n}\n"], ["updateNodeClasses", "\nfunction(ctx) {\n    var $ariaElem,\n        node = ctx.node,\n        tree = ctx.tree,\n        opts = ctx.options,\n        hasChildren = node.hasChildren(),\n        isLastSib = node.isLastSibling(),\n        aria = opts.aria,\n        cn = opts._classNames,\n        cnList = [],\n        statusElem = node[tree.statusClassPropName];\n\n    if (!statusElem || tree._enableUpdate === false) {\n        <earlyExit>\n        return;\n        </earlyExit>\n    }\n\n    if (aria) {\n        <setupAriaElem>\n        $ariaElem = $(node.tr || node.li);\n        </setupAriaElem>\n    }\n\n    <buildClassList>\n    cnList.push(cn.node);\n    if (tree.activeNode === node) {\n        cnList.push(cn.active);\n    }\n    if (tree.focusNode === node) {\n        cnList.push(cn.focused);\n    }\n    if (node.expanded) {\n        cnList.push(cn.expanded);\n    }\n    if (aria) {\n        if (hasChildren !== false) {\n            $ariaElem.attr(\"aria-expanded\", Boolean(node.expanded));\n        } else {\n            $ariaElem.removeAttr(\"aria-expanded\");\n        }\n    }\n    if (node.folder) {\n        cnList.push(cn.folder);\n    }\n    if (hasChildren !== false) {\n        cnList.push(cn.hasChildren);\n    }\n    if (isLastSib) {\n        cnList.push(cn.lastsib);\n    }\n    if (node.lazy && node.children == null) {\n        cnList.push(cn.lazy);\n    }\n    if (node.partload) {\n        cnList.push(cn.partload);\n    }\n    if (node.partsel) {\n        cnList.push(cn.partsel);\n    }\n    if (FT.evalOption(\"unselectable\", node, node, opts, false)) {\n        cnList.push(cn.unselectable);\n    }\n    if (node._isLoading) {\n        cnList.push(cn.loading);\n    }\n    if (node._error) {\n        cnList.push(cn.error);\n    }\n    if (node.statusNodeType) {\n        cnList.push(cn.statusNodePrefix + node.statusNodeType);\n    }\n    if (node.selected) {\n        cnList.push(cn.selected);\n        if (aria) {\n            $ariaElem.attr(\"aria-selected\", true);\n        }\n    } else if (aria) {\n        $ariaElem.attr(\"aria-selected\", false);\n    }\n    if (node.extraClasses) {\n        cnList.push(node.extraClasses);\n    }\n    </buildClassList>\n\n    <assignClassesToStatusElem>\n    statusElem.className = cnList.join(\" \");\n    </assignClassesToStatusElem>\n\n    <updateLastSiblingClass>\n    if (node.li) {\n        $(node.li).toggleClass(cn.lastsib, isLastSib);\n    }\n    </updateLastSiblingClass>\n}\n"], ["childNodesModifiedEventHandler", "\nfunction(delta) {\n    <callNodeModifiedEvent>\n    events.childNodesModified.call(this, delta);\n    </callNodeModifiedEvent>\n\n    var array;\n    if (array = delta.inserted) {\n        <processInsertedNodes>\n        for (var i = 0, child; child = array[i++];) {\n            child.groupId_ = child.delegate ? child.delegate.basisObjectId : child.data.id;\n            this.map_[child.groupId_] = child;\n        }\n        </processInsertedNodes>\n\n        <reinsertNodes>\n        if (this.dataSource && this.nullGroup.first) {\n            var parentNode = this.owner;\n            var nodes = arrayFrom(this.nullGroup.nodes);\n            for (var i = nodes.length; i-- > 0;) {\n                parentNode.insertBefore(nodes[i], nodes[i].nextSibling);\n            }\n        }\n        </reinsertNodes>\n    }\n}\n"], ["recursiveKeyPathCheck", "\nfunction(obj, parts) {\n    if (parts.length === 0) {\n        <baseCaseReturn>\n        return true;\n        </baseCaseReturn>\n    }\n\n    var key = parts.shift();\n\n    if (!_(obj).has(key)) {\n        <returnFalseIfKeyNotFound>\n        return false;\n        </returnFalseIfKeyNotFound>\n    } else {\n        <recursiveCheck>\n        return hasKeyPath(obj[key], parts);\n        </recursiveCheck>\n    }\n}\n"], ["initiateReadingMoreData", "\nfunction maybeReadMore(stream, state) {\n    if (!state.readingMore) {\n        <setReadingMoreFlag>\n        state.readingMore = true;\n        </setReadingMoreFlag>\n        <callReadMoreNextTick>\n        nextTick(maybeReadMore_, stream, state);\n        </callReadMoreNextTick>\n    }\n}\n"], ["calculateSlope", "\nfunction getSlope(aT, aA1, aA2) {\n    <computeIntermediateValues>\n    return 3.0 * a(aA1, aA2) * aT * aT + 2.0 * b(aA1, aA2) * aT + c(aA1);\n    </computeIntermediateValues>\n}\n"], ["readEnvFile", "\nfunction getFile(envPath) {\n    envPath = typeof envPath !== 'undefined' && envPath != '' ? envPath : '.env';\n\n    try {\n        <cacheEnvFile>\n        if (cached.file == null) {\n            envFilePath = path.resolve(process.cwd(), envPath);\n            cached.file = fs.readFileSync(envFilePath, { encoding: 'utf8' })\n        }\n        </cacheEnvFile>\n\n        <returnCachedFile>\n        return cached.file;\n        </returnCachedFile>\n\n    } catch (e) {\n        <handleError>\n        return { error: e }\n        </handleError>\n    }\n}\n"], ["tokenizeParenthesis", "\nfunction() {\n    var captures;\n    if (captures = /^([()])([ \\t]*)/.exec(this.str)) {\n        var paren = captures[1];\n        <updateStateAndCaptureWhitespace>\n        this.skip(captures);\n        </updateStateAndCaptureWhitespace>\n        if (')' == paren) {\n            <resetIsURLFlag>\n            this.isURL = false;\n            </resetIsURLFlag>\n        }\n        <createTokenWithSpace>\n        var tok = new Token(paren, paren);\n        tok.space = captures[2];\n        return tok;\n        </createTokenWithSpace>\n    }\n}\n"], "```\n\nThe basis of the annotations above is to encapsulate blocks of code that serve a distinct purpose within the functions. This allows us to isolate responsibilities which adhere to or violate SRP; for example, reading configuration from a file or generating a list of CSS classes based on certain conditions are specific, self-contained responsibilities, while others might be part of standard procedure within the function's main responsibility (such as checking if a plugin is loaded before continuing execution)."]