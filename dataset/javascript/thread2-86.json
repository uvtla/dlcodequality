[["calculateCoordinate", "\nfunction (d, chart, series) {\n    var returnCx = 0;\n    if (series.x.measure !== null && series.x.measure !== undefined) {\n        returnCx = series.x._scale(d.cx);\n    } else if (series.x._hasCategories() && series.x.categoryFields.length >= 2) {\n        returnCx = series.x._scale(d.cx) + dimple._helpers.xGap(chart, series) + ((d.xOffset + 0.5) * (((chart._widthPixels() / series.x._max) - 2 * dimple._helpers.xGap(chart, series)) * d.width));\n    } else {\n        returnCx = series.x._scale(d.cx) + ((chart._widthPixels() / series.x._max) / 2);\n    }\n    return returnCx;\n}\n"], ["handleButtonClicks", "\nfunction () {\n    if (initial) {\n        $('<div id=\"LikedAvatars\" class=\"AvatarsCollection\"/>').appendTo($('body'));\n        $('<div id=\"DislikedAvatars\" class=\"AvatarsCollection\"/>').appendTo($('body'));\n    }\n    \n    $.each(this.footer.find('button'), function (index, el) {\n        <attachEventHandlers>\n        $(el).on('click', function () {\n            <updateState>\n            DemoAvatars.clicked = true;\n            DemoAvatars.AvatarsTooltipLike && DemoAvatars.AvatarsTooltipLike.close();\n            DemoAvatars.AvatarsTooltipDislike && DemoAvatars.AvatarsTooltipDislike.close();\n            this.AvatarRemoved = true;\n            </updateState>\n            \n            <determineAction>\n            var liked = $(el).hasClass('button-heart');\n            </determineAction>\n            \n            <performAnimation>\n            this.animate('slide' + (liked ? 'Right' : 'Left'), {\n                complete: function () {\n                    this.wrapper.css('display', 'none');\n                    var collectionContainer = liked ? $('#LikedAvatars') : $('#DislikedAvatars');\n                    if (collectionContainer.find('div[data-avatar-tooltip]').length && ((collectionContainer.find('div[data-avatar-tooltip]').length + 1) * $(collectionContainer.find('div[data-avatar-tooltip]')[0]).outerWidth(true) > collectionContainer.outerWidth())) {\n                        $(collectionContainer.find('div[data-avatar-tooltip]')[0]).remove();\n                    }\n                    this.animate('popIn', {\n                        element: $('<div data-avatar-tooltip=\"You ' + (liked ? 'liked' : 'disliked') + ' ' + DemoAvatars.Avatars[this.AvatarIndex] + '\"/>').append($('<div/>').html('<img src=\"https:...\"/>'))\n                    });\n                    DemoAvatars.AvatarsTooltip && DemoAvatars.AvatarsTooltip.attach();\n                }.bind(this)\n            });\n            </performAnimation>\n            <generateTooltip>\n            generateAvatarJBox();\n            </generateTooltip>\n        }.bind(this));\n        </attachEventHandlers>\n    }.bind(this));\n}\n"], ["initializePkgJsonEmbark", "\nfunction PkgJsonEmbark(filepath, kind) {\n  PkgJson.call(this, filepath);\n  this.kind = kind || 'invoked';\n  this.nodeRange = undefined;\n  this.pkg = undefined;\n  this.version = undefined;\n}\n"], ["resolveTreeStructure", "\nfunction resolve(tree, options) {\n    var settings = _.defaults(options, {\n        childNode: 'children',\n        clone: false,\n        attempts: 5,\n        splice: true,\n        isPromise: _.isFunction,\n        isSplice: function isSplice(node, path, tree) {\n          var parentNodePath = path.slice(0, -1);\n          var parentNode = parentNodePath.length ? _.get(tree, parentNodePath) : tree; \n\n          return _.isArray(node) && _.isArray(parentNode); \n        },\n        wrapper: function wrapper(node) {\n          return Promise.resolve(node());\n        }\n    });\n\n    var base = settings.clone ? _.cloneDeep(tree) : tree;\n    var dirty = true; \n    var splices = [];\n\n    <resolvePromises>\n    var resolver = function resolver(root, path) {\n        var promiseQueue = [];\n        _.forEach(root, function (child, childIndex) {\n          if (_.isArray(child)) {\n            promiseQueue.push(resolver(child, path.concat([childIndex])));\n          } else if (_.isPlainObject(child)) {\n            promiseQueue.push(resolver(child, path.concat([childIndex])));\n          } else if (_.isFunction(child)) {\n            var nodePath = path.concat([childIndex]);\n            promiseQueue.push(settings.wrapper(child, nodePath, base).then(function (res) {\n                if (!dirty && _.isObject(res) && treeTools.hasSome(res, function (v) {\n                  return settings.isPromise(v);\n                })) {\n                  dirty = true; \n                } \n                _.set(base, nodePath, res); \n                if (settings.splice && settings.isSplice(res, nodePath, base)) {\n                  splices.push(nodePath);\n                }\n            }));\n          }\n        });\n        return Promise.all(promiseQueue);\n    };\n    </resolvePromises>\n\n    return Promise.resolve().then(function () {\n        return new Promise(function (resolve, reject) {\n          <attemptResolving>\n          var attemptNext = function attemptNext() {\n            if (--settings.attempts > 0 && dirty) {\n              dirty = false; \n              resolver(base, []).then(attemptNext);\n            } else {\n              resolve();\n            }\n          };\n          attemptNext();\n          </attemptResolving>\n        });\n    }).then(function () {\n        <performSplicing>\n        if (!settings.splice) return;\n        splices.reverse().forEach(function (path) {\n          var spliceParentPath = path.slice(0, -1);\n          var spliceParent = spliceParentPath.length ? _.get(base, spliceParentPath) : base;\n          var spliceOffset = path[path.length - 1];\n          spliceParent.splice.apply(spliceParent, [spliceOffset, 1].concat(_toConsumableArray(_.get(base, path))));\n        });\n        </performSplicing>\n        return null;\n    }).then(function () {\n        return base;\n    });\n}\n"], ["transformJSXSyntax", "\nfunction transformJSX(ast, pragma) {\n    assert(t.isFile(ast) || t.isProgram(ast), '<ast> must be a babel ast for transformJSX(ast: AST, pragma: String): AST');\n    assert(typeof pragma === 'string' && pragma, '<pragma> must be a non-empty string for transformJSX(ast: AST, pragma: String): AST');\n    \n    const call = buildCall(pragma);\n    \n    traverse(ast, {\n        JSXElement: {\n            exit(path) {\n                const openingElement = path.get('openingElement');\n                const expression = buildElementCall(call, openingElement);\n                expression.arguments = [...expression.arguments, ...path.node.children];\n                path.replaceWith(t.inherits(expression, path.node));\n            }\n        }\n    });\n    return ast;\n}\n"], ["getAPIDescriptionElements", "\nfunction getAPIDescriptionElems(){\n    var resp = $('.documentation__routes');\n    var namespaces = _.map(resp.children(), function(sectionChild){\n        var namespace = {\n            name: sectionChild.attribs.id.replace(/\\s/, ''),\n        };\n        var methodDescWrapElems = _.map(sectionChild.children, function(child, i){\n            if(child.attribs && child.attribs.class && utils.hasClass('toc-el', child.attribs.class)){\n                return child;     \n            }\n        });\n        namespace.el = _.compact(methodDescWrapElems);\n        return namespace;\n    });\n    return namespaces;\n}\n"], ["RopeJointInitialization", "\nfunction RopeJoint(def, bodyA, bodyB, anchor) {\n  if (!(this instanceof RopeJoint)) {\n    return new RopeJoint(def, bodyA, bodyB, anchor);\n  }\n\n  def = options(def, DEFAULTS);\n  Joint.call(this, def, bodyA, bodyB);\n  bodyA = this.m_bodyA;\n  bodyB = this.m_bodyB;\n\n  this.m_type = RopeJoint.TYPE;\n  <calculateLocalAnchors>\n  this.m_localAnchorA = anchor ? bodyA.getLocalPoint(anchor) : def.localAnchorA || Vec2.neo(-1.0, 0.0);\n  this.m_localAnchorB = anchor ? bodyB.getLocalPoint(anchor) : def.localAnchorB || Vec2.neo(1.0, 0.0);\n  </calculateLocalAnchors>\n  \n  <setJointAttributes>\n  this.m_maxLength = def.maxLength;\n  this.m_mass = 0.0;\n  this.m_impulse = 0.0;\n  this.m_length = 0.0;\n  this.m_state = inactiveLimit;\n  </setJointAttributes>\n\n  \n  \n  \n  \n  \n  \n  \n}\n"], ["findElementsInYUIContext", "\nfunction(selector) {\n        var nodelist = Y.all(Y.Selector.query(selector, this._node));\n        nodelist._query = selector;\n        nodelist._queryRoot = this._node;\n        return nodelist;\n    }\n"], ["setupDebugUtility", "\nfunction setup(env) {\n    createDebug.debug = createDebug;\n    createDebug.default = createDebug;\n    createDebug.coerce = coerce;\n    createDebug.disable = disable;\n    createDebug.enable = enable;\n    createDebug.enabled = enabled;\n    createDebug.humanize = require('ms');\n    \n    Object.keys(env).forEach(key => {\n        createDebug[key] = env[key];\n    });\n    \n    createDebug.instances = [];\n    \n    createDebug.names = [];\n    createDebug.skips = [];\n    \n    createDebug.formatters = {};\n    \n    createDebug.selectColor = function selectColor(namespace) {\n        let hash = 0;\n        for (let i = 0; i < namespace.length; i++) {\n            hash = ((hash << 5) - hash) + namespace.charCodeAt(i);\n            hash |= 0; \n        }\n        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];\n    };\n    \n    createDebug.create = function createDebug(namespace) {\n        let prevTime;\n        function debug(...args) {\n            if (!debug.enabled) {\n                return;\n            }\n            const self = debug;\n            const curr = Number(new Date());\n            const ms = curr - (prevTime || curr);\n            self.diff = ms;\n            self.prev = prevTime;\n            self.curr = curr;\n            prevTime = curr;\n            args[0] = createDebug.coerce(args[0]);\n            if (typeof args[0] !== 'string') {\n                args.unshift('%O');\n            }\n            let index = 0;\n            args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {\n                if (match === '%%') {\n                    return match;\n                }\n                index++;\n                const formatter = createDebug.formatters[format];\n                if (typeof formatter === 'function') {\n                    const val = args[index];\n                    match = formatter.call(self, val);\n                    args.splice(index, 1);\n                    index--;\n                }\n                return match;\n            });\n            createDebug.formatArgs.call(self, args);\n            const logFn = self.log || createDebug.log;\n            logFn.apply(self, args);\n        }\n        debug.namespace = namespace;\n        debug.enabled = createDebug.enabled(namespace);\n        debug.useColors = createDebug.useColors();\n        debug.color = createDebug.selectColor(namespace);\n        debug.destroy = function destroy() {\n            const index = createDebug.instances.indexOf(this);\n            if (index !== -1) {\n                createDebug.instances.splice(index, 1);\n                return true;\n            }\n            return false;\n        };\n        debug.extend = function extend(namespace, delimiter) {\n            const newDebug = createDebug.create(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);\n            newDebug.log = this.log;\n            return newDebug;\n        };\n        if (typeof createDebug.init === 'function') {\n            createDebug.init(debug);\n        }\n        createDebug.instances.push(debug);\n        return debug;\n    };\n    \n    createDebug.enable(createDebug.load());\n    \n    return createDebug;\n}\n"], ["createResourceClusters", "\nfunction createClusters(units, distanceApart = 15.0) {\n    const squaredDistanceApart = distanceApart * distanceApart;\n    return units.reduce((clusters, u) => {\n        const isGeyser = vespeneGeyserTypes.includes(u.unitType);\n        const { distance, target } = clusters.reduce((acc, b) => {\n            const d = distanceSquared(u.pos, b.centroid);\n            if (d < acc.distance) {\n                return { distance: d, target: b };\n            } else {\n                return acc;\n            }\n        }, { distance: Infinity, target: null });\n        if (distance > squaredDistanceApart) {\n            return clusters.concat([{\n                centroid: u.pos,\n                mineralFields: isGeyser ? [] : [u],\n                vespeneGeysers: isGeyser ? [u] : [],\n            }]);\n        } else {\n            if (isGeyser) {\n                target.vespeneGeysers = [...target.vespeneGeysers, u];\n            } else {\n                target.mineralFields = [...target.mineralFields, u];\n            }\n            const size = target.mineralFields.length + target.vespeneGeysers.length;\n            target.centroid = divide(add(multiply(target.centroid, (size - 1)), u.pos), size);\n            return clusters;\n        }\n    }, []);\n}\n"], ""]