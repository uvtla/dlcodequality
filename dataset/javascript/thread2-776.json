[["updateNode", "\nfunction updateNode(node, callback) {\n  syncDb.update(node._id, node, (err, result) => {\n    if(err) return callback(err);\n\n    callback(null, node);\n  });\n}\n"], ["fullEncodeURIComponent", "\nfunction fullEncodeURIComponent (str) {\n    var rv = encodeURIComponent(str).replace(/[!'()*~]/g, function(c) {\n      return '%' + c.charCodeAt(0).toString(16).toUpperCase();\n    });\n    return rv.replace(/\\%20/g,'+');\n}\n"], ["createConnection", "\nfunction createConnection(connectionOptions, config) {\n    var connectionConfig =\n        new ConnectionConfig(connectionOptions, !config, qaMode, clientInfo);\n    \n    var httpClient = options.httpClient ||\n            new options.httpClientClass(connectionConfig);\n    \n    return new connectionClass(\n        new ConnectionContext(connectionConfig, httpClient, config));\n}\n"], ["getAssetInfo", "\nfunction getAssetInfo (queryOptions, { assetId }) {\n  return sendQuery(\n    queryOptions,\n    queryHelper.addQuery(\n      queryHelper.emptyQuery(),\n      'getAssetInfo',\n      {\n        assetId\n      }\n    ),\n    (resolve, reject, responseName, response) => {\n      if (responseName !== 'ASSET_RESPONSE') {\n        const error = JSON.stringify(response.toObject().errorResponse)\n        return reject(new Error(`Query response error: expected=ASSET_RESPONSE, actual=${responseName}\\nReason: ${error}`))\n      }\n\n      const info = response.getAssetResponse().toObject().asset\n      resolve(info)\n    }\n  )\n}\n"], ["initProfiler", "\nfunction initProfiler(name) {\n        checkInit();\n        var profiler = profilerInstances[name];\n        if (profiler === void 0) {\n            profilerInstances[name] = profiler = new Profiler(name, \"ms\");\n            container.appendChild(profiler.widget.element);\n        }\n    }\n"], ["generateExpression", "\nfunction (oInterface, oPathValue) {\n    var i,\n        sName,\n        aParts = [],\n        sPrefix = \"\",\n        oParameter,\n        aParameters = oPathValue.value,\n        oResult,\n        oTemplate = Expression.parameter(oInterface, oPathValue, 0, \"Edm.String\");\n\n    aParts.push('odata.fillUriTemplate(', Basics.resultToString(oTemplate, true), ',{');\n    for (i = 1; i < aParameters.length; i += 1) {\n        oParameter = Basics.descend(oPathValue, i, \"object\");\n        sName = Basics.property(oParameter, \"Name\", \"string\");\n        oResult = Expression.expression(oInterface, Basics.descend(oParameter, \"Value\"),\n            true);\n        aParts.push(sPrefix, Basics.toJSON(sName), \":\",\n            Basics.resultToString(oResult, true));\n        sPrefix = \",\";\n    }\n    aParts.push(\"})\");\n    return {\n        result : \"expression\",\n        value : aParts.join(\"\"),\n        type : \"Edm.String\"\n    };\n}\n"], ["addVectors", "\nfunction add(out, a, b) {\n  out[0] = a[0] + b[0];\n  out[1] = a[1] + b[1];\n  out[2] = a[2] + b[2];\n  out[3] = a[3] + b[3];\n  out[4] = a[4] + b[4];\n  out[5] = a[5] + b[5];\n  out[6] = a[6] + b[6];\n  out[7] = a[7] + b[7];\n  out[8] = a[8] + b[8];\n  return out;\n}\n"], ["generateKey", "\nfunction(keyname, extension) {\n    var keynameToUse = keyname;\n\n    if (extension !== undefined) {\n        keynameToUse += \".\" + extension;\n    }\n\n    promise.success(keynameToUse);\n}\n"], ["postRequest", "\nfunction post(url, data, successCallback, errorCallback) {\n    const request = new XMLHttpRequest();\n\n    request.open('POST', url, true);\n    request.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded; charset=UTF-8');\n\n    request.onreadystatechange = () => {\n        if (request.readyState === 4) {\n            \n            if ((request.status >= 200) && (request.status < 300)) {\n                successCallback(request.responseText);\n            } else {\n                console.error(`POST (${url}): error ${request.status} ${request.statusText}`);\n                errorCallback(request.status, request.statusText);\n            }\n        }\n    };\n\n    request.send(data);\n}\n"], ["execTask", "\nfunction execTask(proc, taskObj) {\n  const { tasks, logger, model, sharedModel, config, logic } = proc;\n  const { task, executor, notifyCmd, successCmd, failCmd,\n    customArgs, execEvery, customExecId, id: taskId } = taskObj;\n\n  \n  <handleCancellation>\n  if (taskObj.cancelTask || !execEvery) {\n    cancelTask(proc, taskId);\n    if (taskObj.cancelTask) return;\n  }\n  </handleCancellation>\n\n  <taskExecution>\n  const execId = customExecId || nextId();\n  const executions = tasks[taskId] = tasks[taskId] || {};\n  const cleanup = () => delete executions[execId];\n\n  \n  if (executions[execId]) {\n    executions[execId].exec(taskObj);\n  } else {\n    const taskCall = executor(proc, taskObj);\n    executions[execId] = taskCall;\n    taskCall.exec(taskObj).then(cleanup, cleanup);\n  }\n  </taskExecution>\n}\n"], "```"]