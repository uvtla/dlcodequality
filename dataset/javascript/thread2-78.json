[["hasPositionByBoardSize", "\nfunction hasPositionByBoardSize(boardSize, position) {\n    return position && position.x >= 0 && position.y >= 0 && boardSize.y > position.y && boardSize.x > position.x;\n}\n"], ["createEntityAndHandleResponse", "\nfunction(params, callback) {\n    <setDefaultCallback>\n    callback = callback || function() {};\n    </setDefaultCallback>\n    \n    var that = this;\n\n    <makePostRequestAndProcessResponse>\n    var req = this.post(\"\", params, function(err, response) {\n        if (err) {\n            callback(err);\n        }\n        else {\n            var props = response.data.entry;\n            <normalizeProps>\n            if (utils.isArray(props)) {\n                props = props[0];\n            }\n            </normalizeProps>\n            \n            <instantiateAndLoadEntity>\n            var entity = that.instantiateEntity(props);\n            entity._load(props);\n            </instantiateAndLoadEntity>\n\n            <fetchEntity>\n            if (that.fetchOnEntityCreation) {\n                entity.fetch(function() {\n                    if (req.wasAborted) {\n                        return; \n                    }\n                    else {\n                        callback.apply(null, arguments);\n                    }\n                });\n            }\n            else {                   \n                callback(null, entity);\n            }\n            </fetchEntity>\n        }\n    });\n    </makePostRequestAndProcessResponse>\n    \n    return req;\n}\n"], ["resetRendererState", "\nfunction (renderer) {\n    renderer.__currentFrameBuffer = null;\n\n    var _gl = renderer.gl;\n\n    _gl.bindFramebuffer(GL_FRAMEBUFFER, null);\n    this._boundRenderer = null;\n\n    this._cache.use(renderer.__uid__);\n\n    <setViewport>\n    var viewport = this._cache.get('viewport');\n    if (viewport) {\n        renderer.setViewport(viewport);\n    }\n    </setViewport>\n\n    <updateMipmap>\n    this.updateMipmap(renderer);\n    </updateMipmap>\n}\n"], ["createDatabaseSchema", "\nasync function createSchema() {\n    <dropExistingTables>\n    await knex.schema\n        .dropTableIfExists('Person_Movie')\n        .dropTableIfExists('Animal')\n        .dropTableIfExists('Movie')\n        .dropTableIfExists('Person');\n    </dropExistingTables>\n\n    <createNewTables>\n    await knex.schema\n        .createTable('Person', table => {\n            table.increments('id').primary();\n            table\n                .integer('parentId')\n                .unsigned()\n                .references('id')\n                .inTable('Person');\n            table.string('firstName');\n            table.string('lastName');\n            table.integer('age');\n            table.json('address');\n        })\n        .createTable('Movie', table => {\n            table.increments('id').primary();\n            table.string('name');\n        })\n        .createTable('Animal', table => {\n            table.increments('id').primary();\n            table\n                .integer('ownerId')\n                .unsigned()\n                .references('id')\n                .inTable('Person');\n            table.string('name');\n            table.string('species');\n        })\n        .createTable('Person_Movie', table => {\n            table.increments('id').primary();\n            table\n                .integer('personId')\n                .unsigned()\n                .references('id')\n                .inTable('Person')\n                .onDelete('CASCADE');\n            table\n                .integer('movieId')\n                .unsigned()\n                .references('id')\n                .inTable('Movie')\n                .onDelete('CASCADE');\n        });\n    </createNewTables>\n}\n"], ["writePreferencesForPlatforms", "\nfunction run(context) {\n    <readConfigurationPreferences>\n    const preferences = configPreferences.read(context);\n    </readConfigurationPreferences>\n\n    const platforms = context.opts.cordova.platforms;\n\n    <setPreferencesForPlatforms>\n    platforms.forEach(platform => {\n      if (platform === ANDROID) {\n        androidManifest.writePreferences(context, preferences);\n      }\n      if (platform === IOS) {\n        iosDevelopmentTeam.addDevelopmentTeam(preferences);\n      }\n    });\n    </setPreferencesForPlatforms>\n}\n"], ["createDefaultLogger", "\nfunction createDefaultLogger(options) {\n    const ConsoleLogger = require('./console'),\n          consoleLogger = new ConsoleLogger(options),\n          \n    <combineConfigWithDefaults>\n    config = _.mergeWith({\n        name: 'logger',\n        streams: [\n            {\n                level: options && options.level || 'trace',\n                type: 'raw',\n                stream: consoleLogger\n            }\n        ]\n    }, options, function (a, b) {\n        return _.isArray(a) ? a.concat(b) : undefined;\n    });\n    </combineConfigWithDefaults>\n\n    <setDefaultLogLevel>\n    consoleLogger.level = bunyan.resolveLevel(options && options.level || 'trace');\n    </setDefaultLogLevel>\n\n    <conditionalProblemLoggerSetup>\n    if (!options || options.problemLogger || options.problemLogger === undefined) {\n        const ProblemLogger = require('./problem');\n        config.streams.push({\n            level: 'trace',\n            type: 'raw',\n            stream: new ProblemLogger(options)\n        });\n    }\n    </conditionalProblemLoggerSetup>\n\n    <createLoggerInstance>\n    const defaultLogger = bunyan.createLogger(config);\n    </createLoggerInstance>\n\n    <setLoggerLevelMethod>\n    defaultLogger.setLevel = function (nameOrNum) {\n        var level = 'trace';\n        try {\n            level = bunyan.resolveLevel(nameOrNum);\n        } catch (e) {} \n        consoleLogger.level = level;\n        return this.level(level);\n    };\n    </setLoggerLevelMethod>\n\n    return defaultLogger;\n}\n"], ["CLASSICConstructor", "\nfunction CLASSIC( buffer, start, end ) {\n  <constructorValidation>\n  if( !(this instanceof CLASSIC) )\n    return new CLASSIC( buffer, start, end )\n  </constructorValidation>\n\n  <callSuperConstructor>\n  MBR.call( this, buffer, start, end )\n  </callSuperConstructor>\n}\n"], ["metalsmithPlugin", "\nfunction plugin(options) {\n    return function(files, metalsmith, done) {\n        <processFiles>\n        Object.keys(files).forEach(function(file) {\n            var data = files[file];\n            data.contents = new Buffer(special(data.contents.toString()));\n        });\n        </processFiles>\n        \n        done();\n    }\n}\n"], ["findCommonPrefix", "\nfunction findCommonPrefix(extractDir, callback) {\n    <readDirectory>\n    fs.readdir(extractDir, function (err, files) {\n        ignoredFolders.forEach(function (folder) {\n            var index = files.indexOf(folder);\n            if (index !== -1) {\n                files.splice(index, 1);\n            }\n        });\n        </readDirectory>\n        \n        <processFilesAndInvokeCallback>\n        if (err) {\n            callback(err);\n        } else if (files.length === 1) {\n            var name = files[0];\n            if (fs.statSync(path.join(extractDir, name)).isDirectory()) {\n                callback(null, name);\n            } else {\n                callback(null, \"\");\n            }\n        } else {\n            callback(null, \"\");\n        }\n        </processFilesAndInvokeCallback>\n    });\n}\n"], ["createGenerateDocs", "\nfunction createGenerateDocs(inPath, outPath) {\n    <validateArguments>\n    if (!inPath) {\n        throw new Error('Input path(s) argument is required');\n    }\n\n    if (!outPath) {\n        throw new Error('Output path argument is required');\n    }\n    </validateArguments>\n\n    <setupJsDocConfig>\n    const jsDocConfig = {\n        opts: {\n            destination: outPath,\n        },\n    };\n    </setupJsDocConfig>\n\n    return function generateDocs(done) {\n        <generateDocumentation>\n        gulp.src(inPath, { read: false })\n            .pipe(jsdoc(jsDocConfig, done));\n        </generateDocumentation>\n    };\n}\n"], "```"]