[["setOptions", "\nfunction(options, inheritFrom) {\n    <inheritSettings>\n    if (inheritFrom) {\n        var group = this.readOption(inheritFrom, 'group');\n        if (group && options.groups[group]) {\n            $.extend(options, options.groups[group]);\n        }\n    }\n    </inheritSettings>\n\n    var opts = Base.prototype.setOptions.call(this, options);\n\n    <inheritAdditionalOptions>\n    if (inheritFrom) {\n        opts = this.inheritOptions(opts, inheritFrom);\n    }\n    </inheritAdditionalOptions>\n\n    <adjustMode>\n    if (opts.mode && opts.mode === 'hover') {\n        opts.mode = Toolkit.isTouch ? 'click' : 'mouseenter';\n    }\n    </adjustMode>\n\n    this.options = opts;\n\n    return opts;\n}\n"], ["_normalizeValidate", "\nfunction _normalizeValidate (field) {\n  if (field.validate) {\n    Object.keys(field.validate).forEach(key => {\n      let validateItem = field.validate[key]\n      if (typeof validateItem === 'function') { return }\n      \n      <standardizeValidationObject>\n      if ((typeof validateItem !== 'object') || (typeof validateItem.args === 'undefined')) {\n        field.validate[key] = { args: validateItem }\n      }\n      </standardizeValidationObject>\n\n      <removeArgsIfBoolean>\n      if (typeof field.validate[key].args === 'boolean') {\n        delete field.validate[key].args\n        if (typeof field.validate[key].msg === 'undefined') {\n          field.validate[key] = true\n        }\n      }\n      </removeArgsIfBoolean>\n\n      <normalizeArgsArray>\n      if ((typeof field.validate[key].args !== 'undefined') && ((field.validate[key].args === 0) || (field.validate[key].args === 1))) {\n        field.validate[key].args = [field.validate[key].args]\n      }\n      </normalizeArgsArray>\n    })\n  }\n}\n"], ["spawnNodes", "\nfunction spawnNodes (n, factory, callback) {\n  timesSeries(n, (_, cb) => factory.spawnNode(cb), callback)\n}\n"], ["parseVCF", "\nfunction parseVCF(text) {\n    var lines = U.reject(text.split('\\n'), function(line) {\n      return line === '';\n    });\n\n    <partitionLines>\n    var partitions = U.partition(lines, function(line) {\n      return line[0] === '#';\n    });\n    </partitionLines>\n\n    <processHeaderAndRecords>\n    var header = parseHeader(partitions[0]),\n        records = U.map(partitions[1], function(line) {\n          return new Record(line, header);\n        });\n    </processHeaderAndRecords>\n\n    return {header: header, records: records};\n}\n"], ["calculateAngleInSinLUT", "\nfunction(theta) {\n    while (theta < 0) {\n        theta += mathUtils.TWO_PI;\n    }\n    return this.sinLUT[((theta * this.rad2deg) + this.quadrant) % this.period];\n}\n"], ["verifier", "\nfunction verifier (req, identifier, userInfo, done) {\n  <prepareAuthInfo>\n  var auth = {\n    id: req.query['openid.identity'],\n    req_query: req.query\n  }\n\n  userInfo.id = req.query['openid.identity']\n  userInfo.name = req.query['openid.ext2.value.fullname']\n  userInfo.givenName = req.query['openid.ext2.value.firstname']\n  userInfo.familyName = req.query['openid.ext2.value.lastname']\n  userInfo.email = req.query['openid.ext2.value.email']\n  </prepareAuthInfo>\n\n  <connectUser>\n  User.connect(req, auth, userInfo, function (err, user) {\n    if (err) { return done(err) }\n    done(null, user)\n  })\n  </connectUser>\n}\n"], ["processScript", "\nfunction(script, filename) {\n    if(!filename) filename = \"openjscad.jscad\";\n    this.abort();\n    this.paramDefinitions = [];\n    this.paramControls = [];\n    this.script = null;\n    this.setError(\"\");\n    var scripthaserrors = false;\n\n    <parseParameters>\n    try\n    {\n      this.paramDefinitions = OpenJsCad.getParamDefinitions(script);\n      this.createParamControls();\n    }\n    catch(e)\n    {\n      this.setError(e.toString());\n      this.setStatus(\"Error.\");\n      scripthaserrors = true;\n    }\n    </parseParameters>\n\n    <loadAndBuildScript>\n    if(!scripthaserrors)\n    {\n      this.script = script;\n      this.filename = filename;\n      this.rebuildSolid();\n    }\n    else\n    {\n      this.enableItems();\n    }\n    </loadAndBuildScript>\n}\n"], ["attachPolygon", "\nfunction (poly) {\n    var area = this._mbr || this;\n\n    if (!poly) {\n        poly = new Crafty.polygon([0, 0], [area._w, 0], [area._w, area._h], [0, area._h]);\n    }\n\n    <handleMultipleArguments>\n    if (arguments.length > 1) {\n        var args = Array.prototype.slice.call(arguments, 0);\n        poly = new Crafty.polygon(args);\n    }\n    </handleMultipleArguments>\n\n    this.map = poly;\n    this.attach(this.map);\n    this.map.shift(area._x, area._y);\n\n    return this;\n}\n"], ["buildNav", "\nfunction buildNav(members) {\n    <initializeNavigation>\n    var nav = '<h2><a href=\"index.html\">Index</a></h2>',\n        seen = {},\n        hasClassList = false,\n        classNav = '',\n        globalNav = '',\n\t\tdiagramNav = '';\n    </initializeNavigation>\n\n    <populateModules>\n    if (members.modules.length) {\n        //... (Code omitted for brevity)\n    }\n    </populateModules>\n    \n    //... (Additional sections omitted for brevity, similar to <populateModules>)\n\t\n\t<finalizeNavigation>\n\tif (members.globals.length) {\n        //... (Code omitted for brevity)\n    }\n\t</finalizeNavigation>\n\n    return nav;\n}\n"], ["initializeWithEmpty", "\nfunction(schema, global) {\n  var {\n    required\n  , properties\n  } = schema;\n\n  if ( !required ) {\n    return {};\n  } else {\n    <populateRequiredProperties>\n    return required.reduce(function(prev, next) {\n      var s = properties[next];\n      if ( !s ) {\n        throw new Error(`property \\`${next}\\` not defined on object`);\n      }\n      prev[next] = empty(s, global);\n      return prev;\n    }, {});\n    </populateRequiredProperties>\n  }\n}\n"], "```\n\nEach function has been annotated with tags that describe the distinct responsibilities they contain. Note that simple functions or single-purpose functions are enclosed in a single tag, while more complex functions with additional responsibilities are further broken down into nested segments."]