[["add_shared", "\nfunction add_shared(hash, customTags, doc_map) {\n    <mergeData>\n    hash = utils.merge(hash, {\n      \"inheritable\" : !!doc_map[\"inheritable\"],\n      \"inheritdoc\" : extract(doc_map, \"inheritdoc\"),\n      \"related\" : extract(doc_map, \"related\"),\n      \"see\" : extract(doc_map, \"see\"),\n      \"private\" : extract(doc_map, \"private\") !== null ? true : false,\n      \"experimental\" : extract(doc_map, \"experimental\") !== null ? true : false,\n      \"ignore\" : extract(doc_map, \"ignore\") !== null ? true : false,\n      \"author\" : extract_plural(doc_map[\"author\"] || []),\n      \"version\" : extract(doc_map, \"version\"),\n      \"since\" : extract(doc_map, \"since\"),\n      \"todo\" : extract(doc_map, \"todo\")\n    });\n    </mergeData>\n\n    <mergeCustomTags>\n    if (customTags !== undefined) {\n      var custom = {};\n      _.each(customTags, function(tag) {\n        var text = extract(doc_map, tag);\n        if (text !== null) {\n          custom[tag] = text.doc.length > 0 ? text.doc : true;\n        }\n      });\n\n      hash = utils.merge(hash, custom);\n    }\n    </mergeCustomTags>\n\n    return hash;\n}\n"], ["activateDefaultPlugins", "\nfunction (ui, done) {\n        <pluginActivationLoop>\n        Object.keys(ui.defaultPlugins).forEach(function (key) {\n            ui.pluginManager.get(key)(ui, ui.bs);\n        });\n        </pluginActivationLoop>\n        done();\n    }\n"], ["processEventByName", "\nfunction (name, data) {\n            switch (name) {\n                case 'layoutchange':\n                    <updateLayout>\n                    api.updateLayout();\n                    </updateLayout>\n                    break;\n\n                case 'linkclick':\n                    <handleLinkClick>\n                    handleLinkClick(data);\n                    </handleLinkClick>\n                    break;\n\n                case 'zoom':\n                    <modifyZoomData>\n                    data.zoom *= config.pageScale;\n                    data.prevZoom *= config.pageScale;\n                    </modifyZoomData>\n                    <updateDraggerData>\n                    if (config.enableDragging) {\n                        updateDragger(data.isDraggable);\n                    }\n                    </updateDraggerData>\n                    <fireZoomEvent>\n                    api.fire(name, data);\n                    </fireZoomEvent>\n                    break;\n\n                case 'dragstart':\n                    <handleDragStart>\n                    if (!$el.hasClass(CSS_CLASS_DRAGGING)) {\n                        $el.addClass(CSS_CLASS_DRAGGING);\n                    }\n                    </handleDragStart>\n                    <fireDragStartEvent>\n                    api.fire(name, data);\n                    </fireDragStartEvent>\n                    break;\n\n                case 'dragend':\n                    <handleDragEnd>\n                    if ($el.hasClass(CSS_CLASS_DRAGGING)) {\n                        $el.removeClass(CSS_CLASS_DRAGGING);\n                    }\n                    </handleDragEnd>\n                    <fireDragEndEvent>\n                    api.fire(name, data);\n                    </fireDragEndEvent>\n                    break;\n\n                default:\n                    <fireDefaultEvent>\n                    api.fire(name, data);\n                    </fireDefaultEvent>\n                    break;\n            }\n        }\n"], ["TextFieldDirective", "\nfunction TextFieldDirective($log, $timeout, fieldHelper) {\n            <directiveConfiguration>\n            this.require = '^formFor';\n            this.restrict = 'EA';\n            this.templateUrl = function ($element, $attributes) {\n                return $attributes['template'] || 'form-for/templates/text-field.html';\n            };\n            this.scope = {\n                attribute: '@',\n                debounce: '@?',\n                disable: '=',\n                focused: '&?',\n                blurred: '&?',\n                help: '@?',\n                iconAfterClicked: '&?',\n                iconBeforeClicked: '&?',\n                placeholder: '@?',\n                rows: '=?',\n                controller: '=?'\n            };\n            </directiveConfiguration>\n            <dependencyAssignment>\n            $log_ = $log;\n            $timeout_ = $timeout;\n            fieldHelper_ = fieldHelper;\n            </dependencyAssignment>\n        }\n"], ["orderBy", "\nfunction orderBy() {\n  \n  var self = (this instanceof QueryBuilder) ? this : new QueryBuilder();\n\n  <parseArguments>\n  var args = mlutil.asArray.apply(null, arguments);\n  </parseArguments>\n  \n  <initializeVariables>\n  var sortOrder = [];\n\n  var scoreOption    = null;\n  var scoreDirection = null;\n  </initializeVariables>\n\n  <sortOrderProcessing>\n  var arg = null;\n  for (var i=0; i < args.length; i++) {\n    arg = args[i];\n    if (typeof arg === 'string' || arg instanceof String) {\n      sortOrder.push(sort(arg));\n    } else {\n      if (scoreOption === null) {\n        scoreOption = arg.score;\n        if (typeof scoreOption === 'string' || scoreOption instanceof String) {\n          scoreOption = 'score-'+scoreOption;\n          scoreDirection = arg.direction;\n          sortOrder.push(\n              (scoreDirection === null || scoreDirection === void 0) ?\n              {score: null} :\n              {score: null, direction: scoreDirection}\n              );\n          continue;\n        } else if (scoreOption === void 0) {\n          scoreOption = null;\n        }\n      }\n\n      sortOrder.push(arg);\n    }\n  }\n  </sortOrderProcessing>\n\n  <buildOrderByClause>\n  self.orderByClause = (scoreOption === null) ? {\n    'sort-order': sortOrder\n  } : {\n    'sort-order': sortOrder,\n    scoreOption:  scoreOption\n  };\n  </buildOrderByClause>\n\n  return self;\n}\n"], ["resolveDependencies", "\nfunction(key) {\n\t        \n\t        <checkResolvedValue>\n\t        var value = _resolved.get(key);\n\t        if (value && (value.pending || value.file)) {\n\t      \t  return;\n\t        }\n\t  \t\t</checkResolvedValue>\n\t  \t\t<invokeResolve>\n\t  \t\tresolve(server, key, loc);\n\t  \t\t</invokeResolve>\n\t    }\n"], ["getParamsDetails", "\nfunction getParamsDetails(spec_c) {\n  <getParaChildren>\n  var paras = getChildren(spec_c, 'para');\n  </getParaChildren>\n  <findParameterList>\n  var details = _.find(_.map(paras, function(para) {\n    return getChild(para, 'parameterlist');\n  }), function(obj) { return (obj != undefined); });\n  </findParameterList>\n  return (details ? details.children : undefined);\n}\n"], ["gettextTranslation", "\nfunction ( domain, context, singular_key, plural_key, val ) {\n      \n      <setDefaults>\n      plural_key = plural_key || singular_key;\n      domain = domain || this._textdomain;\n      </setDefaults>\n\n      <configureFallback>\n      var fallback;\n      if ( ! this.options ) {\n        fallback = new Jed();\n        return fallback.dcnpgettext.call( fallback, undefined, undefined, singular_key, plural_key, val );\n      }\n      </configureFallback>\n\n      <verifyLocaleData>\n      if ( ! this.options.locale_data ) {\n        throw new Error('No locale data provided.');\n      }\n      if ( ! this.options.locale_data[ domain ] ) {\n        throw new Error('Domain `' + domain + '` was not found.');\n      }\n      if ( ! this.options.locale_data[ domain ][ \"\" ] ) {\n        throw new Error('No locale meta information provided.');\n      }\n      </verifyLocaleData>\n\n      <checkTranslationKey>\n      if ( ! singular_key ) {\n        throw new Error('No translation key found.');\n      }\n      </checkTranslationKey>\n\n      <prepareTranslationQuery>\n      var key  = context ? context + Jed.context_delimiter + singular_key : singular_key,\n          locale_data = this.options.locale_data,\n          dict = locale_data[ domain ],\n          defaultConf = (locale_data.messages || this.defaults.locale_data.messages)[\"\"],\n          pluralForms = dict[\"\"].plural_forms || dict[\"\"][\"Plural-Forms\"] || dict[\"\"][\"plural-forms\"] || defaultConf.plural_forms || defaultConf[\"Plural-Forms\"] || defaultConf[\"plural-forms\"],\n          val_list,\n          res;\n      </prepareTranslationQuery>\n\n      <determinePluralFormIndex>\n      var val_idx;\n      if (val === undefined) {\n        val_idx = 1;\n      } else {\n        if ( typeof val != 'number' ) {\n          val = parseInt( val, 10 );\n          if ( isNaN( val ) ) {\n            throw new Error('The number that was passed in is not a number.');\n          }\n        }\n        val_idx = getPluralFormFunc(pluralForms)(val) + 1;\n      }\n      </determinePluralFormIndex>\n\n      <validateTranslationData>\n      if ( ! dict ) {\n        throw new Error('No domain named `' + domain + '` could be found.');\n      }\n      val_list = dict[ key ];\n      if ( ! val_list || val_idx >= val_list.length ) {\n        if (this.options.missing_key_callback) {\n          this.options.missing_key_callback(key, domain);\n        }\n        res = [ null, singular_key, plural_key ];\n        return res[ getPluralFormFunc(pluralForms)( val ) + 1 ];\n      }\n      res = val_list[ val_idx ];\n      if ( ! res  ) {\n        res = [ null, singular_key, plural_key ];\n        return res[ getPluralFormFunc()( val ) + 1 ];\n      }\n      </validateTranslationData>\n\n      return res;\n    }\n"], ["manageAudioMuteState", "\nfunction(mute) {\n            <checkSupport>\n            if (!Crafty.support.audio) return;\n            </checkSupport>\n            <muteChannels>\n            var c;\n            for (var i in this.channels) {\n                c = this.channels[i];\n                c.obj.volume = mute ? 0 : c.volume;\n            }\n            </muteChannels>\n            <updateMutedState>\n            this.muted = mute;\n            </updateMutedState>\n        }\n"], ["getFileServiceFunction", "\nfunction(fileUrl) {\n  <initialLogging>\n  logger.entry('getFileServiceFunction', logger.NO_CLIENT_ID);\n  logger.log('parms', logger.NO_CLIENT_ID, 'fileUrl:', fileUrl);\n  </initialLogging>\n\n  <inputValidation>\n  if (typeof fileUrl !== 'string') {\n    var err = new TypeError('fileUrl must be a string type');\n    logger.ffdc('getFileServiceFunction', 'ffdc001', null, err);\n    logger.throw('getFileServiceFunction', logger.NO_CLIENT_ID, err);\n    throw err;\n  }\n  </inputValidation>\n\n  <prepareFilePath>\n  var filePath = fileUrl;\n  if (os.platform() === 'win32' && filePath.match('^/[a-zA-Z]:/')) {\n    filePath = filePath.substring(1);\n  }\n  </prepareFilePath>\n\n  <createFileServiceFunction>\n  var fileServiceFunction = function(callback) {\n    <fileServiceFunctionLogging>\n    logger.entry('fileServiceFunction', logger.NO_CLIENT_ID);\n    logger.log('parms', logger.NO_CLIENT_ID, 'filePath:', filePath);\n    </fileServiceFunctionLogging>\n\n    <readFileAndProcess>\n    fs.readFile(filePath, {encoding: 'utf8'}, function(err, data) {\n      <callbackLogging>\n      logger.entry('fileServiceFunction.readFile.callback',\n                   logger.NO_CLIENT_ID);\n      logger.log('parms', logger.NO_CLIENT_ID, 'err:', err);\n      logger.log('parms', logger.NO_CLIENT_ID, 'data:', data);\n      </callbackLogging>\n\n      if (err) {\n        <handleReadError>\n        err.message = 'attempt to read ' + filePath + ' failed with the ' +\n                      'following error: ' + err.message;\n        logger.log('error', logger.NO_CLIENT_ID, err);\n        logger.entry('fileServiceFunction.callback', logger.NO_CLIENT_ID);\n        logger.log('parms', logger.NO_CLIENT_ID, 'err:', err);\n        callback(err);\n        logger.exit('fileServiceFunction.callback', logger.NO_CLIENT_ID, null);\n        </handleReadError>\n      } else {\n        var obj;\n        try {\n          <parseJSON>\n          obj = JSON.parse(data);\n          </parseJSON>\n        } catch (err) {\n          <handleParseError>\n          err.message = 'the content read from ' + filePath + ' contained ' +\n                        'unparseable JSON: ' + err.message;\n          logger.caught('fileServiceFunction.readFile.callback',\n                        logger.NO_CLIENT_ID, err);\n          logger.entry('fileServiceFunction.callback', logger.NO_CLIENT_ID);\n          logger.log('parms', logger.NO_CLIENT_ID, 'err:', err);\n          callback(err);\n          logger.exit('fileServiceFunction.callback', logger.NO_CLIENT_ID,\n                      null);\n          </handleParseError>\n        }\n        if (obj) {\n          <returnServiceData>\n          logger.entry('fileServiceFunction.callback', logger.NO_CLIENT_ID);\n          logger.log('parms', logger.NO_CLIENT_ID, 'service:', obj.service);\n          callback(null, obj.service);\n          logger.exit('fileServiceFunction.callback', logger.NO_CLIENT_ID,\n                      null);\n          </returnServiceData>\n        }\n      }\n      <exitCallbackLogging>\n      logger.exit('fileServiceFunction.readFile.callback', logger.NO_CLIENT_ID,\n                  null);\n      </exitCallbackLogging>\n    });\n    </readFileAndProcess>\n\n    <exitFileServiceFunctionLogging>\n    logger.exit('fileServiceFunction', logger.NO_CLIENT_ID, null);\n    </exitFileServiceFunctionLogging>\n  };\n  </createFileServiceFunction>\n\n  <exitAndGetServiceFunction>\n  logger.exit('getFileServiceFunction', logger.NO_CLIENT_ID,\n              fileServiceFunction);\n  return fileServiceFunction;\n  </exitAndGetServiceFunction>\n}\n"], "```"]