[["hashString", "\nfunction hashString(string) {\n  let hashed = 0;\n  for (let ii = 0; ii < string.length; ii++) {\n    hashed = (31 * hashed + string.charCodeAt(ii)) | 0;\n  }\n  return smi(hashed);\n}\n"], ["checkFieldLength", "\nfunction checkFieldLength(parsed, field, length) {\n  length = length || transactionFields[field].options.length;\n  if (parsed.transactions[field] && parsed.transactions[field].toString().length > length) {\n    console.log(parsed.transactions);\n    console.log(field, parsed.transactions[field]);\n  }\n}\n"], ["function", "\nfunction(obj, num, chordPos) {\n        <findAvailableChordPosition>\n        if (currSlur[chordPos] === undefined) {\n          for (x = 0; x < currSlur.length; x++) {\n            if (currSlur[x] !== undefined) {\n              chordPos = x;\n              break;\n            }\n          }\n          if (currSlur[chordPos] === undefined) {\n            var offNum = chordPos*100+1;\n            Common.each(obj.endSlur, function(x) { if (offNum === x) --offNum; });\n            currSlur[chordPos] = [offNum];\n          }\n        }\n        </findAvailableChordPosition>\n        \n        <assignSlurNumbers>\n        var slurNum;\n        for (var i = 0; i < num; i++) {\n          slurNum = currSlur[chordPos].pop();\n          obj.endSlur.push(slurNum);\n        }\n        </assignSlurNumbers>\n        \n        <cleanupIfNecessary>\n        if (currSlur[chordPos].length === 0)\n          delete currSlur[chordPos];\n        </cleanupIfNecessary>\n        \n        return slurNum;\n      }\n"], ["concatStrat", "\nfunction concatStrat(parentVal, childVal) {\n    parentVal = parentVal && !isArray(parentVal) ? [parentVal] : parentVal;\n\n    return childVal\n        ? parentVal\n            ? parentVal.concat(childVal)\n            : isArray(childVal)\n                ? childVal\n                : [childVal]\n        : parentVal;\n}\n"], ["reportError", "\nfunction reportError(node, initial, result, type) {\n    const name = initial.type === \"Identifier\" ? initial.name : initial.value;\n    \n    return context.report({\n        node,\n        message: \"{{type}} {{name}} unnecessarily renamed.\",\n        data: {\n            name,\n            type\n        },\n        fix(fixer) {\n            return fixer.replaceTextRange([\n                initial.range[0],\n                result.range[1]\n            ], name);\n        }\n    });\n}\n"], ["getTouchList", "\nfunction getTouchList(ev) {\n  if(ionic.Gestures.HAS_POINTEREVENTS) {\n    return ionic.Gestures.PointerEvent.getTouchList();\n  }\n  \n  else if(ev.touches) {\n    return ev.touches;\n  }\n  \n  else {\n    ev.identifier = 1;\n    return [ev];\n  }\n}\n"], ["readStdin", "\nasync function readStdin() {\n  let code = \"\";\n  const stdin = process.stdin;\n  return new Promise(resolve => {\n    stdin.setEncoding(\"utf8\");\n    stdin.on(\"readable\", () => {\n      const chunk = process.stdin.read();\n      if (chunk !== null) code += chunk;\n    });\n    stdin.on(\"end\", () => {\n      resolve(code);\n    });\n  });\n}\n"], ["verbositySetting", "\nfunction (program) {\n    var verbosity = program.verbose\n    if (program.quiet) {\n      verbosity = 0\n    } else if (typeof verbosity === 'undefined') {\n      verbosity = 1\n    }\n    return verbosity\n}\n"], ["rootExperiments", "\nfunction rootExperiments(fn) {\n  enqueue(function() {\n    var data = {};\n    var experimentIds = window._vwo_exp_ids;\n    if (!experimentIds) return fn();\n    each(experimentIds, function(experimentId) {\n      var variationName = variation(experimentId);\n      if (variationName) data[experimentId] = variationName;\n    });\n    fn(null, data);\n  });\n}\n"], ["hasMagic", "\nfunction hasMagic(pattern, options) {\n  \n  if (pattern instanceof RegExp) {\n    return {\n      match: function match(str) {\n        return pattern.test(str);\n      }\n    };\n  }\n\n  var minimatch = new _minimatch.Minimatch(pattern, options);\n  var set = minimatch.set;\n\n  if (set.length > 1) {\n    return minimatch;\n  }\n\n  for (var j = 0; j < set[0].length; j++) {\n    if (typeof set[0][j] !== 'string') {\n      return minimatch;\n    }\n  }\n\n  return false;\n}\n"], "```"]