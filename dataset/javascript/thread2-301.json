[["render", "\nfunction render(drizzleData) {\n  return Promise.all([\n    renderPages(drizzleData),\n    renderCollections(drizzleData)\n  ]).then(\n    allData => {\n      return {\n        data: drizzleData.data,\n        pages: allData[0],\n        patterns: allData[1],\n        templates: drizzleData.templates,\n        options: drizzleData.options,\n        tree: drizzleData.tree\n      };\n    },\n    error => DrizzleError.error(error, drizzleData.options.debug)\n  );\n}\n"], ["createKafkaConsumerAsync", "\nfunction createKafkaConsumerAsync(kafkaConfig) {\n    let topicConfig = {};\n    <configureTopic>\n    if ('default_topic_config' in kafkaConfig) {\n        topicConfig = kafkaConfig.default_topic_config;\n        delete kafkaConfig.default_topic_config;\n    }\n    </configureTopic>\n\n    <initializeConsumer>\n    const consumer = P.promisifyAll(\n        new kafka.KafkaConsumer(kafkaConfig, topicConfig)\n    );\n    </initializeConsumer>\n\n    <connectConsumer>\n    return consumer.connectAsync(undefined)\n    .thenReturn(consumer);\n    </connectConsumer>\n}\n"], ["flatMap", "\nfunction flatMap(iterator) {\n    \n    <handleEmptyArguments>\n    if (arguments.length === 0) {\n      return this;\n    }\n    </handleEmptyArguments>\n\n    var result = [],\n        length = this.length,\n        index;\n\n    <iterateAndMap>\n    for (index = 0; index < length; index++) {\n      var iteratorResult = iterator(this[index], index, this);\n\n      if (Array.isArray(iteratorResult)) {\n        result.push.apply(result, iteratorResult);\n      } else {\n        result.push(iteratorResult);\n      }\n    }\n    </iterateAndMap>\n\n    <finalizeResults>\n    return makeImmutableArray(result);\n    </finalizeResults>\n}\n"], ["enforceHeightRestriction", "\nfunction (height) {\n            \n            if (height !== undefined && height !== null && typeof(height) !== \"string\") {\n                \n                height = Math.min(17895697, height); \n                height += \"px\";\n            }\n\n            <applyRenderPolicy>\n            this._renderPolicyValue('height', height);\n            </applyRenderPolicy>\n}\n"], ["argumentsContainOptions", "\nfunction argumentsContainOptions (args) {\n  <checkArgsLength>\n  if (args.length < 2) { \n    return false\n  }\n  </checkArgsLength>\n\n  <checkLastArgForObject>\n  if (_.isPlainObject(args[args.length - 1])) { \n    <checkPreLastArg>\n    if (isClass(args[args.length - 2]) || _.isPlainObject(args[args.length - 2])) { \n      return true\n    }\n    </checkPreLastArg>\n  }\n  </checkLastArgForObject>\n\n  <defaultReturn>\n  return false\n  </defaultReturn>\n}\n"], ["indexKeys", "\nfunction indexKeys(target, pred) {\n  <provideDefaultPredicate>\n  pred = pred || has;\n  </provideDefaultPredicate>\n  var results = [];\n\n  <iterateAndIndex>\n  for (var i = 0, len = target.length; i < len; i += 1) {\n    if (pred(target, i)) {\n      results.push(String(i));\n    }\n  }\n  </iterateAndIndex>\n\n  <returnResults>\n  return results;\n  </returnResults>\n}\n"], ["extractAttributes", "\nfunction extractAttributes(attrSet) {\n\tvar reAttrName = /^[\\w\\-:\\$@]+\\.?$/;\n\n  <splitAndMapAttributes>\n\treturn splitAttributes(attrSet).map(function(attr) {\n      \n      <handleImplicitValue>\n\t\t\tif (reAttrName.test(attr)) {\n\t\t\t\tvar value = '';\n\t\t\t\tif (attr.charAt(attr.length - 1) == '.') {\n\t\t\t\t\t\n\t\t\t\t\tattr = attr.substr(0, attr.length - 1);\n\t\t\t\t\tvalue = attr;\n\t\t\t\t}\n\t\t\t\treturn {\n\t\t\t\t\tname: attr,\n\t\t\t\t\tvalue: value\n\t\t\t\t};\n      }\n      </handleImplicitValue>\n\n      <splitNameAndValue>\n\t\t\tif (~attr.indexOf('=')) {\n\t\t\t\tvar parts = attr.split('=');\n\t\t\t\treturn {\n\t\t\t\t\tname: parts.shift(),\n\t\t\t\t\tvalue: unquote(parts.join('='))\n\t\t\t\t};\n      }\n      </splitNameAndValue>\n\n      <handleDefaultAttribute>\n\t\t\treturn {\n\t\t\t\tname: DEFAULT_ATTR_NAME,\n\t\t\t\tvalue: unquote(attr)\n\t\t\t};\n    });\n    </handleDefaultAttribute>\n  </splitAndMapAttributes>\n}\n"], ["loadObject", "\nfunction loadObject(data, db, callback) {\n    <defaultCallback>\n    callback = callback || function() {};\n    </defaultCallback>\n\n    <iterateAndInsert>\n    var iterator = function(modelName, next){\n        insertCollection(modelName, data[modelName], db, next);\n    };\n    async.forEachSeries(Object.keys(data), iterator, callback);\n    </iterateAndInsert>\n}\n"], ["getDebugNamespaceColor", "\nfunction getDebugNamespaceColor (namespace) {\n  var type = getDebugNamespaceType(namespace);\n\n  <retrieveColor>\n  var color = settings.colors && settings.colors[type];\n  </retrieveColor>\n\n  <returnOrDefault>\n  return color || null;\n  </returnOrDefault>\n}\n"], ["compute", "\nfunction(compute, func, context) {\n\tvar observation = new Observation(func, context, compute);\n\tvar updater = compute.updater.bind(compute);\n\n  <handleNonProductionName>\n\tif(process.env.NODE_ENV !== 'production') {\n\t\tObject.defineProperty(updater,\"name\",{\n\t\t\tvalue: canReflect.getName(compute) + \".updater\",\n\t\t});\n\t}\n  </handleNonProductionName>\n\t\n\tcompute.observation = observation;\n\treturn {\n\t\t\n    <onObserver>\n\t\t_on: function() {\n\t\t\tcanReflect.onValue( observation, updater,\"notify\");\n\t\t\tif (observation.hasOwnProperty(\"_value\")) {\n\t\t\t\tcompute.value = observation._value;\n\t\t\t} else {\n\t\t\t\tcompute.value = observation.value;\n\t\t\t}\n\t\t},\n    </onObserver>\n    \n    <offObserver>\n\t\t_off: function() {\n\t\t\tcanReflect.offValue( observation, updater,\"notify\");\n\t\t},\n    </offObserver>\n\n    <getObservationDepth>\n\t\tgetDepth: function() {\n\t\t\treturn observation.getDepth();\n\t\t}\n    </getObservationDepth>\n\t};\n}\n"], "```"]