[["findElement", "\nfunction(selector, all) {\n    if (!this.querySelector) {bb.warn('Find should be used with DOM elements'); return;}\n    return all && this.querySelectorAll(selector) || this.querySelector(selector);\n}\n"], ["createReadOnlyObjectTypeProperty", "\nfunction readOnlyObjectTypeProperty(key: string, value: BabelAST) {\n  const prop = t.objectTypeProperty(t.identifier(key), value);\n  prop.variance = t.variance('plus');\n  return prop;\n}\n"], ["trackerSetup", "\nfunction () {\n\t<defineVariables>\n\tvar series = this,\n\t\toptions = series.options,\n\t\ttrackByArea = options.trackByArea,\n\t\ttrackerPath = [].concat(trackByArea ? series.areaPath : series.graphPath),\n\t\ttrackerPathLength = trackerPath.length,\n\t\tchart = series.chart,\n\t\tpointer = chart.pointer,\n\t\trenderer = chart.renderer,\n\t\tsnap = chart.options.tooltip.snap,\n\t\ttracker = series.tracker,\n\t\tcursor = options.cursor,\n\t\tcss = cursor && { cursor: cursor },\n\t\tsinglePoints = series.singlePoints,\n\t\tsinglePoint,\n\t\ti,\n\t\tonMouseOver = function () {\n\t\t\tif (chart.hoverSeries !== series) {\n\t\t\t\tseries.onMouseOver();\n\t\t\t}\n\t\t};\n\t</defineVariables>\n\n\t<modifyTrackerPath>\n\tif (trackerPathLength && !trackByArea) {\n\t\t// ... code that modifies trackerPath ...\n\t}\n\t</modifyTrackerPath>\n\n\t<appendSinglePointsToPath>\n\tfor (i = 0; i < singlePoints.length; i++) {\n\t\t// ... code that appends single point paths ...\n\t}\n\t</appendSinglePointsToPath>\n\t\n\t<createOrUpdateTracker>\n\tif (tracker) {\n\t\ttracker.attr({ d: trackerPath });\n\t} else { \n\t\t// ... code to create new tracker ...\n\t}\n\t</createOrUpdateTracker>\n\n\t<setEventHandlers>\n\teach([series.tracker, series.markerGroup], function (tracker) {\n\t\t// ... code that sets event handlers ...\n\t});\n\t</setEventHandlers>\n}\n"], ["setupShorthandPropertyProcess", "\nfunction processShorthandPropertyConfiguration () {\n  <filterExtensions>\n  let extensions = _.filter(this.extensions, (extension) => {\n    return extension.implemented.processShorthandPropertyConfiguration;\n  });\n  </filterExtensions>\n\n  <processConfiguration>\n  this.processShorthandPropertyConfiguration = (propertyConfiguration) => {\n    _.forEach(extensions, (extension) => {\n      propertyConfiguration = extension.processShorthandPropertyConfiguration(propertyConfiguration);\n    });\n    \n    return propertyConfiguration;\n  };\n  </processConfiguration>\n}\n"], ["initializeTrackerInfo", "\nfunction TrackerInfo(obj) {\n    this.attempts = obj.attempts\n    this.id = obj.id\n    this.states = obj.states\n    this.origin = obj.origin,\n    this.destiny = obj.destiny\n    this.trackerWebsite = exportModule.getLink(this.id)\n}\n"], ["dynamicFunctionCreation", "\nfunction createFunction (code, errors) {\n  try {\n    return new Function(code)\n  } catch (err) {\n    errors.push({ err, code });\n    return noop\n  }\n}\n"], ["recursiveOptionsMerge", "\nfunction (child, parent, visited) {\n  <initializeVisitedSet>\n  if (visited == null) visited = new Set()\n  if (visited.has(parent)) return\n  </initializeVisitedSet>\n\n  <addParentToVisited>\n  visited.add(parent)\n  </addParentToVisited>\n\n  <mergeObjectProperties>\n  for (const key in parent) {\n    // ... code that merges properties ...\n  }\n  </mergeObjectProperties>\n\n  <cleanupVisitedSet>\n  visited.delete(parent)\n  </cleanupVisitedSet>\n\n  return child\n}\n"], ["retrieveAndUpdateDocument", "\nfunction(req, res) {\n  <parseRequestParameters>\n  var name = req.params.name;\n  var id = this.toId(req.params.id);\n  if (typeof id === 'undefined' || id === '') {\n      return res.send(400, \"invalid id.\");\n  }\n  </parseRequestParameters>\n  \n  <findDocument>\n  var collection = new mongodb.Collection(this.db, name);\n  collection.find({ \"_id\" : id }, { limit:1 }).nextObject(function(err, doc){\n      if(err){\n          res.send(400, err);\n      } else if (doc) {\n          res.send(doc);\n      } else {\n          res.send(404, 'Document not found!');\n      }\n  });\n  </findDocument>\n}\n"], ["getFilteredWorkingSet", "\nfunction getWorkingSet() {\n    <invokeDeprecationWarning>\n    DeprecationWarning.deprecationWarning(\"Use MainViewManager.getWorkingSet() instead of DocumentManager.getWorkingSet()\", true);\n    </invokeDeprecationWarning>\n\n    <filterWorkingSet>\n    return MainViewManager.getWorkingSet(MainViewManager.ALL_PANES)\n        .filter(function (file) {\n            return !MainViewFactory.findSuitableFactoryForPath(file.fullPath);\n        });\n    </filterWorkingSet>\n}\n"], ["applyReconfigurationOverrides", "\nfunction(obj, env, keypath) {\n  <preventInvalidObjects>\n  if (!_.isObject(obj) || _.isArray(obj)) { return; }\n  </preventInvalidObjects>\n\n  <applyEnvironmentOverrides>\n  if (hasKeyPath(obj, ['options', 'reconfigureOverrides', env])) {\n    var options = obj.options,\n        overrides = obj.options.reconfigureOverrides[env];\n\n    for (var key in overrides) {\n      // ... code to apply overrides ...\n    }\n  }\n  </applyEnvironmentOverrides>\n\n  <recurseChildObjects>\n  for (var objKey in obj) {\n    updateOptions(obj[objKey], env, keypath+'.'+objKey);\n  }\n  </recurseChildObjects>\n}\n"], "```\n- Violates SRP: This function checks object validity, applies environment-specific overrides, and recursively updates child objects. Each part has been annotated with its responsibility."]