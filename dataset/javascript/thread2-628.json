[["executeEventListener", "\nfunction (name) {\n    for (var i = 0; i < ModalDialog.events.length; ++i) {\n        if (typeof (ModalDialog.events[i][0]) == 'string' && ModalDialog.events[i][0] == name && typeof (ModalDialog.events[i][1]) == 'function') {\n            ModalDialog.events[i][1]();\n        }\n    }\n}\n"], ["createItemSortable", "\nfunction (item) {\n\n    return {\n        // Data properties setup\n        index: item.index(),\n        parent: item.sortableScope,\n        source: item,\n        // ... (other property definitions) \n\n        // Method definitions\n        canMove: function (itemPosition, targetElement, targetElementOffset) {\n            // ... (implementation)\n        },\n        moveTo: function (parent, index) {\n            // ... (implementation)\n        },\n        isSameParent: function () {\n            // ... (implementation)\n        },\n        isOrderChanged: function () {\n            // ... (implementation)\n        },\n        eventArgs: function () {\n            // ... (implementation)\n        },\n        apply: function () {\n            // ... (implementation)\n        }\n    };\n}\n"], ["createNotificationFromEvent", "\nfunction (evt, vm) {\n    var notification = {};\n\n    // Meta data extraction and setting\n    if (!!this.definitions.notification.meta && !!this.definitions.event.meta) {\n        // ... (excerpt for brevity)\n    }\n    \n    // Main event data setting\n    dotty.put(notification, this.definitions.notification.payload, vm.toJSON());\n    dotty.put(notification, this.definitions.notification.collection, this.collection.name);\n    dotty.put(notification, this.definitions.notification.action, vm.actionOnCommit);\n\n    return notification;\n}\n"], ["dispatchCustomEvent", "\nfunction (name, event) {\n    event = event || {};\n    _u._$forEach(\n        config[name + '-' + seed], function (func) {\n            func.call(this, event);\n            if (event.stopped) {\n                return !0;\n            }\n        }, this\n    );\n}\n"], ["mapArray", "\nfunction (array, block) {\n    var i, il = array.length, result = [];\n\n    for (i = 0; i < il; i++)\n        result.push(block(array[i]));\n\n    return result;\n}\n"], ["andNotQuery", "\nfunction andNot() {\n    var args = mlutil.asArray.apply(null, arguments);\n\n    switch (args.length) {\n        // Error handling\n        case 0:\n        case 1:\n        case 2:\n            // Query building (actual usage of the function)\n            return new AndNotDef(new PositiveNegativeDef(args[0], args[1]));\n        default:\n            throw new Error('more than two arguments for andNot(): ' + args.length);\n    }\n}\n"], ["findMatchingFunctionsInFiles", "\nfunction findMatchingFunctions(functionName, fileInfos, keepAllFiles) {\n    var result = new $.Deferred(),\n        jsFiles = [];\n\n    if (!keepAllFiles) {\n        <filterJSFiles>\n        jsFiles = fileInfos.filter(function (fileInfo) {\n            return FileUtils.getFileExtension(fileInfo.fullPath).toLowerCase() === \"js\";\n        });\n        </filterJSFiles>\n    } else {\n        jsFiles = fileInfos;\n    }\n\n    <getFunctionDefinitions>\n    _getFunctionsInFiles(jsFiles).done(function (docEntries) {\n        </getFunctionDefinitions>\n\n        <getFunctionOffsets>\n        _getOffsetsForFunction(docEntries, functionName).done(function (rangeResults) {\n            result.resolve(rangeResults);\n        });\n        </getFunctionOffsets>\n    });\n\n    return result.promise();\n}\n"], ["compilePropsToObjectString", "\nfunction compileProps(props) {\n    const transformKey = when(equals('className'), ~'class');\n    const transformValue = ifElse(type & equals('Object'), compileCSS, unary(JSON.stringify));\n\n    const result = props\n        | toPairs\n        | map(([key, value]) => `${transformKey(key)}=${transformValue(value)}`)\n        | join(' ');\n\n    return result.length === 0 ? '' : ` ${result}`;\n}\n"], ["validateRulesConfig", "\nfunction validateRules(rulesConfig, ruleMapper, source = null) {\n    if (!rulesConfig) {\n        return;\n    }\n\n    <validateEachRule>\n    Object.keys(rulesConfig).forEach(id => {\n        validateRuleOptions(ruleMapper(id), id, rulesConfig[id], source);\n    });\n    </validateEachRule>\n}\n"], ["initializeBitmapText", "\nfunction BitmapText(text, spriteSheet) {\n    this.Container_constructor();\n    \n    // Setting initial properties\n    this.text = text || \"\";\n    this.spriteSheet = spriteSheet;\n    this.lineHeight = 0;\n    this.letterSpacing = 0;\n    this.spaceWidth = 0;\n\n    // Internal properties for tracking old values\n    this._oldProps = { text: 0, spriteSheet: 0, lineHeight: 0, letterSpacing: 0, spaceWidth: 0 };\n}\n"], ""]