[["updateIndivisibleOutputsThatWereReceivedUnstable", "\nfunction updateIndivisibleOutputsThatWereReceivedUnstable(conn, onDone){\n\n\t<updateOutputProps>\n\tfunction updateOutputProps(unit, is_serial, onUpdated){\n\t\t\n\t\tconn.query(\n\t\t\t\"UPDATE outputs SET is_serial=? WHERE unit=?\", \n\t\t\t[is_serial, unit],\n\t\t\tfunction(){\n\t\t\t\tis_serial ? updateInputUniqueness(unit, onUpdated) : onUpdated();\n\t\t\t}\n\t\t);\n\t}\n\t</updateOutputProps>\n\t\n\t<updateInputUniqueness>\n\tfunction updateInputUniqueness(unit, onUpdated){\n\t\t\n\t\tconn.query(\"UPDATE inputs SET is_unique=1 WHERE unit=?\", [unit], function(){\n\t\t\tonUpdated();\n\t\t});\n\t}\n\t</updateInputUniqueness>\n\t\n\tconsole.log(\"updatePrivateIndivisibleOutputsThatWereReceivedUnstable starting\");\n\tconn.query(\n\t\t\"SELECT unit, message_index, sequence FROM outputs \"+\n\t\t(conf.storage === 'sqlite' ? \"INDEXED BY outputsIsSerial\" : \"\")+\n\t\t\" JOIN units USING(unit) WHERE outputs.is_serial IS NULL AND units.is_stable=1 AND is_spent=0\", \n\t\tfunction(rows){\n\t\t\tif (rows.length === 0)\n\t\t\t\treturn onDone();\n\t\t\tasync.eachSeries(\n\t\t\t\trows,\n\t\t\t\tfunction(row, cb){\n\t\t\t\t\t\n\t\t\t\t\t<updateFinalOutputProps>\n\t\t\t\t\tfunction updateFinalOutputProps(is_serial){\n\t\t\t\t\t\tupdateOutputProps(row.unit, is_serial, cb);\n\t\t\t\t\t}\n\t\t\t\t\t</updateFinalOutputProps>\n\t\t\t\t\t\n\t\t\t\t\t<goUp>\n\t\t\t\t\tfunction goUp(unit, message_index){\n\t\t\t\t\t\t\n\t\t\t\t\t\tconn.query(\n\t\t\t\t\t\t\t\"SELECT src_unit, src_message_index, src_output_index \"+\n\t\t\t\t\t\t\t\"FROM inputs WHERE unit=? AND message_index=?\", \n\t\t\t\t\t\t\t[unit, message_index],\n\t\t\t\t\t\t\tfunction(src_rows){\n\t\t\t\t\t\t\t\tif (src_rows.length === 0)\n\t\t\t\t\t\t\t\t\tthrow Error(\"updating unstable: blackbyte input not found\");\n\t\t\t\t\t\t\t\tif (src_rows.length > 1)\n\t\t\t\t\t\t\t\t\tthrow Error(\"updating unstable: more than one input found\");\n\t\t\t\t\t\t\t\tvar src_row = src_rows[0];\n\t\t\t\t\t\t\t\tif (src_row.src_unit === null) \n\t\t\t\t\t\t\t\t\treturn cb();\n\t\t\t\t\t\t\t\tconn.query(\n\t\t\t\t\t\t\t\t\t\"SELECT sequence, is_stable, is_serial FROM outputs JOIN units USING(unit) \"+\n\t\t\t\t\t\t\t\t\t\"WHERE unit=? AND message_index=? AND output_index=?\", \n\t\t\t\t\t\t\t\t\t[src_row.src_unit, src_row.src_message_index, src_row.src_output_index],\n\t\t\t\t\t\t\t\t\tfunction(prev_rows){\n\t\t\t\t\t\t\t\t\t\tif (prev_rows.length === 0)\n\t\t\t\t\t\t\t\t\t\t\tthrow Error(\"src unit not found\");\n\t\t\t\t\t\t\t\t\t\tvar prev_output = prev_rows[0];\n\t\t\t\t\t\t\t\t\t\tif (prev_output.is_serial === 0)\n\t\t\t\t\t\t\t\t\t\t\tthrow Error(\"prev is already nonserial\");\n\t\t\t\t\t\t\t\t\t\tif (prev_output.is_stable === 0)\n\t\t\t\t\t\t\t\t\t\t\tthrow Error(\"prev is not stable\");\n\t\t\t\t\t\t\t\t\t\tif (prev_output.is_serial === 1 && prev_output.sequence !== 'good')\n\t\t\t\t\t\t\t\t\t\t\tthrow Error(\"prev is_serial=1 but seq!=good\");\n\t\t\t\t\t\t\t\t\t\tif (prev_output.is_serial === 1) \n\t\t\t\t\t\t\t\t\t\t\treturn cb();\n\t\t\t\t\t\t\t\t\t\tvar is_serial = (prev_output.sequence === 'good') ? 1 : 0;\n\t\t\t\t\t\t\t\t\t\tupdateOutputProps(src_row.src_unit, is_serial, function(){\n\t\t\t\t\t\t\t\t\t\t\tif (!is_serial) \n\t\t\t\t\t\t\t\t\t\t\t\treturn updateFinalOutputProps(0);\n\t\t\t\t\t\t\t\t\t\t\tgoUp(src_row.src_unit, src_row.src_message_index);\n\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\t</goUp>\n\t\t\t\t\t\n\t\t\t\t\tvar is_serial = (row.sequence === 'good') ? 1 : 0;\n\t\t\t\t\tupdateOutputProps(row.unit, is_serial, function(){\n\t\t\t\t\t\tgoUp(row.unit, row.message_index);\n\t\t\t\t\t});\n\t\t\t\t},\n\t\t\t\tonDone\n\t\t\t);\n\t\t}\n\t);\n}\n"], ["validated", "\nfunction validated(invalid){\n    if (invalid) { return callback(invalid) }\n    <coerceData>\n    if(options.coerce){crudUtils.coerceData(options,coerced())}\n    else{coerced(null,options.data)}\n    </coerceData>\n}\n"], ["Eth", "\nfunction Eth(cprovider, options) {\n  if (!(this instanceof Eth)) { \n  \t<throwError>\n  \tthrow new Error('[ethjs] the Eth object requires you construct it with the \"new\" flag (i.e. `const eth = new Eth(...);`).');\n  \t</throwError>\n  }\n  <setup>\n  const self = this;\n  self.options = options || {};\n  const query = new EthQuery(cprovider, self.options.query);\n  Object.keys(Object.getPrototypeOf(query)).forEach((methodName) => {\n    self[methodName] = (...args) => query[methodName].apply(query, args);\n  });\n  self.filter = new EthFilter(query, self.options.query);\n  self.contract = new EthContract(query, self.options.query);\n  self.currentProvider = query.rpc.currentProvider;\n  self.setProvider = query.setProvider;\n  self.getTransactionSuccess = getTransactionSuccess(self);\n  </setup>\n}\n"], ["validateName", "\nfunction validateName(node) {\n\t<nameValidation>\n    const name = node.key.name;\n    const accessibility = node.accessibility || \"public\";\n    const convention = conventions[accessibility];\n\n    if (!convention || convention.test(name)) return;\n\n    context.report({\n        node: node.key,\n        message:\n            \"{{accessibility}} property {{name}} should match {{convention}}.\",\n        data: { accessibility, name, convention },\n    });\n    </nameValidation>\n}\n"], ["CronPattern", "\nfunction CronPattern (pattern) {\n\t<thisPattern>\n\tthis.pattern = pattern;\n\n\tthis.seconds        = fill(Array(60),0); \n\tthis.minutes        = fill(Array(60),0); \n\tthis.hours          = fill(Array(24),0); \n\tthis.days           = fill(Array(31),0); \n\tthis.months         = fill(Array(12),0); \n\tthis.daysOfWeek     = fill(Array(8),0); \n\t</thisPattern>\n\n\t<parse>\n\tthis.parse();\n\t</parse>\n}\n"], ["getInitialModel", "\nfunction getInitialModel(routeInfo, page) {\n\t<initModelDeps>\n\tvar initModelDeps = {\n\t\tappName:    routeInfo.appName,\n\t\ttokens:     routeInfo.tokens,\n\t\trouteInfo:  routeInfo,\n\t\tdefaults:   page.defaults,\n\t\tactiveUser: routeInfo.activeUser || {},\n\t\tcurrentScope: {}\n\t};\n\t</initModelDeps>\n\n\t\n\t<returnModel>\n\tif (!page.model) {\n\t\treturn Q.when({});\n\t}\n    \n\telse if (_.isFunction(page.model)) {\n\t\treturn Q.when(injector.loadModule(page.model, null, { dependencies: initModelDeps }));\n\t}\n\telse {\n\t\tthrow new Error(routeInfo.name + ' page invalid model() format: ' + page.model);\n\t}\n\t</returnModel>\n}\n"], ["anonymous-function", "\nfunction( minx, miny, maxx, maxy ) {\n\t<BoundingBoxCalculation>\n\tvar bbox = '';\n\tif ( this.version === '1.3.0' ) {\n\t\tbbox = [minx, miny, maxx, maxy].join( ',' );\n\t} else {\n\t\tbbox = [miny, minx, maxy, maxx].join( ',' );\n\t}\n\treturn bbox;\n\t</BoundingBoxCalculation>\n}\n"], ["torqueDemo_lis", "\nfunction torqueDemo_lis(KMRotState){\n\t<torqueDemoUpdate>\n    let stepInterval=Math.PI/4;\n    let diff=torqueDemo_pos_sep-KMRotState.position;\n    if(diff>stepInterval||diff< -stepInterval){\n        torqueDemo_pos_sep=KMRotState.position;\n        torqueDemo_set_torque+=(diff>0?0.005:-0.005);\n        torqueDemo_set_torque=torqueDemo_set_torque>0.2?0.2:torqueDemo_set_torque;\n        if(torqueDemo_revlocksw){\n          KMB.cmdMoveToPosition(torqueDemo_pos_sep);\n        }\n        KMB.cmdMaxTorque(torqueDemo_set_torque);\n        $(\"#torqueDemoInfo\").text(\"Now Torque: \"+torqueDemo_set_torque);\n    }\n    console.log(\"torqueDemo_set_torque:\"+torqueDemo_set_torque);\n    </torqueDemoUpdate>\n}\n"], ["throwError-function", "\nfunction (format) {\n\t<throwError>  \n\tthrow new Error(index$1.red('[indian-ocean] You passed in an object but converting to ' + index$1.bold(format) + ' requires a list of objects.') + index$1.cyan('\\nIf you would like to write a one-row csv, put your object in a list like so: `' + index$1.bold('[data]') + '`\\n'));\n\t</throwError>\n}\n"], ["sortByFileFormat", "\nfunction sortByFileFormat(srcDir, format) {\n  <directorySetup>\n  const initialFiles = `${srcDir}/*.${format}`\n  const files = glob.sync(initialFiles);\n  const dest = `${srcDir}/${format}`;\n  let count = 0;\n\n  createDirs([dest]);\n  </directorySetup>\n\n  \n  <fileRenaming>\n  const promises = files.map(f => {\n    return new Promise((resolve, reject) => {\n      const filename = sanitize(path.basename(f));\n      const reg = /[\\w-]+-(16|24|32)\\.[\\w]+/;\n      const match = filename.match(reg);\n      let thisDest = dest;\n\n      if (match) {\n        const size = match[1];\n        thisDest = `${thisDest}/${size}`;\n        createDirs([thisDest]);\n      }\n\n      fs.rename(f, `${thisDest}/${filename}`, err => {\n        if (err) {\n          reject(err);\n        }\n        count++;\n        resolve(`${dest}/${filename}`);\n      });\n    });\n  });\n  </fileRenaming>\n\n  <completionProcess>\n  return Promise.all(promises).then(() => {\n    swlog.logTaskAction('Moved', `${count}/${files.length} ${format.toUpperCase()} files`);\n  });\n  </completionProcess>\n}\n"], ""]