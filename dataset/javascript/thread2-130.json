[["function1", "\nfunction (number) {\n        var q = $q.defer();\n        $window.push.setApplicationIconBadgeNumber(function () {\n          q.resolve();\n        }, number);\n        return q.promise;\n}\n"], ["function2", "\nfunction(key, sig, log) {\n\tgui.Broadcast.$target = this;\n\tgui.Broadcast.dispatchGlobal(edb.BROADCAST_SCRIPT_INVOKE, {\n\t\tkey: key,\n\t\tsig: sig,\n\t\tlog: log\n\t});\n}\n"], ["startTagInColumnGroup", "\nfunction startTagInColumnGroup(p, token) {\n    var tn = token.tagName;\n\n    <DetermineAppropriateAction>\n    if (tn === $.HTML)\n        startTagInBody(p, token);\n    else if (tn === $.COL)\n        p._appendElement(token, NS.HTML);\n    else if (tn === $.TEMPLATE)\n        startTagInHead(p, token);\n    else\n        tokenInColumnGroup(p, token);\n    </DetermineAppropriateAction>\n}\n"], ["function4", "\nfunction( world ){\n    var intg = world.integrator();\n\n    <CheckIntegratorCompatibility>\n    if (intg && intg.name.indexOf('verlet') < 0){\n        throw 'The rigid constraint manager needs a world with a \"verlet\" compatible integrator.';\n    }\n    </CheckIntegratorCompatibility>\n\n    world.on('integrate:positions', this.resolve, this);\n}\n"], ["function5", "\nfunction( source ) {\n\tvar obj = {},\n\t\tname;\n\n\t<CopyProperties>\n\tfor ( name in source )\n\t\tobj[ name ] = source[ name ];\n\t</CopyProperties>\n\n\treturn obj;\n}\n"], ["function6", "\nfunction(input, callback) {\n            \n    var md, line = null, length = 0;\n\n    <ParseInput>\n    for(;;) {\n        if((md = input.match(this.lineRE))) {\n            if(line && line.indexOf('QUOTED-PRINTABLE') != -1 && line.slice(-1) == '=') {\n                line = line.slice(0,-1) + md[1];\n                length = md[0].length;\n            } else {\n                if(line) {\n                    this.lexLine(line, callback);   \n                }\n                line = md[1];\n                length = md[0].length;\n            }\n        } else if((md = input.match(this.foldedLineRE))) {\n            if(line) {\n                line += md[1];\n                length = md[0].length;\n            } else {\n                \n            }\n        } else {\n            console.error(\"Unmatched line: \" + line);\n        }\n        \n        input = input.slice(length);\n\n        if(! input) {\n            break;\n        }\n    }\n    </ParseInput>\n\n    <FinalLineProcessing>\n    if(line) {\n        \n        this.lexLine(line, callback);\n    }\n    \n    line = null;\n    </FinalLineProcessing>\n}\n"], ["filterFolder", "\nfunction filterFolder(posts) {\n    var reFolder = new RegExp(folder);\n    return posts.filter(function filterPosts(post) {\n        return reFolder.test(post.source.substr(0, post.source.lastIndexOf(path.sep)));\n    });\n}\n"], ["function8", "\nfunction(raw_blocks) {\n\tvar result = this.asBlocks(this.compileTemplate(raw_blocks));\n\tif (result.length != 1) Lava.t(\"Expected: exactly one view, got either several or none.\");\n\tif (result[0].type != 'view' && result[0].type != 'widget') Lava.t(\"Expected: view, got: \" + result[0].type);\n\treturn result[0];\n}\n"], ["function9", "\nfunction( fn ){\n    var _p = this._private;\n    var pass = _p.pass[0];\n\n    return this.map( fn ).then(function( include ){\n        var ret = [];\n\n        <CompileResults>\n        for( var i = 0; i < pass.length; i++ ){\n            var datum = pass[i];\n            var incDatum = include[i];\n\n            if( incDatum ){\n                ret.push( datum );\n            }\n        }\n        </CompileResults>\n\n        return ret;\n    });\n}\n"], ["loadTMXLevel", "\nfunction loadTMXLevel(levelId, container, flatten, setViewportBounds) {\n    var level = levels[levelId];\n\n    <InitializeContainer>\n    var autoSort = container.autoSort;\n    container.autoSort = false;\n\n    var levelBounds = level.getBounds();\n\n    if (setViewportBounds) {\n        \n        me.game.viewport.setBounds(\n            0, 0,\n            Math.max(levelBounds.width, me.game.viewport.width),\n            Math.max(levelBounds.height, me.game.viewport.height)\n        );\n    }\n    </InitializeContainer>\n\n    <AddLevelToContainer>\n    me.utils.resetGUID(levelId, level.nextobjectid);\n    container.anchorPoint.set(0, 0);\n    level.addTo(container, flatten);\n    container.sort(true);\n    container.autoSort = autoSort;\n    container.resize(levelBounds.width, levelBounds.height);\n    </AddLevelToContainer>\n\n    <SetContainerPosition>\n    function resize_container() {\n        \n        container.pos.set(\n            Math.max(0, ~~((me.game.viewport.width - levelBounds.width) / 2)),\n            Math.max(0, ~~((me.game.viewport.height - levelBounds.height) / 2)),\n            0\n        );\n    }\n    </SetContainerPosition>\n\n    <AdjustViewport>\n    if (setViewportBounds) {\n        resize_container();\n\n        \n        if (onresize_handler) {\n            me.event.unsubscribe(onresize_handler);\n        }\n        onresize_handler = me.event.subscribe(me.event.VIEWPORT_ONRESIZE, resize_container);\n    }\n    </AdjustViewport>\n}\n"], ""]