[["fetchAncestor", "\nfunction fetchAncestor(type, ids, includePath, req) {\n    return router.actions[\"get\" + util.toCapitalisedCamelCase(type)](ids, {include: includePath, parentRequest: req});\n}\n"], ["handlePlaceholder", "\nfunction () {\n    if (!_placeholderSupported && this._cfg.placeholder) {\n        var element = this._domElt;\n        if (element.value === \"\") {\n            element.value = this._cfg.placeholder;\n            var cssClass = new aria.utils.ClassList(element);\n            cssClass.add('placeholder');\n            cssClass.$dispose();\n            if (this._hasFocus) {\n                ariaUtilsCaret.setPosition(element, 0, 0);\n            }\n            this._hasPlaceholder = true;\n            this._domElt.unselectable = \"on\";\n        }\n    }\n}\n"], ["re_basicSortRows", "\nfunction re_basicSortRows(field, sortType) {\n  <initializeRows>\n  var oThis = this,\n      groupField = this.gridComp.options.groupField;\n  if (!field) {\n      this.rows = new Array();\n      this.groupRows = new Array();\n      if (this.options.values) {\n          $.each(this.options.values, function (i) {\n              var rowObj = {};\n              rowObj.value = this;\n              rowObj.valueIndex = i;\n              oThis.rows.push(rowObj);\n              oThis.addOneRowGroup(rowObj);\n              oThis.rows = oThis.getGroupRows();\n          });\n      }\n      return;\n  }\n  </initializeRows>\n  <sortLogic>\n  if (groupField && field && groupField != field) {\n      oThis.rows = [];\n      $.each(this.groupRows, function () {\n          var nowGroup = this;\n          nowGroup.rows.sort(oThis.gridComp.SortByFun(field, sortType));\n          oThis.rows = oThis.rows.concat(nowGroup.rows);\n      });\n  } else {\n      this.rows.sort(this.gridComp.SortByFun(field, sortType));\n  }\n  </sortLogic>\n}\n"], ["compareStringCH", "\nfunction compareStringCH(x, y) {\n  <parametersDefaulting>\n  var isAsc = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n  var spC = arguments[3];\n  var spC2 = arguments[4];\n  var spV = arguments[5];\n  </parametersDefaulting>\n  <convertToPinyinAndCompare>\n  if (__WEBPACK_IMPORTED_MODULE_0__core__[\"a\" ].GB2312Pinyin.fonts) {\n    x = x == null || x === '' ? '' : __WEBPACK_IMPORTED_MODULE_1__regexp__[\"chFirst\"].test(x) ? getGB2312Pinyin(getFirstChar(x)) : getFirstChar(x);\n    y = y == null || y === '' ? '' : __WEBPACK_IMPORTED_MODULE_1__regexp__[\"chFirst\"].test(y) ? getGB2312Pinyin(getFirstChar(y)) : getFirstChar(y);\n    return compare(x, y, isAsc, spC, spC2, spV);\n  } else {\n    return compareStringEN(x, y, isAsc, spC, spC2, spV);\n  }\n  </convertToPinyinAndCompare>\n}\n"], ["multiplyByInverse", "\nfunction multiplyByInverse(node) {\n  <extractDenominator>\n  let denominator = node.args[1];\n  if (Node.Type.isParenthesis(denominator)) {\n    denominator = denominator.content;\n  }\n  if (!Node.Type.isOperator(denominator) || denominator.op !== '/') {\n    return Node.Status.noChange(node);\n  }\n  </extractDenominator>\n  \n  <createInverseAndNewNode>\n  const inverseNumerator = denominator.args[1];\n  const inverseDenominator = denominator.args[0];\n  const inverseFraction = Node.Creator.operator('/', [inverseNumerator, inverseDenominator]);\n\n  const newNode = Node.Creator.operator('*', [node.args[0], inverseFraction]);\n  return Node.Status.nodeChanged(ChangeTypes.MULTIPLY_BY_INVERSE, node, newNode);\n  </createInverseAndNewNode>\n}\n"], ["setupClient", "\nfunction(id, socket) {\n  EventEmitter.call(this);\n  this.id = id;\n  this.socket = socket;\n  <initializeRemoteAddress>\n  this.remoteAddress = {\n    ip: socket.handshake.address.address,\n    port: socket.handshake.address.port\n  };\n  </initializeRemoteAddress>\n\n  <socketEventHandlers>\n  var self = this;\n\n  socket.on('disconnect', this.emit.bind(this, 'disconnect'));\n\n  socket.on('error', this.emit.bind(this, 'error'));\n\n  socket.on('message', function(msg) {\n    self.emit('message', msg);\n  });\n  </socketEventHandlers>\n  \n  this.state = ST_INITED;\n}\n"], ["getNotIncrementedTopicPayloads", "\nfunction getNotIncrementedTopicPayloads(previousConsumerReadOffset, consumer) {\n    let notIncrementedTopicPayloads = consumer.topicPayloads.filter((topicPayload) => {\n        <compareOffsets>\n        let {topic, partition, offset: currentOffset} = topicPayload;\n        let previousTopicPayloadForPartition = _.find(previousConsumerReadOffset, {topic, partition});\n        return previousTopicPayloadForPartition && currentOffset === previousTopicPayloadForPartition.offset;\n        </compareOffsets>\n    });\n\n    return notIncrementedTopicPayloads;\n}\n"], ["updateAnnotationPosition", "\nfunction() {\n  var elem = $(this);\n  var data = window.kelmu.data[id];\n  data.selectedElementNumber = parseInt(elem.attr('data-annotation'), 10);\n  var elemData = data.definitions['step' + data.stepNumber][data.subStepNumber][data.selectedElementNumber];\n  <setElementData>\n  elemData.top = parseFloat(elem.css('top'));\n  elemData.left = parseFloat(elem.css('left'));\n\n  if (elem.hasClass('kelmu-annotation')) {\n    elemData.height = elem.height();\n    elemData.width = elem.width();\n  }\n  </setElementData>\n}\n"], ["defineModule", "\nfunction(id, deps, factory, _special) {\n    define(id, deps, factory, _special || USED_AS_TRANSPORT);\n}\n"], ["axisCenteredPositionProperties", "\nfunction axisCenteredPositionProperties(options) {\n  <calculateCenteringOffsets>\n  const { oDim, wDim } = options;\n  const { center, leftOffset, rightOffset } = centeringProperties(options);\n  if (leftOffset > 0 || rightOffset > 0) {\n    \n    if (leftOffset < rightOffset) {\n      return { offset: rightOffset, position: wDim - oDim };\n    }\n    \n    if (rightOffset < leftOffset) {\n      return { offset: -leftOffset, position: 0 };\n    }\n  }\n  </calculateCenteringOffsets>\n  \n  return { offset: 0, position: center - oDim / 2 };\n}\n"], "```"]