[["buildBody", "\nfunction buildBody({lineDescriptor, timeseriesesByRange}, descriptorFlags,\n    revisionInfo) {\n  \n  <getDescriptorParts>\n  const descriptorParts = getDescriptorParts(lineDescriptor, descriptorFlags);\n  </getDescriptorParts>\n\n  <stringifyDescriptor>\n  const descriptor = ChartTimeseries.stringifyDescriptor(lineDescriptor);\n  </stringifyDescriptor>\n\n  <initializeRows>\n  const scalarRowsByLabel = new Map();\n  const linkRowsByLabel = new Map();\n  const columnCount = timeseriesesByRange.length;\n  </initializeRows>\n\n  <buildCells>\n  for (const [columnIndex, {range, timeserieses}] of enumerate(\n      timeseriesesByRange)) {\n    const setScalar = (rowLabel, value, unit) => setCell(\n        scalarRowsByLabel, rowLabel, columnCount, columnIndex, {value, unit});\n    const setLink = (rowLabel, href, label) => setCell(\n        linkRowsByLabel, rowLabel, columnCount, columnIndex, {href, label});\n\n    DetailsTable.buildCell(setLink, setScalar, timeserieses, range,\n        revisionInfo);\n  }\n  </buildCells>\n\n  <collectRows>\n  const scalarRows = collectRowsByLabel(scalarRowsByLabel);\n  const linkRows = collectRowsByLabel(linkRowsByLabel);\n  </collectRows>\n\n  return {descriptor, descriptorParts, scalarRows, linkRows};\n}\n"], ["anonymousFunction", "\nfunction (i) {\n      return function (e) {\n        \n        <checkDisabled>\n        if (this.props.disabled) return;\n        </checkDisabled>\n\n        <getMousePosition>\n        var position = this._getMousePosition(e);\n        </getMousePosition>\n\n        <startInteraction>\n        this._start(i, position[0]);\n        </startInteraction>\n\n        <addHandlers>\n        this._addHandlers(this._getMouseEventMap());\n        </addHandlers>\n\n        <pauseEvent>\n        pauseEvent(e);\n        </pauseEvent>\n\n      }.bind(this);\n    }\n"], ["serializeCookie", "\nfunction serializeCookie(cookie) {\n  \n  return {\n    path: cookie.path,\n    name: cookie.key,\n    value: cookie.value,\n    domain: cookie.domain\n  };\n  \n}\n"], ["sendRecursively", "\nfunction sendRecursively(event, currentState, isUnhandledPass) {\n  var log = this.enableLogging,\n      eventName = isUnhandledPass ? 'unhandledEvent' : event,\n      action = currentState[eventName],\n      contexts, sendRecursiveArguments, actionArguments;\n\n  <getContexts>\n  contexts = [].slice.call(arguments, 3);\n  </getContexts>\n\n  <invokeActionFunction>\n  if (typeof action === 'function') {\n    if (log) {\n      if (isUnhandledPass) {\n        Ember.Logger.log(`STATEMANAGER: Unhandled event '${event}' being sent to state ${currentState.get('path')}.`);\n      } else {\n        Ember.Logger.log(`STATEMANAGER: Sending event '${event}' to state ${currentState.get('path')}.`);\n      }\n    }\n\n    actionArguments = contexts;\n    if (isUnhandledPass) {\n      actionArguments.unshift(event);\n    }\n    actionArguments.unshift(this);\n\n    return action.apply(currentState, actionArguments);\n  }\n  </invokeActionFunction>\n  else {\n    <handleParentState>\n    var parentState = get(currentState, 'parentState');\n    if (parentState) {\n\n      sendRecursiveArguments = contexts;\n      sendRecursiveArguments.unshift(event, parentState, isUnhandledPass);\n\n      return sendRecursively.apply(this, sendRecursiveArguments);\n    } else if (!isUnhandledPass) {\n      return sendEvent.call(this, event, contexts, true);\n    }\n    </handleParentState>\n  }\n}\n"], ["anonymousFunctionComplex", "\nfunction() {\n      \n\n      <initializeVariables>\n      var a = this['re'];\n      var b = this['im'];\n      </initializeVariables>\n\n      <calc>\n      var noIM = a > 1 && b === 0;\n      var oneMinus = 1 - a;\n      var onePlus = 1 + a;\n      var d = oneMinus * oneMinus + b * b;\n      </calc>\n\n      <computeNewComplexNumber>\n      var x = (d !== 0)\n              ? new Complex(\n                      (onePlus * oneMinus - b * b) / d,\n                      (b * oneMinus + onePlus * b) / d)\n              : new Complex(\n                      (a !== -1) ? (a / 0) : 0,\n                      (b !== 0) ? (b / 0) : 0);\n      </computeNewComplexNumber>\n\n      <modifyComplexNumber>\n      var temp = x['re'];\n      x['re'] = logHypot(x['re'], x['im']) / 2;\n      x['im'] = Math.atan2(x['im'], temp) / 2;\n      if (noIM) {\n        x['im'] = -x['im'];\n      }\n      </modifyComplexNumber>\n\n      return x;\n    }\n"], ["mountAt", "\nfunction mountAt(url) {\n\t  var opts = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\t  var name = opts.name;\n\n    <buildMountObject>\n\t  return {\n\t\t  state: this,\n\t\t  url: url,\n\t\t  name: name,\n\t\t  buildUiRouterState: builder\n\t  };\n    </buildMountObject>\n\n    <builder>\n\t  function builder(options) {\n\t\t  var state = buildUiRouterState(this.state, options);\n\n      <extendStateWithUrlAndName>\n\t\t  if (this.url !== undefined) {\n\t\t\t  state.url = url;\n\t\t  }\n\n\t\t  if (this.name !== undefined) {\n\t\t\t  state.name = name;\n\t\t  }\n      </extendStateWithUrlAndName>\n\n\t\t  return state;\n\t  }\n    </builder>\n}\n"], ["dateList", "\nfunction dateList(numbers, type) {\n  \n  <handleSingleElement>\n    if (numbers.length < 2) {\n      return numberToDateName('' + numbers[0], type);\n    }\n  </handleSingleElement>\n\n  <buildDateList>\n    var lastVal = '' + numbers.pop();\n    var outputText = '';\n\n    for (var i = 0, value; value = numbers[i]; i++) {\n      if (outputText.length > 0) {\n        outputText += ', ';\n      }\n      outputText += numberToDateName(value, type);\n    }\n    return outputText + ` ${locale['and']} ` + numberToDateName(lastVal, type);\n    </buildDateList>\n}\n"], ["anonymousFunctionPieChartNode", "\nfunction (node, startAngle) {\n            \n            if (!node) {\n                return;\n            }\n\n            var endAngle = startAngle;\n\n            <computeAngleAndLayout>\n            \n            if (node !== virtualRoot) {\n                \n                var value = node.getValue();\n\n                var angle = (sum === 0 && stillShowZeroSum)\n                    ? unitRadian : (value * unitRadian);\n                if (angle < minAngle) {\n                    angle = minAngle;\n                    restAngle -= minAngle;\n                }\n                else {\n                    valueSumLargerThanMinAngle += value;\n                }\n\n                endAngle = startAngle + dir * angle;\n\n                var depth = node.depth - rootDepth\n                    - (renderRollupNode ? -1 : 1);\n                var rStart = r0 + rPerLevel * depth;\n                var rEnd = r0 + rPerLevel * (depth + 1);\n\n                var itemModel = node.getModel();\n                if (itemModel.get('r0') != null) {\n                    rStart = parsePercent(itemModel.get('r0'), size / 2);\n                }\n                if (itemModel.get('r') != null) {\n                    rEnd = parsePercent(itemModel.get('r'), size / 2);\n                }\n\n                node.setLayout({\n                    angle: angle,\n                    startAngle: startAngle,\n                    endAngle: endAngle,\n                    clockwise: clockwise,\n                    cx: cx,\n                    cy: cy,\n                    r0: rStart,\n                    r: rEnd\n                });\n            }\n\n            \n            if (node.children && node.children.length) {\n                \n                var siblingAngle = 0;\n                zrUtil.each(node.children, function (node) {\n                    siblingAngle += renderNode(node, startAngle + siblingAngle);\n                });\n            }\n\n            </computeAngleAndLayout>\n\n            return endAngle - startAngle;\n        }\n"], ["isWritable", "\nfunction isWritable(p) {\n    if (!fs.existsSync(p)) {\n        return false;\n    }\n    let stats = fs.statSync(p);\n    let mode = stats.mode;\n    let uid = process.getuid ? process.getuid() : 0;\n    let gid = process.getgid ? process.getgid() : 0;\n    let owner = uid === stats.uid;\n    let group = gid === stats.gid;\n    return !!(owner && (mode & parseInt('00200', 8)) ||\n        group && (mode & parseInt('00020', 8)) ||\n        (mode & parseInt('00002', 8)));\n}\n"], ["clearAjax", "\nfunction clearAjax() {\n  <iterateOverRequestsToClear>\n  each(function(request) {\n    try {\n      <resetEventHandlers>\n      request.onload = noop;\n      request.onerror = noop;\n      request.onabort = noop;\n      request.onreadystatechange = noop;\n      </resetEventHandlers>\n\n      <applyQueuedHandlers>\n      each(function(added) {\n        request[added[0]].apply(request, added[1]);\n      }, request._queue || []);\n      </applyQueuedHandlers>\n\n      <abortRequest>\n      request.abort();\n      </abortRequest>\n    } catch (e) {\n      \n    }\n  }, requests);\n  </iterateOverRequestsToClear>\n\n  <clearRequestsList>\n  requests.length = [];\n  </clearRequestsList>\n}\n"], "```"]