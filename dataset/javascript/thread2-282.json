[["getCacheCtor", "\nfunction getCacheCtor(cache){\n  <checkCacheAndReturn>\n  if (!cache){\n    return;\n  }\n  </checkCacheAndReturn>\n\n  <checkCacheFunctionality>\n  if (typeof cache === 'function'){\n    return cache;\n  }\n  </checkCacheFunctionality>\n\n  <defineRuntimeLoad>\n  function runtimeLoad(moduleRef){\n    return require(moduleRef);\n  }\n  </defineRuntimeLoad>\n\n  <defineCacheCtors>\n  var cacheCtors = {\n    disabled: runtimeLoad('./DisabledCache'),\n    memory: runtimeLoad('./MemoryStore'),\n    memcached: runtimeLoad('./MemcachedStore'),\n    redis: runtimeLoad('./RedisStore')\n  };\n  </defineCacheCtors>\n\n  <validateAndReturnCache>\n  if (!(cache in cacheCtors)){\n    throw new Error('Unsupported cache provider: ' + cache);\n  }\n  </validateAndReturnCache>\n\n  return cacheCtors[cache];\n}\n"], ["removeClass", "\nfunction(el, c) {\n  <modifyClassList>\n  if (el.classList) {\n    el.classList.remove(c);\n  } else {\n    <updateClassName>\n    el.className = el.className.replace(c, '').replace(/^\\s+|\\s+$/g, '');\n    </updateClassName>\n  }\n  </modifyClassList>\n}\n"], ["evalBoard", "\nfunction(evalfunc, code){\n  var result = true, bd = this.board;\n  <evaluateBoardRows>\n  allloop: do{\n    for(var by=1; by<=bd.maxby; by+=2){\n      var clist = bd.cellinside(bd.minbx+1, by, bd.maxbx-1, by);\n      if( evalfunc.call(this, clist) ){ continue;}\n      result = false;\n      if(this.checkOnly){ break allloop;}\n    }\n    </evaluateBoardRows>\n\n    <evaluateBoardColumns>\n    for(var bx=1; bx<=bd.maxbx; bx+=2){\n      var clist = bd.cellinside(bx, bd.minby+1, bx, bd.maxby-1);\n      if( evalfunc.call(this, clist) ){ continue;}\n      result = false;\n      if(this.checkOnly){ break allloop;}\n    }\n    </evaluateBoardColumns>\n  } while(0);\n  </evaluateBoardRows>\n\n  <updateResult>\n  if(!result){\n    this.failcode.add(code);\n  }\n  </updateResult>\n}\n"], ["runDatabaseSetup", "\nasync function run () {\n  const {host, port, database, username: user, password, idleTimeoutMillis} = config()\n  <initializeClient>\n  const client = new Client({host, port, database: 'postgres', user, password, idleTimeoutMillis})\n  </initializeClient>\n\n  <manageDatabase>\n  await client.connect()\n  await client.query(`DROP DATABASE IF EXISTS ${database}`)\n  await client.query(`CREATE DATABASE ${database}`)\n  await client.end()\n  </manageDatabase>\n\n  <logSuccess>\n  console.log(`\\x1b[32m\\u2714 Database \\x1b[1m${database}\\x1b[22m created successfully!\\x1b[0m`)\n  </logSuccess>\n}\n"], ["setupCompilerHooks", "\nfunction(compiler){\n  bindCallbackMethod(compiler, \"compilation\",\n                     this, this.addDependencyFactories);\n  bindCallbackMethod(compiler.parser, \"expression window.angular\",\n                     this, this.addAngularVariable);\n  bindCallbackMethod(compiler.parser, \"expression angular\",\n                     this, this.addAngularVariable);\n  bindCallbackMethod(compiler.parser, \"call angular.module\",\n                     this, this.parseModuleCall);\n  bindCallbackMethod(compiler.resolvers.normal, \"module-module\",\n                     this, this.resolveModule);\n}\n"], ["handleGolrResponse", "\nfunction(request_data, response_hook) {\n  <setSuccessCallback>\n  anchor.jq_vars['success'] = function(json_data){\n    var retlist = [];\n    var resp = new bbop.golr.response(json_data);\n    </setSuccessCallback>\n\n    <initializeVariables>\n    result_count = null;\n    return_count = null;\n    </initializeVariables>\n\n    <processResponseData>\n    if( resp.success() ){\n      result_count = resp.total_documents();\n      return_count = resp.documents().length;\n\n      loop(resp.documents(), function(doc){\n        <generateLabel>\n        var lbl = label_tt.fill(doc);\n        </generateLabel>\n\n        <generateValue>\n        var val = value_tt.fill(doc);\n        </generateValue>\n\n        <createAndPushItem>\n        var item = {\n          'label': lbl,\n          'value': val,\n          'document': doc\n        };\n        retlist.push(item);\n        </createAndPushItem>\n      });\n    }\n    </processResponseData>\n\n    <callResponseHook>\n    response_hook(retlist);\n    </callResponseHook>\n  };\n\n  <externalQuery>\n  anchor.set_comfy_query(request_data.term);\n  anchor.JQ.ajax(anchor.get_query_url(), anchor.jq_vars);\n  </externalQuery>\n}\n"], ["SensorConstructor", "\nfunction Sensor(sensorInfo, options) {\n  <initializeProperties>\n  var props = this.properties = this.constructor.properties;\n  var id = sensorInfo.id;\n  </initializeProperties>\n\n  <setId>\n  if (id) {\n    this.id = id;\n  } else {\n    if (props && props.id) {\n      this.id = template(props.id, options);\n    }\n  }\n  </setId>\n\n  <setOtherDetails>\n  this.info = sensorInfo;\n  this.options = _.defaults(options || {}, sensorInfo.options);\n  this.model = sensorInfo.model;\n  this.device = sensorInfo.device;\n  </setOtherDetails>\n\n  <initializeEventEmitter>\n  EventEmitter.call(this);\n  </initializeEventEmitter>\n}\n"], ["numberOfBits", "\nfunction nbits(x) {\n  var n = 1, t;\n  <calculateBits>\n  if ((t = x >>> 16) != 0) {\n    x = t;\n    n += 16;\n  }\n  if ((t = x >> 8) != 0) {\n    x = t;\n    n += 8;\n  }\n  if ((t = x >> 4) != 0) {\n    x = t;\n    n += 4;\n  }\n  if ((t = x >> 2) != 0) {\n    x = t;\n    n += 2;\n  }\n  if ((t = x >> 1) != 0) {\n    x = t;\n    n += 1;\n  }\n  </calculateBits>\n  return n;\n}\n"], ["linkUserWithFacebook", "\nfunction(facebookAccessToken, options) {\n  <setupOptions>\n  options = options || {};\n  options['data'] = options['data'] || {};\n  _.extend(options['data'], {\n    \"fb_at\" : facebookAccessToken,\n    \"token_type\" : \"mac\"\n  });\n  </setupOptions>\n\n  <syncUser>\n  (this.sync || Backbone.sync).call(this, \"linkUserWithFacebook\", this, options);\n  </syncUser>\n}\n"], ["createRequestTimeoutError", "\nfunction createRequestTimeoutErr(opts, req) {\n  assert.object(opts, 'opts');\n  assert.object(req, 'req');\n\n  <getErrorInfoAndMessage>\n  var errInfo = createErrInfo(opts, req);\n  var errMsg = [\n    opts.method,\n    'request to',\n    errInfo.fullUrl,\n    'failed to complete within',\n    opts.requestTimeout + 'ms'\n  ].join(' ');\n  </getErrorInfoAndMessage>\n\n  <constructError>\n  return new ERR_CTOR.RequestTimeoutError({\n    info: _.assign(errInfo, {\n      requestTimeout: opts.requestTimeout\n    })\n  }, '%s', errMsg);\n  </constructError>\n}\n"], "```"]