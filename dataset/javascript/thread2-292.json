[["constructor", "\nfunction(points, parameters) {\n  parameters = defaultValue(parameters, defaultValue.EMPTY_OBJECT); // Handling default parameters\n  \n  this.points = defaultValue(points, []); // Handling default points\n  \n  this.point = undefined; // Initializing point to undefined\n  \n  // Setting object properties from parameters\n  this.id = parameters.id;\n  this.categoryName = parameters.categoryName;\n  this.name = parameters.name;\n  this.units = parameters.units;\n  this.color = parameters.color;\n  this.yAxisMin = parameters.yAxisMin;\n  this.yAxisMax = parameters.yAxisMax;\n  this.type = parameters.type;\n  this.onClick = parameters.onClick;\n  this.showAll = defaultValue(parameters.showAll, true);\n\n  this.yAxisWidth = 40; // Fixed yAxisWidth\n}\n"], ["getLocationFromIndex", "\nfunction getLocationFromIndex(string, index) {\n  const lines = string.split('\\n');\n  let destructure = false;\n  let idx = 0;\n  const results = [];\n  let found = [];\n\n  <handleSingleIndices>\n  if (!Array.isArray(index)) {\n    index = [index];\n    destructure = true;\n  }\n  </handleSingleIndices>\n\n  <lineProcessingLoop>\n  for (let i = 0, l = lines.length; i < l; i++) {\n    const m = index.length;\n    const line = lines[i];\n    const lineLength = line.length + 1;\n    if (!m) break;\n    \n    <locationResults>\n    for (let j = 0; j < m; j++) {\n      if (idx + lineLength > index[j]) {\n        results.push({\n          line: i + 1,\n          column: index[j] - idx\n        });\n        found.push(j);\n      }\n    }\n    </locationResults>\n\n    <updateIndex>\n    if (found.length) {\n      for (let k = 0, n = found.length; k < n; k++) {\n        index.splice(found[k] - k, 1);\n      }\n      found = [];\n    }\n    </updateIndex>\n    idx += lineLength;\n  }\n  </lineProcessingLoop>\n\n  <returnResults>\n  if (results.length) return destructure ? results[0] : results;\n  return { line: 0, column: 0 };\n  </returnResults>\n}\n"], ["drawImageWithOptions", "\nfunction(opacity, scale, translate, compositeOperation) {\n  <processOptions>\n  var options = opacity;\n  if (!$.isPlainObject(options)) {\n    options = {\n      opacity: opacity,\n      scale: scale,\n      translate: translate,\n      compositeOperation: compositeOperation\n    };\n  }\n  if (!this.useCanvas || !this.sketchCanvas) {\n    return;\n  }\n  opacity = options.opacity;\n  compositeOperation = options.compositeOperation;\n  var bounds = options.bounds;\n  </processOptions>\n\n  <configureAndDrawImage>\n  this.context.save();\n  this.context.globalAlpha = opacity;\n  if (compositeOperation) {\n    this.context.globalCompositeOperation = compositeOperation;\n  }\n  // Rest of drawing logic omitted for brevity\n  this.context.restore();\n  </configureAndDrawImage>\n}\n"], ["handleStorage", "\nfunction(key, value){\n    var ls = this._local.localStorage;\n    \n    <retrieveItem>\n    if( value === undefined ) {\n      return ls ? ls.getItem(key) : $.cookie(key);\n    } \n    </retrieveItem>\n    <removeItem>\n    else if ( value === null ) {\n      if( ls ) {\n        ls.removeItem(key);\n      } else {\n        $.removeCookie(key);\n      }\n    } \n    </removeItem>\n    <setItem>\n    else {\n      if( ls ) {\n        ls.setItem(key, value);\n      } else {\n        $.cookie(key, value, this.options.persist.cookie);\n      }\n    }\n    </setItem>\n}\n"], ["modifyURLHashParameters", "\nfunction (oComponent, sParameterName, aValues) {\n  var oParsedHash = Utils.getParsedURLHash(sParameterName);\n\n  <handleParsedHash>\n  if (oParsedHash.params) {\n    hasher.changed.active = false;\n\n    var mTechnicalParameters = Utils.getTechnicalParametersForComponent(oComponent);\n    \n    <processParameters>\n    if (!mTechnicalParameters) {\n      this.log.warning(\"Component instance not provided, so technical parameters in component data and browser history remain unchanged\");\n    }\n    if (aValues.length === 0) {\n      delete oParsedHash.params[sParameterName];\n      mTechnicalParameters && delete mTechnicalParameters[sParameterName];\n    } else {\n      oParsedHash.params[sParameterName] = aValues;\n      mTechnicalParameters && (mTechnicalParameters[sParameterName] = aValues);\n    }\n    </processParameters>\n    hasher.replaceHash(Utils.getUshellContainer().getService(\"URLParsing\").constructShellHash(oParsedHash));\n    hasher.changed.active = true;\n  }\n  </handleParsedHash>\n}\n"], ["escapeHtml", "\nfunction escapeHtml (s, replaceDoubleQuote) {\n  <formatString>\n  if (s === 'undefined') {\n    s = ''\n  }\n  if (typeof s !== 'string') {\n    s = s + ''\n  }\n  s = s\n    .replace(/&/g, '&amp;')\n    .replace(/</g, '&lt;')\n    .replace(/>/g, '&gt;')\n  if (replaceDoubleQuote) {\n    return s.replace(/\"/g, '&quot;')\n  }\n  </formatString>\n  return s\n}\n"], ["parseApiResponse", "\nfunction parse(response, opts, callback) {\n  var parser, jsonParseError, result;\n\n  <processJsonOrElse>\n  if (opts.format.toUpperCase() === 'XML') {\n    callback(null, response);\n    return;\n  }\n  if (opts.contentType && opts.contentType.indexOf('json') >= 0) {\n    try {\n      result = JSON.parse(response);\n    } catch (e) {\n      jsonParseError = e;\n    }\n    return validateAndCleanResponse(jsonParseError, { response: result });\n  }\n  </processJsonOrElse>\n\n  <parseXml>\n  parser = new xml2js.Parser({\n    mergeAttrs: true,\n    explicitArray: false\n  });\n  parser.parseString(response, validateAndCleanResponse);\n  </parseXml>\n\n  <validateAndCleanResponse>\n  function validateAndCleanResponse(err, result) {\n    // Error handling and response cleaning logic omitted for brevity\n    return callback(null, cleanedResult);\n  }\n  </validateAndCleanResponse>\n}\n"], ["ngModelWarning", "\nfunction _ngModelWarning(name, type, instance, warningConfig) {\n  <emitWarning>\n  if (!Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__[\"isDevMode\"])() || warningConfig === 'never')\n      return;\n  if (((warningConfig === null || warningConfig === 'once') && !type._ngModelWarningSentOnce) ||\n      (warningConfig === 'always' && !instance._ngModelWarningSent)) {\n      ReactiveErrors.ngModelWarning(name);\n      type._ngModelWarningSentOnce = true;\n      instance._ngModelWarningSent = true;\n  }\n  </emitWarning>\n}\n"], ["adjustDayOfMonth", "\nfunction adjustDayOfMonth(self) {\n  <adjustFields>\n  var fields = self.fields;\n  var year = fields[YEAR];\n  var month = fields[MONTH];\n  var monthLen = getMonthLength(year, month);\n  var dayOfMonth = fields[DAY_OF_MONTH];\n  if (dayOfMonth > monthLen) {\n      self.set(DAY_OF_MONTH, monthLen);\n  }\n  </adjustFields>\n}\n"], ["initialiseModel", "\nfunction initialise(model, instance, autoInitialiseModel) {\n  if (autoInitialiseModel === void 0) { autoInitialiseModel = true; }\n  if (instance) {\n    <initialiseInstance>\n    if (autoInitialiseModel && model.clean === false) {\n      initialise(model);\n    }\n    exports.console.log(\"initialise \" + instance);\n    invoke(model.onInitialise, undefined, instance);\n    </initialiseInstance>\n  }\n  else {\n    <initialiseModelStructure>\n    exports.console.log(\"initialise \" + model.name);\n    model.accept(new InitialiseElements(), false);\n    model.clean = true;\n    </initialiseModelStructure>\n  }\n}\n"], "```\n\nIn reviewing the above functions, I have annotated blocks that represent distinct responsibilities according to the definition provided. Responsibilities are larger, conceptual blocks of logic rather than simple one-liners or basic assignments. Each annotated section performs a task that contributes to the overall responsibility of the function."]