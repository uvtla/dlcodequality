[["createAndConfigureType", "\nfunction(typeData)\n{\n    <createNewType>\n    var newType = new ASProxy(this, typeData.name); </createNewType>\n\n    <addAccessorsToType>\n    var accessors = typeData.accessors;\n    for (var i = 0; i < accessors.length; i++)\n    {\n        this.addPropertyToType(newType, accessors[i]);\n    }\n    </addAccessorsToType>\n\n    <addMethodsToType>\n    var methods = typeData.methods;\n    for (var i = 0; i < methods.length; i++)\n    {\n        if (FABridge.blockedMethods[methods[i]] == undefined)\n        {\n            this.addMethodToType(newType, methods[i]);\n        }\n    }\n    </addMethodsToType>\n\n    <cacheAndReturnNewType>\n    this.remoteTypeCache[newType.typeName] = newType;\n    return newType;\n    </cacheAndReturnNewType>\n}\n"], ["cloneObjectWithWeakMap", "\nfunction clone(obj, custom_method, extra_args, wm) {\n\n    <handleWeakMapParameters>\n    if (custom_method instanceof WeakMap) {\n        wm = custom_method;\n        custom_method = null;\n    } else if (extra_args instanceof WeakMap) {\n        wm = extra_args;\n        extra_args = null;\n    }\n\n    if (!wm) {\n        wm = new WeakMap();\n        wm.source = obj;\n        wm.custom_method = custom_method;\n        wm.extra_args = extra_args;\n    } else if (wm.has(obj)) {\n        return wm.get(obj);\n    }\n    </handleWeakMapParameters>\n\n    <prepareCustomMethodArguments>\n    if (custom_method) {\n        extra_args = [wm].concat(extra_args);\n    }\n    </prepareCustomMethodArguments>\n\n    <performClone>\n    return real_clone({'_': obj}, custom_method, extra_args, wm)['_'];\n    </performClone>\n}\n"], ["copyArrayPortion", "\nfunction copy(array, first, count) {\n    <setDefaultValues>\n    first = valueOrDefault(first, 0);\n    count = valueOrDefault(count, array.length);\n    </setDefaultValues>\n    <performSliceOperation>\n    return Array.prototype.slice.call(array, first, count);\n    </performSliceOperation>\n}\n"], ["migrateDownCommand", "\nfunction down(){\n    <prepareMigrationCommand>\n    var key = (grunt.option('name') || \"\"),\n        label = ( key || \"EMPTY\"),\n        cmd = (migrateBinPath + \" down \" + key).trim();\n    </prepareMigrationCommand>\n\n    <executeMigrationCommand>\n    grunt.log.write('Running migration \"DOWN\" [' + label + ']...').ok();\n    run(cmd);\n    </executeMigrationCommand>\n}\n"], ["parseXMLDeclaration", "\nfunction declaration() {\n    <matchDeclarationStart>\n    var m = match(/^<\\?xml\\s*/);\n    if (!m) return;\n    </matchDeclarationStart>\n    \n    <initializeDeclarationNode>\n    var node = {\n        attributes: {},\n    };\n    </initializeDeclarationNode>\n\n    <parseAttributes>\n    while (!(eos() || is('?>'))) {\n        var attr = attribute();\n        if (!attr) return node;\n        node.attributes[attr.name] = attr.value;\n    }\n    </parseAttributes>\n\n    <matchDeclarationEnd>\n    match(/\\?>\\s*/);\n    </matchDeclarationEnd>\n\n    <returnNode>\n    return node;\n    </returnNode>\n}\n"], ["calculateEffectiveVectorLength", "\nfunction isSpanVec(vec, index) {\n    <calculateSpan>\n    var effectivelen = vec.reduce(function (prev, mem) { return prev += mem.span ? mem.span : 1; }, 0);\n    </calculateSpan>\n    <compareLengthAndIndex>\n    return effectivelen > index;\n    </compareLengthAndIndex>\n}\n"], ["timeoutCallbackWrapper", "\nfunction t(time, done) {\n  <handleArguments>\n  if (arguments.length === 1) {\n    done = time;\n    time = 2000;\n  }\n  var error = new Error(`Callback took too long (max: ${time})`);\n  var waiting = true;\n  </handleArguments>\n\n  <setCallbackTimeout>\n  var timeout = setTimeout(function () {\n    if (!waiting) return;\n    waiting = false;\n    done(error);\n  }, time);\n  </setCallbackTimeout>\n\n  <callbackCompletionHandler>\n  function handler() {\n    if (!waiting) return;\n    clearTimeout(timeout);\n    waiting = false;\n    done.apply(this, arguments);\n  }\n  </callbackCompletionHandler>\n\n  <returnCallbackHandler>\n  return handler;\n  </returnCallbackHandler>\n}\n"], ["navigationToRoute", "\nfunction(route, args) {\n    <generateRouteUrl>\n    url = urls.route(route, args);\n    </generateRouteUrl>\n    <logNavigation>\n    logging.log(\"navigate to \", url);\n    </logNavigation>\n    <performNavigation>\n    window.location.hash = url;\n    </performNavigation>\n    <chainFunctionCall>\n    return this;\n    </chainFunctionCall>\n}\n"], ["getCollectionModel", "\nfunction (query, indexName) {\n    <retrieveModelFromCollection>\n    var model = this.collection.get(query, indexName);\n    </retrieveModelFromCollection>\n    <checkAndReturnModel>\n    if (model && includes(this.models, model)) return model;\n    </checkAndReturnModel>\n}\n"], ["getNewPathForDestination", "\nfunction getPathToDestination(pathToSource, pathToDestinationFile) {\n    <determineDestinationType>\n    var isDestinationDirectory = (/\\/$/).test(pathToDestinationFile);\n    </determineDestinationType>\n    <extractFileName>\n    var fileName = path.basename(pathToSource);\n    </extractFileName>\n    <computeNewPath>\n    var newPathToDestination;\n    if (typeof pathToDestinationFile === 'undefined') {\n        newPathToDestination = pathToSource;\n    } else {\n        newPathToDestination = pathToDestinationFile + (isDestinationDirectory ? fileName : '');\n    }\n    </computeNewPath>\n    <returnComputedPath>\n    return newPathToDestination;\n    </returnComputedPath>\n}\n"], ""]