[["drawSelectionRange", "\nfunction drawSelectionRange(cm,range$$1,output){\n    <variables_initialization>\n    var display=cm.display,doc=cm.doc;\n    var fragment=document.createDocumentFragment();\n    var padding=paddingH(cm.display),leftSide=padding.left;\n    var rightSide=Math.max(display.sizerWidth,displayWidth(cm)-display.sizer.offsetLeft)-padding.right;\n    var docLTR=doc.direction==\"ltr\";\n    </variables_initialization>\n    <add_function>\n    function add(left,top,width,bottom){\n        if(top<0){top=0;}\n        top=Math.round(top);bottom=Math.round(bottom);\n        fragment.appendChild(elt(\"div\",null,\"CodeMirror-selected\",\"position: absolute; left: \"+left+\"px;\\n                             top: \"+top+\"px; width: \"+(width==null?rightSide-left:width)+\"px;\\n                             height: \"+(bottom-top)+\"px\"));\n    }\n    </add_function>\n    <drawForLine_function>\n    function drawForLine(line,fromArg,toArg){\n        var lineObj=getLine(doc,line);\n        var lineLen=lineObj.text.length;\n        var start,end;\n        <coords_function>\n        function coords(ch,bias){return _charCoords(cm,Pos(line,ch),\"div\",lineObj,bias);}\n        </coords_function>\n        <wrapX_function>\n        function wrapX(pos,dir,side){\n            var extent=wrappedLineExtentChar(cm,lineObj,null,pos);\n            var prop=dir==\"ltr\"==(side==\"after\")?\"left\":\"right\";\n            var ch=side==\"after\"?extent.begin:extent.end-(/\\s/.test(lineObj.text.charAt(extent.end-1))?2:1);\n            return coords(ch,prop)[prop];\n        }\n        </wrapX_function>\n        var order=getOrder(lineObj,doc.direction);\n        iterateBidiSections(order,fromArg||0,toArg==null?lineLen:toArg,function(from,to,dir,i){\n            var ltr=dir==\"ltr\";\n            var fromPos=coords(from,ltr?\"left\":\"right\");\n            var toPos=coords(to-1,ltr?\"right\":\"left\");\n            var openStart=fromArg==null&&from==0,openEnd=toArg==null&&to==lineLen;\n            var first=i==0,last=!order||i==order.length-1;\n            if(toPos.top-fromPos.top<=3){\n                var openLeft=(docLTR?openStart:openEnd)&&first;\n                var openRight=(docLTR?openEnd:openStart)&&last;\n                var left=openLeft?leftSide:(ltr?fromPos:toPos).left;\n                var right=openRight?rightSide:(ltr?toPos:fromPos).right;\n                add(left,fromPos.top,right-left,fromPos.bottom);\n            }else{\n                <multiline_selection_logic>\n                var topLeft,topRight,botLeft,botRight;\n                if(ltr){\n                    topLeft=docLTR&&openStart&&first?leftSide:fromPos.left;\n                    topRight=docLTR?rightSide:wrapX(from,dir,\"before\");\n                    botLeft=docLTR?leftSide:wrapX(to,dir,\"after\");\n                    botRight=docLTR&&openEnd&&last?rightSide:toPos.right;\n                }else{\n                    topLeft=!docLTR?leftSide:wrapX(from,dir,\"before\");\n                    topRight=!docLTR&&openStart&&first?rightSide:fromPos.right;\n                    botLeft=!docLTR&&openEnd&&last?leftSide:toPos.left;\n                    botRight=!docLTR?rightSide:wrapX(to,dir,\"after\");\n                }\n                add(topLeft,fromPos.top,topRight-topLeft,fromPos.bottom);\n                if(fromPos.bottom<toPos.top){add(leftSide,fromPos.bottom,null,toPos.top);}\n                add(botLeft,toPos.top,botRight-botLeft,toPos.bottom);\n                </multiline_selection_logic>\n            }\n            if(!start||cmpCoords(fromPos,start)<0){start=fromPos;}\n            if(cmpCoords(toPos,start)<0){start=toPos;}\n            if(!end||cmpCoords(fromPos,end)<0){end=fromPos;}\n            if(cmpCoords(toPos,end)<0){end=toPos;}\n        });\n        return{start:start,end:end};\n    }\n    </drawForLine_function>\n    var sFrom=range$$1.from(),sTo=range$$1.to();\n    if(sFrom.line==sTo.line){drawForLine(sFrom.line,sFrom.ch,sTo.ch);}else{\n        <multi_line_selection>\n        var fromLine=getLine(doc,sFrom.line),toLine=getLine(doc,sTo.line);\n        var singleVLine=visualLine(fromLine)==visualLine(toLine);\n        var leftEnd=drawForLine(sFrom.line,sFrom.ch,singleVLine?fromLine.text.length+1:null).end;\n        var rightStart=drawForLine(sTo.line,singleVLine?0:null,sTo.ch).start;\n        if(singleVLine){\n            if(leftEnd.top<rightStart.top-2){\n                add(leftEnd.right,leftEnd.top,null,leftEnd.bottom);\n                add(leftSide,rightStart.top,rightStart.left,rightStart.bottom);\n            }else{\n                add(leftEnd.right,leftEnd.top,rightStart.left-leftEnd.right,leftEnd.bottom);\n            }\n        }\n        if(leftEnd.bottom<rightStart.top){add(leftSide,leftEnd.bottom,null,rightStart.top);}\n        </multi_line_selection>\n    }\n    output.appendChild(fragment);\n}\n"], ["convolve", "\nfunction convolve(src, kernel, tgt) {\n    <validate_input>\n    if (!src.length || !kernel.length) return src;\n    </validate_input>\n\n    <initialize_target>\n    var i = 0, \n        j = 0, \n        a = 0, \n        b = 0, \n        w = src.length, \n        l = src[0].length, \n        m = kernel.length, \n        n = kernel[0].length; \n    \n    if (typeof tgt === 'undefined') {\n        tgt = new Array(w);\n        for (i = 0; i < w; i++) {\n            tgt[i] = new Float64Array(l);\n        }\n    }\n    </initialize_target>\n    \n    <perform_convolution>\n    for (i = 0; i < w; i++) {\n        for (j = 0; j < l; j++) {\n            var last = 0;\n            tgt[i][j] = 0;\n            \n            for (a = 0; a < m; a++) {\n                for (b = 0; b < n; b++) {\n                    <check_source_boundary>\n                    if (typeof src[i+a] !== 'undefined' &&\n                        typeof src[i+a][j+b] !== 'undefined') {\n                        last = src[i+a][j+b];\n                    }\n                    </check_source_boundary>\n                    \n                    <calculate_convolution>\n                    tgt[i][j] += last * kernel[a][b];\n                    </calculate_convolution>\n                }\n            }\n        }\n    }\n    </perform_convolution>\n\n    return tgt;\n}\n"], ["ejs_renderFile_wrapper", "\nfunction () {\n    <render_and_handle_error>\n    return ejs.renderFile(file, data, options, function (error, content) {\n        if (error) {\n            self.emit(\"error\", error);\n            return callback(-2);\n        }\n        \n        return callback({\n            \"data\": new Buffer(content), \n            \"mimeType\": \"text/html\"\n        });\n    });\n    </render_and_handle_error>\n}\n"], ["getSignerClass", "\nfunction getSignerClass(request) {\n    var version;\n    <retrieve_operation_data>\n    var operation = null;\n    var authtype = '';\n    if (request) {\n      var operations = request.service.api.operations || {};\n      operation = operations[request.operation] || null;\n      authtype = operation ? operation.authtype : '';\n    }\n    </retrieve_operation_data>\n    \n    <decide_version>\n    if (this.config.signatureVersion) {\n      version = this.config.signatureVersion;\n    } else if (authtype === 'v4' || authtype === 'v4-unsigned-body') {\n      version = 'v4';\n    } else {\n      version = this.api.signatureVersion;\n    }\n    </decide_version>\n    \n    <get_signer>\n    return AWS.Signers.RequestSigner.getVersion(version);\n    </get_signer>\n  }\n"], ["process_entry", "\nfunction(entry) {\n    <check_entry>\n    if (entry) {\n        if (successCallback) {\n            <create_result>\n            var result = (entry.isDirectory) ? new (require('./DirectoryEntry'))(entry.name, entry.fullPath, entry.filesystem) : new (require('org.apache.cordova.file.FileEntry'))(entry.name, entry.fullPath, entry.filesystem);\n            </create_result>\n            <success_callback_invocation>\n            successCallback(result);\n            </success_callback_invocation>\n        }\n    }\n    </check_entry>\n    else {\n        <handle_failure>\n        fail && fail(FileError.NOT_FOUND_ERR);\n        </handle_failure>\n    }\n}\n"], ["getCommits", "\nfunction getCommits(repo, branchName) {\n    <retrieve_commits>\n  return caller.call(repo, repo.commits, branchName)\n    </retrieve_commits>\n    <map_commits>\n  .then(function (commits) {\n    return commits.map(function (commitObj) {\n      return {\n        id: commitObj.id,\n        message: commitObj.message,\n        committed_date: commitObj.committed_date\n      }\n    })\n  })\n  </map_commits>\n}\n"], ["ApiError_constructor", "\nfunction ApiError(response, client) {\n  <set_properties>\n  this.name = \"heap.ApiError\";\n  this.response = response;\n  this.client = client;\n  this.message = this.toString();\n  </set_properties>\n  <capture_error_stack>\n  Error.captureStackTrace(this, ApiError);\n  </capture_error_stack>\n}\n"], ["evaluate_tree_function", "\nfunction (env) {\n    <eval_args>\n    var args = this.args.map(function (a) { return a.eval(env) });\n    </eval_args>\n    <invoke_tree_function>\n    if (this.name in tree.functions) { \n        try {\n            return tree.functions[this.name].apply(tree.functions, args);\n        } catch (e) {\n            throw { type: e.type || \"Runtime\",\n                    message: \"error evaluating function `\" + this.name + \"`\" +\n                             (e.message ? ': ' + e.message : ''),\n                    index: this.index, filename: this.filename };\n        }\n    </invoke_tree_function>\n    else { \n        <create_anonymous_tree_instance>\n        return new(tree.Anonymous)(this.name +\n               \"(\" + args.map(function (a) { return a.toCSS(env) }).join(', ') + \")\");\n        </create_anonymous_tree_instance>\n    }\n}\n"], ["isSatisfiable", "\nfunction isSatisfiable (comparators, options) {\n  <evaluate_satisfiability>\n  var result = true\n  var remainingComparators = comparators.slice()\n  var testComparator = remainingComparators.pop()\n\n  while (result && remainingComparators.length) {\n    result = remainingComparators.every(function (otherComparator) {\n      return testComparator.intersects(otherComparator, options)\n    })\n\n    testComparator = remainingComparators.pop()\n  }\n  </evaluate_satisfiability>\n\n  return result\n}\n"], ["parse_arguments", "\nfunction(args, optNames) {\n\t\t<process_args>\n\t\tvar opt = {\"_\": []}; \n\t\tfor (var i = 0; i < args.length; i++) {\n\t\t\tvar arg = new String(args[i]);\n\t\t\tvar name;\n\t\t\tvar value;\n\t\t\tif (arg.charAt(0) == \"-\") {\n\t\t\t\tif (arg.charAt(1) == \"-\") { \n\t\t\t\t\targ = arg.substring(2);\n\t\t\t\t\tvar m = arg.split(\"=\");\n\t\t\t\t\tname = m.shift();\n\t\t\t\t\tvalue = m.shift();\n\t\t\t\t\tif (typeof value == \"undefined\") value = true;\n\t\t\t\t\t\n\t\t\t\t\tfor (var n in optNames) { \n\t\t\t\t\t\tif (name == optNames[n]) {\n\t\t\t\t\t\t\tname = n;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse { \n\t\t\t\t\targ = arg.substring(1);\n\t\t\t\t\tvar m = arg.split(\"=\");\n\t\t\t\t\tname = m.shift();\n\t\t\t\t\tvalue = m.shift();\n\t\t\t\t\tif (typeof value == \"undefined\") value = true;\n\t\t\t\t\t\n\t\t\t\t\tfor (var n in optNames) { \n\t\t\t\t\t\tif (name == n || name+'[]' == n) {\n\t\t\t\t\t\t\tname = n;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (name.match(/(.+)\\[\\]$/)) { \n\t\t\t\t\tname = RegExp.$1;\n\t\t\t\t\tif (!opt[name]) opt[name] = [];\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (opt[name] && opt[name].push) {\n\t\t\t\t\topt[name].push(value);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\topt[name] = value;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse { \n\t\t\t\topt._.push(args[i]);\n\t\t\t}\n\t\t}\n\t\t</process_args>\n\t\treturn opt;\n\t}\n"], ""]