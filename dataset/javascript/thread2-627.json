[["compareNumericField", "\nfunction compareNumericField(field, a, b) {\n  var nodeA = (a[1]);\n  var nodeB = (b[1]);\n  return nodeA[field] - nodeB[field];\n}\n"], ["setButter", "\nfunction setButter(message, error, traceback, asHtml) {\n  var butter = $('#butter');\n  \n  butter.css('display', 'none');\n  <changeButterClass>\n  if (error) {\n    butter.removeClass('info').addClass('error');\n  } else {\n    butter.removeClass('error').addClass('info');\n  }\n  </changeButterClass>\n  <clearButter>\n  butter.children().remove();\n  </clearButter>\n  <appendMessage>\n  if (asHtml) {\n    butter.append($('<div>').html(message));\n  } else {\n    butter.append($('<div>').text(message));\n  }\n  </appendMessage>\n\n  <centerButter>\n  function centerButter() {\n    butter.css('left', ($(window).width() - $(butter).outerWidth()) / 2);\n  }\n  </centerButter>\n\n  <handleTraceback>\n  if (traceback) {\n    <createShowDetailLink>\n    var showDetail = $('<a href=\"\">').text('Detail');\n    showDetail.click(function(event) {\n      $('#butter-detail').toggle();\n      centerButter();\n      event.preventDefault();\n    });\n    var butterDetail = $('<pre id=\"butter-detail\">').text(traceback);\n    butterDetail.css('display', 'none');\n    </createShowDetailLink>\n\n    <appendShowDetailAndDetail>\n    butter.append(showDetail);\n    butter.append(butterDetail);\n    </appendShowDetailAndDetail>\n  }\n  </handleTraceback>\n  centerButter();\n  butter.css('display', null);\n}\n"], ["checkAvailable", "\nfunction checkAvailable(host, port) {\n  return new Promise(function(resolve, reject) {\n    const socket = new net.Socket();\n    \n    <socketConnectionBehavior>\n    socket.on('connect', () => {\n      <cleanupSocketOnConnect>\n      cleanupSocket(socket);\n      resolve(true);\n      </cleanupSocketOnConnect>\n    });\n\n    socket.on('error', err => {\n      <cleanupSocketOnError>\n      cleanupSocket(socket);\n      if (err.code !== 'ECONNREFUSED') {\n        <socketErrorHandling>\n        return reject(err);\n        </socketErrorHandling>\n      }\n      </cleanupSocketOnError>\n\n      <socketConnectFailure>\n      resolve(false);\n      </socketConnectFailure>\n    });\n    </socketConnectionBehavior>\n\n    <socketInitiateConnection>\n    socket.connect({ port: port, host: host });\n    </socketInitiateConnection>\n  });\n}\n"], ["sign", "\nfunction sign(private_key, data) {\n  <createKeyFromPrivateKey>\n  var key = new bitcoinjs.ECKey(new BigInteger(private_key, 16), false);\n  </createKeyFromPrivateKey>\n  \n  <hashData>\n  var hash = bitcoinjs.crypto.hash256(new Buffer(data, 'hex'));\n  </hashData>\n  \n  <signHash>\n  return key.sign(hash).toDER().toString('hex');\n  </signHash>\n}\n"], ["Extractor", "\nfunction Extractor(ac , options) {\n  EventEmitter.call(this);\n  var self = this;\n  <initializeExtractorProperties>\n  self.matchers = [];\n  self.vars = ac || {};\n  self.options = options || {};\n  self.watchers = [];\n  </initializeExtractorProperties>\n  <setupListenMethod>\n  self._listen = function (car, file) {\n    car.once('end', function () {\n      <emitEndEvent>\n      self.emit('end', self.vars);\n      </emitEndEvent>\n    });\n    car.on('line', function (line) {\n      <processLineWithMatchers>\n      var i;\n      var firstMatch = true;\n      for (i = 0; i < self.matchers.length; i++) {\n        var matcher = self.matchers[i];\n        var m;\n        while(matcher.handler && (m = matcher.re.exec(line)) !== null){\n          matcher.handler(m, self.vars, file , firstMatch);\n          firstMatch = false;\n          if(!self.options.successive){\n            i = self.matchers.length;\n            break;\n          }\n        }\n      }\n      </processLineWithMatchers>\n    });\n    return self;\n  };\n  </setupListenMethod>\n}\n"], ["stepsMatch", "\nfunction stepsMatch(str, lax) {\n  var match;\n\n  <matchStrictValidSteps>\n  \n  match = str.match(STEPS_VALID_REGEX);\n  if (match && _validateStepsParams(match)) { \n    return _tagMatch(match, STEP);\n  }\n  </matchStrictValidSteps>\n\n  <matchGeneralSteps>\n  match = str.match(STEPS_GENERAL_REGEX);\n  if (match) {\n    match = _getValidStepsParams(match);\n    if (match && _validateStepsParams(match)) {\n      return _tagMatch(match, STEP);\n    } else { \n      <logInvalidCode>\n      window.console.log(\"brackets-steps: TimingFunctionUtils._getValidStepsParams created invalid code\");\n      </logInvalidCode>\n    }\n  }\n  </matchGeneralSteps>\n\n  <laxMatching>\n  \n  if (lax) {\n    \n    <matchLaxSteps>\n    match = str.match(STEP_LAX_REGEX);\n    if (match) {\n      return _tagMatch(match, STEP);\n    }\n    </matchLaxSteps>\n  } else {\n    \n    <matchStrictSteps>\n    match = str.match(STEP_STRICT_REGEX);\n    if (match) {\n      \n      return _tagMatch(str.match(STEP_LAX_REGEX), STEP);\n    }\n    </matchStrictSteps>\n  }\n  </laxMatching>\n\n  return null;\n}\n"], ["findFiles", "\nfunction(files, opts) {\n  var self    = this,\n    cwd     = this.getUI('cwd'),\n    cwdHash = this.cwd().hash,\n    newItem = $();\n  \n  opts = opts || {};\n  \n  <iterateOverFiles>\n  $.each(files, function(i, f) {\n    <matchFilesWithCwd>\n    if (f.phash === cwdHash || self.searchStatus.state > 1) {\n      <addToNewItemCollection>\n      newItem = newItem.add(cwd.find('#'+self.cwdHash2Id(f.hash)));\n      </addToNewItemCollection>\n      <checkFirstOnlyOption>\n      if (opts.firstOnly) {\n        return false;\n      }\n      </checkFirstOnlyOption>\n    }\n    </matchFilesWithCwd>\n  });\n  </iterateOverFiles>\n  \n  return newItem;\n}\n"], ["V1", "\nfunction V1(domain) {\n  Version.prototype.constructor.call(this, domain, 'v1');\n\n  <initializeV1Properties>\n  this._compositionHooks = undefined;\n  this._compositionSettings = undefined;\n  this._recordings = undefined;\n  this._recordingSettings = undefined;\n  this._compositions = undefined;\n  this._rooms = undefined;\n  </initializeV1Properties>\n}\n"], ["resolveWhen", "\nfunction resolveWhen() {\n  var dfd = pendings[handle];\n  <resolveDeferred>\n  if (dfd) {\n    dfd.forEach(function (promise) {\n      promise.resolve(instance);\n    });\n    delete pendings[handle];\n  }\n  </resolveDeferred>\n}\n"], ["_fnRowAttributes", "\nfunction _fnRowAttributes( row )\n{\n  var tr = row.nTr;\n  var data = row._aData;\n\n  if ( tr ) {\n    <setIdFromRowData>\n    if ( data.DT_RowId ) {\n      tr.id = data.DT_RowId;\n    }\n    </setIdFromRowData>\n\n    <setClassFromRowData>\n    if ( data.DT_RowClass ) {\n      \n      var a = data.DT_RowClass.split(' ');\n      row.__rowc = row.__rowc ?\n        _unique( row.__rowc.concat( a ) ) :\n        a;\n\n      $(tr)\n        .removeClass( row.__rowc.join(' ') )\n        .addClass( data.DT_RowClass );\n    }\n    </setClassFromRowData>\n\n    <setDataFromRowData>\n    if ( data.DT_RowData ) {\n      $(tr).data( data.DT_RowData );\n    }\n    </setDataFromRowData>\n  }\n}\n"], ""]