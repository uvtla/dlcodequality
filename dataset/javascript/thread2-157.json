[["functionResponsibility", "\n    var first, keys, subkey;\n    if (typeof context === \"undefined\" || context === null) {\n        context = this;\n    }\n    if (key.indexOf(\".\") > -1) {\n        keys = key.split(\".\");\n        first = keys.shift();\n        subkey = keys.join(\".\");\n        return this._attr_get(keys.join(\".\"), context[first]);\n    } else {\n        return context[key];\n    }\n    "], ["functionResponsibility", "\n    var iStart = b24H ? 0 : 1;\n    var b2400 = this._oTimePicker.getSupport2400() ? 24 : 23;\n    var iEnd = b24H ? b2400 : 12;\n\n    return genValues(iStart, iEnd, sLeadingChar);\n    "], ["functionResponsibility", "\n    if (!(this instanceof UAParser)) {\n        return new UAParser(uastring, extensions).getResult();\n    }\n\n    var ua = uastring || ((window && window.navigator && window.navigator.userAgent) ? window.navigator.userAgent : EMPTY);\n    var rgxmap = extensions ? util.extend(regexes, extensions) : regexes;\n\n    this.getBrowser = function () {\n        var browser = mapper.rgx.apply(this, rgxmap.browser);\n        browser.major = util.major(browser.version);\n        return browser;\n    };\n    this.getCPU = function () {\n        return mapper.rgx.apply(this, rgxmap.cpu);\n    };\n    this.getDevice = function () {\n        return mapper.rgx.apply(this, rgxmap.device);\n    };\n    this.getEngine = function () {\n        return mapper.rgx.apply(this, rgxmap.engine);\n    };\n    this.getOS = function () {\n        return mapper.rgx.apply(this, rgxmap.os);\n    };\n    this.getResult = function() {\n        return {\n            ua      : this.getUA(),\n            browser : this.getBrowser(),\n            engine  : this.getEngine(),\n            os      : this.getOS(),\n            device  : this.getDevice(),\n            cpu     : this.getCPU()\n        };\n    };\n    this.getUA = function () {\n        return ua;\n    };\n    this.setUA = function (uastring) {\n        ua = uastring;\n        return this;\n    };\n    this.setUA(ua);\n    return this;\n    "], ["checkValueContainsItem", "\n    if (_.isString(val)) return val.indexOf(item) !== -1;\n    if (_.isArray(val))  return _.indexOf(val, item) !== -1;\n    if (_.isObject(val)) return _.has(val, item);\n    return false;\n    "], ["iterateCollection", "\n    var index = -1,\n        iterable = collection,\n        length = collection ? collection.length : 0;\n\n    if (typeof length == 'number' && length > -1 && length <= maxSafeInteger) {\n        while (++index < length) {\n            if (callback(iterable[index], index, collection) === false) {\n                break;\n            }\n        }\n    } else {\n        baseForOwn(collection, callback);\n    }\n    return collection;\n    "], ["normalizeNodes", "\n    'use strict';\n    ['any', 'all', 'none'].forEach(type => {\n        if (!Array.isArray(node[type])) {\n            return;\n        }\n        node[type]\n            .filter(checkRes => Array.isArray(checkRes.relatedNodes))\n            .forEach(checkRes => {\n                checkRes.relatedNodes = checkRes.relatedNodes.map(relatedNode => {\n                    var res = {\n                        html: relatedNode.source\n                    };\n                    if (options.elementRef && !relatedNode.fromFrame) {\n                        res.element = relatedNode.element;\n                    }\n                    if (options.selectors !== false || relatedNode.fromFrame) {\n                        res.target = relatedNode.selector;\n                    }\n                    if (options.xpath) {\n                        res.xpath = relatedNode.xpath;\n                    }\n                    return res;\n                });\n            });\n    });\n    "], ["drawHighlights", "\n    // Variable declarations\n    let {isVertical, width, length, barWidth, barOffset, barMargin,\n        X, Y, ticksLength, ticksPadding} = context.barDimensions;\n    let hlWidth = width * (parseFloat(options.highlightsWidth) || 0) / 100;\n\n    // Early return if no highlights or width\n    if (!options.highlights || !hlWidth) return ;\n\n    // Calculating dimensions and intervals\n    let hasLeft = options.tickSide !== 'right';\n    let hasRight = options.tickSide !== 'left';\n    let i = 0;\n    let s = options.highlights.length;\n    let tickOffset = (width - barWidth) / 2;\n    let interval = options.maxValue - options.minValue;\n    \n    // Calculating effective positions\n    let eX = round(isVertical ? X + tickOffset : X + barMargin + barOffset);\n    let eH = hlWidth;\n    let eY = isVertical ? Y + length - barMargin - barOffset: Y + tickOffset;\n    \n    let hLeft = round((options.ticksWidth / 100 + ticksPadding) * width)\n        + (hlWidth - options.ticksWidth / 100 * width);\n    let hRight = round(barWidth + ticksPadding * width);\n\n    context.save();\n\n    // Drawing loop for highlights\n    for (; i < s; i++) {\n        let entry = options.highlights[i];\n        \n        let eStart = ticksLength * abs(options.minValue - entry.from) /\n            interval;\n        \n        let eW = ticksLength * abs((entry.to - entry.from) / interval);\n\n        context.beginPath();\n        context.fillStyle = entry.color;\n\n        // Drawing highlight rectangles based on vertical or horizontal orientation\n        if (isVertical) {\n            if (hasLeft) context.rect(eX - hLeft, eY - eStart, eH, -eW);\n            if (hasRight) context.rect(eX + hRight, eY - eStart, eH, -eW);\n        } else {\n            if (hasLeft) context.rect(eX + eStart, eY - hLeft, eW, eH);\n            if (hasRight) context.rect(eX + eStart, eY + hRight, eW, eH);\n        }\n\n        context.fill();\n        context.closePath();\n    }\n    "], ["convertSetToArray", "\n    var index = -1,\n        result = Array(set.size);\n\n    set.forEach(function (value) {\n        result[++index] = value;\n    });\n    return result;\n    "], ["retrieveModelData", "\n    var select = {};\n    select[pathName] = 1;\n\n    Model.findOne({_id: model}, select, function (err, doc) {\n      if (err) return done(err);\n      if (!doc) return done(null, []);\n\n      done(null, doc[pathName].reduce(function (o, friend) {\n        o[friend._id] = friend.toObject();\n        return o;\n      }, {}));\n    });\n    "], ["formatUrl", "\n    var start = url.indexOf('/:')\n    if (start === -1) return url\n\n    var end = url.indexOf('/', ++start)\n\n    if (end === -1) {\n        return url.slice(0, start) + '{' + url.slice(++start) + '}'\n    } else {\n        return formatParamUrl(url.slice(0, start) + '{' + url.slice(++start, end) + '}' + url.slice(end))\n    }\n    "], "}\n```\nFormatting a URL to swap placeholders with a new syntax is what this function is about. It can be considered SRP compliant since it is singularly focused on URL formatting."]