[["koifyRouter", "\nfunction koifyRouter(Router) {\n  <declareRouterPrototype>\n  let routerPrototype = Router; \n  </declareRouterPrototype>\n\n  <initializeRouterPrototypeCopy>\n  let routerPrototype_ = {}; \n  </initializeRouterPrototypeCopy>\n\n  <getAndSortRouterMethods>\n  let routerMethods = Object.keys(routerPrototype).sort(); \n  </getAndSortRouterMethods>\n\n  <defineIsRouterFunction>\n  function isRouter(someRouter) {\n    let someRouterPrototype = Object.getPrototypeOf(someRouter);\n    let someRouterMethods = Object.keys(someRouterPrototype).sort();\n\n    return arrayEqual(someRouterMethods, routerMethods) && (typeof someRouterPrototype === 'function');\n  }\n  </defineIsRouterFunction>\n\n  <overrideUseMethod>\n  routerPrototype_.use = routerPrototype.use;\n  routerPrototype.use = function () {\n    let args = slice.call(arguments);\n\n    for (let i = 0; i < args.length; i++) {\n      let handler = args[i];\n\n      if (isFunction(handler) && !isRouter(handler)) {\n        args[i] = ko.ko(handler);\n      }\n    }\n\n    return routerPrototype_.use.apply(this, args);\n  };\n  </overrideUseMethod>\n\n  <overrideParamMethod>\n  routerPrototype_.param = routerPrototype.param;\n  routerPrototype.param = function () {\n    let args = slice.call(arguments);\n\n    let handler = args[1];\n\n    if (isFunction(handler)) {\n      args[1] = ko.ko(handler, true);\n    }\n\n    return routerPrototype_.param.apply(this, args);\n  };\n  </overrideParamMethod>\n\n  <defineRouterProperty>\n  Object.defineProperty(routerPrototype, '$$koified', {\n    configurable: true,\n    writable: true,\n    value: false\n  });\n  </defineRouterProperty>\n\n  return Router;\n}\n"], ["parseLineForBeatmap", "\nfunction (line) {\n  <splitLineIntoMembers>\n  members = line.split(',');\n  </splitLineIntoMembers>\n\n  <handleBackgroundInfo>\n  if (members[0] == '0' && members[1] == '0' && members[2]) {\n    var bgName = members[2].trim();\n    if (bgName.charAt(0) == '\"' && bgName.charAt(bgName.length - 1) == '\"') {\n      beatmap.bgFilename = bgName.substring(1, bgName.length - 1);\n    } else {\n      beatmap.bgFilename = bgName;\n    }\n  }\n  </handleBackgroundInfo>\n  <handleBreakTimesInfo>\n  else if (members[0] == '2' && /^[0-9]+$/.test(members[1]) && /^[0-9]+$/.test(members[2])) {\n    beatmap.breakTimes.push({\n      startTime: parseInt(members[1]),\n      endTime: parseInt(members[2])\n    });\n  }\n  </handleBreakTimesInfo>\n}\n"], ["createCustomElement", "\nfunction () {\n  function impl (element) {\n    customElement.call(this, element)\n  }\n  <inheritCustomElement>\n  impl.prototype = Object.create(customElement.prototype)\n  </inheritCustomElement>\n  return impl\n}\n"], ["calculateAbsolutePath", "\nfunction(){\n  var args = arrayFrom(arguments).reverse();\n  <initializePath>\n  var path = [];\n  var absoluteFound = false;\n  </initializePath>\n\n  <processPathArguments>\n  for (var i = 0; !absoluteFound && i < args.length; i++)\n    if (typeof args[i] == 'string')\n    {\n      path.unshift(args[i]);\n      absoluteFound = ABSOLUTE_RX.test(args[i]);\n    }\n  </processPathArguments>\n\n  <handleBaseURI>\n  if (!absoluteFound)\n    path.unshift(baseURI == '/' ? '' : baseURI);\n  else if (path.length && path[0] == '/')\n    path[0] = '';\n  </handleBaseURI>\n\n  <normalizeAndReturnPath>\n  return utils.normalize(path.join('/'));\n  </normalizeAndReturnPath>\n}\n"], ["hasSimilarSelectors", "\nfunction hasSimilarSelectors(selectors1, selectors2) {\n  <traverseFirstSelectorList>\n  var cursor1 = selectors1.head;\n\n  while (cursor1 !== null) {\n    <traverseSecondSelectorList>\n    var cursor2 = selectors2.head;\n\n    while (cursor2 !== null) {\n      <compareSelectors>\n      if (cursor1.data.compareMarker === cursor2.data.compareMarker) {\n        return true;\n      }\n      </compareSelectors>\n\n      cursor2 = cursor2.next;\n    }\n    </traverseSecondSelectorList>\n\n    cursor1 = cursor1.next;\n  }\n  </traverseFirstSelectorList>\n\n  return false;\n}\n"], ["setCopyrightInfo", "\nfunction setCopyrightInfo_(map) {\n  <initializeDiv>\n  var div = null;\n  </initializeDiv>\n\n  <findExistingcopyrightDiv>\n  if (map) {\n    var mvc = map.controls[G.ControlPosition.BOTTOM_RIGHT];\n    if (mvc) {\n      for (var i = 0, c = mvc.getLength(); i < c; i++) {\n        if (mvc.getAt(i).id === 'agsCopyrights') {\n          div = mvc.getAt(i);\n          break;\n        }\n      }\n    }\n  </findExistingcopyrightDiv>\n  <createNewCopyrightDiv>\n  if (!div) {\n    div = document.createElement('div');\n    div.style.fontFamily = 'Arial,sans-serif';\n    div.style.fontSize = '10px';\n    div.style.textAlign = 'right';\n    div.id = 'agsCopyrights';\n    map.controls[G.ControlPosition.BOTTOM_RIGHT].push(div);\n    G.event.addListener(map, 'maptypeid_changed', function() {\n      setCopyrightInfo_(map);\n    });\n  }\n  </createNewCopyrightDiv>\n  <aggregateCopyrightInfo>\n  var ovs = map.agsOverlays;\n  var cp = [];\n  var svc, type;\n  if (ovs) {\n    for (var i = 0, c = ovs.getLength(); i < c; i++) {\n      <addCopyrightInfoToOverlay>\n      addCopyrightInfo_(cp, ovs.getAt(i).mapService_, map);\n      </addCopyrightInfoToOverlay>\n    }\n  }\n  </aggregateCopyrightInfo>\n  <handleOverlayMapTypes>\n  var ovTypes = map.overlayMapTypes;\n  if (ovTypes) {\n    for (var i = 0, c = ovTypes.getLength(); i < c; i++) {\n      type = ovTypes.getAt(i);\n      if (type instanceof MapType) {\n        for (var j = 0, cj = type.tileLayers_.length; j < cj; j++) {\n          <addCopyrightInfoToTileLayer>\n          addCopyrightInfo_(cp, type.tileLayers_[j].mapService_, map);\n          </addCopyrightInfoToTileLayer>\n        }\n      }\n    }\n  }\n  </handleOverlayMapTypes>\n  <handleMapType>\n  type = map.mapTypes.get(map.getMapTypeId());\n  if (type instanceof MapType) {\n    for (var i = 0, c = type.tileLayers_.length; i < c; i++) {\n      <addCopyrightInfoToMapType>\n      addCopyrightInfo_(cp, type.tileLayers_[i].mapService_, map);\n      </addCopyrightInfoToMapType>\n      <handleTextColour>\n      if (type.negative) {\n        div.style.color = '#ffffff';\n      } else {\n        div.style.color = '#000000';\n      }\n      </handleTextColour>\n    }\n  }\n  </handleMapType>\n  <updateCopyrightInnerHTML>\n  div.innerHTML = cp.join('<br/>');\n  </updateCopyrightInnerHTML>\n}\n"], ["middleware", "\nfunction mw(store) {\n  <ensureSingleStoreAssignment>\n  if (savedStore && savedStore !== store) {\n    throw new Error('cannot assign logicMiddleware instance to multiple stores, create separate instance for each');\n  }\n  </ensureSingleStoreAssignment>\n  <assignStoreToSavedStore>\n  savedStore = store;\n  </assignStoreToSavedStore>\n\n  <returnMiddlewareFunction>\n  return next => {\n    savedNext = next;\n    const { action$, sub, logicCount: cnt } =\n          applyLogic(arrLogic, savedStore, savedNext,\n                     logicSub, actionSrc$, deps, logicCount,\n                     monitor$);\n    actionEnd$ = action$;\n    logicSub = sub;\n    logicCount = cnt;\n\n    return action => {\n      <logActionStart>\n      debug('starting off', action);\n      </logActionStart>\n      <notifyMonitorTopOperation>\n      monitor$.next({ action, op: 'top' });\n      </notifyMonitorTopOperation>\n      <pushActionIntoStream>\n      actionSrc$.next(action);\n      </pushActionIntoStream>\n      return action;\n    };\n  };\n  </returnMiddlewareFunction>\n}\n"], ["ApplicationConstructor", "\nfunction Application(config, dataReplace) {\n  <validateConfigParameter>\n  if (!Helper.isObject(config) && !Helper.isArray(config)) {\n    throw BaseError({\n      title: 'The first parameter must be an array or object.',\n    });\n  }\n  </validateConfigParameter>\n  <assignConfig>\n  this._data = config;\n  </assignConfig>\n  <handleTemplateReplacement>\n  if (Helper.isObject(dataReplace) || Helper.isArray(dataReplace)) {\n    this.template(dataReplace);\n  }\n  </handleTemplateReplacement>\n}\n"], ["initiateOrResetDataSource", "\nfunction()\n{\n  <checkInitialization>\n  if(!this._initialized)\n  {\n    return;\n  }\n  </checkInitialization>\n  \n  if(this._dataSource !== null)\n  {\n    <handleExistingPolling>\n    if(this._pollingID !== null)\n    {\n      this._dataSource.clearInterval(this._pollingID);\n      this._pollingID = null;\n    }\n    </handleExistingPolling>\n    \n    <setupNewPollingInterval>\n    if(this._pollingInterval > 0)\n    {\n      this._pollingID = this._dataSource.setInterval(this._pollingInterval, this._request, this._loadDataHandler, this);\n    }\n    </setupNewPollingInterval>\n    <sendRequestToDataSource>\n    this._dataSource.sendRequest(this._request, this._loadDataHandler, this);\n    </sendRequestToDataSource>\n  }\n}\n"], ["updateUser", "\nfunction update(form) {\n  <formValidation>\n  if (!vm.user._id || form && !form.$valid) {\n    return;\n  }\n  </formValidation>\n\n  <requestUserUpdate>\n  UserService.update(vm.user)\n    .then(updateUserSuccess)\n    .catch(updateUserCatch);\n  </requestUserUpdate>\n\n  <updateSuccessLogic>\n  function updateUserSuccess(updatedUser) {\n    vm.displayName = updatedUser.name;\n    <displaySuccessToast>\n    Toast.show({text: 'User ' + updatedUser.name + ' updated'});\n    </displaySuccessToast>\n    <resetFormPristine>\n    if (form) {\n      form.$setPristine();\n    }\n    </resetFormPristine>\n  }\n  </updateSuccessLogic>\n\n  <handleUpdateError>\n  function updateUserCatch(err) {\n    <displayWarningToast>\n    Toast.show({\n      type: 'warn',\n      text: 'Error while updating user ' + vm.displayName,\n      link: {state: $state.$current, params: $stateParams}\n    });\n    </displayWarningToast>\n\n    <setResponseErrorsOnForm>\n    if (form && err) {\n      form.setResponseErrors(err.data);\n    }\n    </setResponseErrorsOnForm>\n  }\n  </handleUpdateError>\n}\n"], "```\n\nSome functions have a single responsibility and therefore are entirely enclosed with a single tag. Others violate the SRP and have nested tags representing distinct responsibilities. Tags are placed around coherent blocks that represent a specific task or purpose within the function. Simple variable assignments or return statements are not considered separate responsibilities unless they form part of a larger, distinct block of code."]