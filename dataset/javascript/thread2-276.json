[["setRaspberryVersion", "\nfunction setRaspberryVersion() {\n    if (currentPins) {\n        return Promise.resolve();\n    }\n\n    return new Promise(function(resolve, reject) {\n        <readFile>\n        fs.readFile('/proc/cpuinfo', 'utf8', function(err, data) {\n            if (err) {\n                return reject(err);\n            }\n        </readFile>\n\n        <parseRevisionNumber>\n        var match = data.match(/Revision\\s*:\\s*[0-9a-f]*([0-9a-f]{4})/);\n\n        if (!match) {\n            var errorMessage = 'Unable to match Revision in /proc/cpuinfo: ' + data;\n            return reject(new Error(errorMessage));\n        }\n\n        var revisionNumber = parseInt(match[1], 16);\n        </parseRevisionNumber>\n\n        <determinePinVersion>\n        var pinVersion = (revisionNumber < 4) ? 'v1' : 'v2';\n        </determinePinVersion>\n\n        <debugInfo>\n        debug(\n            'seen hardware revision %d; using pin mode %s',\n            revisionNumber,\n            pinVersion\n        );\n        </debugInfo>\n\n        <updateCurrentPins>\n        currentValidBcmPins = []\n        Object.keys(PINS[pinVersion]).forEach(\n            function(pin) {\n                \n                currentValidBcmPins.push(PINS[pinVersion][pin]);\n            }\n        );\n\n        currentPins = PINS[pinVersion];\n        </updateCurrentPins>\n\n        return resolve();\n    });\n});\n"], ["hashingProcess", "\nfunction (doFlush) {\n    \n    var data = this._data;\n    var dataWords = data.words;\n    var dataSigBytes = data.sigBytes;\n    var blockSize = this.blockSize;\n    var blockSizeBytes = blockSize * 4;\n\n    \n    <calculateBlocksReady>\n    var nBlocksReady = dataSigBytes / blockSizeBytes;\n    if (doFlush) {\n        nBlocksReady = Math.ceil(nBlocksReady);\n    } else {\n        nBlocksReady = Math.max((nBlocksReady | 0) - this._minBufferSize, 0);\n    }\n    </calculateBlocksReady>\n\n    <prepareForProcessing>\n    var nWordsReady = nBlocksReady * blockSize;\n    var nBytesReady = Math.min(nWordsReady * 4, dataSigBytes);\n    </prepareForProcessing>\n\n    <processData>\n    if (nWordsReady) {\n        for (var offset = 0; offset < nWordsReady; offset += blockSize) {\n            this._doProcessBlock(dataWords, offset);\n        }\n\n        var processedWords = dataWords.splice(0, nWordsReady);\n        data.sigBytes -= nBytesReady;\n    }\n    </processData>\n\n    <outputResult>\n    return new WordArray.init(processedWords, nBytesReady);\n    </outputResult>\n"], ["onFrameNavigated", "\nfunction _onFrameNavigated(event, res) {\n    \n    if (!res.frame.parentId) {\n        exports.url = _cleanURL(res.frame.url);\n    }\n}\n"], ["printStack", "\nfunction printStack(err) {\n    if (err && err.stack) {\n        console.error(err.stack);\n    }\n    else {\n        console.log(err);\n    }\n}\n"], ["handleMouseEvent", "\nfunction (evt) {\n    if (this.mouseDown && (!this.lastUp || !this.lastUp.equals(evt.xy))) {\n        if(this.stoppedDown && this.freehandMode(evt)) {\n            if (this.persist) {\n                this.destroyPersistedFeature();\n            }\n            this.removePoint();\n            this.finalize();\n        } else {\n            if (this.passesTolerance(this.lastDown, evt.xy,\n                                        this.pixelTolerance)) {\n                if (this.touch) {\n                    this.modifyFeature(evt.xy);\n                }\n                if(this.lastUp == null && this.persist) {\n                    this.destroyPersistedFeature();\n                }\n                this.addPoint(evt.xy);\n                this.lastUp = evt.xy;\n                if(this.line.geometry.components.length === this.maxVertices + 1) {\n                    this.finishGeometry();\n                }\n            }\n        }\n    }\n    this.stoppedDown = this.stopDown;\n    this.mouseDown = false;\n    return !this.stopUp;\n}\n"], ["limitLetterbox", "\nfunction() {\n    return function limitLetterbox(params) {\n      if(params.width <= 0 || params.height <= 0) {\n        return params;\n      }\n      var viewportAspectRatio = params.width / params.height;\n\n      <calculateFullWidthHeightZoom>\n      var fullWidthZoom = 1.0;\n      var fullHeightZoom = viewportAspectRatio / params.mediaAspectRatio;\n      </calculateFullWidthHeightZoom>\n\n      <adjustZoomBasedOnAspectRatio>\n      \n      if (params.mediaAspectRatio >= viewportAspectRatio) {\n        params.zoom = Math.min(params.zoom, fullWidthZoom);\n      }\n\n      if (params.mediaAspectRatio <= viewportAspectRatio) {\n        params.zoom = Math.min(params.zoom, fullHeightZoom);\n      }\n      </adjustZoomBasedOnAspectRatio>\n\n      \n      \n      var minX, maxX;\n      if (params.zoom > fullWidthZoom) {\n        minX = maxX = 0.5;\n      } else {\n        <calculateMinMaxX>\n        minX = 0.0 + 0.5 * params.zoom / fullWidthZoom;\n        maxX = 1.0 - 0.5 * params.zoom / fullWidthZoom;\n        </calculateMinMaxX>\n      }\n\n      \n      \n      var minY, maxY;\n      if (params.zoom > fullHeightZoom) {\n        minY = maxY = 0.5;\n      } else {\n        <calculateMinMaxY>\n        minY = 0.0 + 0.5 * params.zoom / fullHeightZoom;\n        maxY = 1.0 - 0.5 * params.zoom / fullHeightZoom;\n        </calculateMinMaxY>\n      }\n\n      <clampParameters>\n      params.x = clamp(params.x, minX, maxX);\n      params.y = clamp(params.y, minY, maxY);\n      </clampParameters>\n\n      return params;\n    };\n  }\n"], ["setPermissions", "\nfunction(permissions, negative) {\n            if (!negative) {\n                negative = false;\n            }\n            if (permissions !== null && Array.isArray(permissions)) {\n                if (negative) {\n                    this.permissions.exclude = permissions;\n                } else {\n                    this.permissions.include = permissions;\n                }\n            }\n        }\n"], ["initializeComponent", "\nfunction(layer, lonlat, data) {\n    this.layer = layer;\n    this.lonlat = lonlat;\n    this.data = (data != null) ? data : {};\n    this.id = OpenLayers.Util.createUniqueID(this.CLASS_NAME + \"_\"); \n}\n"], ["configureBuilder", "\nfunction (flagOrBuilder) {\n        if (_.isFunction(flagOrBuilder)) {\n            this.object(flagOrBuilder);\n        }\n\n        if (flagOrBuilder == null || flagOrBuilder) {\n            this.isArray = true;\n        } else {\n            delete this.isArray;\n        }\n\n        return this;\n    }\n"], ["serverConfiguration", "\nfunction(options, section, option, value) {\n    var req = {url: this.urlPrefix + \"/_config/\"};\n    if (section) {\n        req.url += encodeURIComponent(section) + \"/\";\n        if (option) {\n            req.url += encodeURIComponent(option);\n        }\n    }\n    if (value === null) {\n        req.type = \"DELETE\";        \n    } else if (value !== undefined) {\n        <prepareRequest>\n        req.type = \"PUT\";\n        req.data = toJSON(value);\n        req.contentType = \"application/json\";\n        req.processData = false\n        </prepareRequest>\n    }\n\n    <sendAjaxRequest>\n    ajax(req, options,\n        \"An error occurred retrieving/updating the server configuration\"\n    );\n    </sendAjaxRequest>\n}\n"], "```"]