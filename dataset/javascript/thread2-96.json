[["createElement", "\nfunction(descriptor, options) {\n  var options = options || {};\n\n  <parseTagName>\n  var tagName = /^([a-zA-Z0-9]*)/.exec(descriptor);\n  options.tag = tagName && tagName[1] ? tagName[1] : 'div';\n  </parseTagName>\n\n  <parseId>\n  var id = /#([a-zA-Z0-9_]*)/.exec(descriptor);\n  if (id && id[1]) options.id = id[1];\n  </parseId>\n\n  <parseClasses>\n  var matchClasses = new SRegExp(/\\.([a-zA-Z0-9_-]*)/g);\n  if (!options.class) {\n    options.class = matchClasses.match(descriptor).map(function(m) {\n      return m.match[1];\n    }).join(' ');\n  }\n  </parseClasses>\n\n  return new ElementRenderer(options);\n}\n"], ["carveMaze", "\nfunction(x, y, depth, maxDepth) {\n  <checkMaxDepth>\n  if (depth >= maxDepth) {\n    console.warn(\"MAXIMUM DEPTH REACHED: %d\", maxDepth);\n    return;\n  }\n  </checkMaxDepth>\n\n  <validateCell>\n  if (!this.isCell(x, y)) {\n    return;\n  }\n  </validateCell>\n\n  <processNeighbors>\n  let dirs = this.getShuffledNeighborDirs(x, y);\n  for (var key in dirs) {\n    var sDir = dirs[key];\n    var n = this.getNeighbor(x, y, sDir);\n    if (n === null) {\n      continue;\n    }\n\n    if (this.isMasked(n.x, n.y)) {\n      continue;\n    }\n\n    if (this.isCell(n.x, n.y) && !this.hasConnections(n.x, n.y)) {\n      this.connectUndirected(x, y, sDir);\n      this.carveMaze(n.x, n.y, depth + 1, maxDepth);\n    }\n  }\n  </processNeighbors>\n}\n"], ["curatedDeviceDisconnected", "\nfunction curatedDeviceDisconnected(eventData) {\n  self.log(' *** Handle', self.handle, 'triggered event: DEVICE_DISCONNECTED', eventData.name, eventData.operation);\n}\n"], ["pinchControlInitialization", "\nfunction(options) {\n  OpenLayers.Control.prototype.initialize.apply(this, arguments);\n  this.handler = new OpenLayers.Handler.Pinch(this, {\n    start: this.pinchStart,\n    move: this.pinchMove,\n    done: this.pinchDone\n  }, this.handlerOptions);\n}\n"], ["processStdin", "\nfunction stdin() {\n  var buf = '';\n  process.stdin.setEncoding('utf8');\n  \n  <readStdin>\n  process.stdin.on('data', function(chunk) {\n    buf += chunk;\n  });\n  </readStdin>\n\n  <compileOutput>\n  process.stdin.on('end', function() {\n    var output;\n    if (options.client) {\n      output = pug.compileClient(buf, options);\n    } else {\n      var fn = pug.compile(buf, options);\n      output = fn(options);\n    }\n    process.stdout.write(output);\n  }).resume();\n  </compileOutput>\n}\n"], ["getSVGFromChart", "\nfunction (additionalOptions) {\n  var chart = this,\n    chartCopy,\n    sandbox,\n    svg,\n    seriesOptions,\n    sourceWidth,\n    sourceHeight,\n    cssWidth,\n    cssHeight,\n    options = merge(chart.options, additionalOptions); \n\n  <setDocument>\n  if (!doc.createElementNS) {\n    \n  }\n  </setDocument>\n\n  <prepareSandbox>\n  sandbox = createElement(DIV, null, {\n    position: ABSOLUTE,\n    top: '-9999em',\n    width: chart.chartWidth + PX,\n    height: chart.chartHeight + PX\n  }, doc.body);\n  </prepareSandbox>\n\n  <calculateDimensions>\n  cssWidth = chart.renderTo.style.width;\n  cssHeight = chart.renderTo.style.height;\n  sourceWidth = options.exporting.sourceWidth ||\n    options.chart.width ||\n    (/px$/.test(cssWidth) && parseInt(cssWidth, 10)) ||\n    600;\n  sourceHeight = options.exporting.sourceHeight ||\n    options.chart.height ||\n    (/px$/.test(cssHeight) && parseInt(cssHeight, 10)) ||\n    400;\n  </calculateDimensions>\n\n  <updateChartOptions>\n  extend(options.chart, {\n    animation: false,\n    renderTo: sandbox,\n    forExport: true,\n    width: sourceWidth,\n    height: sourceHeight\n  });\n  options.exporting.enabled = false; \n  delete options.data; \n  </updateChartOptions>\n\n  <buildChartCopy>\n  options.series = [];\n  each(chart.series, function (serie) {\n    seriesOptions = merge(serie.options, {\n      animation: false, \n      enableMouseTracking: false,\n      showCheckbox: false,\n      visible: serie.visible\n    });\n\n    if (!seriesOptions.isInternal) { \n      options.series.push(seriesOptions);\n    }\n  });\n  </buildChartCopy>\n\n  <mergeAdditionalOptions>\n  if (additionalOptions) {\n    each(['xAxis', 'yAxis'], function (axisType) {\n      each(splat(additionalOptions[axisType]), function (axisOptions, i) {\n        options[axisType][i] = merge(options[axisType][i], axisOptions);\n      });\n    });\n  }\n  </mergeAdditionalOptions>\n\n  <finalizeChartCopy>\n  chartCopy = new Highcharts.Chart(options, chart.callback);\n  </finalizeChartCopy>\n\n  <adjustAxes>\n  each(['xAxis', 'yAxis'], function (axisType) {\n    each(chart[axisType], function (axis, i) {\n      var axisCopy = chartCopy[axisType][i],\n        extremes = axis.getExtremes(),\n        userMin = extremes.userMin,\n        userMax = extremes.userMax;\n\n      if (axisCopy && (userMin !== UNDEFINED || userMax !== UNDEFINED)) {\n        axisCopy.setExtremes(userMin, userMax, true, false);\n      }\n    });\n  });\n  </adjustAxes>\n\n  <retrieveSVG>\n  svg = chartCopy.container.innerHTML;\n  </retrieveSVG>\n\n  <cleanup>\n  options = null;\n  chartCopy.destroy();\n  discardElement(sandbox);\n  </cleanup>\n\n  <sanitizeAndFormatSVG>\n  svg = this.sanitizeSVG(svg);\n  svg = svg.replace(/(url\\(#highcharts-[0-9]+)&quot;/g, '$1')\n    .replace(/&quot;/g, \"'\");\n  </sanitizeAndFormatSVG>\n\n  return svg;\n}\n"], ["initializePhysics", "\nfunction () {\n  var data = this.data;\n\n  <setupDebugging>\n  this.debug = data.debug;\n  </setupDebugging>\n\n  <initializeCallbacks>\n  this.callbacks = {beforeStep: [], step: [], afterStep: []};\n  </initializeCallbacks>\n\n  <setupEventListeners>\n  this.listeners = {};\n  </setupEventListeners>\n\n  <initializeDriver>\n  this.driver = null;\n  switch (data.driver) {\n    case 'local':\n      this.driver = new LocalDriver();\n      break;\n\n    case 'network':\n      this.driver = new NetworkDriver(data.networkUrl);\n      break;\n\n    case 'worker':\n      this.driver = new WorkerDriver({\n        fps: data.workerFps,\n        engine: data.workerEngine,\n        interpolate: data.workerInterpolate,\n        interpolationBufferSize: data.workerInterpBufferSize,\n        debug: data.workerDebug\n      });\n      break;\n\n    default:\n      throw new Error('[physics] Driver not recognized: \"%s\".', data.driver);\n  }\n  </initializeDriver>\n\n  <configureDriver>\n  this.driver.init({\n    quatNormalizeSkip: 0,\n    quatNormalizeFast: false,\n    solverIterations: data.iterations,\n    gravity: data.gravity\n  });\n\n  this.driver.addMaterial({name: 'defaultMaterial'});\n  this.driver.addMaterial({name: 'staticMaterial'});\n  this.driver.addContactMaterial('defaultMaterial', 'defaultMaterial', {\n    friction: data.friction,\n    restitution: data.restitution,\n    contactEquationStiffness: data.contactEquationStiffness,\n    contactEquationRelaxation: data.contactEquationRelaxation,\n    frictionEquationStiffness: data.frictionEquationStiffness,\n    frictionEquationRegularization: data.frictionEquationRegularization\n  });\n  this.driver.addContactMaterial('staticMaterial', 'defaultMaterial', {\n    friction: 1.0,\n    restitution: 0.0,\n    contactEquationStiffness: data.contactEquationStiffness,\n    contactEquationRelaxation: data.contactEquationRelaxation,\n    frictionEquationStiffness: data.frictionEquationStiffness,\n    frictionEquationRegularization: data.frictionEquationRegularization\n  });\n  </configureDriver>\n}\n"], ["filterValidRule", "\nfunction filterValidRule(rule) {\n  return (rule.hasOwnProperty('match') && typeof rule.match === \"object\")\n    && (rule.hasOwnProperty('use') && (\n      typeof rule.use === \"object\"\n      || typeof rule.use === \"function\"\n    ))\n    && (\n      (rule.match.hasOwnProperty('request'))\n      || (rule.match.hasOwnProperty('base'))\n    )\n}\n"], ["buildUpdateFn", "\nfunction buildUpdateFn(element, className, attrs) {\n  return function updateAttrValue(fallback) {\n    <updateWithInterpolationCheck>\n    if (!needsInterpolation(fallback)) {\n      attrs[attrs.$normalize(className)] = fallback;\n    }\n    </updateWithInterpolationCheck>\n  };\n}\n"], ["toggleOperationsDialog", "\nfunction(evt) {  \n  if (that._operationsDialog.isShowing()) {\n    that._operationsDialog.hide();\n  } else {\n    that._operationsDialog.show();\n  }\n}\n"], "```"]