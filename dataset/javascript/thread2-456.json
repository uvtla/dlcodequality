[["createHandler", "\nasync function _createHandler(model, request, Log) {\n  let payload = null\n\n  try {\n    <handlePayloadFormatting>\n    let isArray = true\n    if (!_.isArray(request.payload)) {\n      payload = [Object.assign({}, request.payload)]\n      isArray = false\n    } else {\n      payload = request.payload.map(item => {\n        return _.isObject(item) ? _.assignIn({}, item) : item\n      })\n    }\n    </handlePayloadFormatting>\n\n    <preprocessing>\n    try {\n      if (\n        model.routeOptions &&\n        model.routeOptions.create &&\n        model.routeOptions.create.pre\n      ) {\n        for (let document of payload) {\n          await model.routeOptions.create.pre(document, request, Log)\n        }\n      }\n    } catch (err) {\n      handleError(\n        err,\n        'There was a preprocessing error creating the resource.',\n        Boom.badRequest,\n        Log\n      )\n    }\n    </preprocessing>\n\n    <applyCreatedAt>\n    if (config.enableCreatedAt) {\n      for (let document of payload) {\n        document.createdAt = new Date()\n      }\n    }\n    </applyCreatedAt>\n\n    <createModel>\n    let data\n    try {\n      data = await model.create(payload)\n    } catch (err) {\n      Log.error(err)\n      if (err.code === 11000) {\n        throw Boom.conflict('There was a duplicate key error.')\n      } else {\n        throw Boom.badImplementation(\n          'There was an error creating the resource.'\n        )\n      }\n    }\n    </createModel>\n\n    <queryResponseData>\n    let attributes = QueryHelper.createAttributesFilter({}, model, Log)\n\n    data = data.map(item => {\n      return item._id\n    })\n\n    let result = await model\n      .find()\n      .where({ _id: { $in: data } })\n      .select(attributes)\n      .lean()\n      .exec()\n    </queryResponseData>\n\n    <postprocessing>\n    try {\n      if (\n        model.routeOptions &&\n        model.routeOptions.create &&\n        model.routeOptions.create.post\n      ) {\n        for (let document of result) {\n          await model.routeOptions.create.post(document, request, result, Log)\n        }\n      }\n    } catch (err) {\n      handleError(\n        err,\n        'There was a postprocessing error creating the resource.',\n        Boom.badRequest,\n        Log\n      )\n    }\n    </postprocessing>\n\n    <returnResult>\n    if (isArray) {\n      return result\n    } else {\n      return result[0]\n    }\n    </returnResult>\n  } catch (err) {\n    handleError(err, null, null, Log)\n  }\n}\n"], ["createAndPlaceLabel", "\nfunction(canvas, node, controller) {\n  var id = node.id, tag = this.getLabel(id);\n  if(!tag && !(tag = document.getElementById(id))) {\n    <createNewLabel>\n    var ns = 'http://www.w3.org/2000/svg';\n    tag = document.createElementNS(ns, 'svg:text');\n    var tspan = document.createElementNS(ns, 'svg:tspan');\n    tag.appendChild(tspan);\n    var container = this.getLabelContainer();\n    tag.setAttribute('id', id);\n    tag.setAttribute('class', 'node');\n    container.appendChild(tag);\n    controller.onCreateLabel(tag, node);\n    this.labels[node.id] = tag;\n    </createNewLabel>\n  }\n  <placeExistingLabel>\n  this.placeLabel(tag, node, controller);\n  </placeExistingLabel>\n}\n"], ["formatChartTicks", "\nfunction(tickValue, index, ticks) {\n  <calculateDelta>\n  var delta = ticks.length > 3 ? ticks[2] - ticks[1] : ticks[1] - ticks[0];\n  </calculateDelta>\n\n  <adjustDeltaForFractionalValues>\n  if (Math.abs(delta) > 1) {\n    if (tickValue !== Math.floor(tickValue)) {\n      delta = tickValue - Math.floor(tickValue);\n    }\n  }\n  </adjustDeltaForFractionalValues>\n\n  <calculateTickString>\n  var logDelta = helpers.log10(Math.abs(delta));\n  var tickString = '';\n\n  if (tickValue !== 0) {\n    var numDecimal = -1 * Math.floor(logDelta);\n    numDecimal = Math.max(Math.min(numDecimal, 20), 0);\n    tickString = tickValue.toFixed(numDecimal);\n  } else {\n    tickString = '0';\n  }\n  </calculateTickString>\n\n  return tickString;\n}\n"], ["extractMethodName", "\nfunction methodNameFromTree(tree) {\n  <handleComputedPropertyName>\n  if (tree.type === COMPUTED_PROPERTY_NAME) {\n    return '';\n  }\n  </handleComputedPropertyName>\n\n  <handleStringLiteralToken>\n  if (tree.literalToken && tree.literalToken.type === STRING) {\n    return tree.getStringValue().substr(1, -1);\n  }\n  </handleStringLiteralToken>\n\n  <getStringValue>\n  return tree.getStringValue();\n  </getStringValue>\n}\n"], ["createCSSObject", "\nfunction cssobj$1 (obj, config, state) {\n  <setConfigDefaults>\n  config = config || {};\n\n  var local = config.local;\n  config.local = !local\n    ? {space: ''}\n    : local && typeof local === 'object' ? local : {};\n\n  config.plugins = [].concat(\n    config.plugins || [],\n    cssobj_plugin_selector_localize(config.local),\n    cssobj_plugin_post_cssom(config.cssom)\n  );\n  </setConfigDefaults>\n\n  <initializeCSSObject>\n  return cssobj(config)(obj, state)\n  </initializeCSSObject>\n}\n"], ["fetchRelations", "\nfunction(options) {\n  options = options || {};\n  var self = this;\n  var fns = [];\n\n  <gatherFetchFunctions>\n  _.each(self.relationDefinitions, function(relationAttributes, relationKey) {\n    if (_.isArray(options.onlyRelations)) {\n      if (options.onlyRelations.indexOf(relationKey) === -1) return;\n    }\n    var relation = self.get(relationKey);\n    if (relation && !relation.url) {\n      return;\n    }\n    if (relation && relation.fetch) {\n      var fetchOpts = _.has(options.relation, relationKey)\n        ? _.clone(options.relation[relationKey])\n        : _.clone(options);\n      fns.push(_.bind(relation.fetch, relation, fetchOpts));\n    }\n  }, this);\n  </gatherFetchFunctions>\n\n  <executeFetchFunctions>\n  return parallel(fns)\n    .then(function relationsFetched() {\n      self.fetchStatus = 'all_fetched';\n      return self;\n    }, function error(err) {\n      if (options.ignoreFailures) {\n        self.fetchStatus = 'all_fetched';\n        return when.resolve(self);\n      }\n      return when.reject(err);\n    });\n    </executeFetchFunctions>\n}\n"], ["processAPIResponse", "\nfunction apiResponded(apiResponse) {\n  <initializeParser>\n  var parser = new xml2js.Parser({explicitArray:false});\n  </initializeParser>\n\n  <parseXMLResponse>\n  parser.parseString(apiResponse, function (err, result) {\n    <processParsedResponse>\n    if(typeof a.processor !== 'undefined')\n      a.processor(result.response, a.callback);\n    else\n      a.callback(result.response);\n    </processParsedResponse>\n  });\n  </parseXMLResponse>\n}\n"], ["invokeCallbackOnValueMatch", "\nfunction(o,value,fn){\n  <forEachValueMatch>\n  this.forEach(o,function everymover(e,i,b){\n    if(e === value){\n     if(fn) fn.call(this,e,i,b);\n    }\n  },this);\n  </forEachValueMatch>\n  return;\n}\n"], ["searchRangeQuadTree", "\nfunction(queryLow, queryHigh) {\n  <validateArguments>\n  this.validateFindArguments_(queryLow, queryHigh);\n  </validateArguments>\n\n  if (this.root_ === undefined)\n    return [];\n\n  <findIntersections>\n  var ret = [];\n  this.root_.appendIntersectionsInto_(ret, queryLow, queryHigh);\n  </findIntersections>\n\n  return ret;\n}\n"], ["getType", "\nfunction getType (val) {\n  if (val === null) {\n    return 'null'\n  } else if (val === void 0) {\n    return 'undefined'\n  }\n  <determineType>\n  return Object.prototype.toString.call(val)\n    .replace(/^\\[.+\\s(.+?)]$/, '$1')\n    .toLowerCase()\n  </determineType>\n}\n"], ""]