[["getHeaderElement", "\nfunction(theadCell) {\n    var elTh;    \n    if (theadCell instanceof YAHOO.widget.Column) {\n        var oColumn = theadCell;\n        <getColumnHeader>\n        elTh = oColumn.getThEl();\n        </getColumnHeader>\n        if(elTh) {\n            return elTh;\n        }\n    }    \n    else {\n        <getDomElement>\n        var el = Dom.get(theadCell);\n        </getDomElement>\n\n        if(el && (el.ownerDocument == document)) {            \n            if(el.nodeName.toLowerCase() != \"th\") {                \n                <findAncestor>\n                elTh = Dom.getAncestorByTagName(el,\"th\");\n                </findAncestor>\n            }\n            else {\n                elTh = el;\n            }\n\n            return elTh;\n        }\n    }\n    return null;\n}\n"], ["readYml", "\nfunction readYml(file, fn) {\n\n  var m;\n  <initializeApi>\n  var api = {};\n  </initializeApi>\n  <safeLoadYaml>\n  var resource = yaml.safeLoad(fs.readFileSync(file, 'utf8'));\n  </safeLoadYaml>\n  <iteratePaths>\n  var paths = Object.keys(resource.paths);\n  _.each(paths, function(path) {\n    <handleApiPrefix>\n    if (options.apiPrefix && path.indexOf(options.apiPrefix) === 0){\n        path = path.replace(options.apiPrefix, \"\");\n    }\n    </handleApiPrefix>\n    <assignApiProperties>\n    api.resourcePath = path;\n    api.description = resource.description || \"\";\n    descriptor.paths[path] = resource.paths[path];\n    </assignApiProperties>\n\n    <mergeDefinitions>\n    if (descriptor.definitions && Object.keys(descriptor.definitions).length) {\n      m = _.merge(descriptor.definitions, resource.definitions);\n      descriptor.definitions = m;\n    } else {\n      descriptor.definitions = resource.definitions;\n    }\n    </mergeDefinitions>\n  });\n  </iteratePaths>\n\n  <callCallback>\n  fn();\n  </callCallback>\n}\n"], ["compileRegularHoliday", "\nfunction compileRegularHoliday(value) {\n  if (typeof value === 'function') {\n    return value;\n  } else if (typeof value === 'string') {\n    <convertStringToHolidays>\n    return stringToRegularHolidays(value);\n    </convertStringToHolidays>\n  } else if (typeof value === 'number' &&  1 <= value && value <= 31) {\n    <constructNumberBasedHoliday>\n    var regular = {week: {}, day: {}, xweek:{}};\n    regular.day[value] = true;\n    return regular;\n    </constructNumberBasedHoliday>\n  } else {\n    <defaultHolidayStructure>\n    return {week: {}, day: {}, xweek:{}};\n    </defaultHolidayStructure>\n  }\n}\n"], ["RTCOutboundRTPStreamStats", "\nfunction RTCOutboundRTPStreamStats(rTCOutboundRTPStreamStatsDict){\n  <checkInstance>\n  if(!(this instanceof RTCOutboundRTPStreamStats))\n    return new RTCOutboundRTPStreamStats(rTCOutboundRTPStreamStatsDict)\n  </checkInstance>\n\n  <checkProperties>\n  <checkPacketsSent>\n  checkType('int', 'rTCOutboundRTPStreamStatsDict.packetsSent', rTCOutboundRTPStreamStatsDict.packetsSent, {required: true});\n  </checkPacketsSent>\n  <checkBytesSent>\n  checkType('int', 'rTCOutboundRTPStreamStatsDict.bytesSent', rTCOutboundRTPStreamStatsDict.bytesSent, {required: true});\n  </checkBytesSent>\n  <checkTargetBitrate>\n  checkType('float', 'rTCOutboundRTPStreamStatsDict.targetBitrate', rTCOutboundRTPStreamStatsDict.targetBitrate, {required: true});\n  </checkTargetBitrate>\n  <checkRoundTripTime>\n  checkType('float', 'rTCOutboundRTPStreamStatsDict.roundTripTime', rTCOutboundRTPStreamStatsDict.roundTripTime, {required: true});\n  </checkRoundTripTime>\n  </checkProperties>\n\n  <callParentConstructor>\n  RTCOutboundRTPStreamStats.super_.call(this, rTCOutboundRTPStreamStatsDict)\n  </callParentConstructor>\n\n  <defineProperties>\n  Object.defineProperties(this, {\n    packetsSent: {\n      writable: true,\n      enumerable: true,\n      value: rTCOutboundRTPStreamStatsDict.packetsSent\n    },\n    bytesSent: {\n      writable: true,\n      enumerable: true,\n      value: rTCOutboundRTPStreamStatsDict.bytesSent\n    },\n    targetBitrate: {\n      writable: true,\n      enumerable: true,\n      value: rTCOutboundRTPStreamStatsDict.targetBitrate\n    },\n    roundTripTime: {\n      writable: true,\n      enumerable: true,\n      value: rTCOutboundRTPStreamStatsDict.roundTripTime\n    }\n  })\n  </defineProperties>\n}\n"], ["getConfigPath", "\nfunction getConfigPath(configPaths) {\n  let conf = null;\n  <iterateConfigPaths>\n  some(configPaths, configPath => {\n    if (!configPath) return;\n    \n    <composeConfigPath>\n    const compiledConfigPath = template(configPath)(process.env);\n    let resolvedConfigPath = resolve(process.cwd(), compiledConfigPath);\n    const resolvedName = fileExists(resolvedConfigPath);\n    </composeConfigPath>\n\n    <checkResolvedConfigPath>\n    if (resolvedConfigPath && resolvedName) {\n      conf = resolvedName;\n    }\n    </checkResolvedConfigPath>\n\n    return conf;\n  });\n  </iterateConfigPaths>\n\n  <returnConfigPath>\n  return conf;\n  </returnConfigPath>\n}\n"], ["sectionSpaces", "\nfunction (req, res) {\n  let sectionId = req.query.oveSectionId;\n  if (sectionId === undefined) {  \n    <logAndSendAllSpaces>\n    log.debug('Returning parsed result of ' + Constants.SPACES_JSON_FILENAME);\n    Utils.sendMessage(res, HttpStatus.OK, JSON.stringify(server.spaces));\n    </logAndSendAllSpaces>\n  } else if (!server.state.get('sections[' + sectionId + ']')) {\n    <logAndSendEmptySuccess>\n    log.debug('Unable to produce list of spaces for section id:', sectionId);\n    Utils.sendEmptySuccess(res);\n    </logAndSendEmptySuccess>\n  } else {\n    <logAndSendSectionSpaces>\n    log.debug('Returning parsed result of ' + Constants.SPACES_JSON_FILENAME + ' for section id:', sectionId);\n    Utils.sendMessage(res, HttpStatus.OK, JSON.stringify(server.state.get('sections[' + sectionId + '][spaces]')));\n    </logAndSendSectionSpaces>\n  }\n}\n"], ["parseSearchString", "\nfunction parseSearchString(str) {\n\n    <replaceXTyesInTeq>\n    str = tia.cU.replaceXTypesInTeq(str);\n    </replaceXTyesInTeq>\n\n    <defineRegex>\n    var re = /&(\\w|\\d|_|-)+/g;\n    </defineRegex>\n\n    <initializeSearchData>\n    var searchData = [];\n    var prevLastIndex = 0;\n    var query;\n    </initializeSearchData>\n\n    <extractAndStoreQueries>\n    while (true) {\n      var reResult = re.exec(str);\n\n      if (reResult === null) {\n        <handleLastQuery>\n        query = str.slice(prevLastIndex).trim();\n        if (query) {\n          searchData.push({\n            query: query,\n          });\n        }\n        </handleLastQuery>\n        return searchData;\n      }\n\n      <handleMatchedQueries>\n      query = str.slice(prevLastIndex, reResult.index).trim();\n      var reference = str.slice(reResult.index + 1, re.lastIndex).trim();\n      prevLastIndex = re.lastIndex;\n\n      if (query) {\n        searchData.push({\n          query: query,\n        });\n      }\n\n      searchData.push({\n        reference: reference,\n      });\n      </handleMatchedQueries>\n    }\n    </extractAndStoreQueries>\n  }\n"], ["slide15", "\nfunction slide15() {\n\t\t\n    <createNewSlide>\n    var slide = pptx.addNewSlide();\n    slide.addNotes('API Docs: https://...');\n    slide.addTable( [ [{ text:'Chart Examples: Bubble Charts', options:gOptsTextL },gOptsTextR] ], gOptsTabOpts );\n    </createNewSlide>\n\n    <defineChartData>\n    var arrDataBubble1 = [\n        { name:'X-Axis',    values:[0.3,0.6,0.9,1.2,1.5,1.7] },\n        { name:'Y-Value 1', values:[1.3, 9, 7.5, 2.5, 7.5,  5], sizes:[1,4,2,3,7,4] },\n        { name:'Y-Value 2', values:[  5, 3,   2,   7,   2, 10], sizes:[9,7,9,2,4,8] }\n    ];\n    var arrDataBubble2 = [\n        { name:'X-Axis',   values:[1, 2, 3, 4, 5, 6] },\n        { name:'Airplane', values:[33, 20, 51, 65, 71, 75], sizes:[10,10,12,12,15,20] },\n        { name:'Train',    values:[99, 88, 77, 89, 99, 99], sizes:[20,20,22,22,25,30] },\n        { name:'Bus',      values:[21, 22, 25, 49, 59, 69], sizes:[11,11,13,13,16,21] }\n    ];\n    </defineChartData>\n\n    <createBubbleChartOptions>\n    var optsChartBubble1 = { ... };\n    var optsChartBubble2 = { ... };\n    var optsChartBubble3 = { ... };\n    var optsChartBubble4 = { ... };\n    </createBubbleChartOptions>\n    \n    <addChartsToSlide>\n    slide.addText( '.', { ... } );\n    slide.addChart( pptx.charts.BUBBLE, arrDataBubble1, optsChartBubble1 );\n    slide.addChart( pptx.charts.BUBBLE, arrDataBubble2, optsChartBubble2 );\n    slide.addChart( pptx.charts.BUBBLE, arrDataBubble1, optsChartBubble3 );\n    slide.addChart( pptx.charts.BUBBLE, arrDataBubble2, optsChartBubble4 );\n    </addChartsToSlide>\n}\n"], ["getTangentLine", "\nfunction(t) {\n    <checkDifferentiability>\n    if (!this.isDifferentiable()) return null;\n    </checkDifferentiability>\n\n    <clampValue>\n    if (t < 0) t = 0;\n    else if (t > 1) t = 1;\n    </clampValue>\n\n    <calculateSkeletonPoints>\n    var skeletonPoints = this.getSkeletonPoints(t);\n    </calculateSkeletonPoints>\n\n    <constructTangentLine>\n    var p1 = skeletonPoints.startControlPoint2;\n    var p2 = skeletonPoints.dividerControlPoint1;\n    var tangentStart = skeletonPoints.divider;\n    var tangentLine = new Line(p1, p2);\n    tangentLine.translate(tangentStart.x - p1.x, tangentStart.y - p1.y); \n    </constructTangentLine>\n\n    <returnTangentLine>\n    return tangentLine;\n    </returnTangentLine>\n}\n"], ["adjustConnectedBlocks", "\nfunction(e) {\n    <identifyConnectedBlocks>\n    var blockA = this.getInputTargetBlock('THEN');\n    var blockB = this.getInputTargetBlock('ELSE');\n    var parentConnection = this.outputConnection.targetConnection;\n    </identifyConnectedBlocks>\n\n    <checkCompatibility>\n    if ((blockA || blockB) && parentConnection) {\n      for (var i = 0; i < 2; i++) {\n        var block = (i == 1) ? blockA : blockB;\n        if (block && !block.outputConnection.checkType_(parentConnection)) {\n          <handleIncompatibleBlock>\n          Blockly.Events.setGroup(e.group);\n          if (parentConnection === this.prevParentConnection_) {\n            this.unplug();\n            parentConnection.getSourceBlock().bumpNeighbours_();\n          } else {\n            block.unplug();\n            block.bumpNeighbours_();\n          }\n          Blockly.Events.setGroup(false);\n          </handleIncompatibleBlock>\n        }\n      }\n    }\n    </checkCompatibility>\n\n    <storePreviousParentConnection>\n    this.prevParentConnection_ = parentConnection;\n    </storePreviousParentConnection>\n}\n"], "```"]