[["fixRedirectedResponse", "\nfunction fixRedirectedResponse(response) {\n  if (isNotRedirectedResponse(response)) {\n    return Promise.resolve(response);\n  }\n\n  <responseBodyRetrieval>\n  const body = 'body' in response ?\n    Promise.resolve(response.body) : response.blob(); \n  </responseBodyRetrieval>\n\n  <createNewResponse>\n  return body.then(data => {\n    return new Response(data, {\n      headers: response.headers,\n      status: response.status\n    });\n  });\n  </createNewResponse>\n}\n"], ["send", "\nfunction send(stream) {\n  res.setHeader('content-type', mimetype);\n\n  <handleCacheControl>\n  if (config.setCacheControl && !isNaN(config.maxAge)) {\n    res.setHeader('Cache-Control', `public, max-age=${Math.floor(config.maxAge / 1000)}`)\n  }\n  </handleCacheControl>\n\n  <handleBeforeSend>\n  if (config.beforeSend === 'function') {\n    config.beforeSend(res, stream);\n  }\n  </handleBeforeSend>\n  \n  <streamToBuffer>\n  stream2buffer(stream, (err, buffer) => {\n    if (err) {\n      <handleStreamingError>\n      res.status(500).send('Internal Server Error');\n      return;\n      </handleStreamingError>\n    }\n    \n    <etagAndSend>\n    const eTag = etag(buffer);\n    const headers = req.headers;\n    \n    if (headers['if-none-match'] && headers['if-none-match'].replace('\"', '') === eTag) {\n      res.status(304);\n      res.setHeader('ETag', eTag);\n      res.setHeader('Content-Length', 0);\n      res.end();\n      return;\n    }\n    \n    res.setHeader('ETag', eTag);\n    res.send(buffer);\n    </etagAndSend>\n  });\n  </streamToBuffer>\n}\n"], ["fingerprint", "\nfunction fingerprint(key) {\n    assert.string(key, 'ssh_key');\n\n    <parseAndFingerprintKey>\n    var k = sshpk.parseKey(key, 'ssh');\n    return (k.fingerprint('md5').toString('hex'));\n    </parseAndFingerprintKey>\n}\n"], ["notify", "\nfunction notify() {\n    var args = arguments\n    <invokeHandlers>\n    handlers.forEach(function(f){ f.apply(null, args) })\n    </invokeHandlers>\n}\n"], ["_makeCenteredTippy", "\nfunction _makeCenteredTippy() {\n  <configureTippyOptions>\n  const tippyOptions = {\n    content: this.el,\n    placement: 'top',\n    ...this.options.tippyOptions\n  };\n\n  tippyOptions.arrow = false;\n  tippyOptions.popperOptions = tippyOptions.popperOptions || {};\n\n  const finalPopperOptions = Object.assign(\n    {},\n    defaultPopperOptions,\n    tippyOptions.popperOptions,\n    {\n      modifiers: Object.assign(\n        centeredStylePopperModifier,\n        tippyOptions.popperOptions.modifiers\n      )\n    }\n  );\n\n  tippyOptions.popperOptions = finalPopperOptions;\n  </configureTippyOptions>\n\n  <createTippyInstance>\n  return tippy(document.body, tippyOptions);\n  </createTippyInstance>\n}\n"], ["onHardwareBackButton", "\nfunction onHardwareBackButton(e) {\n    <determineNavigationAction>\n    var backView = $ionicHistory.backView();\n    if (backView) {\n      \n      backView.go();\n    } else {\n      \n      ionic.Platform.exitApp();\n    }\n    e.preventDefault();\n    </determineNavigationAction>\n    return false;\n}\n"], ["remove", "\nfunction remove(server, labels) {\n  <deleteLabelsAndHandleResponse>\n  return (0, _label.deleteLabels)((0, _config.configure)(server), labels).then(_handlers.deleteSuccessHandler).catch(_handlers.errorHandler);\n  </deleteLabelsAndHandleResponse>\n}\n"], ["Row", "\nfunction Row(clone) {\n  <cloneRowData>\n\tthis.raw = {};\n\n\tif (clone) {\n\t\tif (clone.raw) clone = clone.raw;\n\t\tfor (var k in clone)\n\t\t\tthis.raw[k] = clone[k];\n\t}\n  </cloneRowData>\n}\n"], ["syncThroughHeaders", "\nfunction syncThroughHeaders (prevHeader) {\n    <prepareHexHeaders>\n    var hexHeaders = headersChain.map(function (data) {\n      return util.header2buffer(data).toString('hex')\n    })\n    </prepareHexHeaders>\n\n    <syncHeadersPromiseChain>\n    return Promise.try(function () {\n      \n      var targets = {}\n      <getCachedTarget>\n      function getCachedTarget (chunkIndex) {\n        if (targets[chunkIndex] !== undefined) {\n          return Promise.resolve(targets[chunkIndex])\n        }\n\n        return getTarget.apply(null, arguments)\n          .then(function (target) {\n            targets[chunkIndex] = target\n            return target\n          })\n      }\n      </getCachedTarget>\n\n      var getHeaderFn = self.getHeader.bind(self)\n      <reduceHeaders>\n      return Promise.reduce(headersChain, function (prevHeader, header) {\n        var chunkIndex = Math.floor(header.height / 2016)\n        return getCachedTarget(chunkIndex, headersChain, getHeaderFn)\n          .then(function (target) {\n            verifyHeader(header.hash, header,\n                         prevHeader.hash, prevHeader, target, self._isTestnet)\n\n            return header\n          })\n      }, prevHeader)\n      </reduceHeaders>\n    })\n    <updateStorageWithHeader>\n    .then(function () {\n      return self.storage.setLastHash(_.last(headersChain).hash)\n    })\n    </updateStorageWithHeader>\n    <handleCompactStorage>\n    .then(function () {\n      return self.storage.compactMode\n        ? self.storage.getChunkHashesCount()\n        : null\n    })\n    .then(function (chunkHashesCount) {\n      var lastHeaderChunkIndex = Math.floor(_.last(headersChain).height / 2016)\n      \n      \n      \n      if (!self.storage.compactMode ||\n          chunkHashesCount === lastHeaderChunkIndex) {\n        return self.storage.putHeaders(hexHeaders)\n      }\n\n      \n      return self.storage.getHeadersCount()\n        .then(function (headersCount) {\n          \n          return Promise.map(_.range(headersCount), function (index) {\n            return self.storage.getHeader(index)\n          })\n        })\n        .then(function (headers) {\n          \n          \n          for (var index = 0; headers.length !== 2016; index += 1) {\n            headers.push(hexHeaders[index])\n          }\n\n          \n          var rawChunk = new Buffer(headers.join(''), 'hex')\n          var chunkHash = util.hashEncode(util.sha256x2(rawChunk))\n\n          \n          return Promise.all([\n            self.storage.putChunkHashes([chunkHash]),\n            self.storage.truncateHeaders(0)\n          ])\n        })\n        .then(function () {\n          \n          var startHeight = chunkHashesCount * 2016\n          var hexHeaders = _.chain(headersChain)\n            .filter(function (header) {\n              return header.height >= startHeight\n            })\n            .map(function (header) {\n              return util.header2buffer(header).toString('hex')\n            })\n            .value()\n\n          \n          return self.storage.putHeaders(hexHeaders)\n        })\n    })\n    </handleCompactStorage>\n    <emitNewBlock>\n    .then(function () {\n      \n      var latest = _.last(headersChain)\n      self.latest = {hash: latest.hash, height: latest.height}\n      self.emit('newBlock', self.latest.hash, self.latest.height)\n    })\n    </emitNewBlock>\n  }\n"], ["setHeaders", "\nfunction setHeaders(req, headers) {\n    <setRequestHeaders>\n    var i;\n    for (i = 0; i < headers.length; ++i) {\n        req.setRequestHeader(headers[i][0], headers[i][1]);\n    }\n    </setRequestHeaders>\n}\n"], "```"]