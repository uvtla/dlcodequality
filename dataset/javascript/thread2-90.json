[["calculateRpcReward", "\nfunction (poolRecipient, recipients, rpcData) {\n\n    var reward = rpcData.coinbasevalue;\n    var rewardToPool = reward;\n\n    var txOutputBuffers = [];\n\n    if (rpcData.masternode && rpcData.superblock) {\n        <distributeMasternodeSuperblockReward>\n        if (rpcData.masternode.payee) {\n            var payeeReward = 0;\n\n            payeeReward = rpcData.masternode.amount;\n            reward -= payeeReward;\n            rewardToPool -= payeeReward;\n\n            var payeeScript = util.addressToScript(rpcData.masternode.payee);\n            txOutputBuffers.push(Buffer.concat([\n                util.packInt64LE(payeeReward),\n                util.varIntBuffer(payeeScript.length),\n                payeeScript\n            ]));\n        } else if (rpcData.superblock.length > 0) {\n            for (var i in rpcData.superblock) {\n                var payeeReward = 0;\n\n                payeeReward = rpcData.superblock[i].amount;\n                reward -= payeeReward;\n                rewardToPool -= payeeReward;\n\n                var payeeScript = util.addressToScript(rpcData.superblock[i].payee);\n                txOutputBuffers.push(Buffer.concat([\n                    util.packInt64LE(payeeReward),\n                    util.varIntBuffer(payeeScript.length),\n                    payeeScript\n                ]));\n            }\n        }\n        </distributeMasternodeSuperblockReward>\n    }\n\n    <handleExtraPayee>\n    if (rpcData.payee) {\n        var payeeReward = 0;\n\n        if (rpcData.payee_amount) {\n            payeeReward = rpcData.payee_amount;\n        } else {\n            payeeReward = Math.ceil(reward / 5);\n        }\n\n        reward -= payeeReward;\n        rewardToPool -= payeeReward;\n\n        var payeeScript = util.addressToScript(rpcData.payee);\n        txOutputBuffers.push(Buffer.concat([\n            util.packInt64LE(payeeReward),\n            util.varIntBuffer(payeeScript.length),\n            payeeScript\n        ]));\n    }\n    </handleExtraPayee>\n\n    <distributeRewardToRecipients>\n    for (var i = 0; i < recipients.length; i++) {\n        var recipientReward = Math.floor(recipients[i].percent * reward);\n        rewardToPool -= recipientReward;\n\n        txOutputBuffers.push(Buffer.concat([\n            util.packInt64LE(recipientReward),\n            util.varIntBuffer(recipients[i].script.length),\n            recipients[i].script\n        ]));\n    }\n    </distributeRewardToRecipients>\n\n    <allocatePoolReward>\n    txOutputBuffers.unshift(Buffer.concat([\n        util.packInt64LE(rewardToPool),\n        util.varIntBuffer(poolRecipient.length),\n        poolRecipient\n    ]));\n    </allocatePoolReward>\n\n    <handleWitnessCommitment>\n    if (rpcData.default_witness_commitment !== undefined) {\n        witness_commitment = new Buffer(rpcData.default_witness_commitment, 'hex');\n        txOutputBuffers.unshift(Buffer.concat([\n            util.packInt64LE(0),\n            util.varIntBuffer(witness_commitment.length),\n            witness_commitment\n        ]));\n    }\n    </handleWitnessCommitment>\n\n    return Buffer.concat([\n        util.varIntBuffer(txOutputBuffers.length),\n        Buffer.concat(txOutputBuffers)\n    ]);\n}\n"], ["getPathWithQuery", "\nfunction (encodeQuery) {\n    var path = this.getPath();\n\n    <appendQueryString>\n    if (this.query.count()) {\n        path += (QUERY_SEPARATOR + this.getQueryString(encodeQuery));\n    }\n    </appendQueryString>\n\n    return path;\n}\n"], ["PaperRippleInitialization", "\nfunction PaperRipple(cfg) {\n    if (cfg === void 0) { cfg = {}; }\n    <initializeProperties>\n    this.waves = [];\n    this.initialOpacity = cfg.initialOpacity || 0.25;\n    this.opacityDecayVelocity = cfg.opacityDecayVelocity || 0.8;\n    this.initTarget(cfg && cfg.nodeType ? cfg : cfg.target && cfg.target.nodeType ? cfg.target : null);\n    this.recenters = cfg.recenters || this.recenters;\n    this.center = cfg.center || this.center;\n    this.round = cfg.round || this.round;\n    </initializeProperties>\n}\n"], ["loadAndRenderTemplate", "\nfunction loadTemplate() {\n  <generateTemplateData>\n  generateData();\n  </generateTemplateData>\n\n  return new Promise(function(resolve, reject) {\n    <loadTemplateFile>\n    $.get('src/demo-template.html', function(response) {\n      template = response;\n      <renderTemplate>\n      render();\n      </renderTemplate>\n      resolve();\n    }).fail(function() {\n      reject();\n    });\n    </loadTemplateFile>\n  });\n}\n"], ["extractAppArguments", "\nfunction selectAppArgs(options) {\n  return {\n    <gatherArguments>\n    name: options.name,\n    // ... (similar lines for each option property)\n    globalShortcuts: options.globalShortcuts,\n    </gatherArguments>\n  };\n}\n"], ["initializeComponent", "\nfunction (name, scope) {\n    var component = components[name];\n\n    <createComponent>\n    if (component) {\n        var args = [];\n        for (var i = 0; i < component.mixins.length; ++i) {\n            args.push(this.createComponent(component.mixins[i], scope));\n        }\n        args.unshift(scope);\n        return component.creator.apply(component.creator, args);\n    }\n    </createComponent>\n\n    return null;\n}\n"], ["copyEllipticCurvePoint", "\nfunction ecp_copy(R, N, l) {\n    mpn_copyi(R[0], N[0], l), mpn_copyi(R[1], N[1], l), mpn_copyi(R[2], N[2], l);\n    return R;\n}\n"], ["handleCompletionOnError", "\nfunction (error) {\n    if (typeof error === 'undefined') { error = null; }\n\n    <markAsCompleted>\n    if (completed === false) {\n        completed = true;\n    </markAsCompleted>\n\n    <destroyResources>\n    writer.destroy();\n    reader.destroy();\n    </destroyResources>\n\n    return cb(error);\n}\n"], ["WriteHtmlToDocument", "\nfunction (html) {\n    <openDocumentStream>\n    this.$.open('text/html', 'replace');\n    </openDocumentStream>\n\n    <setCustomDomainIfNeeded>\n    CKEDITOR.env.isCustomDomain() && (this.$.domain = document.domain);\n    </setCustomDomainIfNeeded>\n\n    <writeAndCloseDocument>\n    this.$.write(html);\n    this.$.close();\n    </writeAndCloseDocument>\n}\n"], ["eventCallbackWrapper", "\nfunction (evt) {\n    var args = (this._apply === true && ariaUtilsType.isArray(this._args)) ? this._args.slice() : [this._args];\n    var resIndex = (this._resIndex === undefined) ? 0 : this._resIndex;\n\n    <mergeEventIntoCallbackArguments>\n    if (resIndex > -1) {\n        args.splice(resIndex, 0, evt);\n    }\n    </mergeEventIntoCallbackArguments>\n\n    return this._function.apply(this._scope, args);\n}\n"], "```\n\nNote: Each function has been annotated based on its overall responsibility or distinct responsibilities. There are functions with single responsibilities, hence they are wrapped as a whole, while other functions contain multiple responsibilities indicated by internal tags."]