```javascript
<generateColors>
function generateColors(conf) {
  for (var key in conf.color) {
    if (typeof conf.color[key] !== 'string') continue;
    conf.color[key] = new Color(conf.color[key]);
  }
  return conf;
}
</generateColors>

<calculatePosition>
function (hostEl, targetEl, positionStr, appendToBody) {

  <parsePositionStr>
  var positionStrParts = positionStr.split('-');
  var pos0 = positionStrParts[0], pos1 = positionStrParts[1] || 'center';
  </parsePositionStr>

  var hostElPos,
    targetElWidth,
    targetElHeight,
    targetElPos;

  <calculateElementPositions>
  hostElPos = appendToBody ? this.offset(hostEl) : this.position(hostEl);
  targetElWidth = targetEl.prop('offsetWidth');
  targetElHeight = targetEl.prop('offsetHeight');
  </calculateElementPositions>

  <defineShiftFunctions>
  var shiftWidth = {
    center: function () {
      return hostElPos.left + hostElPos.width / 2 - targetElWidth / 2;
    },
    left: function () {
      return hostElPos.left;
    },
    right: function () {
      return hostElPos.left + hostElPos.width;
    }
  };

  var shiftHeight = {
    center: function () {
      return hostElPos.top + hostElPos.height / 2 - targetElHeight / 2;
    },
    top: function () {
      return hostElPos.top;
    },
    bottom: function () {
      return hostElPos.top + hostElPos.height;
    }
  };
  </defineShiftFunctions>

  <calculateTargetPosition>
  switch (pos0) {
    case 'right':
      targetElPos = {
        top: shiftHeight[pos1](),
        left: shiftWidth[pos0]()
      };
      break;
    case 'left':
      targetElPos = {
        top: shiftHeight[pos1](),
        left: hostElPos.left - targetElWidth
      };
      break;
    case 'bottom':
      targetElPos = {
        top: shiftHeight[pos0](),
        left: shiftWidth[pos1]()
      };
      break;
    default:
      targetElPos = {
        top: hostElPos.top - targetElHeight,
        left: shiftWidth[pos1]()
      };
      break;
  }
  </calculateTargetPosition>

  return targetElPos;
}
</calculatePosition>

<composeConfiguration>
function compose(...args) {
  
  const crsConfigs = args.slice(0).reverse();
  const crsConfig = {
    env: pipe(crsConfigs.map(c => c.env)),
    paths: pipe(crsConfigs.map(c => c.paths)),
    webpack: pipe(crsConfigs.map(c => c.webpack)),
    devServer: pipe(crsConfigs.map(c => c.devServer)),
    jest: pipe(crsConfigs.map(c => c.jest)),
    scripts: mergeScripts(crsConfigs.map(c => c.scripts)),
  };
  return crsConfig;
}
</composeConfiguration>

<numberType>
function numberType(mname, tpe, options) {
  const doubles = options.themeDoubles.split(',')
  if (doubles && doubles.includes(mname)) {
    return 'Double'
  } else {
    return 'Int'
  }
}
</numberType>

<slugify>
function slugify(str) {
  return str
    .replace(/[ÀÁÂÃÄÅàáâãäåæÆ]/g, 'a')
    .replace(/[çÇ]/g, 'c')
    .replace(/[ðÐ]/g, 'd')
    .replace(/[ÈÉÊËéèêë]/g, 'e')
    .replace(/[ÏïÎîÍíÌì]/g, 'i')
    .replace(/[Ññ]/g, 'n')
    .replace(/[øØœŒÕõÔôÓóÒò]/g, 'o')
    .replace(/[ÜüÛûÚúÙù]/g, 'u')
    .replace(/[ŸÿÝý]/g, 'y')
    .replace(/[^a-z0-9- ]/gi, '')
    .replace(/ /gi, '-')
    .toLowerCase();
}
</slugify>

<TransportsConstructor>
function Transports(oOptions, oLogger) {
    this._client = new AdtClient(oOptions.conn, oOptions.auth, undefined, oLogger);
}
</TransportsConstructor>

<removeRemote>
async function removeRemote(name) {
  try {
    await exec(`git remote remove ${name}`);
    logger.log(`Removed remote ${name}`);
  } catch (error) {
    throw error;
  }
}
</removeRemote>

<hasPermission>
function hasPermission (user, modelName, permission, callback) {

    <retrievePermissions>
    get(modelName, true).getPermissions(user, function (err, permissions) {

        if (err) {
            return callback(false);
        }

        return callback(permissions[permission]);

    });
    </retrievePermissions>

}
</hasPermission>

<deploySmartContract>
async function () {
  <logUUID>
    logger.step('** Getting UUID of ST prime contract from openSTUtility Contract');
    const stPrimeUUIDResponse = await openStUtility.getSimpleTokenPrimeUUID()
      , simpleTokenPrimeUUID = stPrimeUUIDResponse.data.simpleTokenPrimeUUID
    ;
    </logUUID>

    <checkUUIDLength>
    if (simpleTokenPrimeUUID.length <= 2) {
      logger.error('Exiting the deployment as simpleTokenPrimeUUID has invalid length');
      process.exit(1);
    }
    </checkUUIDLength>

    <logContractAddress>
    logger.step('** Getting address of ST prime contract from openSTUtility Contract');
    const getSimpleTokenPrimeContractAddressResponse = await openStUtility.getSimpleTokenPrimeContractAddress()
      , simpleTokenPrimeContractAddress = getSimpleTokenPrimeContractAddressResponse.data.simpleTokenPrimeContractAddress;
    </logContractAddress>

    <checkCodeLength>
    logger.step('** Checking if ST prime contract was deployed correctly at the address obtained');
    const code = await web3Provider.eth.getCode(simpleTokenPrimeContractAddress);
    if (code.length <= 2) {
      logger.error('Contract deployment failed. Invalid code length for contract: simpleTokenPrime');
      process.exit(1);
    }
    </checkCodeLength>

    <initializeTransfer>
    logger.step('** Initialize Transfer of ST Prime - all base tokens from initial ST Prime holder address to ST Prime contract address');
    const initialSTPrimeHolderBalanceInWei = await web3Provider.eth.getBalance(
      coreAddresses.getAddressForUser(utilityInitialSTPrimeHolder));

    if (initialSTPrimeHolderBalanceInWei != stPrimeTotalSupplyInWei) {
      logger.error('Initial ST Prime holder - ' + utilityInitialSTPrimeHolder + ' doesn\'t have max total supply of ST Prime');
      process.exit(1);
    }

    const stPrime = new StPrimeKlass(simpleTokenPrimeContractAddress);
    await stPrime.initialTransferToContract(utilityInitialSTPrimeHolder, {gasPrice: UC_GAS_PRICE, gas: UC_GAS_LIMIT});

    const simpleTokenPrimeContractBalanceInWei = await web3Provider.eth.getBalance(simpleTokenPrimeContractAddress);

    if (simpleTokenPrimeContractBalanceInWei != stPrimeTotalSupplyInWei) {
      logger.error('simpleTokenPrimeContract: ' + simpleTokenPrimeContractAddress + ' doesn\'t have max total supply of ST Prime');
      process.exit(1);
    }

    const initialSTPrimeHolderBalanceInWeiAfterTransfer = await web3Provider.eth.getBalance(coreAddresses.getAddressForUser(utilityInitialSTPrimeHolder));
    if (initialSTPrimeHolderBalanceInWeiAfterTransfer != 0) {
      logger.error('Initial ST Prime holder balance should be 0 after transfer');
      process.exit(1);
    }
    </initializeTransfer>

    return Promise.resolve(responseHelper.successWithData(
      {contract: 'stPrime', address: simpleTokenPrimeContractAddress, uuid: simpleTokenPrimeUUID}));
  }
</deploySmartContract>

<filterWithCallback>
function (callback, invert) {
    <defineCallbackInverse>
    var callbackInverse,
        matches = [],
        i = 0,
        length = this.length,
        callbackExpect = !invert;
    </defineCallbackInverse>

    <filterElements>
    for (; i < length; i++) {
        callbackInverse = !callback(this[i], i);
        if (callbackInverse !== callbackExpect) {
            matches.push(this[i]);
        }
    }
    </filterElements>

    return matches;
}
</filterWithCallback>
```