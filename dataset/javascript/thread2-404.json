[["unnamed", "\nfunction() {\n    <calculateDependencies>\n    var dependencies = this.__all__.reduce(function(all, mixin) {\n      return mixin instanceof Mixin.__class__ ?\n        all.concat(mixin.__mixins__()) :\n        all;\n    }, []);\n    return dependencies\n      .concat([this]); </calculateDependencies>\n}\n"], ["ShimEvent", "\nfunction ShimEvent(type, debug) {\n  <initializeEventProperties>\n  this.type = type;\n  this.debug = debug;\n  this.bubbles = false;\n  this.cancelable = false;\n  this.eventPhase = 0;\n  this.timeStamp = new Date().valueOf(); </initializeEventProperties>\n}\n"], ["validateForm", "\nfunction(formName) {\n    <validateFormFields>\n    this.currentForm = formName;\n    this.errors = {};\n\n    for (var fieldName in this.validationInformation[formName]) {\n        this.currentField = fieldName;\n        currentFieldsValidations = this.validationInformation[formName][fieldName];\n        currentFieldsValue = this.utils.getFieldsValue(this.currentForm, this.currentField);\n\n        for (i = 0; i < currentFieldsValidations.length; i++) {\n            var method,\n                parameters = [];\n\n            currentValidationMethodAndParameters = this.getValidationMethodAndParameters(currentFieldsValidations[i]);\n            method = currentValidationMethodAndParameters[0];\n\n            \n            if (currentValidationMethodAndParameters.length === 2) {\n                parameters = currentValidationMethodAndParameters[1];\n            }\n\n            if (! this.callValidationMethodWithParameters(method, parameters, currentFieldsValue)) {\n                parameters.shift();\n                this.messages.addValidationErrorMessage(method, parameters);\n            }\n        }\n    }\n    </validateFormFields>\n\n    \n    return this.utils.isEmptyObject(this.errors); </checkIfValidationPassed>\n}\n"], ["_initConverter", "\nfunction _initConverter(){\n    <setupCSVConverter>\n    var csvConverter = new Converter_1();\n    var started = false;\n    var writeStream = process.stdout;\n    csvConverter.on(\"record_parsed\",function(rowJSON){\n        if (started){\n            writeStream.write(\",\\n\");\n        }\n        writeStream.write(JSON.stringify(rowJSON));  \n        if (started === false){\n            started = true;\n        }\n    });\n    writeStream.write(\"[\\n\"); \n\n    csvConverter.on(\"end_parsed\",function(){\n        writeStream.write(\"\\n]\"); \n    });\n    csvConverter.on(\"error\",function(err){\n        console.error(err);\n        process.exit(-1);\n    });\n    </setupCSVConverter>\n    return csvConverter;\n}\n"], ["webpack_require", "\nfunction (module, exports, __webpack_require__) {\n\n  \"use strict\";\n\n  \n  \n\n  <checkPrerequisites>\n  if (__webpack_require__(6)) { </checkPrerequisites>\n    <webpack_module_implementation>\n    \n    </webpack_module_implementation>\n  <defaultCase>\n  } else module.exports = function () {}; </defaultCase>\n\n  \n}\n"], ["buildCatTasks", "\nfunction buildCatTasks (opts) {\n  \n  <retrieveUtilities>\n  const { makeRequest, ConfigurationError, handleError, snakeCaseKeys } = opts </retrieveUtilities>\n  \n\n  <defineAcceptedParameters>\n  const acceptedQuerystring = [\n    'format',\n    'node_id',\n    'actions',\n    'detailed',\n    'parent_task',\n    'h',\n    'help',\n    's',\n    'v',\n    'pretty',\n    'human',\n    'error_trace',\n    'source',\n    'filter_path'\n  ] </defineAcceptedParameters>\n\n  <mapParametersToSnakeCase>\n  const snakeCase = {\n    nodeId: 'node_id',\n    parentTask: 'parent_task',\n    errorTrace: 'error_trace',\n    filterPath: 'filter_path'\n  } </mapParametersToSnakeCase>\n\n  <catTasksFunction>\n  return function catTasks (params, options, callback) { </catTasksFunction>\n    <handleOptions>\n    options = options || {}\n    if (typeof options === 'function') {\n      callback = options\n      options = {}\n    }\n    if (typeof params === 'function' || params == null) {\n      callback = params\n      params = {}\n      options = {}\n    } </handleOptions>\n\n    \n    <validateRequestBody>\n    if (params.body != null) {\n      const err = new ConfigurationError('This API does not require a body')\n      return handleError(err, callback)\n    } </validateRequestBody>\n\n    \n    <validateHeaders>\n    if (options.headers != null && typeof options.headers !== 'object') {\n      const err = new ConfigurationError(`Headers should be an object, instead got: ${typeof options.headers}`)\n      return handleError(err, callback)\n    } </validateHeaders>\n\n    <variableDeclarations>\n    var warnings = []\n    var { method, body, ...querystring } = params\n    querystring = snakeCaseKeys(acceptedQuerystring, snakeCase, querystring, warnings)\n    </variableDeclarations>\n\n    <defaultRequestMethod>\n    if (method == null) {\n      method = 'GET'\n    } </defaultRequestMethod>\n\n    <handleIgnoreOption>\n    var ignore = options.ignore\n    if (typeof ignore === 'number') {\n      options.ignore = [ignore]\n    } </handleIgnoreOption>\n\n    <defineRequestPath>\n    var path = ''\n\n    path = '/' + '_cat' + '/' + 'tasks' </defineRequestPath>\n\n    \n    <createRequestObject>\n    const request = {\n      method,\n      path,\n      body: null,\n      querystring\n    } </createRequestObject>\n\n    <assignWarnings>\n    options.warnings = warnings.length === 0 ? null : warnings </assignWarnings>\n    <makeAPIRequest>\n    return makeRequest(request, options, callback)\n    </makeAPIRequest>\n  }\n}\n"], ["getDescription", "\nfunction getDescription(conversation) {\n    <constructDescription>\n    if (conversation.metadata.conversationersationName) {\n      return 'The Conversation ' + conversation.metadata.conversationersationName + ' has been deleted';\n    } else {\n      return 'The Conversation with ' +\n        conversation.participants.join(', ').replace(/(.*),(.*)/, '$1 and$2') +\n        ' has been deleted';\n    } </constructDescription>\n}\n"], ["filterDeps", "\nfunction filterDeps (deps) {\n  <handleEmptyFilterList>\n  if (!filterList.length) return deps </handleEmptyFilterList>\n\n  <filterDependencies>\n  return Object.keys(deps).reduce(function (filteredDeps, name) {\n    if (filterList.indexOf(name) !== -1) {\n      filteredDeps[name] = deps[name]\n    }\n    return filteredDeps\n  }, {}) </filterDependencies>\n}\n"], ["unnamed", "\nfunction() {\n    <initializeRomProperties>\n\t\tthis.prgBanks = this.header[4];\n\t\tthis.chrBanks = this.header[5];\n\t\tthis.ramBanks = this.header[8] || 1;\n\n\t\tthis.prgSize = this.prgBanks * 16 * 1024;\n\t\tthis.chrSize = this.chrBanks * 8 * 1024;\n\t\tthis.ramSize = this.ramBanks * 8 * 1024;\n\n\t\tthis.prgData = this.data.subarray( 0, this.prgSize );\n\n\t\tif ( this.chrBanks ) {\n\t\t\tthis.chrData = this.data.subarray( this.prgSize, this.prgSize + this.chrSize );\n\t\t} else {\n\t\t\t\n\t\t\tthis.chrData = new Uint8Array( 0x2000 );\n\t\t}\n\n\t\tthis.ramData = new Uint8Array( this.ramSize );\n\n\t\tthis.initMapper();\n\t\t</initializeRomProperties>\n}\n"], ["getLinks", "\nfunction getLinks(db, callback) {\n\n  \n  <manageCacheSetup>\n  let cacheKey = db.id + \"-\" + 'links';\n  let cache = cache_links.get(cacheKey);\n  if ( cache !== null ) {\n    return callback(null, cache);\n  } </manageCacheSetup>\n\n  \n  <executeDbQuery>\n  let select = \"SELECT link_category_title, link_title, link_description, link_url FROM rt_links;\";\n\n  \n  db.select(select, function(err, results) {\n\n    \n    if ( err ) {\n      return callback(err);\n    } </executeDbQuery>\n\n    \n    <prepareResponse>\n    let rtn = [];\n\n    \n    for ( let i = 0; i < results.length; i++ ) {\n      let row = results[i];\n\n      \n      let link = new Link(\n        row.link_category_title,\n        row.link_title,\n        row.link_description,\n        row.link_url\n      );\n\n      \n      rtn.push(link);\n    } </prepareResponse>\n\n    \n    <cacheResponse>\n    cache_links.put(cacheKey, rtn); </cacheResponse>\n\n    \n    <returnCallback>\n    return callback(null, rtn);\n    </returnCallback>\n\n  });\n\n}\n"], "```"]