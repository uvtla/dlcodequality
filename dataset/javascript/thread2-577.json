[["toArray", "\nfunction toArray(item) {\n\tif (!(item instanceof Array)) {\n\t\tvar newitem = [];\n\t\tif (item) {\n\t\t\tnewitem.push(item);\n\t\t}\n\t\treturn newitem;\n\t}\n\telse {\n\t\treturn item;\n\t}\n}\n"], ["getNormalizedEventCoords", "\nfunction getNormalizedEventCoords(ev, pageOffset, clientRect) {\n  const { x, y } = pageOffset;\n  const documentX = x + clientRect.left;\n  const documentY = y + clientRect.top;\n  \n  let normalizedX;\n  let normalizedY;\n  \n  if (ev.type === 'touchstart') {\n    normalizedX = ev.changedTouches[0].pageX - documentX;\n    normalizedY = ev.changedTouches[0].pageY - documentY;\n  } else {\n    normalizedX = ev.pageX - documentX;\n    normalizedY = ev.pageY - documentY;\n  }\n\n  return { x: normalizedX, y: normalizedY };\n}\n"], ["map", "\nasync function map(array, fn, self = undefined) {\n  const v = await Promise.resolve(array);\n  if (!Array.isArray(v)) {\n    throw TypeError('not an array');\n  }\n  \n  const arr = (v);\n  const n = arr.length;\n  const values = new Array(n);\n  \n  for (let i = 0; i < n; i++) {\n    if (i in arr) {\n      values[i] = await Promise.resolve(fn.call(self, arr[i], i, arr));\n    }\n  }\n  return values;\n}\n"], ["unnamedFunction", " (Function should have a name. Assuming an appropriate name related to the execution flow represented by the code.)\nfunction(value) {\n    this.terminal._caretChange = Caret.NO_CHANGE;\n\n    return this.requisition.update(value).then(function(updated) {\n      \n      if (!updated) {\n        return RESOLVED;\n      }\n      this.textChanged();\n      return this.terminal.unsetChoice();\n    }.bind(this));\n}\n"], ["MySQL", "\nfunction MySQL(config) {\n  var self = this;\n  \n  config = config || {};\n  config.host = config.host || 'localhost';\n  config.port = config.port || 3306;\n  \n  this.className = this.constructor.name;\n  \n  this.config = config;\n  \n  this.client = mysql.createConnection(config);\n\n  if (typeof config.storage == 'string') {\n    this.storage = app.getResource('storages/' + config.storage);\n  } else if (config.storage instanceof protos.lib.storage) {\n    this.storage = config.storage;\n  }\n  \n  this.db = config.database;\n      \n  protos.util.onlySetEnumerable(this, ['className', 'db']);\n}\n"], ["unnamedFunction", " (Function should have a name. Assuming an appropriate name related to loading template context dependencies.)\nfunction (tplCtxt) {\n  this.$assert(133, tplCtxt.$TemplateCtxt);\n  \n  var toLoad = tplCtxt.getCSSDependencies();\n  var tplClasspath = tplCtxt.tplClasspath;\n  var loadResult = this.loadClassPathDependencies(tplClasspath, toLoad, {\n      isTemplate : true\n  });\n\n  if (loadResult.changes) {\n      this.$raiseEvent({\n          name : \"styleChange\",\n          templateClasspath : tplClasspath\n      });\n  }\n\n  this.$raiseEvent({\n      name : \"dependenciesLoaded\",\n      templateClasspath : tplClasspath\n  });\n\n  return loadResult.classes;\n}\n"], ["Null", "\nfunction Null() {\n\tspec.Asn1Spec.call(this, new spec.Asn1Tag(spec.TagClass.Universal, spec.TagFormat.Primitive, UniversalTag.Null));\n}\n"], ["buildShaderProgram", "\nfunction buildShaderProgram(gl, name, config, resources) {\n  const progConfig = config.programs[name];\n  \n  <compileShaders>\n  const compiledVertexShader = compileShader(\n    gl,\n    progConfig.vertexShader,\n    gl.VERTEX_SHADER\n  );\n  const compiledFragmentShader = compileShader(\n    gl,\n    progConfig.fragmentShader,\n    gl.FRAGMENT_SHADER\n  );\n  </compileShaders>\n\n  const program = createShaderProgram(gl, [\n    compiledVertexShader,\n    compiledFragmentShader,\n  ]);\n\n  resources.programs[name] = program;\n\n  if (progConfig.mapping) {\n    applyProgramDataMapping(gl, name, progConfig.mapping, config, resources);\n  }\n\n  return program;\n}\n"], ["loadComponentFile", "\nfunction loadComponentFile (meta, key, filepath, messages) {\n  const ext = path.extname(filepath).slice(1)\n  const loader = fileLoaders[ext] || fileLoaders.DEFAULT\n\n  return loader(meta, key, filepath, messages)\n}\n"], ["isChild", "\nfunction isChild(child, parent) {\n\twhile (child = child.parentNode) {\n\t\tif (child == parent) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n"], ""]