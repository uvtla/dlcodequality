[["newDatagrid", "\nfunction newDatagrid(response) {\n  const now = new Date();\n  const date = now.toLocaleString('en-GB', { timeZone: 'Asia/Tokyo' });\n  <generateIds>\n  const instance = misc.uuidv4().slice(0, 8);\n  const viewID = misc.uuidv4().slice(0, 8);\n  const collectionID = response.workflowID.slice(0, 8);\n  </generateIds>\n  <prepareData>\n  const data = {\n    $schema: \"https://json-schema.org/draft/2020-12/schema\",\n    id: instance,\n    name: response.name,\n    views: [\n      {\n        $schema: \"https://json-schema.org/draft/2020-12/schema\",\n        viewID: viewID,\n        name: response.name,\n        viewType: \"datagrid\",\n        rows: collectionID,\n        checkpoints: [\n          { type: 'creation', date: date }\n        ]\n      }\n    ],\n    dataset: [\n      {\n        $schema: \"https://json-schema.org/draft/2020-12/schema\",\n        collectionID: collectionID,\n        name: response.name,\n        contents: [response]\n      }\n    ],\n    sessionStarted: date\n  };\n  </prepareData>\n  <saveData>\n  return putItem(data)\n    .then(() => ({ instance: instance, viewID: viewID }));\n  </saveData>\n}\n"], ["appendTag", "\nfunction appendTag(elem) {\n  <determineParent>\n  var parent;\n  if (!elem.parent || elem.parent.type === 'root') {\n    parent = find(destChildren, 'html');\n    if (parent) {\n      parent = find(parent.children, 'body');\n    }\n    if (parent) {\n      utils.appendChild(parent, elem);\n    } else {\n      utils.append(destChildren[destChildren.length - 1], elem);\n    }\n  } else {\n    utils.append(destChildren[destChildren.length - 1], elem);\n  }\n  </determineParent>\n}\n"], ["generateBezier", "\nfunction generateBezier(mX1, mY1, mX2, mY2) {\n  <initializeConstants>\n  var NEWTON_ITERATIONS = 4,\n      NEWTON_MIN_SLOPE = 0.001,\n      SUBDIVISION_PRECISION = 0.0000001,\n      SUBDIVISION_MAX_ITERATIONS = 10,\n      kSplineTableSize = 11,\n      kSampleStepSize = 1.0 / (kSplineTableSize - 1.0),\n      float32ArraySupported = \"Float32Array\" in window;\n  </initializeConstants>\n  <validateArguments>\n  if (arguments.length !== 4) {\n    return false;\n  }\n  for (var i = 0; i < 4; ++i) {\n    if (typeof arguments[i] !== \"number\" || isNaN(arguments[i]) || !isFinite(arguments[i])) {\n      return false;\n    }\n  }\n  </validateArguments>\n  <clampValues>\n  mX1 = Math.min(mX1, 1);\n  mX2 = Math.min(mX2, 1);\n  mX1 = Math.max(mX1, 0);\n  mX2 = Math.max(mX2, 0);\n  </clampValues>\n  \n  <createSampleValues>\n  var mSampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);\n  </createSampleValues>\n  \n  <defineBeizerFunctions>\n  function A(aA1, aA2) { return 1.0 - 3.0 * aA2 + 3.0 * aA1; }\n  function B(aA1, aA2) { return 3.0 * aA2 - 6.0 * aA1; }\n  function C(aA1)      { return 3.0 * aA1; }\n  function calcBezier(aT, aA1, aA2) { return ((A(aA1, aA2)*aT + B(aA1, aA2))*aT + C(aA1))*aT; }\n  function getSlope(aT, aA1, aA2) { return 3.0 * A(aA1, aA2)*aT*aT + 2.0 * B(aA1, aA2) * aT + C(aA1); }\n  function newtonRaphsonIterate(aX, aGuessT) {\n    for (var i = 0; i < NEWTON_ITERATIONS; ++i) {\n      var currentSlope = getSlope(aGuessT, mX1, mX2);\n      if (currentSlope === 0.0) return aGuessT;\n      var currentX = calcBezier(aGuessT, mX1, mX2) - aX;\n      aGuessT -= currentX / currentSlope;\n    }\n    return aGuessT;\n  }\n  function calcSampleValues() { for (var i = 0; i < kSplineTableSize; ++i) { mSampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2); } }\n  function binarySubdivide(aX, aA, aB) {\n    var currentX, currentT, i = 0;\n    do {\n      currentT = aA + (aB - aA) / 2.0;\n      currentX = calcBezier(currentT, mX1, mX2) - aX;\n      if (currentX > 0.0) {\n        aB = currentT;\n      } else {\n        aA = currentT;\n      }\n    } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);\n    return currentT;\n  }\n  function getTForX(aX) {\n    var intervalStart = 0.0,\n        currentSample = 1,\n        lastSample = kSplineTableSize - 1;\n    for (; currentSample != lastSample && mSampleValues[currentSample] <= aX; ++currentSample) {\n      intervalStart += kSampleStepSize;\n    }\n    --currentSample;\n\n    var dist = (aX - mSampleValues[currentSample]) / (mSampleValues[currentSample+1] - mSampleValues[currentSample]),\n        guessForT = intervalStart + dist * kSampleStepSize,\n        initialSlope = getSlope(guessForT, mX1, mX2);\n\n    if (initialSlope >= NEWTON_MIN_SLOPE) {\n      return newtonRaphsonIterate(aX, guessForT);\n    } else if (initialSlope == 0.0) {\n      return guessForT;\n    } else {\n      return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize);\n    }\n  }\n  </defineBeizerFunctions>\n  \n  <prepareFunction>\n  var _precomputed = false;\n  function precompute() {\n    _precomputed = true;\n    if (mX1 != mY1 || mX2 != mY2) calcSampleValues();\n  }\n  var f = function (aX) {\n    if (!_precomputed) precompute();\n    if (mX1 === mY1 && mX2 === mY2) return aX; \n    if (aX === 0) return 0;\n    if (aX === 1) return 1;\n    return calcBezier(getTForX(aX), mY1, mY2);\n  };\n  f.getControlPoints = function() { return [{ x: mX1, y: mY1 }, { x: mX2, y: mY2 }]; };\n\n  var str = \"generateBezier(\" + [mX1, mY1, mX2, mY2] + \")\";\n  f.toString = function () { return str; };\n  </prepareFunction>\n  \n  return f;\n}\n"], ["tokenizeText", "\nfunction tokenizeText(text, callback) {\n  \"use strict\";\n  <processText>\n  processTokens(tokenizer.tokenize(text) || [], function (error, tokens) {\n    process.nextTick(function () {\n      callback(error, tokens);\n    });\n  });\n  </processText>\n}\n"], ["toggleFullScreen", "\nfunction toggleFullScreen() {\n  <checkAndToggle>\n  if ((document.fullScreenElement && \n       document.fullScreenElement !== null) ||    \n      (!document.mozFullScreen && !document.webkitIsFullScreen)) {\n    if (document.documentElement.requestFullScreen) {  \n      document.documentElement.requestFullScreen();  \n    } else if (document.documentElement.mozRequestFullScreen) {  \n      document.documentElement.mozRequestFullScreen();  \n    } else if (document.documentElement.webkitRequestFullScreen) {  \n      document.body.webkitRequestFullScreen();  \n    }  \n  } else {  \n    if (document.cancelFullScreen) {  \n      document.cancelFullScreen();  \n    } else if (document.mozCancelFullScreen) {  \n      document.mozCancelFullScreen();  \n    } else if (document.webkitCancelFullScreen) {  \n      document.webkitCancelFullScreen();  \n    }  \n  }  \n  </checkAndToggle>\n}\n"], ["ClientChannel", "\nfunction ClientChannel(client, opts) {\n  opts = opts || {};\n  events.EventEmitter.call(this);\n\n  this.client = client;\n  <setupOptions>\n  this.timeout = utils.getOption(opts, 'timeout', client._timeout$);\n  this._endWritable = !!utils.getOption(opts, 'endWritable', true);\n  this._prefix = normalizedPrefix(opts.scope);\n  </setupOptions>\n\n  <setupCacheAdapter>\n  var cache = client._cache$;\n  var clientSvc = client._svc$;\n  var hash = opts.serverHash;\n  if (!hash) {\n    hash = clientSvc.hash;\n  }\n  var adapter = cache[hash];\n  if (!adapter) {\n    \n    hash = clientSvc.hash;\n    adapter = cache[hash] = new Adapter(clientSvc, clientSvc, hash);\n  }\n  this._adapter = adapter;\n  </setupCacheAdapter>\n\n  <setupRegistry>\n  this._registry = new Registry(this, PREFIX_LENGTH);\n  this.pending = 0;\n  this.destroyed = false;\n  this.draining = false;\n  this.once('_eot', function (pending, err) {\n    \n    \n    debug('client channel EOT');\n    this.destroyed = true;\n    this.emit('eot', pending, err);\n  });\n  </setupRegistry>\n}\n"], ["upload_file", "\nasync function upload_file(file, { upload_folder, log }) {\n  if (log) {\n    log.debug(`Uploading: ${file.filename}`);\n  }\n\n  <generateUniqueFilename>\n  const file_name = await generate_unique_filename(upload_folder, {\n    on_collision: (file_name) => {\n      log.info(`Generate unique file name: collision for \"${file_name}\". Taking another try.`);\n    }\n  });\n  </generateUniqueFilename>\n\n  const output_file = path.join(upload_folder, file_name);\n\n  <writeFile>\n  return await new Promise((resolve, reject) => {\n    \n    fs.ensureDir(upload_folder, (error) => {\n      if (error) {\n        return reject(error);\n      }\n      const stream = fs.createWriteStream(output_file);\n\n      file.pipe(stream)\n        .on('finish', () => resolve(path.relative(upload_folder, output_file)))\n        .on('error', error => reject(error))\n    });\n  });\n  </writeFile>\n}\n"], ["anonymous1", "\nfunction(options) {\n  var self = this;\n  <findAndDestroy>\n  return self.find(options).then(function(objects) {\n    return AV.Object.destroyAll(objects, options);\n  });\n  </findAndDestroy>\n}\n"], ["anonymous2", "\nfunction() {\n  var url   = this.docsUrl;\n  var _this = this;\n  \n  <initializeDeferred>\n  var d = Q.defer();\n  </initializeDeferred>\n\n  <requestApiDocs>\n  Q.nfcall(request, url + '/api-docs').then(function(data) {\n    var $        = cheerio.load(data);\n    var list     = $('ul.nav-list li a');\n    var requests = [];\n\n    list.each(function() {\n      var href = $(this).attr('href');\n\n      if (/service$/.test(href)) {\n        <getServiceInterface>\n        var p = _this.getServiceInterface(url + href);\n        p.then(function(s) { d.notify(s.serviceName); });\n        </getServiceInterface>\n        requests.push(p);\n      }\n    });\n    \n    Q.spread(requests, function() {\n      d.resolve(_(arguments).toArray());\n    });\n  });\n  </requestApiDocs>\n\n  return d.promise;\n}\n"], ["placeOrder", "\nfunction placeOrder(account, order, secret, options, callback) {\n  <createTransaction>\n  var transaction = createOrderTransaction(account, order);\n  </createTransaction>\n  var converter = TxToRestConverter.parseSubmitOrderFromTx;\n  <executeTransaction>\n  transact(transaction, this, secret, options, converter, callback);\n  </executeTransaction>\n}\n"], "```"]