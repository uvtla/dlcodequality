[["function", "\nfunction (options) {\n    <validation>\n    if (!isStringValid(options.key)) {\n        throw new TypeError('Unable to load data, a key is not a non-empty string.');\n    }\n\n    if (!isStringValid(options.urlTemplate)) {\n        throw new TypeError('Unable to load data, a urlTemplate is not a non-empty string.');\n    }\n\n    var errorHandler = options.loadFailureHandler;\n    if (errorHandler !== undefined) {\n        if (!angular.isString(errorHandler)) {\n            throw new Error('Unable to load data, a loadFailureHandler is not a string.');\n        } else errorHandler = $injector.get(errorHandler);\n    }\n    </validation>\n\n    <setup>\n    var loaders = [],\n        tables = [],\n        deferred = $q.defer();\n\n    function addTablePart(table) {\n        tables.push(table);\n    }\n    </setup>\n\n    <data-loading>\n    for (var part in parts) {\n        if (hasPart(part) && parts[part].isActive) {\n            loaders.push(\n              parts[part]\n                .getTable(options.key, $q, $http, options.urlTemplate, errorHandler)\n                .then(addTablePart)\n            );\n        }\n    }\n\n    if (loaders.length) {\n        $q.all(loaders).then(\n          function () {\n              var table = {};\n              for (var i = 0; i < tables.length; i++) {\n                  deepExtend(table, tables[i]);\n              }\n              deferred.resolve(table);\n          },\n          function () {\n              deferred.reject(options.key);\n          }\n        );\n    } else {\n        deferred.resolve({});\n    }\n    </data-loading>\n\n    return deferred.promise;\n}\n"], ["function", "\nfunction(type, name, value) {\n    <initial-processing>\n    if (type === 'text' && value == null) {\n      value = name;\n      name = undefined;\n    }\n    </initial-processing>\n\n    <check-animateAttribute>\n    if (name === this.animateAttribute) {\n      return;\n    }\n    </check-animateAttribute>\n\n    <binder-setup>\n    var binder = this.getBinder(type, name), binders = this.binders[type];\n\n    if (!binder) {\n      var toMatch = (type === 'text') ? value : name;\n      binders._wildcards.some(function(wildcardBinder) {\n        if (toMatch.match(wildcardBinder.expression)) {\n          binder = wildcardBinder;\n          return true;\n        }\n      });\n    }\n\n    if (binder &&\n        type === 'attribute' &&\n        binder.prototype.onlyWhenBound &&\n        !this.binders[type]._delimitersOnlyInDefault &&\n        !this.isBound(type, value)) {\n      return;\n    }\n\n    if (!binder && value && (type === 'text' || this.isBound(type, value))) {\n      binder = this.getBinder(type, '__default__');\n    }\n    </binder-setup>\n\n    return binder;\n}\n"], ["initialize-iconpicker", "\nfunction (element, options) {\n    this.$element = $(element);\n    this.options  = $.extend({}, Iconpicker.DEFAULTS, this.$element.data());\n    this.options  = $.extend({}, this.options, options);\n}\n"], ["add-empty-line", "\nfunction addEmptyLineAfter(\n  node,\n  newline\n)  {\n  <add-line-logic>\n  const after = _.last(node.raws.after.split(\";\"));\n\n  if (!/\\r?\\n/.test(after)) {\n    node.raws.after = node.raws.after + _.repeat(newline, 2);\n  } else {\n    node.raws.after = node.raws.after.replace(/(\\r?\\n)/, `${newline}$1`);\n  }\n  </add-line-logic>\n\n  return node;\n}\n"], ["MutationSigner-constructor", "\nfunction MutationSigner(privateKey) {\n    this.publicKey = ByteBuffer.wrap(privateKey.publicKey.toBuffer());\n    <signer-setup>\n    this._signer = bitcore.crypto.ECDSA().set({\n        endian: \"big\",\n        privkey: privateKey.privateKey\n    });\n    </signer-setup>\n}\n"], ["possible-moves", "\nfunction() {\n\n    var step = this.step;\n    var cost = this.cost();\n    var diagonalCost = this.diagonalCost();\n\n    return [\n        { offsetX: step  , offsetY: 0     , cost: cost },\n        { offsetX: step  , offsetY: step  , cost: diagonalCost },\n        { offsetX: 0     , offsetY: step  , cost: cost },\n        { offsetX: -step , offsetY: step  , cost: diagonalCost },\n        { offsetX: -step , offsetY: 0     , cost: cost },\n        { offsetX: -step , offsetY: -step , cost: diagonalCost },\n        { offsetX: 0     , offsetY: -step , cost: cost },\n        { offsetX: step  , offsetY: -step , cost: diagonalCost }\n    ];\n}\n"], ["forEach", "\nfunction forEach(object, iterator, thisp) {\n    if (object) {\n        <handle-array>\n        if (object.forEach) {\n            object.forEach(iterator, thisp);\n            return;\n        }\n        </handle-array>\n\n        <validation>\n        if (!(iterator instanceof Function)) {\n            throw new TypeError('iterator should be a Function');\n        }\n        </validation>\n\n        <iteration>\n        var key, length;\n\n        if (isString(object)) {\n            length = object.length;\n            for (key = 0; key < length; key += 1) {\n                iterator.call(thisp, object[key], key, object);\n            }\n            return;\n        }\n\n        for (key in object) {\n            if (object.hasOwnProperty(key)) {\n                iterator.call(thisp, object[key], key, object);\n            }\n        }\n        </iteration>\n    }\n}\n"], ["get-indent", "\nfunction getTopLevelIndentByTemplateTag(templateTag) {\n    const baseIndentText = getActualLineIndentText(\n        templateTag.loc.start.line\n    )\n    return new ExpectedIndent(\n        baseIndentText,\n        options.indentSize * options.startIndent\n    )\n}\n"], ["history-management", "\nfunction(state, title, url) {\n  var t = document.title;\n  <store-last-title>\n  if (lastTitle != null) {\n    document.title = lastTitle;\n  }\n  </store-last-title>\n  <push-history>\n  historyPushState && fastFixChrome(historyPushState, arguments);\n  </push-history>\n  <change-state>\n  changeState(state, url);\n  </change-state>\n  <restore-title>\n  document.title = t;\n  lastTitle = title;\n  </restore-title>\n}\n"], ["container-configuration", "\nfunction(raw_tag) {\n\n    var container_config = {\n        type: 'Element',\n        tag_name: raw_tag.name\n    };\n\n    <static-attributes>\n    if ('attributes' in raw_tag) this._parseContainerStaticAttributes(container_config, raw_tag.attributes);\n    </static-attributes>\n    <control-attributes>\n    if ('x' in raw_tag) this._parseContainerControlAttributes(container_config, raw_tag.x);\n    </control-attributes>\n\n    return container_config;\n\n}\n"], "```"]