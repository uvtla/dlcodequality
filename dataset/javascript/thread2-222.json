[["function_triggerEmitter", "\nfunction() {\n\t\n\tvar args = Array.prototype.slice.apply(arguments);\n\t\n\tif (typeof args[0] == 'string') {\n\t\targs[0] = { type: args[0] };\n\t}\n\t\n\tthis.__$emitterPrivate.trigger.apply(this.__$emitterPrivate, args);\n\tthis.__$emitterPublic.trigger.apply(this.__$emitterPublic, args);\n\t\n\treturn this;\n}\n"], ["function_initPlugins", "\nfunction initPlugins(router, site) {\n  return bluebird.all(module.exports.plugins.map(plugin => {\n    <plugin_initialization>\n    return bluebird.try(() => {\n      if (typeof plugin === 'function') {\n        return plugin(router, pluginDBAdapter, publish, sites, site);\n      } else {\n        log('warn', 'Plugin is not a function');\n        return bluebird.resolve();\n      }\n    });\n    </plugin_initialization>\n  }));\n}\n"], ["function_getState", "\nfunction getState (file) {\n    \n    <state_initialization>\n    var state = {};\n    state.ephemeral = getFileInfo (file + \".eph\");\n    state.ready = getFileInfo (file + \".rdy\");\n    state.base = getFileInfo (file);\n    state.backup = getFileInfo (file + \".bak\");\n    state.tertiary = getFileInfo (file + \".bk2\");\n    </state_initialization>\n\n    <state_determination>\n    if (state.ephemeral.exists) {\n        state.status = cc.SAFE_INTERVENE;\n    } else if ((state.ready.exists) || (state.tertiary.exists)) {\n        state.status = cc.SAFE_RECOVERABLE;\n    } else if (state.base.exists) {\n        state.status = cc.SAFE_NORMAL;\n    } else {\n        if (state.backup.exists) {\n            state.status = cc.SAFE_RECOVERABLE;\n        } else {\n            state.status = cc.DOES_NOT_EXIST;\n        }\n    }\n    </state_determination>\n\n    return (state);\n}\n"], ["function_supportsMapAndSet", "\nfunction supportsMapAndSet() {\n  if (typeof Symbol === 'undefined' || typeof Map === 'undefined' || typeof Set === 'undefined') {\n    return false;\n  }\n  <species_property_check>\n  var prop = Object.getOwnPropertyDescriptor(Map, Symbol.species);\n  return prop && 'get' in prop && Map[Symbol.species] === Map;\n  </species_property_check>\n}\n"], ["function_setNodeIndex", "\nfunction(parentNode, reverse, ofType) {\n  parentNode._counted = true;\n  if (reverse) {\n    <reverse_idx>\n    for (var nodes = parentNode.childNodes, i = nodes.length - 1, j = 1; i >= 0; i--) {\n      var node = nodes[i];\n      if (node.nodeType == 1 && (!ofType || node._counted)) node.nodeIndex = j++;\n    }\n    </reverse_idx>\n  } else {\n    <normal_idx>\n    for (var i = 0, j = 1, nodes = parentNode.childNodes; node = nodes[i]; i++)\n      if (node.nodeType == 1 && (!ofType || node._counted)) node.nodeIndex = j++;\n    </normal_idx>\n  }\n}\n"], ["function_intersectModules", "\nfunction intersectModules(modulesA, modulesB) {\n  const intersection = [];\n  for (const module of modulesA) {\n    <module_inclusion>\n    if (modulesB.includes(module)) {\n      intersection.push(module);\n    }\n    </module_inclusion>\n  }\n  return intersection;\n}\n"], ["function_<anonymous", ">\nfunction (args) {\n    var sectionMacro = this.macro;\n    <macro_assignment>\n    if (sectionMacro) {\n        \n        if (!args.macro) {\n            args.macro = sectionMacro;\n        } else {\n            var targetMacro = args.macro;\n            if (ariaUtilsType.isObject(targetMacro) && !targetMacro.name) {\n                targetMacro.name = sectionMacro.name;\n                targetMacro.scope = sectionMacro.scope;\n                if (!targetMacro.args) {\n                    targetMacro.args = sectionMacro.args;\n                }\n            }\n        }\n    }\n    </macro_assignment>\n    \n    \n    this._domElt = null;\n}\n"], ["function_<anonymous_async", ">\nasync function () {\n\n    const log = []\n\n    <independent_functions>\n    const a =       () => {                     log.push ('a')              }\n    const b = async () => { await __.sleep (1); log.push ('b');             }\n    const c =       () => {                     log.push ('c'); return 42   } \n    const d =       () => {                     log.push ('d');             } \n    </independent_functions>\n\n    <function_execution>\n    await __.each ([a, b, c], (fn, i, break_) =>\n                                __.then (fn, x => {\n                                                if (x === 42) break_ () }))\n    </function_execution>\n\n    <assertion>\n    $assert (log, ['a', 'b', 'c'])\n    </assertion>\n}\n"], ["function_sheetifySass", "\nfunction sheetifySass (filename, source, options, done) {\n  const sassOpts = extend({\n    data: source,\n    file: filename,\n    indentedSyntax: /\\.sass$/i.test(filename)\n  }, options)\n\n  <sass_render>\n  sass.render(sassOpts, function (err, res) {\n    if (err) return done(err)\n    done(null, {\n      css: String(res.css),\n      files: res.stats.includedFiles\n    })\n  })\n  </sass_render>\n}\n"], ["function_inherit", "\nfunction inherit(target, parent) {\n\t<argument_validation>\n\tassertArgumentOfType('function', target, ERROR_MESSAGES.NOT_CONSTRUCTOR, 'Target', 'inherit');\n\tparent = toFunction(\n\t\tparent,\n\t\tnew TypeError(\n\t\t\tmsg(\n\t\t\t\tERROR_MESSAGES.WRONG_TYPE,\n\t\t\t\t'Parent',\n\t\t\t\t'inherit',\n\t\t\t\t'non-null object or function',\n\t\t\t\tparent === null ? 'null' : typeof parent\n\t\t\t)\n\t\t)\n\t);\n\t</argument_validation>\n\n\tif (classIsA(target, parent)) {\n\t\treturn target;\n\t}\n\n\tvar resultingProperties = {};\n\t<property_computation>\n\tvar targetPrototype = target.prototype;\n\tfor (var propertyName in parent.prototype) {\n\t\t\n\t\tif (propertyName === 'constructor' || propertyName === '__proto__' || propertyName === 'toString' || propertyName.match(/^Symbol\\(__proto__\\)/)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tvar notInTarget = <notInTarget>targetPrototype[propertyName] === undefined;</notInTarget>\n\t\tvar parentHasNewerImplementation = notInTarget || <isOverrider>isOverriderOf(propertyName, parent, target);</isOverrider>\n\t\tif (parentHasNewerImplementation) {\n\t\t\tresultingProperties[propertyName] = parent.prototype[propertyName];\n\t\t} else {\n\t\t\tvar areTheSame = targetPrototype[propertyName] === parent.prototype[propertyName];\n\t\t\tvar targetIsUpToDate = areTheSame || <isOverrider>isOverriderOf(propertyName, target, parent);</isOverrider>\n\t\t\tif (targetIsUpToDate === false) {\n\t\t\t\t\n\t\t\t\tthrow new Error(\n\t\t\t\t\tmsg(\n\t\t\t\t\t\tERROR_MESSAGES.ALREADY_PRESENT,\n\t\t\t\t\t\tpropertyName,\n\t\t\t\t\t\tclassName(parent, 'parent'),\n\t\t\t\t\t\tclassName(target, 'target')\n\t\t\t\t\t)\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\t</property_computation>\n\n\t<property_assignment>\n\tcopy(resultingProperties, targetPrototype);\n\tvar multiparents = nonenum(target, '__multiparents__', []);\n\tmultiparents.push(parent);\n\t</property_assignment>\n\n\t<cache_clearing>\n\tclearAssignableCache(target, parent);\n\t</cache_clearing>\n\n\treturn target;\n}\n"], "```"]