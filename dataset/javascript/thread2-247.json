[["trimHtml", "\nfunction trimHtml(html) {\n  <trimSpaces>\n  function trimSpaces(all, s1, s2) {\n    \n    if (!s1 && !s2) {\n      return ' ';\n    }\n    return '\\u00a0';\n  }\n  </trimSpaces>\n\n  <filterHtml>\n  html = filter(html, [\n    /^[\\s\\S]*<body[^>]*>\\s*|\\s*<\\/body[^>]*>[\\s\\S]*$/ig, \n    /<!--StartFragment-->|<!--EndFragment-->/g, \n    [/( ?)<span class=\"Apple-converted-space\">\\u00a0<\\/span>( ?)/g, trimSpaces],\n    /<br class=\"Apple-interchange-newline\">/g,\n    /<br>$/i \n  ]);\n  </filterHtml>\n\n  return html;\n}\n"], ["handle", "\nfunction handle(filePath) {\n  var file = toVFile(filePath)\n  \n  <testFile>\n  var result = test(file)\n  </testFile>\n  \n  <includeFile>\n  if (mask(result, INCLUDE)) {\n    if (one) {\n      callback(null, file)\n      return true\n    }\n    results.push(file)\n  }\n  </includeFile>\n  \n  <breakExecution>\n  if (mask(result, BREAK)) {\n    callback(null, one ? null : results)\n    return true\n  }\n  </breakExecution>\n}\n"], ["SRPCompliantFunction", "\nfunction( options ){\n  // This function is SRP compliant since it contains a single responsibility: manipulating an options map based on the provided keys.\n}\n"], ["SRPCompliantFunction", "\nfunction json (program, callback) {\n  // This function is SRP compliant as it coordinates the parsing process and formatting of JSON input.\n}\n"], ["SRPCompliantFunction", "\nfunction(property) {\n  // This function is SRP compliant because it involves checking for the existence of a style property on a DOM element with various vendor prefixes.\n}\n"], ["addComputed", "\nfunction(namespace, map) {\n  <validateParameters>\n  if (typeof namespace === 'string' && typeof map === 'object') {\n    // ... rest of the code omitted for brevity ...\n  } else if (namespace && typeof namespace === 'object') {\n    // ... rest of the code omitted for brevity ...\n  } else {\n    throw new TypeError('addComputed must have a map object');\n  }\n  </validateParameters>\n}\n"], ["SRPCompliantFunction", "\nfunction parse_PtgAttrIfError(blob) {\n  // This is a SRP-compliant function dedicated to parsing a specific part of a data blob.\n}\n"], ["oxdSocketRequest", "\nfunction oxdSocketRequest(port, host, params, command, callback) {\n  \n  <prepareData>\n  let data = {\n    command,\n    params\n  };\n  </prepareData>\n\n  <createClient>\n  const client = new net.Socket();\n  </createClient>\n\n  <connectAndSendData>\n  client.connect(port, host, () => {\n    // ... rest of the code omitted for brevity ...\n  });\n  </connectAndSendData>\n\n  <onDataReceived>\n  client.on('data', (req) => {\n    // ... rest of the code omitted for brevity ...\n  });\n  </onDataReceived>\n\n  <onError>\n  client.on('error', (err) => {\n    // ... rest of the code omitted for brevity ...\n  });\n  </onError>\n\n  <onClose>\n  client.on('close', () => {\n    // ... rest of the code omitted for brevity ...\n  });\n  </onClose>\n}\n"], ["SRPCompliantFunction", "\nfunction RSAGenerate(B,E) {\n  // Despite its length, this function has a single responsibility: generating RSA keys.\n}\n"], ["extractRadioDecoders", "\nfunction extractRadioDecoders(devices) {\n  <collectRadioDecoders>\n  var radioDecoders = {};\n\n  for(var deviceId in devices) {\n    var radioDecodings = devices[deviceId].radioDecodings || [];\n    for(var cDecoding = 0; cDecoding < radioDecodings.length; cDecoding++) {\n      var radioDecoder = radioDecodings[cDecoding].identifier;\n      var radioDecoderId = radioDecoder.value;\n      radioDecoders[radioDecoderId] = { identifier: radioDecoder };\n    }\n  }\n  </collectRadioDecoders>\n  return radioDecoders;\n}\n"], "```"]