[["getSourceCodeOfFiles", "\nfunction getSourceCodeOfFiles(patterns, providedOptions, providedCallback) {\n    <initializeVariables>\n    const sourceCodes = {};\n    const globPatternsList = typeof patterns === \"string\" ? [patterns] : patterns;\n    let options, callback;\n\n    const defaultOptions = Object.assign({}, baseDefaultOptions, { cwd: process.cwd() });\n\n    if (typeof providedOptions === \"undefined\") {\n        options = defaultOptions;\n        callback = null;\n    } else if (typeof providedOptions === \"function\") {\n        callback = providedOptions;\n        options = defaultOptions;\n    } else if (typeof providedOptions === \"object\") {\n        options = Object.assign({}, defaultOptions, providedOptions);\n        callback = providedCallback;\n    }\n    debug(\"constructed options:\", options);\n    </initializeVariables>\n\n    <searchAndReadFiles>\n    const filenames = globUtils.listFilesToProcess(globPatternsList, options)\n        .filter(fileInfo => !fileInfo.ignored)\n        .reduce((files, fileInfo) => files.concat(fileInfo.filename), []);\n\n    if (filenames.length === 0) {\n        debug(`Did not find any files matching pattern(s): ${globPatternsList}`);\n    }\n    filenames.forEach(filename => {\n        const sourceCode = getSourceCodeOfFile(filename, options);\n\n        if (sourceCode) {\n            debug(\"got sourceCode of\", filename);\n            sourceCodes[filename] = sourceCode;\n        }\n        if (callback) {\n            callback(filenames.length); \n        }\n    });\n    </searchAndReadFiles>\n    \n    return sourceCodes;\n}\n"], ["objMap", "\nfunction objMap(callback, thisArg = UNDEFINED) {\n    <mapOverObject>\n    const dst = [];\n    each.call(this, (value, key, src) => {\n        const result = callback.call(thisArg, value, key, src);\n        if (result === BREAK) return BREAK;\n        if (result !== UNDEFINED) {\n            dst.push(result);\n        }\n    });\n    </mapOverObject>\n    return dst;\n}\n"], ["onLanguageInitialized", "\nfunction onLanguageInitialized(sLanguage, resolve, hyphenateMethod) {\n\t\t<setHyphenationMethod>\n\t\toHyphenateMethods[sLanguage] = hyphenateMethod;\n\t\toHyphenationInstance.bIsInitialized = true;\n\t\t</setHyphenationMethod>\n\t\t\n\t\t<processLanguageQueue>\n\t\tif (aLanguagesQueue.length > 0) {\n\t\t\taLanguagesQueue.forEach(function (oElement) {\n\t\t\t\tinitializeLanguage(oElement.sLanguage, oElement.oConfig, oElement.resolve);\n\t\t\t});\n\t\t\taLanguagesQueue = [];\n\t\t}\n\t\t</processLanguageQueue>\n\n\t\t<updateLoadingStateAndResolve>\n\t\toHyphenationInstance.bLoading = false;\n\t\tresolve(\n\t\t\tgetLanguageFromPattern(sLanguage)\n\t\t);\n\t\t</updateLoadingStateAndResolve>\n\t}\n"], ["doCreate", "\nfunction doCreate(path, isFolder) {\n        <validationAndDeferredInitialization>\n        var d = new $.Deferred();\n        var filename = FileUtils.getBaseName(path);\n\n        \n        if (!isValidFilename(filename)){\n            return d.reject(ERROR_INVALID_FILENAME).promise();\n        }\n\n        \n        \n        if (!isValidPath(path)) {\n            return d.reject(ERROR_INVALID_FILENAME).promise();\n        }\n        </validationAndDeferredInitialization>\n\n        <fileSystemOperation>\n        FileSystem.resolve(path, function (err) {\n            if (!err) {\n                \n                d.reject(FileSystemError.ALREADY_EXISTS);\n            } else {\n                if (isFolder) {\n                    <createDirectory>\n                    var directory = FileSystem.getDirectoryForPath(path);\n\n                    directory.create(function (err) {\n                        if (err) {\n                            d.reject(err);\n                        } else {\n                            d.resolve(directory);\n                        }\n                    });\n                    </createDirectory>\n                } else {\n                    <createFile>\n                    var file = FileSystem.getFileForPath(path);\n\n                    FileUtils.writeText(file, \"\").then(function () {\n                        d.resolve(file);\n                    }, d.reject);\n                    </createFile>\n                }\n            }\n        });\n        </fileSystemOperation>\n\n        return d.promise();\n    }\n"], ["hasCallback", "\nfunction hasCallback (callbackContext = null) {\n        <determineIfCallbackExists>\n        if (!this.state[ACTION]\n            || callbackContext === this.state[CONTEXT]\n            || !this.isText()) {\n\n            return false;\n        }\n        </determineIfCallbackExists>\n        return true;\n    }\n"], ["parseHealthcheck", "\nfunction parseHealthcheck(cmd) {\n    <parseDirectiveAndArguments>\n    var words = parseWords(cmd.rest),\n        cmdDirectiveIndex = words.indexOf(\"CMD\"),        \n        noneDirectiveIndex = words.indexOf(\"NONE\");\n\n    if (cmdDirectiveIndex === -1 && noneDirectiveIndex === -1) {\n        cmd.error = 'A HEALTHCHECK instruction must specify either NONE, or a valid CMD and options';\n        return false;\n    } else if (cmdDirectiveIndex !== -1) {\n        \n        if (cmdDirectiveIndex === words.length - 1) {\n            cmd.error = 'A CMD directive must specify a command for the healthcheck to run';\n            return false;\n        }\n        \n        cmd.args = { command: words.slice(cmdDirectiveIndex + 1).join(\" \") };\n\n        if (cmdDirectiveIndex > 0) {\n            \n            <parseCmdOptions>\n            var cmdDirectiveOptions = words.slice(0, cmdDirectiveIndex),\n                validCmdOptions = [\"interval\", \"retries\", \"timeout\", \"start-period\"];\n\n            for (var i = 0; i < cmdDirectiveOptions.length; i++) {\n                var match = /--([a-zA-Z0-9_-]+)=(\\d+)/.exec(cmdDirectiveOptions[i]);\n                if (!match) {\n                    cmd.error = '\"' + cmdDirectiveOptions[i] + '\" isn\\'t a syntactically valid CMD option';\n                    return false;\n                } else if (validCmdOptions.indexOf(match[1]) === -1) {\n                    cmd.error = '\"' + match[1] + '\" isn\\'t a valid CMD option';\n                    return false;\n                }\n\n                cmd.args[match[1]] = match[2];\n            }\n            </parseCmdOptions>\n        }\n    } else if (noneDirectiveIndex !== -1) {\n        if (words.length > 1) {\n            cmd.error = 'The NONE directive doesn\\'t support additional options';\n            return false;\n        }\n\n        cmd.args = { isNone: true };\n    }\n    </parseDirectiveAndArguments>\n\n    return true;\n}\n"], ["attachListener", "\nfunction attachListener (msg, listener) {\n  <attachOrRetrieveListener>\n  var attached = msg.__onFinished\n\n  if (!attached || !attached.queue) {\n    attached = msg.__onFinished = createListener(msg)\n    attachFinishedListener(msg, attached)\n  }\n  </attachOrRetrieveListener>\n\n  <enqueueListener>\n  attached.queue.push(listener)\n  </enqueueListener>\n}\n"], ["Conrec", "\nfunction Conrec(drawContour) {\n    <initialization>\n    if (!drawContour) {\n      var c = this;\n      c.contours = {};\n      \n      <initializeDrawContour>\n      this.drawContour = function(startX, startY, endX, endY, contourLevel, k) {\n        var cb = c.contours[k];\n        if (!cb) {\n          cb = c.contours[k] = new ContourBuilder(contourLevel);\n        }\n        cb.addSegment({x: startX, y: startY}, {x: endX, y: endY});\n      }\n      </initializeDrawContour>\n      \n      <initializeContourList>\n      this.contourList = function() {\n        var l = [];\n        var a = c.contours;\n        for (var k in a) {\n          var s = a[k].s;\n          var level = a[k].level;\n          while (s) {\n            var h = s.head;\n            var l2 = [];\n            l2.level = level;\n            l2.k = k;\n            while (h && h.p) {\n              l2.push(h.p);\n              h = h.next;\n            }\n            l.push(l2);\n            s = s.next;\n          }\n        }\n        l.sort(function(a, b) { return a.k - b.k });\n        return l;\n      }\n      </initializeContourList>\n    } else {\n      <setProvidedDrawContour>\n      this.drawContour = drawContour;\n      </setProvidedDrawContour>\n    }\n    </initialization>\n\n    <initializeArrays>\n    this.h  = new Array(5);\n    this.sh = new Array(5);\n    this.xh = new Array(5);\n    this.yh = new Array(5);\n    </initializeArrays>\n  }\n"], ["parallelClear", "\nfunction (callback) {\n    var self = this;\n    <parallelTasksExecution>\n    async.parallel([\n      function (callback) {\n        <clearCollections>\n        async.each(self.dispatcher.tree.getCollections(), function (col, callback) {\n          if (col.noReplay) {\n            return callback(null);\n          }\n          col.repository.clear(callback);\n        }, callback);\n        </clearCollections>\n      },\n      function (callback) {\n        <clearStore>\n        self.store.clear(callback);\n        </clearStore>\n      }\n    ], callback);\n    </parallelTasksExecution>\n  }\n"], ["getCheckedAndUnchecked", "\nfunction getCheckedAndUnchecked (checkboxes) {\n  <identifyingCheckedAndUnchecked>\n  var checked = [], unchecked = [];\n  for (var i = 0; i < arguments.length; i++) {\n    var checkbox = arguments[i];\n    if (checkbox.is(\":checked\")) {\n      checked.push(checkbox.data(\"value\"));\n    }\n    else {\n      unchecked.push(checkbox.data(\"value\"));\n    }\n  }\n  </identifyingCheckedAndUnchecked>\n  return { checked: checked, unchecked: unchecked };\n}\n"], "```"]