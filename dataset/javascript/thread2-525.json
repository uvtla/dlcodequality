[["abortMultipartUploadWithErrorHandling", "\nfunction (rootError) {\n    cachedClient.abortMultipartUpload(\n      {\n        Bucket: destinationDetails.Bucket,\n        Key: destinationDetails.Key,\n        UploadId: multipartUploadID\n      },\n      function (abortError) {\n        if (abortError)\n          ws.emit('error', rootError + '\\n Additionally failed to abort the multipart upload on S3: ' + abortError);\n        else\n          ws.emit('error', rootError);\n      }\n    );\n  }\n"], ["rightShiftBuffer", "\nfunction _rightShift(buffer) {\n        var carry, prevcarry;\n        for (var i = 0; i < buffer.length; i++) {\n            carry = prevcarry;\n            prevcarry = (buffer[i] & 0x1) !== 0;\n            buffer[i] >>= 1;\n            if (carry && i > 0) {\n                buffer[i] |= 0x80;\n            }\n        }\n    }\n"], ["buildGlobalAndPluginSpecificOverrides", "\nfunction(options, results) {\n    \n    var overrides = {};\n    \n    _.forEach(options, function(opt) {\n      \n      if (opt.conf.type === 'global') {\n        overrides[opt.conf.key] = results[opt.name];\n      }\n      \n      else {\n        \n        var type = opt.conf.type;\n        var plugin = opt.conf.plugin;\n        var key = opt.conf.key;\n\n        \n        if (!overrides[type]) {\n          overrides[type] = {};\n        }\n        if (!overrides[type][plugin]) {\n          overrides[type][plugin] = {};\n        }\n\n        \n        overrides[type][plugin][key] = results[opt.name];\n      }\n    });\n\n    \n    return overrides;\n}\n"], ["PromptComponent", "\nfunction Prompt({ message, when = true }) {\n  return (\n    <RouterContext.Consumer>\n      {context => {\n        invariant(context, \"You should not use <Prompt> outside a <Router>\");\n\n        if (!when || context.staticContext) return null;\n\n        const method = context.history.block;\n\n        return (\n          <Lifecycle\n            onMount={self => {\n              self.release = method(message);\n            }}\n            onUpdate={(self, prevProps) => {\n              if (prevProps.message !== message) {\n                self.release();\n                self.release = method(message);\n              }\n            }}\n            onUnmount={self => {\n              self.release();\n            }}\n            message={message}\n          />\n        );\n      }}\n    </RouterContext.Consumer>\n  );\n}\n"], ["byteArrayToStringConversion", "\nfunction (byteArray) {\n    var result = \"\",\n        len = byteArray.byteLength,\n        i;\n\n    for (i = 0; i < len; i += 1) {\n        result += String.fromCharCode(byteArray[i]);\n    }\n    return result;\n}\n"], ["updateCalendarInputValues", "\nfunction(elem, keyUp) {\n\t\t\tvar inst = this._getInst(elem);\n\t\t\tif (!$.isEmptyObject(inst)) {\n\t\t\t\tvar value = '';\n\t\t\t\tvar altValue = '';\n\t\t\t\tvar sep = (inst.options.multiSelect ? inst.options.multiSeparator :\n\t\t\t\t\tinst.options.rangeSeparator);\n\t\t\t\tvar calendar = inst.options.calendar;\n\t\t\t\tvar dateFormat = inst.get('dateFormat');\n\t\t\t\tvar altFormat = inst.options.altFormat || dateFormat;\n\t\t\t\tvar settings = {localNumbers: inst.options.localNumbers};\n\t\t\t\tfor (var i = 0; i < inst.selectedDates.length; i++) {\n\t\t\t\t\tvalue += (keyUp ? '' : (i > 0 ? sep : '') +\n\t\t\t\t\t\tcalendar.formatDate(dateFormat, inst.selectedDates[i], settings));\n\t\t\t\t\taltValue += (i > 0 ? sep : '') +\n\t\t\t\t\t\tcalendar.formatDate(altFormat, inst.selectedDates[i], settings);\n\t\t\t\t}\n\t\t\t\tif (!inst.inline && !keyUp) {\n\t\t\t\t\t$(elem).val(value);\n\t\t\t\t}\n\t\t\t\t$(inst.options.altField).val(altValue);\n\t\t\t\tif ($.isFunction(inst.options.onSelect) && !keyUp && !inst.inSelect) {\n\t\t\t\t\tinst.inSelect = true; \n\t\t\t\t\tinst.options.onSelect.apply(elem, [inst.selectedDates]);\n\t\t\t\t\tinst.inSelect = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n"], ["replaceFileContent", "\nfunction replaceContent(args, generator) {\n    args.path = args.path || process.cwd();\n    const fullPath = path.join(args.path, args.file);\n\n    const re = args.regex ? new RegExp(args.pattern, 'g') : args.pattern;\n\n    let body = generator.fs.read(fullPath);\n    body = body.replace(re, args.content);\n    generator.fs.write(fullPath, body);\n}\n"], ["injectContentIntoFile", "\nfunction getNewContent(target, collection, opt) {\n  var logger = opt.quiet ? noop : function (filesCount) {\n    if (filesCount) {\n      var pluralState = filesCount > 1 ? 's' : '';\n      log(cyan(filesCount) + ' file' + pluralState + ' into ' + magenta(target.relative) + '.');\n    } else {\n      log('Nothing to inject into ' + magenta(target.relative) + '.');\n    }\n  };\n  var content = String(target.contents);\n  var targetExt = extname(target.path);\n  var files = prepareFiles(collection, targetExt, opt, target);\n  var filesPerTags = groupArray(files, 'tagKey');\n  var startAndEndTags = Object.keys(filesPerTags);\n  var matches = [];\n  var injectedFilesCount = 0;\n\n  startAndEndTags.forEach(function (tagKey) {\n    var files = filesPerTags[tagKey];\n    var startTag = files[0].startTag;\n    var endTag = files[0].endTag;\n    var tagsToInject = getTagsToInject(files, target, opt);\n    content = inject(content, {\n      startTag: startTag,\n      endTag: endTag,\n      tagsToInject: tagsToInject,\n      removeTags: opt.removeTags,\n      empty: opt.empty,\n      willInject: function (filesToInject) {\n        injectedFilesCount += filesToInject.length;\n      },\n      onMatch: function (match) {\n        matches.push(match[0]);\n      }\n    });\n  });\n\n  logger(injectedFilesCount);\n\n  if (opt.empty) {\n    var ext = '{{ANY}}';\n    var startTag = getTagRegExp(opt.tags.start(targetExt, ext, opt.starttag), ext, opt);\n    var endTag = getTagRegExp(opt.tags.end(targetExt, ext, opt.endtag), ext, opt);\n\n    content = inject(content, {\n      startTag: startTag,\n      endTag: endTag,\n      tagsToInject: [],\n      removeTags: opt.removeTags,\n      empty: opt.empty,\n      shouldAbort: function (match) {\n        return matches.indexOf(match[0]) !== -1;\n      }\n    });\n  }\n  return Buffer.from(content);\n}\n"], ["findNodesAfterIndex", "\nfunction findAllAfter(parent, index, test) {\n  var results = []\n  var children\n  var child\n  var length\n\n  if (!parent || !parent.type || !parent.children) {\n    throw new Error('Expected parent node')\n  }\n\n  children = parent.children\n  length = children.length\n\n  if (index && index.type) {\n    index = children.indexOf(index)\n  }\n\n  if (isNaN(index) || index < 0 || index === Infinity) {\n    throw new Error('Expected positive finite index or child node')\n  }\n\n  while (++index < length) {\n    child = children[index]\n\n    if (is(test, child, index, parent)) {\n      results.push(child)\n    }\n  }\n\n  return results\n}\n"], ["bigIntegerConversion", "\nfunction _bi(value, base) {\n        if (base !== undefined) {\n            if (base === 256) {\n                return _bi(utils.string2bytes(value));\n            }\n            return new BigInteger(value, base);\n        } else if (typeof value === 'string') {\n            return new BigInteger(value, 10);\n        } else if ((value instanceof Array) || (value instanceof Uint8Array)) {\n            return new BigInteger(value);\n        } else if (typeof value === 'number') {\n            return new BigInteger(value.toString(), 10);\n        } else {\n            throw \"Can't convert \" + value + \" to BigInteger\";\n        }\n    }\n"], "```"]