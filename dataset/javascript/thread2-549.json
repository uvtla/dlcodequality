[["prepare", "\nfunction prepare(oInfo, i) {\n\tvar fnFormatter = oInfo.formatter,\n\t\toModel,\n\t\tsModelName = oInfo.model;\n\n\tif (oInfo.path && oInfo.path.indexOf(\">\") > 0) {\n\t\tsModelName = oInfo.path.slice(0, oInfo.path.indexOf(\">\"));\n\t}\n\toModel = oWithControl.getModel(sModelName);\n\n\tif (fnFormatter && fnFormatter.requiresIContext === true) {\n\t\tfnFormatter = oInfo.formatter\n\t\t\t= fnFormatter.bind(null, createContextInterface(oWithControl, mSettings, i));\n\t}\n\n\tif (fnFormatter && bAsync\n\t\t\t&& (oModel && oModel.$$valueAsPromise || i === undefined && bValueAsPromise)) {\n\t\toInfo.formatter = function () {\n\t\t\tvar that = this;\n\t\t\treturn SyncPromise.all(arguments).then(function (aArguments) {\n\t\t\t\treturn fnFormatter.apply(that, aArguments);\n\t\t\t});\n\t\t};\n\t\toInfo.formatter.textFragments = fnFormatter.textFragments;\n\t}\n\toInfo.mode = BindingMode.OneTime;\n\toInfo.parameters = oInfo.parameters || {};\n\toInfo.parameters.scope = oScope;\n\tif (bAsync && oModel && oModel.$$valueAsPromise) { \n\t\tbValueAsPromise = oInfo.parameters.$$valueAsPromise = true;\n\t}\n}\n"], ["emit", "\nfunction emit(event ) {\n\tthis._events = this._events || {};\n\n\tvar list = (this._events[event] || []).slice(0);\n\tfor(var i = 0; i < list.length; i++) {\n\t\tlist[i].apply(this, Array.prototype.slice.call(arguments, 1))\n\t}\n\treturn list.length > 0;\n}\n"], ["uniq", "\nfunction uniq(array, isSorted, callback, thisArg) {\n\tvar index = -1,\n\t\tlength = array ? array.length : 0,\n\t\tresult = [],\n\t\tseen = result;\n\n\tif (typeof isSorted != 'boolean' && isSorted != null) {\n\t\tthisArg = callback;\n\t\tcallback = isSorted;\n\t\tisSorted = false;\n\t}\n\n\tvar isLarge = !isSorted && length >= largeArraySize;\n\tif (isLarge) {\n\t\tvar cache = {};\n\t}\n\tif (callback != null) {\n\t\tseen = [];\n\t\tcallback = lodash.createCallback(callback, thisArg);\n\t}\n\twhile (++index < length) {\n\t\tvar value = array[index],\n\t\t\tcomputed = callback ? callback(value, index, array) : value;\n\n\t\tif (isLarge) {\n\t\t\tvar key = keyPrefix + computed;\n\t\t\tvar inited = cache[key]\n\t\t\t\t? !(seen = cache[key])\n\t\t\t\t: (seen = cache[key] = []);\n\t\t}\n\t\tif (isSorted\n\t\t\t\t? !index || seen[seen.length - 1] !== computed\n\t\t\t\t: inited || indexOf(seen, computed) < 0\n\t\t\t) {\n\t\t\tif (callback || isLarge) {\n\t\t\t\tseen.push(computed);\n\t\t\t}\n\t\t\tresult.push(value);\n\t\t}\n\t}\n\treturn result;\n}\n"], ["translate", "\nfunction translate() {\n\tvar a = arguments, v = a[0], o, i = 1;\n\tif(a[1].length) { a = a[1]; i = 0; }\n\tfor(o=a[i++]; i<a.length; i++) {\n\t\to = o.union(a[i]);\n\t}\n\treturn o.translate(v);\n}\n"], ["clone", "\nfunction clone(value) {\n\treturn valueTypes[typeof value] && value !== null\n\t\t? (isArray(value) ? value.slice() : extend({}, value))\n\t\t: value;\n}\n"], ["_updateBlock", "\nfunction _updateBlock(w, input, output, decrypt) {\n\tvar Nr = w.length / 4 - 1;\n\tvar m0, m1, m2, m3, sub;\n\tif(decrypt) {\n\t\tm0 = imix[0];\n\t\tm1 = imix[1];\n\t\tm2 = imix[2];\n\t\tm3 = imix[3];\n\t\tsub = isbox;\n\t} else {\n\t\tm0 = mix[0];\n\t\tm1 = mix[1];\n\t\tm2 = mix[2];\n\t\tm3 = mix[3];\n\t\tsub = sbox;\n\t}\n\tvar a, b, c, d, a2, b2, c2;\n\ta = input[0] ^ w[0];\n\tb = input[decrypt ? 3 : 1] ^ w[1];\n\tc = input[2] ^ w[2];\n\td = input[decrypt ? 1 : 3] ^ w[3];\n\tvar i = 3;\n\n\tfor(var round = 1; round < Nr; ++round) {\n\t\ta2 =\n\t\t\tm0[a >>> 24] ^\n\t\t\tm1[b >>> 16 & 255] ^\n\t\t\tm2[c >>> 8 & 255] ^\n\t\t\tm3[d & 255] ^ w[++i];\n\t\tb2 =\n\t\t\tm0[b >>> 24] ^\n\t\t\tm1[c >>> 16 & 255] ^\n\t\t\tm2[d >>> 8 & 255] ^\n\t\t\tm3[a & 255] ^ w[++i];\n\t\tc2 =\n\t\t\tm0[c >>> 24] ^\n\t\t\tm1[d >>> 16 & 255] ^\n\t\t\tm2[a >>> 8 & 255] ^\n\t\t\tm3[b & 255] ^ w[++i];\n\t\td =\n\t\t\tm0[d >>> 24] ^\n\t\t\tm1[a >>> 16 & 255] ^\n\t\t\tm2[b >>> 8 & 255] ^\n\t\t\tm3[c & 255] ^ w[++i];\n\t\ta = a2;\n\t\tb = b2;\n\t\tc = c2;\n\t}\n\n\toutput[0] =\n\t\t(sub[a >>> 24] << 24) ^\n\t\t(sub[b >>> 16 & 255] << 16) ^\n\t\t(sub[c >>> 8 & 255] << 8) ^\n\t\t(sub[d & 255]) ^ w[++i];\n\toutput[decrypt ? 3 : 1] =\n\t\t(sub[b >>> 24] << 24) ^\n\t\t(sub[c >>> 16 & 255] << 16) ^\n\t\t(sub[d >>> 8 & 255] << 8) ^\n\t\t(sub[a & 255]) ^ w[++i];\n\toutput[2] =\n\t\t(sub[c >>> 24] << 24) ^\n\t\t(sub[d >>> 16 & 255] << 16) ^\n\t\t(sub[a >>> 8 & 255] << 8) ^\n\t\t(sub[b & 255]) ^ w[++i];\n\toutput[decrypt ? 1 : 3] =\n\t\t(sub[d >>> 24] << 24) ^\n\t\t(sub[a >>> 16 & 255] << 16) ^\n\t\t(sub[b >>> 8 & 255] << 8) ^\n\t\t(sub[c & 255]) ^ w[++i];\n}\n"], ["getSubtitlesByFilename", "\nasync function getSubtitlesByFilename (filename) {\n\treturn getSubtitlesList(filename)\n\t\t.then(parseSearchResults)\n\t\t.then(getBestSearchResult(filename))\n\t\t.then(getSubtitlesPage)\n\t\t.then(parseDownloadLink)\n\t\t.then(downloadZip)\n\t\t.then(extractSrt)\n}\n"], ["map", "\nfunction map( result ) {\n\tconst invalid = !result || result.length < 2;\n\treturn invalid ? null : ( result.slice( 1 ).map( normalizeRegexResult ));\n}\n"], ["doAutoLinks", "\nfunction doAutoLinks(text) {\n\ttext = text.replace(/<((https?|ftp|dict):[^'\">\\s]+)>/gi,\"<a href=\\\"$1\\\">$1</a>\");\n\ttext = text.replace(/<(?:mailto:)?([-.\\w]+\\@[-a-z0-9]+(\\.[-a-z0-9]+)*\\.[a-z]+)>/gi, function(wholeMatch,m1) {\n\t\treturn encodeEmailAddress(unescapeSpecialChars(m1));\n\t});\n\n\treturn text;\n}\n"], ["tableRow", "\nfunction tableRow () {\n\tvar args = arrayify(arguments)\n\tvar rows = args.shift()\n\tif (!rows) return\n\tvar options = args.pop()\n\tvar cols = args\n\t\n\t<retrieveData>\n\tif (options.data) {\n\t\tvar data = handlebars.createFrame(options.data)\n\t\tcols.forEach(function (col, index) {\n\t\t\tvar colNumber = index + 1\n\t\t\tdata['col' + colNumber] = containsData(rows, col)\n\t\t})\n\t}\n\t</retrieveData>\n\t\n\t<generateOutput>\n\tvar output = ''\n\trows.forEach(function (row) {\n\t\toutput += options.fn(row, { data: data })\n\t})\n\treturn output\n\t</generateOutput>\n}\n"], "```"]