[["hextoipv6", "\nfunction hextoipv6(s) {\n  <validateHex>\n  if (! s.match(/^[0-9A-Fa-f]{32}$/))\n    throw \"malformed IPv6 address octet\";\n  </validateHex>\n\n  \n  s = s.toLowerCase();\n\n  <splitHex>\n  var a = s.match(/.{1,4}/g);\n  </splitHex>\n\n  <normalizeGroups>\n  for (var i = 0; i < 8; i++) {\n    a[i] = a[i].replace(/^0+/, \"\");\n    if (a[i] == '') a[i] = '0';\n  }\n  s = \":\" + a.join(\":\") + \":\";\n  </normalizeGroups>\n\n  <findLongestZeroSequence>\n  var aZero = s.match(/:(0:){2,}/g);\n  </findLongestZeroSequence>\n\n  <shortenSingleZeroGroup>\n  if (aZero === null) return s.slice(1, -1);\n  </shortenSingleZeroGroup>\n\n  <pickLongestZeroSequence>\n  var item = '';\n  for (var i = 0; i < aZero.length; i++) {\n    if (aZero[i].length > item.length) item = aZero[i];\n  }\n  </pickLongestZeroSequence>\n\n  <replaceWithDoubleColon>\n  s = s.replace(item, '::');\n  return s.slice(1, -1);\n  </replaceWithDoubleColon>\n}\n"], ["showConfirmationModal", "\nfunction showConfirmationModal(settings) {\n  <sendMessage>\n  window.parent.postMessage(\n    {\n      msg: 'luigi.ux.confirmationModal.show',\n      data: {\n        settings\n      }\n    },\n    '*'\n  );\n  </sendMessage>\n  \n  <initPromise>\n  promises.confirmationModal = {};\n  promises.confirmationModal.promise = new Promise((resolve, reject) => {\n    promises.confirmationModal.resolveFn = resolve;\n    promises.confirmationModal.rejectFn = reject;\n  });\n  </initPromise>\n  return promises.confirmationModal.promise;\n}\n"], ["debounceFunction", "\nfunction(func, wait) {\n  var self = this,\n      timeout,\n      timestamp\n\n  var later = function() {\n    <checkDisposal>\n    if (self._disposed) {\n      clearTimeout(timeout)\n      timeout = self = null\n      return\n    }\n    </checkDisposal>\n\n    <calculateElapsedTime>\n    var last = getTime() - timestamp\n    </calculateElapsedTime>\n\n    <rescheduleOrExecute>\n    if (last < wait && last >= 0) {\n      timeout = setTimeout(later, wait - last)\n    } else {\n      timeout = null\n      func()\n    }\n    </rescheduleOrExecute>\n  }\n\n  return function() {\n    <setTimestamp>\n    timestamp = getTime()\n    </setTimestamp>\n\n    <scheduleFirstExecution>\n    if (!timeout) {\n      timeout = setTimeout(later, wait)\n    }\n    </scheduleFirstExecution>\n  }\n}\n"], ["makeCorporations", "\nfunction makeCorporations(agent) {\n  let functor = function (id) {\n    return new CorporationImpl(agent, id);\n  };\n\n  <attachSearchFunction>\n  functor.search = search_1.makeDefaultSearch(agent, \"corporation\" );\n  </attachSearchFunction>\n\n  <attachNPCFunction>\n  functor.npc = function () {\n    return agent.request('get_corporations_npccorps', undefined);\n  };\n  </attachNPCFunction>\n\n  <attachNamesFunction>\n  functor.names = function (ids) {\n    <handleLargeIdArrays>\n    if (ids.length > 100) {\n      return names_1.getNames(agent, \"corporation\" , ids);\n    }\n    </handleLargeIdArrays>\n    else {\n      <handleSmallIdArrays>\n      return agent.request('get_corporations_names', { query: { 'corporation_ids': ids } })\n          .then(result => {\n          let map = new Map();\n          for (let name of result) {\n              map.set(name.corporation_id, name.corporation_name);\n          }\n          return map;\n      });\n      </handleSmallIdArrays>\n    }\n  };\n  </attachNamesFunction>\n  \n  return functor;\n}\n"], ["ForCommand", "\nfunction ForCommand(value, engine) {\n  <parseForCommand>\n  var rule = new RegExp(\n      stringFormat(\n        '^\\\\s*({0}[\\\\s\\\\S]+{1})\\\\s+as\\\\s+{0}([0-9a-z_]+){1}\\\\s*(,\\\\s*{0}([0-9a-z_]+){1})?\\\\s*$',\n        regexpLiteral(engine.options.variableOpen),\n        regexpLiteral(engine.options.variableClose)\n      ),\n      'i'\n  );\n  </parseForCommand>\n\n  <matchForCommand>\n  var match = value.match(rule);\n  if (!match) {\n      throw new Error('Invalid ' + this.type + ' syntax: ' + value);\n  }\n  </matchForCommand>\n\n  <assignForCommandProperties>\n  this.list = match[1];\n  this.item = match[2];\n  this.index = match[4];\n  Command.call(this, value, engine);\n  this.cloneProps = ['list', 'item', 'index'];\n  </assignForCommandProperties>\n}\n"], ["drawLoop", "\nfunction drawLoop () {\n  <clearCanvas>\n  ctx.clearRect(0, 0, canvas.width, canvas.height)\n  </clearCanvas>\n\n  <calculateCenter>\n  var centerX = canvas.width / 2\n  var centerY = canvas.height / 2\n  </calculateCenter>\n\n  <drawPrimaryCircle>\n  ctx.beginPath()\n  ctx.arc(centerX, centerY, 100, 0, 2 * Math.PI, false)\n  ctx.fillStyle = 'yellow'\n  ctx.fill()\n  </drawPrimaryCircle>\n\n  <drawSegments>\n  ctx.strokeStyle = 'lime'\n  scope.draw(ctx, 0, 0, centerX, centerY)\n\n  ctx.strokeStyle = 'cyan'\n  scope.draw(ctx, centerX, 0, centerX, centerY)\n\n  ctx.strokeStyle = 'red'\n  scope.draw(ctx, 0, centerY, null, centerY)\n  </drawSegments>\n\n  <requestNextAnimationFrame>\n  window.requestAnimationFrame(drawLoop)\n  </requestNextAnimationFrame>\n}\n"], ["setSegment", "\nfunction setSegment(start, end, identifier) {\n  <assignDefaultIdentifier>\n  if (identifier === undefined || identifier === null || identifier.length === 0) {\n    identifier = \"default\";\n  }\n  </assignDefaultIdentifier>\n\n  <createNewSegment>\n  this.segments[identifier] = new WaveformDataSegment(this, start, end);\n  </createNewSegment>\n\n  return this.segments[identifier];\n}\n"], ["setNestedValue", "\nfunction setNestedValue(data, field, value) {\n  var fieldParts = _.isArray(field) ? field : field.split('.');\n\n  <handleSingleFieldParts>\n  if (fieldParts.length === 1) {\n      data[field] = _.isString(value) ? value.trim() : value;\n      return;\n  }\n  </handleSingleFieldParts>\n\n  <initializeNestedStructureIfNecesssary>\n  data[fieldParts[0]] = data[fieldParts[0]] || {};\n  </initializeNestedStructureIfNecesssary>\n\n  <recursiveSetNestedValue>\n  setNestedValue(data[fieldParts[0]], fieldParts.slice(1, fieldParts.length), value);\n  </recursiveSetNestedValue>\n}\n"], ["getCheckedValues", "\nfunction getCheckedValues() {\n  var checkedValues = [];\n  for(var i=0, j=this.checkboxes.length; i<j; i++) {\n    if(this.checkboxes[i].checked) {\n        checkedValues[checkedValues.length] = this.checkboxes[i].value;\n    }\n  }\n  return checkedValues;\n}\n"], ["parseHTMLComment", "\nfunction parseHTMLComment(mode, code, tokens, flags, scope, parseMode) {\n  <locateStartOfComment>\n  var index = code.index,\n      length = code.length;\n\n  if (\n    code.codePointAt(index) === 0x003c &&\n    code.codePointAt(++index) === 0x0021 &&\n    code.codePointAt(++index) === 0x002d &&\n    code.codePointAt(++index) === 0x002d\n  ) {\n      index++;\n  </locateStartOfComment>\n\n  <searchCommentClosing>\n  for (; index < length; index++) {\n      if (\n          code.codePointAt(index) === 0x002d &&\n          code.codePointAt(index + 1) === 0x002d &&\n          code.codePointAt(index + 2) === 0x003e\n      ) {\n          index += 3;\n          code.index = index;\n\n          return true;\n      }\n  }\n  </searchCommentClosing>\n\n  <handleUnclosedComment>\n  throw code.makeError(\n    code.index, code.index + 4,\n    'Unclosed Comment: Expected \"-->\" to fallow \"<!--\".'\n  );\n  </handleUnclosedComment>\n}\n"], "```"]