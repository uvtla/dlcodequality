[["patchBundle", "\nfunction patchBundle(bundle: Bundle, delta: DeltaBundle): Bundle {\n  const map = new Map(bundle.modules);\n\n  for (const [key, value] of delta.modified) {\n    map.set(key, value);\n  }\n\n  for (const [key, value] of delta.added) {\n    map.set(key, value);\n  }\n\n  for (const key of delta.deleted) {\n    map.delete(key);\n  }\n\n  const modules = Array.from(map.entries());\n\n  return {\n    pre: bundle.pre,\n    post: bundle.post,\n    modules,\n  };\n}\n"], ["getItemAtIndex", "\nfunction (state, index) {\n  var items = this._getItems(state.choice);\n  if (index < items.length) {\n    return items[index];\n  }\n  return null;\n}\n"], ["processNodeRuleWithREM", "\nfunction processNodeRuleWithREM(nodeRule, imageReplaces, rootFontSize){\n    var img, imgKey, __url\n    _.each(nodeRule.declarations, function(e){\n        if(e.property == 'background-image'){\n            __url = __getURL(e.value)\n            img = img || imageReplaces[__url]\n            imgKey = img? __url: imgKey\n        }\n    })\n    if(!img) return\n    \n    updateNodeByMerge(nodeRule, __generatorCSSObj(img))\n\n    function __getURL(bgURL){\n        return _.trim(bgURL.split('url').join(''), '()\"\\'')\n    }\n    function __generatorCSSObj(img){\n        return {\n            \"background-image\": \"url(\"+img.sprite+\")\",\n            \"background-position\":  \"-\"+img.x/rootFontSize+\"rem -\"+img.y/rootFontSize+\"rem\",\n            \"-webkit-background-size\": img.spriteWidth / rootFontSize + \"rem\",\n            \"-moz-background-size\": img.spriteWidth / rootFontSize + \"rem\",\n            \"-o-background-size\": img.spriteWidth / rootFontSize + \"rem\",\n            \"background-size\": img.spriteWidth / rootFontSize + \"rem\"\n        }\n    }\n}\n"], ["BIP151", "\nfunction BIP151(cipher) {\n  if (!(this instanceof BIP151))\n    return new BIP151(cipher);\n\n  EventEmitter.call(this);\n\n  this.input = new BIP151Stream(cipher);\n  this.output = new BIP151Stream(cipher);\n\n  this.initReceived = false;\n  this.ackReceived = false;\n  this.initSent = false;\n  this.ackSent = false;\n  this.completed = false;\n  this.handshake = false;\n\n  this.pending = [];\n  this.total = 0;\n  this.waiting = 4;\n  this.hasSize = false;\n\n  this.timeout = null;\n  this.job = null;\n  this.onShake = null;\n\n  this.bip150 = null;\n}\n"], ["setupBlocklyIconMenu", "\nfunction() {\n    this.appendDummyInput()\n        .appendField(new Blockly.FieldIconMenu(\n            [\n              {src: Blockly.mainWorkspace.options.pathToMedia + 'icons/set-led_mystery.svg',\n                value: 'mystery', width: 48, height: 48, alt: 'Mystery'},\n              ...\n              {src: Blockly.mainWorkspace.options.pathToMedia + 'icons/set-led_white.svg',\n                value: 'white', width: 48, height: 48, alt: 'White'}\n            ]), 'CHOICE');\n    this.setOutput(true);\n    this.setColour(Blockly.Colours.looks.primary,\n        Blockly.Colours.looks.secondary,\n        Blockly.Colours.looks.tertiary\n    );\n  }\n"], ["_applyChange", "\nfunction _applyChange(oChange, oRelevantContainer, mPropertyBag, fnIterator) {\n    ...\n    \n    oChangeContent.movedElements.forEach(function (mMovedElement) {\n        ...\n        \n        if (iCurrentIndexInAggregation !== iTargetIndex) {\n            ...\n        } else {\n            ...\n        }\n\n        ...\n        \n        var oTemplate = oModifier.getBindingTemplate(oTable, ITEMS_AGGREGATION_NAME);\n\n        if (oTemplate) {\n            ...\n            oModifier.updateAggregation(oTable, ITEMS_AGGREGATION_NAME);\n        } else {\n            moveColumns(iSourceIndex, iTargetIndex);\n        }\n    }, this);\n\n    return true;\n}\n"], ["run", "\nfunction run (answers) {\n    ls(['LICENSE', 'package.json', 'README.md', 'index.js', 'index.html', 'examples/basic/index.html', 'tests/index.test.js']).forEach(function (file) {\n      answers.aframeVersion = aframeVersion;\n      answers.npmName = `aframe-${answers.shortName}-component`;\n      fs.writeFileSync(file, nunjucks.render(file, answers));\n    });\n  }\n"], ["_fnHungarianMap", "\nfunction _fnHungarianMap ( o ) {\n    ...\n    \n    $.each( o, function (key, val) {\n        match = key.match(/^([^A-Z]+?)([A-Z])/);\n    \n        if ( match && hungarian.indexOf(match[1]+' ') !== -1 ) {\n            ...\n    \n            if ( match[1] === 'o' ) {\n                _fnHungarianMap( o[key] );\n            }\n        }\n    } );\n    \n    o._hungarianMap = map;\n}\n"], ["runJob", "\nfunction (jobName, param, customParams, callback) {\n    ...\n    \n    doRequest({\n        ...\n    }, customParams, callback);\n}\n"], ["makeTheCall", "\nfunction makeTheCall(api, apiName, apiCall, fn) {\n  request(apiCall, function(error, response, body) {\n    if (error) {\n      ...\n    } else if (response.statusCode == 200) {\n      ...\n    } else {\n      ...\n    }\n  });\n}\n"], "```\n\nThe annotations are in place. Each named function is surrounded by tags that reflect the name or purpose of the function, indicating that the function has a single cohesive responsibility compliant with the SRP. If there were any violations such as a function having multiple distinct responsibilities, nested tags would be used to highlight these within the main tag of the function."]