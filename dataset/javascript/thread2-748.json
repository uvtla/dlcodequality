[["checkUserNotificationAccess", "\nfunction (username, channel) {\n  var list = this.getUserNotifications(username);\n\n  if (list === null) {\n    return false;\n  }\n\n  return list.indexOf(channel) >= 0;\n}\n"], ["getFormat0Segment", "\nfunction getFormat0Segment(glyfUnicodes) {\n  var unicodes = [];\n  glyfUnicodes.forEach(function (u) {\n    if (u.unicode !== undefined && u.unicode < 256) {\n      unicodes.push([u.unicode, u.id]);\n    }\n  });\n\n  unicodes.sort(function (a, b) {\n    return a[0] - b[0];\n  });\n\n  return unicodes;\n}\n"], ["unregisterMathJaxExplorerHook", "\nfunction() {\n  if (Explorer.hook) {\n    MathJax.Hub.UnRegister.MessageHook(Explorer.hook);\n    Explorer.hook = null;\n  }\n}\n"], ["constructChainObject", "\nfunction Chain(opts) {\n  if (!(this instanceof Chain)) {\n    return new Chain(opts);\n  }\n\n  if (opts.constructor) {\n    this.devices = new opts.constructor(opts.actuators);\n  } else {\n    this.devices = opts.actuators;\n  }\n\n  this.chainType = opts.chainType;\n\n  this.links = opts.links;\n\n  this.origin = opts.origin || [0, 0, 0];\n  this.position = opts.startAt || [0, 0, 0];\n\n  this.require = opts.require || true;\n}\n"], ["verifyCalibrationConstants", "\nfunction verifyCalibrationConstants(bundle, testName) {\n  var defered = q.defer();\n  var msg = '';\n  if (bundle.calibrationInfoValid) {\n    <getHighResADCState>\n    var checkHighRes = false;\n    try {\n      checkHighRes = bundle.device.savedAttributes.HARDWARE_INSTALLED.highResADC;\n    } catch (err) {\n      checkHighRes = false;\n    }\n    </getHighResADCState>\n    var deviceTypeName = bundle.device.savedAttributes.deviceTypeName;\n    \n    <validateCalibrationInfo>\n    var calCheckResult = getInvalidCalibrationValues(deviceTypeName, checkHighRes, bundle.calibrationInfo);\n    </validateCalibrationInfo>\n\n    <updateBundleWithCalibrationTestResult>\n    if (calCheckResult.length > 0) {\n      msg = calCheckResult.length.toString() + ' calibration constants are out of range.';\n      bundle.hardwareTests[testName].status = false;\n      bundle.hardwareTests[testName].executed = true;\n      bundle.hardwareTests[testName].testMessage = msg;\n    } else {\n      msg = 'Device calibration constants are in range.';\n      bundle.hardwareTests[testName].status = true;\n      bundle.hardwareTests[testName].executed = true;\n      bundle.hardwareTests[testName].testMessage = msg;\n    }\n    </updateBundleWithCalibrationTestResult>\n  } else {\n    msg = 'Skipped due to invalid calibration info';\n    bundle.hardwareTests[testName].status = false;\n    bundle.hardwareTests[testName].executed = true;\n    bundle.hardwareTests[testName].testMessage = msg;\n  }\n  defered.resolve(bundle);\n  return defered.promise;\n}\n"], ["getImageDataFromSource", "\nfunction getImageData(img) {\n  let data = null;\n  return new Promise((reslove, reject) => {\n    if (img.src) {\n      <handleBase64Source>\n      if (/^data\\:/i.test(img.src)) {\n        data = base64ToArrayBuffer(img.src);\n        reslove(data)\n      }\n      </handleBase64Source>\n      <handleBlobSource>\n      else if (/^blob\\:/i.test(img.src)) {\n        var fileReader = new FileReader();\n        fileReader.onload = function (e) {\n          data = e.target.result;\n          reslove(data)\n        };\n        objectURLToBlob(img.src, function (blob) {\n          fileReader.readAsArrayBuffer(blob);\n        });\n      }\n      </handleBlobSource>\n      <handleHttpSource>\n      else {\n        var http = new XMLHttpRequest();\n        http.onload = function () {\n          if (this.status == 200 || this.status === 0) {\n            data = http.response\n            reslove(data)\n          } else {\n            throw \"Could not load image\";\n          }\n          http = null;\n        };\n        http.open(\"GET\", img.src, true);\n        http.responseType = \"arraybuffer\";\n        http.send(null);\n      }\n      </handleHttpSource>\n    } else {\n      reject('img error')\n    }\n  })\n}\n"], ["filterOptionsBasedOnValue", "\nfunction filterOptions(options, value) {\n  \n  if (!value) {\n    return options;\n  }\n\n  value = value.toLowerCase();\n\n  return options.filter(({ label }) => label.toLowerCase().indexOf(value) >= 0);\n}\n"], ["outputBindingDataForElement", "\nfunction xPropOutput(element, bindInfo, data) {\n  \n  if (!element.lifeCycle.created) {\n    return;\n  }\n\n  var el = element.el;\n\n  if (element.tagName === 'input' && bindInfo.name === 'checked') {\n    var bindValue = getANodeProp(element.aNode, 'value');\n    var bindType = getANodeProp(element.aNode, 'type');\n\n    if (bindValue && bindType) {\n      switch (el.type.toLowerCase()) {\n        case 'checkbox':\n          data[el.checked ? 'push' : 'remove'](bindInfo.expr, el.value);\n          return;\n\n        case 'radio':\n          el.checked && data.set(bindInfo.expr, el.value, {\n            target: {\n              node: element,\n              prop: bindInfo.name\n            }\n          });\n          return;\n      }\n    }\n  }\n\n  data.set(bindInfo.expr, el[bindInfo.name], {\n    target: {\n      node: element,\n      prop: bindInfo.name\n    }\n  });\n}\n"], ["dynamicFilesCompilation", "\nfunction() {\n  for (var i = 0; i < DYNAMIC_FILES.length; i++) {\n    addFile(dynamicFilesCompiled[i](options), { name: DYNAMIC_FILES[i] });\n  }\n}\n"], ["addOrdinalNumberSuffix", "\nfunction addOrdinalNumberSuffix(num) {\n  var j = num % 10,\n    k = num % 100;\n  if (j == 1 && k != 11) {\n    return num + \"st\";\n  }\n  if (j == 2 && k != 12) {\n    return num + \"nd\";\n  }\n  if (j == 3 && k != 13) {\n    return num + \"rd\";\n  }\n  return num + \"th\";\n}\n"], "```"]