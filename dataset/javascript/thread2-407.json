[["convertToTokens", "\nfunction convertToTokens( contents, filterParams ) {\n  <createTokens>\n  var tokens = marked.lexer( contents );\n  </createTokens>\n\n  <returnTokensIfNoFilter>\n  if ( ! filterParams ) {\n    return tokens;\n  }\n  </returnTokensIfNoFilter>\n\n  <isTokenValid>\n  function isTokenValid( token ) {\n    <checkTokenParam>\n    function checkTokenParam( valid, targetValue, key ) {\n      if ( ! valid ) {\n        return false;\n      }\n\n      if ( typeof targetValue === 'undefined' ) {\n        return true;\n      }\n\n      var tokenPropToTest = token[ key ];\n      <testTokenValue>\n      if ( isRegExp( targetValue ) ) {\n        return targetValue.test( tokenPropToTest );\n      }\n      </testTokenValue>\n\n      return tokenPropToTest === targetValue;\n    }\n    </checkTokenParam>\n\n    return reduce( filterParams, checkTokenParam, true );\n  }\n  </isTokenValid>\n\n  <filterTokens>\n  return tokens.filter( isTokenValid );\n  </filterTokens>\n}\n"], ["resetImage", "\nfunction resetImage() {\n  <checkCurrentScale>\n  if (currentScale == 1) return;\n  </checkCurrentScale>\n\n  <initializeVariables>\n  var node = zoomNode, left, top, trans, w, h, pos, start, end, parent, flowTag;\n  </initializeVariables>\n\n  <calculateTransformations>\n  trans = getComputedTranslate(node);\n  parent = node.parentNode;\n  w = node.clientWidth * trans.scaleX;\n  h = node.clientHeight * trans.scaleX;\n  pos = getPosition(node);\n  start = {\n      left: (1 - trans.scaleX) * trans.offsetX + pos.left + trans.translateX,\n      top: (1 - trans.scaleX) * trans.offsetY + pos.top + trans.translateY\n  };\n  end = {\n      left: start.left + w,\n      top: start.top + h\n  };\n  </calculateTransformations>\n\n  <adjustPositionBasedOnOverflow>\n  left = start.left;\n  top = start.top;\n  flowTag = overFlow(parent, {start: start, end: end});\n  switch (flowTag) {\n      case 1: ... // omitted for brevity\n  }\n  if (w < parent.clientWidth) {\n      left = pos.left - (trans.scaleX - 1) * node.clientWidth / 2;\n  }\n  if (h < parent.clientHeight) {\n      top = pos.top - (trans.scaleX - 1) * node.clientHeight / 2;\n  }\n  </adjustPositionBasedOnOverflow>\n\n  <applyTransformation>\n  node.style.webkitTransitionDuration = '100ms';\n  node.style.webkitTransform = generateTranslate(trans.translateX + left - start.left, trans.translateY + top - start.top, 0, trans.scaleX);\n  </applyTransformation>\n}\n"], ["calculateDirection", "\nfunction(course) {\n  <initializeVariables>\n  var s = this['SCALE'];\n  var k = DIRECTIONS.length;\n  </initializeVariables>\n\n  <computeDirection>\n  var dir = Math.round(course / s * k);\n  </computeDirection>\n\n  <returnDirection>\n  return DIRECTIONS[mod(dir, k)];\n  </returnDirection>\n}\n"], ["makeCallback", "\nfunction makeCallback(callback) {\n  <checkCallbackType>\n  if (_.isFunction(callback)) {\n    return callback;\n  }\n  </checkCallbackType>\n\n  <constructCallback>\n  var result = function() { return callback; };\n  result._callback = callback;\n  </constructCallback>\n\n  <returnConstructedCallback>\n  return result;\n  </returnConstructedCallback>\n}\n"], ["responseCreditConsume", "\nfunction responseCreditConsume(status, credits, options){\n  \n  <initializeOptions>\n  options = options || {};\n  </initializeOptions>\n\n  <handleFailStatus>\n  if(status === 'fail'){\n    return {\n        status: status,\n        errorMessage: options.errorMessage || '',\n        credits: credits\n    };\n  }\n  </handleFailStatus>\n  \n  <handleOkStatus>\n  else if(status === 'ok'){\n    return {\n        status: status,\n        errorMessage: options.errorMessage || '',\n        bizId: options.bizId,\n        credits: credits\n    };\n  }\n  </handleOkStatus>\n  \n  <throwErrorForInvalidStatus>\n  else{\n    throw new Error('status \u4e0d\u5b58\u5728\uff0c\u53ef\u9009\u503c\u4e3a ok \u6216 fail');\n  }\n  </throwErrorForInvalidStatus>\n}\n"], ["backwardPropagation", "\nfunction(y) {\n  <initializeVariables>\n  var N = this.layers.length;\n  </initializeVariables>\n  \n  <computeInitialLoss>\n  var loss = this.layers[N-1].backward(y); \n  </computeInitialLoss>\n\n  <propagateBackward>\n  for(var i=N-2;i>=0;i--) { \n    this.layers[i].backward();\n  }\n  </propagateBackward>\n\n  <returnLoss>\n  return loss;\n  </returnLoss>\n}\n"], ["updateValueAndFireEvent", "\nfunction(value, sendUpdatedEvt) {\n  \n  <updateElementValue>\n  this.hiddenEl.value = value || \"\";\n  this.el.value  =  value || \"\";\n  </updateElementValue>\n\n  <updateClassFromState>\n  this.setClassFromState();\n  </updateClassFromState>\n\n  <fireUpdateEventIfNecessary>\n  if(sendUpdatedEvt !== false) {\n    this.fireUpdatedEvt();\n  }\n  </fireUpdateEventIfNecessary>\n\n}\n"], ["combineUsingBinaryFunction", "\nfunction nary(binary, args) {\n  <initializeAccumulator>\n  var len = args.length;\n  var result = args[0];\n  </initializeAccumulator>\n  \n  <applyBinaryFunction>\n  for (var i = 1; i < len; ++i)\n    result = binary(result, args[i]);\n  </applyBinaryFunction>\n\n  <returnResult>\n  return result;\n  </returnResult>\n}\n"], ["removeClientModelDocWithDialogConfirmation", "\nfunction remove(form, ev) {\n  <displayDialogConfirmation>\n  var confirm = $mdDialog.confirm()\n    .title('Delete clientModelDoc ' + vm.displayName + '?')\n    .content('Do you really want to delete clientModelDoc ' + vm.displayName + '?')\n    .ariaLabel('Delete clientModelDoc')\n    .ok('Delete clientModelDoc')\n    .cancel('Cancel')\n    .targetEvent(ev);\n\n  $mdDialog.show(confirm)\n    .then(performRemove);\n  </displayDialogConfirmation>\n\n  <performRemove>\n  function performRemove() {\n    ClientModelDocService.remove(vm.clientModelDoc)\n      .then(deleteClientModelDocSuccess)\n      .catch(deleteClientModelDocCatch);\n\n    function deleteClientModelDocSuccess() {\n      Toast.show({type: 'success', text: 'ClientModelDoc ' + vm.displayName + ' deleted'});\n      vm.showList();\n    }\n\n    function deleteClientModelDocCatch(err) {\n      Toast.show({\n        type: 'warn',\n        text: 'Error while deleting clientModelDoc ' + vm.displayName,\n        link: {state: $state.$current, params: $stateParams}\n      });\n\n      if (form && err) {\n        form.setResponseErrors(err, vm.errors);\n      }\n    }\n  }\n  </performRemove>\n}\n"], ["mine", "\nfunction mine(data, target, min, max) {\n  <initializeNonce>\n  let nonce = min;\n  </initializeNonce>\n\n  <prepareInitialData>\n  data.writeUInt32LE(nonce, 76, true);\n  </prepareInitialData>\n\n  <miningLoop>\n  while (nonce <= max) {\n    <hashAndCompare>\n    if (rcmp(calHash(data), target) <= 0)\n      return nonce;\n    </hashAndCompare>\n\n    <incrementNonce>\n    nonce++;\n    </incrementNonce>\n\n    <updateDataWithNewNonce>\n    data.writeUInt32LE(nonce, 76, true);\n    </updateDataWithNewNonce>\n  }\n  </miningLoop>\n\n  <returnInvalidNonce>\n  return -1;\n  </returnInvalidNonce>\n}\n"], "```"]