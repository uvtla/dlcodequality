[["parse_compobj", "\nfunction parse_compobj(obj) {\n    var v = {};\n    var o = obj.content;\n\n    <parse_id>\n    var l = 28, m;\n    m = __lpstr(o, l);\n    l += 4 + __readUInt32LE(o, l);\n    v.UserType = m;\n    </parse_id>\n\n    <parse_clipboard>\n    m = __readUInt32LE(o, l);\n    l += 4;\n    switch (m) {\n        case 0x00000000: break;\n        case 0xffffffff: case 0xfffffffe: l += 4; break;\n        default:\n            if (m > 0x190) throw new Error(\"Unsupported Clipboard: \" + m.toString(16));\n            l += m;\n    }\n    </parse_clipboard>\n\n    <parse_reserved>\n    m = __lpstr(o, l);\n    l += m.length === 0 ? 0 : 5 + m.length;\n    v.Reserved1 = m;\n    </parse_reserved>\n\n    <check_extension>\n    if ((m = __readUInt32LE(o, l)) !== 0x71b2e9f4) return v;\n    throw new Error(\"Unsupported Unicode Extension\");\n    </check_extension>\n}\n"], ["Spotlight", "\nfunction Spotlight() {\n    <spotlightRotations_declaration>\n    var spotlightRotations = [ /* ... Array Content ... */ ];\n    </spotlightRotations_declaration>\n\n    <minigameAlias_declaration>\n    var minigameAlias = { /* ... Object Content ... */ };\n    </minigameAlias_declaration>\n\n    <class_fields>\n    \n    this.PEST_CONTROL = 'pest control';\n    /* ... More Fields ... */\n    this.TROUBLE_BREWING = 'trouble brewing';\n    </class_fields>\n\n    <readRotations_method>\n    var readRotations = function () {\n        /* ... Method Implementation ... */\n    }\n    </readRotations_method>\n\n    <getRotation_method>\n    this.getRotation = function (onDate) {\n        /* ... Method Implementation ... */\n    }\n    </getRotation_method>\n\n    <getMinigameNext_method>\n    this.getMinigameNext = function (minigame) {\n        /* ... Method Implementation ... */\n    }\n    </getMinigameNext_method>\n}\n"], ["color_conversion", "\nfunction (color) {\n    <validate_and_convert>\n    var type = this.type(color, 'color.toHex() : \"' + color + '\" ' + MSG_NOT_COLOR);\n    switch (type) {\n        /* ... Case Setup for Conversion ... */\n    }\n    </validate_and_convert>\n}\n"], ["Logger", "\nfunction Logger(sid, flag) {\n  \n  this.sid = sid;\n  \n  <create_log_stream>\n  this.out = fs.createWriteStream(\n    __dirname + '/logs/' + sid.replace(/:/g, '-') + '.log', { flags: flag || 'w' });\n  </create_log_stream>\n  \n  this.buf = {};\n  \n  this.last = {};\n}\n"], ["runSeleniumInBackground", "\nfunction runSeleniumInBackground(done) {\n    <announce_start>\n    console.log([moment().format('HH:mm:ss:SSS')] + ' kne: starting selenium server in background...');\n    </announce_start>\n\n    <start_selenium_process>\n    selenium_proc = child_process.spawn('java',\n        /* ... Arguments ... */,\n        {\n            stdio: ['ignore', 'pipe', 'pipe'],\n        });\n    var running = false;\n    </start_selenium_process>\n\n    <handle_selenium_output>\n    selenium_proc.stderr.on('data', function (buffer) {\n        /* ... Error Handling ... */\n    });\n\n    selenium_proc.on('close', function (code) {\n        /* ... Close Event Handling ... */\n    });\n    </handle_selenium_output>\n}\n"], ["UrlNode", "\nfunction UrlNode(data) {\n    <method_definitions>\n    this.append = function (next) { /* ... Implementation ... */ };\n    this.getData = function () { /* ... Implementation ... */ };\n    /* ... More Methods ... */\n    this.getParams = function () { /* ... Implementation ... */ };\n    </method_definitions>\n\n    <initialize_data_and_params>\n    var queryParamSplit = data.split(\"?\");\n    this.params = null;\n    this.data = null;\n    this.next = null;\n    if (queryParamSplit != null && queryParamSplit.length > 1) {\n        this.setData(queryParamSplit[0]);\n        this.setParams(queryParamSplit[1]);\n    } else {\n        this.setData(data);\n    }\n    </initialize_data_and_params>\n}\n"], ["update_ngModel", "\nfunction (model) {\n    <check_ngModel>\n    if (!this.ngModel) {\n        return;\n    }\n    </check_ngModel>\n\n    <update_model>\n    var index = this.selected.indexOf(model);\n    if (index !== -1) {\n        this.selected.splice(index, 1);\n        if (this.multiple) {\n            this.ngModel.$setViewValue(this.selected);\n        } else {\n            this.ngModel.$setViewValue(undefined);\n        }\n    }\n    </update_model>\n}\n"], ["parseInlineKatex", "\nfunction parseInlineKatex(state, silent) {\n    <setup>\n    var dollar = 0x24;\n    /* ... Setup Variables ... */\n    </setup>\n\n    <check_initial_condition>\n    if (state.src.charCodeAt(pos) !== dollar) { return false; }\n    ++pos;\n    /* ... Additional Checks ... */\n    </check_initial_condition>\n\n    <process_markdown_latex>\n    while ((matchStart = state.src.indexOf('$', matchEnd)) !== -1) {\n        /* ... Inline Parsing Logic ... */\n    }\n    </process_markdown_latex>\n\n    <handle_failure>\n    if (!silent) state.pending += marker;\n    state.pos += marker.length;\n    </handle_failure>\n\n    return true;\n}\n"], ["callApi", "\nfunction callApi(method, parameters, callback) {\n\n    <parameter_validation>\n    if (typeof parameters === 'undefined') {\n        throw new Error('undefined is not a valid parameters object.');\n    }\n\n    if (typeof parameters !== 'object') {\n        throw new Error('valid parameters object required.');\n    }\n    </parameter_validation>\n\n    <check_api_keys>\n    var opts = this.options;\n    var noCallback = !callback || typeof callback !== 'function';\n    let noApiKey = typeof opts.API_KEY !== 'string' || opts.API_KEY.length === 0 || typeof opts.API_SECRET !== 'string' || opts.API_SECRET.length === 0;\n    if (noApiKey) {\n        if (noCallback) {\n            throw new Error('API key and API secret required.');\n        }\n        return callback(new Error(\"API key and API secret required.\"));\n    }\n    </check_api_keys>\n\n    <set_method>\n    opts.method = method;\n    </set_method>\n\n    <construct_url>\n    let url = makeApiUrl(opts, parameters);\n    </construct_url>\n\n    <setup_request_options>\n    let reqOptions = {\n        uri: url,\n        json: true,\n        timeout: process.env.CF_TIMEOUT || opts.DEFAULT_TIMEOUT\n    };\n    </setup_request_options>\n\n    <execute_request>\n    if (noCallback) {\n        return new Request(reqOptions);\n    }\n\n    return callRequest(reqOptions, handleCallback.bind(null, callback));\n    </execute_request>\n}\n"], ["wheel_event_handler", "\nfunction () {\n    <shouldPreventDefault>\n    var shouldPreventDefault = function (deltaX, deltaY) {\n        /* ... Implementation ... */\n    };\n    </shouldPreventDefault>\n\n    <attach_mousewheel_event>\n    $this.mousewheel(function (e, delta, deltaX, deltaY) {\n        /* ... Event Handling Logic ... */\n    });\n    </attach_mousewheel_event>\n}\n"], ""]