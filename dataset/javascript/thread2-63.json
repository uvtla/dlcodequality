[["hasOwnEvent", "\nfunction hasOwnEvent(moduleObject, moduleOption) {\n    moduleOption = defaultOption(moduleOption);\n    return moduleObject.hasOwnProperty(moduleOption.event) && (moduleObject[moduleOption.event] instanceof Event);\n}\n"], ["register", "\nfunction register(componentPath, tagName, cache) {\n  <inputValidation>\n  if (typeof componentPath === 'object') {\n    const definition = componentPath\n    return jComponent.register(definition)\n  }\n\n  if (typeof componentPath !== 'string') {\n    throw new Error('componentPath must be a string')\n  }\n\n  if (!tagName || typeof tagName !== 'string') {\n    tagName = 'main' \n  }\n  </inputValidation>\n\n  <loadComponent>\n  const oldLoad = nowLoad\n  const component = nowLoad = {\n    tagName,\n    json: _.readJson(`${componentPath}.json`),\n  }\n\n  if (!component.json) {\n    throw new Error(`invalid componentPath: ${componentPath}`)\n  }\n  </loadComponent>\n\n  <processDependencies>\n  const usingComponents = component.json.usingComponents || {}\n  const usingComponentKeys = Object.keys(usingComponents)\n  for (let i = 0, len = usingComponentKeys.length; i < len; i++) {\n    const key = usingComponentKeys[i]\n    const usingPath = path.join(path.dirname(componentPath), usingComponents[key])\n    const id = register(usingPath, key, cache)\n    usingComponents[key] = id\n  }\n  </processDependencies>\n\n  <compileComponent>\n  component.wxml = compile.getWxml(componentPath, cache.options, usingComponents)\n  component.wxss = wxss.getContent(`${componentPath}.wxss`)\n  </compileComponent>\n\n  <execComponentScript>\n  _.runJs(componentPath)\n  </execComponentScript>\n\n  <compileStylesheet>\n  cache.wxss.push(wxss.compile(component.wxss, {\n    prefix: tagName,\n    ...cache.options,\n  }))\n  </compileStylesheet>\n\n  nowLoad = oldLoad\n\n  return component.id\n}\n"], ["Inliner", "\nfunction Inliner(source, options, callback) {\n  var inliner = this;\n  events.EventEmitter.call(this);\n\n  <parseArguments>\n  if (typeof source !== 'string') {\n    callback = options;\n    options = source;\n  }\n\n  if (typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n\n  if (!options) {\n    options = {};\n  }\n\n  if (options.url) {\n    this.url = options.url;\n  }\n\n  if (options.filename) {\n    this.filename = options.filename;\n  }\n\n  if (options.source) {\n    this.source = options.source;\n  } else {\n    this.source = source;\n  }\n  </parseArguments>\n\n  <processHeaders>\n  if (options.header) {\n    options.headers = options.header;\n    delete options.header;\n  }\n  \n  if (options.headers && !Array.isArray(options.headers)) {\n    options.headers = [options.headers];\n  }\n\n  if (options.headers && Array.isArray(options.headers)) {\n    options.headers = options.headers.reduce(function (acc, curr) {\n       \n      if (typeof curr === 'string') {\n        var parts = curr.split(':').map(function (s) {\n          return s.trim();\n        });\n        acc[parts[0]] = parts[1];\n      } else {\n        var key = Object.keys(curr);\n        acc[key] = curr[key];\n      }\n      return acc;\n    }, {});\n  }\n  </processHeaders>\n\n  <assignOptions>\n  this.headers = options.headers || {};\n\n  this.callback = function wrapper(error, res) {\n    \n    inliner.callback = function noop() {\n      \n      inliner.emit('error', 'callback fired again');\n    };\n\n    callback(error, res);\n  };\n  this.options = assign({}, Inliner.defaults(), options);\n  this.jobs = {\n    total: 0,\n    todo: 0,\n    tasks: tasks,\n    add: this.addJob.bind(this),\n    breakdown: {},\n    done: {},\n  };\n  </assignOptions>\n\n  <initializeJobTasks>\n  Object.keys(this.jobs.tasks).forEach(function (key) {\n    \n    this.jobs.breakdown[key] = 0;\n    this.jobs.done[key] = this.completeJob.bind(this, key);\n  }.bind(this));\n  </initializeJobTasks>\n\n  this.isFile = options.useStdin || false;\n\n  <errorHandling>\n  this.on('error', function localErrorHandler(event) {\n    \n    inliner.callback(event);\n  });\n  </errorHandling>\n\n  <prepareInlining>\n  if (this.source) {\n    if (typeof setImmediate === 'undefined') {\n      global.setImmediate = function setImmediatePolyfill(fn) {\n        \n        setTimeout(fn, 0);\n      };\n    }\n    this.promise = new Promise(function (resolve) {\n      \n      global.setImmediate(function () {\n        resolve(inliner.main());\n      });\n    });\n  } else {\n    \n    this.promise = Promise.reject(new Error('No source to inline'));\n  }\n  </prepareInlining>\n\n  return this;\n}\n"], ["searchBar_checkSearchResultPage", "\nfunction searchBar_checkSearchResultPage(searchTerm) {\n    <retrieveTargetInfo>\n    var targetUrl = this._bss.currentEngine.getSubmission(searchTerm, null).uri;\n    var currentUrl = this._controller.tabs.activeTabWindow.document.location.href;\n    </retrieveTargetInfo>\n\n    <extractDomainName>\n    var domainName = targetUrl.host.replace(/.+\\.(\\w+)\\.\\w+$/gi, \"$1\");\n    var index = currentUrl.indexOf(domainName);\n    </extractDomainName>\n\n    <assertDomain>\n    this._controller.assertJS(\"subject.URLContainsDomain == true\",\n                              {URLContainsDomain: currentUrl.indexOf(domainName) != -1});\n    </assertDomain>\n\n    <assertSearchTerm>\n    this._controller.assertJS(\"subject.URLContainsText == true\",\n                              {URLContainsText: currentUrl.toLowerCase().indexOf(searchTerm.toLowerCase()) != -1});\n    </assertSearchTerm>\n  }\n"], ["formatValue", "\nfunction() {\n    <handlePercentFormat>\n\t\tif (format === 'percent') {\n\t\t\treturn {\n\t\t\t\tvalue: value,\n\t\t\t\tformat: 'PERCENT',\n\t\t\t\tpercent: value / 100\n\t\t\t}\n\t\t}\n    </handlePercentFormat>\n    <handleTimeFormat>\n\t\telse if (format === 'time') {\n\t\t\tvar elapse = (Date.now() - startTime) / 1000;\n\t\t\tvar otime = endValue - elapse;\n\t\t\tvar percent = elapse / endValue;\n\t\t\t\n\t\t\tvar time = Math.max(0, Math.round(otime));\n\t\t\tvar hours = (time / 3600) >> 0;\n\t\t\tvar minutes = ((time - (hours * 3600)) / 60) >> 0;\n\t\t\tvar seconds = time - (hours * 3600) - (minutes * 60);\n\t\t\tif (seconds < 10 && minutes) seconds = '0' + seconds;\n\t\t\t\n\t\t\tif (minutes) {\n\t\t\t\treturn {\n\t\t\t\t\tvalue: minutes,\n\t\t\t\t\tformat: 'MINUTES',\n\t\t\t\t\tpercent: percent\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\treturn {\n\t\t\t\t\tvalue: seconds,\n\t\t\t\t\tformat: 'SECONDS',\n\t\t\t\t\tpercent: percent\n\t\t\t\t};\n\t\t\t}\n\t\t}\n    </handleTimeFormat>\n}\n"], ["nodeExtent", "\nfunction nodeExtent(graph, attribute) {\n  <validateGraphInput>\n  if (!isGraph(graph))\n    throw new Error('graphology-metrics/extent: the given graph is not a valid graphology instance.');\n  </validateGraphInput>\n\n  <prepareAttributeList>\n  var attributes = [].concat(attribute);\n  </prepareAttributeList>\n\n  <initializeResults>\n  var results = {};\n\n  for (a = 0; a < attributes.length; a++) {\n    key = attributes[a];\n\n    results[key] = [Infinity, -Infinity];\n  }\n  </initializeResults>\n\n  <calculateExtents>\n  var nodes = graph.nodes(),\n      node,\n      data,\n      value,\n      key,\n      a,\n      i,\n      l;\n\n  for (i = 0, l = nodes.length; i < l; i++) {\n    node = nodes[i];\n    data = graph.getNodeAttributes(node);\n\n    for (a = 0; a < attributes.length; a++) {\n      key = attributes[a];\n      value = data[key];\n\n      if (value < results[key][0])\n        results[key][0] = value;\n\n      if (value > results[key][1])\n        results[key][1] = value;\n    }\n  }\n  </calculateExtents>\n\n  <returnResults>\n  return typeof attribute === 'string' ? results[attribute] : results;\n  </returnResults>\n}\n"], ["loadCollection", "\nfunction (value, options, callback) {\n    \n    var done = function (err, collection) {\n        <handleErrors>\n        if (err) {\n            return callback(err);\n        }\n        </handleErrors>\n\n        <validateCollection>\n        if (!_.isObject(collection)) {\n            return callback(new Error(COLLECTION_LOAD_ERROR_MESSAGE));\n        }\n        </validateCollection>\n\n        <instantiateCollection>\n        collection = new Collection(Collection.isCollection(collection) ? collection.toJSON() : collection);\n        </instantiateCollection>\n\n        <finalizeCallback>\n        callback(null, collection);\n        </finalizeCallback>\n    };\n\n    <processDirectCollections>\n    if (_.isObject(value)) {\n        return processCollection(value, done);\n    }\n    </processDirectCollections>\n\n    <loadExternalCollection>\n    externalLoader('collection', value, options, function (err, data) {\n        if (err) {\n            return done(err);\n        }\n        if (!_.isObject(data)) {\n            return done(new Error(COLLECTION_LOAD_ERROR_MESSAGE));\n        }\n\n        return processCollection(data, done);\n    });\n    </loadExternalCollection>\n}\n"], ["isMyTurn", "\nfunction isMyTurn(game, from) {\n    <checkGameStatus>\n    if (game.score.ended)\n        return false;\n    </checkGameStatus>\n    <getCurrentPosition>\n    from = Board.getPositionFromBoard(game.board, from);\n    </getCurrentPosition>\n    <determineTurn>\n    return isWhiteTurn(game) ? Position.hasWhitePiece(from) : Position.hasBlackPiece(from);\n    </determineTurn>\n}\n"], ["createFunction", "\nfunction createFunction(name, func, core, useCoreAPI) {\n  <parseFunction>\n  var beginBody = -1;\n  var funcParams = '';\n  var params = [];\n  var paramsClean = [];\n  var funcBody = '';\n  var header = '';\n  var action = null;\n  var isArrowFunction = true;\n  var isOneLine = false;\n  var functionName = name;\n\n  if (functionName.indexOf('.') !== -1) {\n    functionName = name.split('.')[name.split('.').length - 1];\n  }\n\n  if (func.trim().indexOf('function') === 0) {\n    isArrowFunction = false;\n  }\n  </parseFunction>\n\n  <extractFunctionParameters>\n  if (isArrowFunction) {\n    beginBody = func.indexOf('=>');\n\n    header = func.substring(0, beginBody);\n    header = header.replace('=>', '');\n\n    if (header.indexOf('(') !== -1) {\n      funcParams = header\n        .split('(')[1]\n        .replace(')', '')\n        .trim();\n    } else {\n      funcParams = header.trim();\n    }\n\n    params = funcParams.split(',');\n    params.forEach(function(param) {\n      paramsClean.push(param.trim());\n    });\n    </extractFunctionParameters>\n\n    <extractFunctionBody>\n    funcBody = func.substring(beginBody + 2, func.length).trim();\n\n    if (funcBody.indexOf('{') === 0) {\n      funcBody = funcBody.substring(1, funcBody.lastIndexOf('}')).trim();\n    }\n\n    if (funcBody.indexOf('\\n') === -1) {\n      isOneLine = true;\n    }\n\n    if (isArrowFunction && isOneLine && funcBody.indexOf('return ') === -1) {\n      funcBody = 'return ' + funcBody;\n    }\n    </extractFunctionBody>\n  } else {\n    <handleNonArrowFunction>\n    beginBody = func.indexOf('{');\n    header = func.substring(0, beginBody);\n\n    funcParams = header\n      .split('(')[1]\n      .replace(')', '')\n      .trim();\n\n    params = funcParams.split(',');\n    params.forEach(function(param) {\n      paramsClean.push(param.trim());\n    });\n\n    funcBody = func.substring(beginBody + 1);\n    funcBody = funcBody.substring(0, funcBody.lastIndexOf('}')).trim();\n    </handleNonArrowFunction>\n  }\n\n  <replaceThisAlias>\n  funcBody = funcBody.replace(/_this/g, 'this');\n  </replaceThisAlias>\n\n  <finalizeParams>\n  if (paramsClean[0] === '') {\n    paramsClean = [];\n  }\n  </finalizeParams>\n\n  <insertCoreAPI>\n  if (useCoreAPI) {\n    paramsClean.push('$component');\n    paramsClean.push('$db');\n    paramsClean.push('$metamodel');\n    paramsClean.push('$workflow');\n    paramsClean.push('$behavior');\n    paramsClean.push('$state');\n    paramsClean.push('$log');\n    paramsClean.push('$helper');\n  }\n\n  if ($helper.isOnNode()) {\n    paramsClean.push('require');\n  }\n  </insertCoreAPI>\n\n  <createAnonymousFunction>\n  if (paramsClean[0] !== '') {\n    action = new Function(\n      '__action',\n      'return function ' +\n        functionName +\n        ' (' +\n        paramsClean.join(', ') +\n        \") { return new Function('\" +\n        paramsClean.join(\"', '\") +\n        \"', __action).apply(this, arguments) };\"\n    )(funcBody);\n  } else {\n    action = new Function(\n      '__action',\n      'return function ' +\n        functionName +\n        ' () { return new Function(__action).apply(this, arguments) };'\n    )(funcBody);\n  }\n  </createAnonymousFunction>\n\n  return action;\n}\n"], ["rebootHandler", "\nfunction rebootHandler(job) {\n   <handleJobStatus>\n   if (job.status.status === 'QUEUED' || isUndefined(job.status.statusDetails) || isUndefined(job.status.statusDetails.step)) {\n      <startRebootProcess>\n      job.inProgress({ operation: job.operation, step: 'initiated' }, function(err) { \n         showJobsError(err);\n\n         var delay = (isUndefined(job.document.delay) ? '0' : job.document.delay.toString());\n         </startRebootProcess>\n\n         <executeRebootCommand>\n         \n         exec('sudo /sbin/shutdown -r +' + delay, function (err) { \n            if (!isUndefined(err)) {\n               job.failed({ operation: job.operation, errorCode: 'ERR_SYSTEM_CALL_FAILED', errorMessage: 'unable to execute reboot, check passwordless sudo permissions on agent', \n                            error: errorToString(err) }, showJobsError);\n            }\n         });\n         </executeRebootCommand>\n      });\n\n   \n   } else if (job.status.statusDetails.step === 'initiated') {\n      <markJobSucceeded>\n      job.succeeded({ operation: job.operation, step: 'rebooted' }, showJobsError);\n      </markJobSucceeded>\n   } else {\n      <handleUnexpectedState>\n      job.failed({ operation: job.operation, errorCode: 'ERR_UNEXPECTED', errorMessage: 'reboot job execution in unexpected state' }, showJobsError);\n      </handleUnexpectedState>\n   }   \n}\n"], ""]