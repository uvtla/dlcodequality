[["zoomChart", "\nfunction (e, panning) {\n\n\t<initializeVariables>\n\tvar chart = this,\n\t\thoverPoints = chart.hoverPoints,\n\t\tdoRedraw;</initializeVariables>\n\n\t<resetHoverPoints>\n\tif (hoverPoints) {\n\t\teach(hoverPoints, function (point) {\n\t\t\tpoint.setState();\n\t\t});\n\t}</resetHoverPoints>\n\n\t<handlePanning>\n\teach(panning === 'xy' ? [1, 0] : [1], function (isX) {\n\t\tvar mousePos = e[isX ? 'chartX' : 'chartY'],\n\t\t\taxis = chart[isX ? 'xAxis' : 'yAxis'][0],\n\t\t\tstartPos = chart[isX ? 'mouseDownX' : 'mouseDownY'],\n\t\t\thalfPointRange = (axis.pointRange || 0) / 2,\n\t\t\textremes = axis.getExtremes(),\n\t\t\tnewMin = axis.toValue(startPos - mousePos, true) + halfPointRange,\n\t\t\tnewMax = axis.toValue(startPos + chart[isX ? 'plotWidth' : 'plotHeight'] - mousePos, true) - halfPointRange;\n\n\t\tif (axis.series.length && newMin > mathMin(extremes.dataMin, extremes.min) && newMax < mathMax(extremes.dataMax, extremes.max)) {\n\t\t\taxis.setExtremes(newMin, newMax, false, false, { trigger: 'pan' });\n\t\t\tdoRedraw = true;\n\t\t}\n\t\tchart[isX ? 'mouseDownX' : 'mouseDownY'] = mousePos;\n\t});</handlePanning>\n\n\t<redrawChart>\n\tif (doRedraw) {\n\t\tchart.redraw(false);\n\t}\n\tcss(chart.container, { cursor: 'move' });</redrawChart>\n}\n"], ["validateOption", "\nfunction(option) {\n\t<initializeVariables>\n          var flattened, attrs, error, invalidAttrs;\n          option = option || getOptionsAttrs(options);</initializeVariables>\n\n          <processOption>\n          if(_.isString(option)){\n            attrs = [option];\n          } else if(_.isArray(option)) {\n            attrs = option;\n          }</processOption>\n          <validateAttributes>\n          if (attrs) {\n            _.each(attrs, function (attr) {\n              <getValue>\n              var value;\n              if (isNestedModel(this)) {\n                value = this.get(attr);\n              } else {\n                value = flatten(this.attributes)[attr];\n              }</getValue>\n              <checkError>\n              error = validateAttr(this, value, attr);\n              if (error) {\n                invalidAttrs = invalidAttrs || {};\n                invalidAttrs[attr] = error;\n              }</checkError>\n            }, this);\n          }</validateAttributes>\n\n          <triggerInvalidIfNeeded>\n          if (option === true) {\n            invalidAttrs = this.validate();\n          }\n          if (invalidAttrs) {\n            this.trigger('invalid', this, invalidAttrs, {validationError: invalidAttrs});\n          }</triggerInvalidIfNeeded>\n          <returnValidationResult>\n          return attrs ? !invalidAttrs : this.validation ? this._isValid : true;</returnValidationResult>\n}\n"], ["isEqualWithFunction", "\nfunction isEqualWith (obj1, obj2, func) {\n\t<executeWithCustomFunction>\n\tif (isFunction(func)) {\n\t\treturn equalCompare(obj1, obj2, function (v1, v2, key, obj1, obj2) {\n\t\t\tvar result = func(v1, v2, key, obj1, obj2)\n\t\t\treturn isUndefined(result) ? defaultCompare(v1, v2) : !!result\n\t\t}, func)\n\t}</executeWithCustomFunction>\n\t<executeWithDefaultComparison>\n\treturn equalCompare(obj1, obj2, defaultCompare)</executeWithDefaultComparison>\n}\n"], ["getProperty1", "\nfunction getProperty1() {\n\t<createPropertyNode>\n\tconst type = NodeType.PropertyType;\n\tconst token = tokens[pos];\n\tconst line = token.ln;\n\tconst column = token.col;\n\tconst content = getIdentOrInterpolation();\n\n\treturn newNode(type, content, line, column);</createPropertyNode>\n}\n"], ["asyncifyFunctions", "\nfunction asyncifyFunctions(forms) {\n  \n\t<processFormList>\n\tforms.forEach(function(form) {\n\t\t<checkAndModifyFunctions>\n\t\tif (sl.isList(form)) {\n\t\t\tif(sl.typeOf(form[0]) === 'symbol' &&\n\t\t\t\tsl.valueOf(form[0]) === 'function' &&\n\t\t\t\tasyncNeeded(form)) {\n\t\t\t\t\tform.unshift(sl.atom(\"async\"));\n\t\t\t\t\tasyncifyFunctions(form);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tasyncifyFunctions(form);\n\t\t\t}\n\t\t}</checkAndModifyFunctions>\n\t});</processFormList>\n}\n"], ["endOfUnitCalculation", "\nfunction endOf (unit = 'DD') {\n\t<calculateEndOfUnit>\n\tswitch (unit) {\n\t\tcase 'mm':\n\t\t\treturn Miment(this.format('YYYY-MM-DD hh:mm:59'))\n\t\tcase 'hh':\n\t\t\treturn Miment(this.format('YYYY-MM-DD hh:59:59'))\n\t\tcase 'DD':\n\t\t\treturn Miment(this.format('YYYY-MM-DD 23:59:59'))\n\t\tcase 'ww':\n\t\tcase 'WW':\n\t\t\treturn Miment(this.firstDayOfWeek().add(6, 'DD').format('YYYY-MM-DD 23:59:59'))\n\t\tcase 'MM':\n\t\t\treturn Miment(this.lastDay().format('YYYY-MM-DD 23:59:59'))\n\t\tcase 'YY':\n\t\tcase 'YYYY':\n\t\t\treturn Miment(this.set(12, 'MM').lastDay().format('YYYY-MM-DD 23:59:59'))\n\t}</calculateEndOfUnit>\n}\n"], ["delegateSelectors", "\nasync function delegateSelectors (\n\tpage,\n\tbrowser,\n\tscenario,\n\tviewport,\n\tvariantOrScenarioLabelSafe,\n\tscenarioLabelSafe,\n\tconfig,\n\tselectors,\n\tselectorMap\n) {\n\t<initializeVariables>\n\tlet compareConfig = { testPairs: [] };\n\tlet captureDocument = false;\n\tlet captureViewport = false;\n\tlet captureList = [];\n\tlet captureJobs = [];</initializeVariables>\n\n\t<processSelectors>\n\tselectors.forEach(function (selector, selectorIndex) {\n\t\tconst testPair = engineTools.generateTestPair(config, scenario, viewport, variantOrScenarioLabelSafe, scenarioLabelSafe, selectorIndex, selector);\n\t\tconst filePath = config.isReference ? testPair.reference : testPair.test;\n\n\t\tif (!config.isReference) {\n\t\t\tcompareConfig.testPairs.push(testPair);\n\t\t}\n\n\t\tselectorMap[selector].filePath = filePath;\n\t\t<assignCapturingTasks>\n\t\tif (selector === BODY_SELECTOR || selector === DOCUMENT_SELECTOR) {\n\t\t\tcaptureDocument = selector;\n\t\t} else if (selector === VIEWPORT_SELECTOR) {\n\t\t\tcaptureViewport = selector;\n\t\t} else {\n\t\t\tcaptureList.push(selector);\n\t\t}</assignCapturingTasks>\n\t});</processSelectors>\n\n\t<scheduleCaptureJobs>\n\tif (captureDocument) {\n\t\tcaptureJobs.push(function () { return captureScreenshot(page, browser, captureDocument, selectorMap, config, []); });\n\t}\n\tif (captureViewport) {\n\t\tcaptureJobs.push(function () { return captureScreenshot(page, browser, captureViewport, selectorMap, config, []); });\n\t}\n\tif (captureList.length) {\n\t\tcaptureJobs.push(function () { return captureScreenshot(page, browser, null, selectorMap, config, captureList); });\n\t}</scheduleCaptureJobs>\n\n\t<executeAndManageJobs>\n\treturn new Promise(function (resolve, reject) {\n\t\tvar job = null;\n\t\tvar errors = [];\n\t\tvar next = function () {\n\t\t\t<processJobQueue>\n\t\t\tif (captureJobs.length === 0) {\n\t\t\t\tif (errors.length === 0) {\n\t\t\t\t\tresolve();\n\t\t\t\t} else {\n\t\t\t\t\treject(errors);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tjob = captureJobs.shift();\n\t\t\tjob().catch(function (e) {\n\t\t\t\tconsole.log(e);\n\t\t\t\terrors.push(e);\n\t\t\t}).then(function () {\n\t\t\t\tnext();\n\t\t\t});</processJobQueue>\n\t\t};\n\t\tnext();\n\t}).then(async () => {\n\t\t<closeBrowser>\n\t\tconsole.log(chalk.green('x Close Browser'));\n\t\tawait browser.close();\n\t\t</closeBrowser>\n\t}).catch(async (err) => {\n\t\t<handleErrorAndCloseBrowser>\n\t\tconsole.log(chalk.red(err));\n\t\tawait browser.close();\n\t\t</handleErrorAndCloseBrowser>\n\t}).then(_ => compareConfig);</executeAndManageJobs>\n}\n"], ["arrayPushConversion", "\nfunction(array, args) {\n\t<initializeVariables>\n\tvar first = args[0];\n\tif (first) {\n\t\t<convertAndExtendArray>\n\t\tif (!oflist(array) && islist(first)) {\n\t\t\targs = first;\n\t\t}\n\t\tArray.prototype.push.apply(array,\n\t\t\tthis.convert(array, args)\n\t\t);</convertAndExtendArray>\n\t}</initializeVariables>\n}\n"], ["saveToPlayHistory", "\nfunction onAdvance(event, globalObject) {\n\t<initializeVariables>\n    var maxPlayHistoryLength = globalObject.config.DubBotBase.numberOfPlayedSongsToStore;</initializeVariables>\n\n\t<constructPlayObject>\n    var play = {\n        media: event.media,\n        startDate: event.startDate,\n        user: event.incomingDJ,\n        votes: {\n            grabs: [],\n            mehs: [],\n            woots: []\n        }\n    };</constructPlayObject>\n\n\t<updatePlayHistory>\n    globalObject.roomState.playHistory.unshift(play);\n\n    if (globalObject.roomState.playHistory.length > maxPlayHistoryLength) {\n        globalObject.roomState.playHistory.length = maxPlayHistoryLength;\n    }</updatePlayHistory>\n}\n"], ["detectFallbackCompositionEnd", "\nfunction isFallbackCompositionEnd(topLevelType, nativeEvent) {\n\t<matchTopLevelType>\n\tswitch (topLevelType) {\n\t\tcase 'topKeyUp':\n\t\t\t<returnEndKeyMatch>\n\t\t\treturn END_KEYCODES.indexOf(nativeEvent.keyCode) !== -1;</returnEndKeyMatch>\n\t\tcase 'topKeyDown':\n\t\t\t<returnIfNotStartKey>\n\t\t\treturn nativeEvent.keyCode !== START_KEYCODE;</returnIfNotStartKey>\n\t\tcase 'topKeyPress':\n\t\tcase 'topMouseDown':\n\t\tcase 'topBlur':\n\t\t\t<returnAlwaysEnd>\n\t\t\treturn true;</returnAlwaysEnd>\n\t\tdefault:\n\t\t\t<defaultFallback>\n\t\t\treturn false;</defaultFallback>\n\t}</matchTopLevelType>\n}\n"], "```"]