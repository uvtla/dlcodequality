[["handleScrollEnd", "\nfunction handleScrollEnd() {\n    scrollingStarted = false;\n    ghostScrollStart = null;\n    clearTimeout(scrollendTID);\n    scope.broadcast('scrollend', buildEventData());\n}\n"], ["Communications", "\nfunction Communications(f1, options) {\n  <determineOptions>\n  var opts = options || {\n    resourceName: 'communication'\n  }\n  if (!opts.resourceName) {\n    opts.resourceName = 'communication'\n  }\n  </determineOptions>\n  F1Resource.call(this, f1, opts)\n}\n"], ["findProxyName", "\nfunction findProxyName(moduleName, proxyName, uri, callback) {\n    var base = path.basename(moduleName),\n        proxyUri = path.join(uri, proxyName, base)\n\n    <checkInitialProxyUri>\n    fs.stat(proxyUri, checkIfProxyExists)\n    </checkInitialProxyUri>\n\n    function checkIfProxyExists(err, stat) {\n        if (err) {\n            <adjustProxyUriOnError>\n            if (proxyUri.substr(-3, 3) === \".js\") {\n                proxyUri = proxyUri.substr(0, proxyUri.length - 3)\n            } else {\n                proxyUri = proxyUri + \".js\"\n            }\n            </adjustProxyUriOnError>\n\n            <recheckProxyUri>\n            fs.stat(proxyUri, checkIfChangedUriHelped)\n            </recheckProxyUri>\n        } else {\n            <successfulProxyCallback>\n            callback(null, path.relative(uri, proxyUri))\n            </successfulProxyCallback>\n        }\n    }\n\n    function checkIfChangedUriHelped(err, stat) {\n        if (err) {\n            <recurseOnSameDirectory>\n            moduleName = path.dirname(moduleName)\n\n            findProxyName(moduleName, proxyName, uri, callback)\n            </recurseOnSameDirectory>\n        } else {\n            <handleExtensionCheck>\n            if (proxyUri.substr(-3, 3) === \".js\") {\n                callback(null, path.relative(uri, proxyUri))\n            } else {\n                findProxyObject(uri, path.relative(uri, proxyUri),\n                    callback)\n            }\n            </handleExtensionCheck>\n        }\n    }\n}\n"], ["syntaxTreeConstruction", "\nfunction (index, blocks, out) {\n    <initializeLocals>\n    var length = blocks.length, buffer = [];\n    var nextIndex = index, goAhead = (length > nextIndex), block;\n    </initializeLocals>\n\n    <processBlocks>\n    while (goAhead) {\n        block = blocks[nextIndex];\n        if (block.type === \"text\") {\n            if (block.value !== \"\") {\n                <handleTextBlock>\n                try {\n                  block.value = htmlEntitiesToUtf8(block.value);\n                  buffer.push(block);\n                } catch (e) {\n                  this._logError(e.message, block);\n                }\n                </handleTextBlock>\n            }\n        } else if (block.type === \"expression\") {\n            <processExpressionBlock>\n            if (this._validateExpressionBlock(block)) {\n                buffer.push(block);\n            }\n            </processExpressionBlock>\n        } else if (block.type === \"comment\") {\n            \n        } else {\n            goAhead = false;\n        }\n\n        if (goAhead) {\n            nextIndex++;\n            goAhead = (length > nextIndex);\n        }\n    }\n    </processBlocks>\n\n    <constructNodeFromBuffer>\n    var node = null;\n    if (buffer.length === 1 && buffer[0].type === \"text\") {\n        \n        node = new Node(\"text\");\n        node.value = buffer[0].value;\n    } else if (buffer.length > 0) {\n        \n        var onlyText=true;\n        for (var i = 0; i < buffer.length; i++) {\n            if (buffer[i].type !== \"text\") {\n                onlyText = false;\n                break;\n            }\n        }\n        if (onlyText) {\n            var texts=[];\n            for (var i = 0; i < buffer.length; i++) {\n                texts.push(buffer[i].value);\n            }\n            node = new Node(\"text\");\n            node.value = texts.join('');\n        } else {\n            \n            node = new Node(\"textblock\");\n            node.content = buffer;\n        }\n    }\n    if (node) {\n        out.push(node);\n    }\n    </constructNodeFromBuffer>\n\n    \n    return nextIndex > index ? nextIndex - 1 : index;\n}\n"], ["updateSearchFieldState", "\nfunction (oThis) {\n    <retrieveElements>\n    var $this = oThis.$(),\n        $ico = oThis._ctrl.$(\"searchico\");\n    </retrieveElements>\n\n    <updateTitleAttribute>\n    if ($this.hasClass(\"sapUiSearchFieldClear\") && $this.hasClass(\"sapUiSearchFieldVal\")) {\n        $ico.attr(\"title\", oThis._clearTooltipText);\n    } else {\n        $ico.removeAttr(\"title\");\n    }\n    </updateTitleAttribute>\n}\n"], ["sha1hex", "\nfunction sha1hex(source) {\n  <generateHash>\n  var hash = crypto.createHash(SHA1);\n  hash.update(new Buffer('' + source));\n  return hash.digest(ENCODING);\n  </generateHash>\n}\n"], ["Server", "\nfunction Server(clientListener) {\n  <initiateServer>\n  net.Server.call(this);\n  </initiateServer>\n  this._services = [];\n  \n  <attachClientListener>\n  if (clientListener) { this.addListener('client', clientListener); }\n  </attachClientListener>\n  \n  <setupConnectionListener>\n  var self = this;\n  this.addListener('connection', function (socket) {\n    var connection = new Connection(socket);\n    connection.once('connect', function (remote) {\n      self.emit('client', connection, remote);\n    });\n    connection.on('error', function (err) {\n      self.emit('clientError', err, this);\n    });\n    \n    <exposeServices>\n    self._services.forEach(function (service) {\n      connection.expose(service.name, service.service);\n    });\n    </exposeServices>\n  });\n  </setupConnectionListener>\n}\n"], ["construct_guesses", "\nfunction construct_guesses(parts) {\n    <baseCase>\n    if (parts.length === 1) {\n        return [parts];\n    }\n    </baseCase>\n\n    <recursiveConstruction>\n    const last = parts.pop();\n    const rest = construct_guesses(parts);\n    </recursiveConstruction>\n\n    <createGuesses>\n    const guesses = [];\n    for (const guess of rest) {\n        const one = clone(guess);\n        one.push('/~/');\n        one.push(last);\n\n        const two = clone(guess);\n        two.push('/node_modules/');\n        two.push(last);\n\n        guesses.push(one);\n        guesses.push(two);\n    }\n    </createGuesses>\n\n    return guesses;\n}\n"], ["errorHandler", "\nfunction errorHandler(err, req, res, next) {\n\n    <logError>\n    console.log('# Docloop error handler:');\n    console.error(err);\n    </logError>\n\n    <handleDocloopError>\n    if (err instanceof DocloopError) return res.status(err.status).send(err.toString());\n    </handleDocloopError>\n\n    <handleGenericError>\n    res.status(500).send(err.toString());\n    </handleGenericError>\n}\n"], ["assertFragmentMap", "\nfunction assertFragmentMap(\n  componentName: string,\n  fragmentSpec: GeneratedNodeMap,\n): void {\n  <assertFragmentSpecStructure>\n  invariant(\n    fragmentSpec && typeof fragmentSpec === 'object',\n    'Could not create Relay Container for `%s`. ' +\n      'Expected a set of GraphQL fragments, got `%s` instead.',\n    componentName,\n    fragmentSpec,\n  );\n  </assertFragmentSpecStructure>\n\n  <assertEachFragment>\n  for (const key in fragmentSpec) {\n    if (fragmentSpec.hasOwnProperty(key)) {\n      const fragment = fragmentSpec[key];\n      invariant(\n        fragment &&\n          (typeof fragment === 'object' || typeof fragment === 'function'),\n        'Could not create Relay Container for `%s`. ' +\n          'The value of fragment `%s` was expected to be a fragment, got `%s` instead.',\n        componentName,\n        key,\n        fragment,\n      );\n    }\n  }\n  </assertEachFragment>\n}\n"], ""]