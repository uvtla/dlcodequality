[["createFilterFunction", "\nfunction (f, fieldsIndex, ignoreEmptyFields) {\n  if (!f)\n    <returnEmptyFunction>return function () {};</returnEmptyFunction>\n  return function () {\n    var context = this;\n    var args = arguments;\n\n    <checkAndPauseCollection>\n    if (self.collection.paused)\n      return;\n    </checkAndPauseCollection>\n\n    <handleFieldsIndexAndProjection>\n    if (fieldsIndex !== undefined && self.projectionFn) {\n      args[fieldsIndex] = self.projectionFn(args[fieldsIndex]);\n      if (ignoreEmptyFields && _.isEmpty(args[fieldsIndex]))\n        return;\n    }\n    </handleFieldsIndexAndProjection>\n\n    <enqueueObservedTask>\n    self.collection._observeQueue.queueTask(function () {\n      f.apply(context, args);\n    });\n    </enqueueObservedTask>\n  };\n}\n"], ["querySelectorAllWithFlag", "\nfunction querySelectorAll(sel, flag) {\n  <performQuerySelector>\n  var nodes = this.root.querySelectorAll(normalize(sel));\n  </performQuerySelector>\n  return !flag ? nodes : <mapNodesToTags>\n  Array.prototype.map.call(nodes, function (node) {\n    return node._tag || undefined;\n  });\n  </mapNodesToTags>\n}\n"], ["fetchMapDataWithFilter", "\nfunction(x, y, filter) {\n  <mapDataRetrieval>\n  if(filter){\n    <filterMapData>\n    var result = this.map.get(x, y);\n    if(result){\n      return result.filter(filter);\n    }\n    </filterMapData>\n  }\n  </mapDataRetrieval>\n  return this.map.get(x, y);\n}\n"], ["appendToDataAndExecuteCallback", "\nfunction(data, done) {\n  <pushDataLoop>\n  for(var i = 0; i < data.length; i++) {\n    this._data.push(this._clone(data[i]));\n  }\n  </pushDataLoop>\n  <executeCallback>done();</executeCallback>\n}\n"], ["organizeFeatureCollection", "\nfunction (featureCollection, indexKey) {\n  <initialSetup>\n  var features = featureCollection.features;\n  var feature;\n  var properties;\n  var featureIndex = {};\n  var value;\n  </initialSetup>\n\n  <consolidateFeatures>\n  for (var index = 0; index < features.length; ++index) {\n    feature = features[index];\n    properties = feature.properties;\n    value = properties[indexKey];\n   \n    if (value in featureIndex) {\n      <mergeDuplicateFeatures>\n      var existingFeature = featureIndex[value];\n      if (existingFeature.geometry.type !== 'GeometryCollection') {\n        featureIndex[value] = {\n          type: 'Feature',\n          geometry: {\n            type: 'GeometryCollection',\n            geometries: [feature.geometry, existingFeature.geometry]\n          }\n        };\n      }\n      else {\n        existingFeature.geometry.geometries.push(feature.geometry);\n      }\n      </mergeDuplicateFeatures>\n    }\n    else {\n      <assignFeature>\n      featureIndex[value] = feature;\n      </assignFeature>\n    }\n  }\n  </consolidateFeatures>\n\n  <returnFeatureIndex>return featureIndex;</returnFeatureIndex>\n}\n"], ["createTupleFactory", "\nfunction tuple4Of(a, b, c, d) {\n  <instantiateTuple>\n  var self = getInstance(this, tuple4Of);\n  self.types = rest(arguments);\n  return self;\n  </instantiateTuple>\n}\n"], ["asyncReadComponentsMap", "\nasync function readComponentsMap(path) {\n  <readFilePromise>\n  return new Promise((resolve, reject) => {\n    <readFromFileSystem>\n    fs.readFile(path, (err, data) => {\n      if (err) {\n        <handleError>return resolve({});</handleError>\n      }\n      <parseData>resolve(JSON.parse(data));</parseData>\n    });\n    </readFromFileSystem>\n  });\n  </readFilePromise>\n}\n"], ["mongodbAppender", "\nfunction mongodbAppender(config) {\n  <validateConfig>\n  if (!config || !config.connectionString) {\n    throw new Error('connectionString is missing. Cannot connect to mongdb.');\n  }\n  </validateConfig>\n\n  <setupVariables>\n  var collection;\n  var cache = [];\n  var layout = config.layout || log4js.layouts.messagePassThroughLayout;\n  var collectionName = config.collectionName || 'log';\n  var connectionOptions = config.connectionOptions || {};\n  </setupVariables>\n\n  <defineErrorHelper>\n  function ERROR(err) {\n    Error.call(this);\n    Error.captureStackTrace(this, this.constructor);\n    this.name = err.toString();\n    this.message = err.message || 'error';\n  }\n  </defineErrorHelper>\n\n  <defineReplaceKeys>\n  function replaceKeys(src) {\n    <declarations>\n    var result = {};\n    </declarations>\n\n    <defineMixin>\n    function mixin(dest, source, cloneFunc) {\n      if (lxHelpers.isObject(source)) {\n        <replaceInvalidKeys>\n        lxHelpers.forEach(source, function (value, key) {\n          if (key[0] === '$') {\n            key = key.replace('$', '_dollar_');\n          }\n          key = key.replace(/\\./g, '_dot_');\n          dest[key] = cloneFunc ? cloneFunc(value) : value;\n        });\n        </replaceInvalidKeys>\n      }\n      return dest;\n    }\n    </defineMixin>\n\n    <handleNonObjectValues>\n    if (!src || typeof src !== 'object' || typeof src === 'function' || src instanceof Date || src instanceof RegExp || \u00a0src instanceof mongodb.ObjectID) {\n      return src;\n    }\n    </handleNonObjectValues>\n\n    <handleErrorObject>\n    if (lxHelpers.getType(src) === 'error') {\n      return new ERROR(src);\n    }\n    </handleErrorObject>\n\n    <processArrayValues>\n    if (lxHelpers.isArray(src)) {\n      result = [];\n      lxHelpers.arrayForEach(src, function (item) {\n        result.push(replaceKeys(item));\n      });\n    }\n    </processArrayValues>\n\n    <callMixin>return mixin(result, src, replaceKeys);</callMixin>\n  }\n  </defineReplaceKeys>\n\n  <defineGetOptions>\n  function getOptions() {\n    var options = { w: 0 };\n    if (config.write === 'normal' || config.write === 'safe') {\n      options.w = 1;\n      if(config.write === 'safe') options.journal = true;\n    }\n    return options;\n  }\n  </defineGetOptions>\n\n  <defineInsertFunction>\n  function insert(loggingEvent) {\n    var options = getOptions();\n    <insertLogic>\n    if (collection) {\n      if (options.w === 0) {\n        <insertWithoutWaiting>\n        collection.insert(logEventMapper(loggingEvent), options);\n        </insertWithoutWaiting>\n      } else {\n        <insertWithCallback>\n        collection.insert(logEventMapper(loggingEvent), options, function (error) {\n          if (error) {\n            <handleInsertError>\n            console.error('log: Error writing data to log!');\n            console.error(error);\n            console.log('log: Connection: %s, collection: %, data: %j', config.connectionString, collectionName, loggingEvent);\n            </handleInsertError>\n          }\n        });\n        </insertWithCallback>\n      }\n    } else {\n      <cacheLoggingEvent>cache.push(loggingEvent);</cacheLoggingEvent>\n    }\n    </insertLogic>\n  }\n  </defineInsertFunction>\n\n  <fixMongoDBConnectionString>\n  if (config.connectionString.indexOf('mongodb:undefined') === 0) {\n    config.connectionString = 'mongodb://undefined';\n  }\n  </fixMongoDBConnectionString>\n\n  <connectToMongoDB>\n  mongodb.MongoClient.connect(config.connectionString, connectionOptions, function (err, db) {\n    if (err) {\n      <handleConnectionError>\n      console.error('Error connecting to mongodb! URL: %s', config.connectionString);\n      console.error(err);\n      </handleConnectionError>\n    }\n    collection = db.collection(config.collectionName || 'log');\n    <flushCache>\n    cache.forEach(function (loggingEvent) {\n      setImmediate(function () {\n        insert(loggingEvent);\n      });\n    });\n    </flushCache>\n  });\n  </connectToMongoDB>\n\n  <appenderFunction>\n  return function (loggingEvent) {\n    <prepareLoggingEventData>\n    if (Object.prototype.toString.call(loggingEvent.data[0]) === '[object String]') {\n      loggingEvent.data = layout(loggingEvent);\n    } else if (loggingEvent.data.length === 1) {\n      loggingEvent.data = loggingEvent.data[0];\n    }\n    loggingEvent.data = replaceKeys(loggingEvent.data);\n    </prepareLoggingEventData>\n    <performInsert>insert(loggingEvent);</performInsert>\n  };\n  </appenderFunction>\n}\n"], ["GetHeadersPacketInheritance", "\nfunction GetHeadersPacket(locator, stop) {\n  <handleInstantiation>\n  if (!(this instanceof GetHeadersPacket))\n    return new GetHeadersPacket(locator, stop);\n  </handleInstantiation>\n  \n  <callParentConstructor>GetBlocksPacket.call(this, locator, stop);</callParentConstructor>\n}\n"], ["generateLayers", "\nfunction generateLayers () {\n  <logStart>grunt.log.write(\"Generating layers...\");</logStart>\n\n  <defineConfig>\n  var config = lang.extend({}, requireConfig, {\n    isPrepareStage: true,\n    optimize: \"none\",\n    optimizeCss: \"none\",\n    appDir: buildDir,\n    dir: tempDir,\n    baseUrl: \"./\",\n    logLevel: 2, // WARN\n    removeCombined: false,\n    skipDirOptimize: true,\n    keepBuildDir: false,\n    skipSemiColonInsertion: true,\n    pragmas: {\n      prepare: true,\n      build: true\n    },\n    pragmasOnSave: {\n      prepareSave: true\n    },\n    modules: modules.map(function (module) { return { name: module }; }),\n    onBuildWrite: function (moduleName, modulePath, contents) {\n      <processOnBuildWriteStart>\n      layers.some(function (layer) {\n        var relPath = path.relative(path.resolve(config.dir), modulePath);\n        var layerDir = layer.dir;\n        if (!Array.isArray(layerDir)) {\n          layerDir = [layerDir];\n        }\n        layerDir.forEach(function(dir) {\n          if (relPath.indexOf(dir) === 0) {\n            if (options.ignoreModules) {\n              if (options.ignoreModules.some(function (m) {\n                return m === moduleName;\n              })) {\n                return;\n              }\n            }\n            layer.modules[moduleName] = true;\n          }\n        });\n      });\n      if (moduleName.indexOf('xhtmpl!') === 0) {\n        modulesToDelete.push(path.join(outputDir, modulePath.slice('xhtmpl!'.length)));\n        if (contents.charAt(contents.length-1) === \";\") {\n          contents = contents.slice(0, contents.length-1);\n        }\n        file.saveFile(path.join(buildDir, modulePath.slice('xhtmpl!'.length)), contents);\n      }\n      </processOnBuildWriteEnd>\n      <returnModuleWithPragmas>return \"\\n\";</returnModuleWithPragmas>\n    }\n  });\n  </defineConfig>\n\n  <runOptimizer>\n  requirejs.optimize(\n    config,\n    lang.safeCallback(function () {\n      <processLayers>\n      layers.forEach(function (layer) {\n        var modules = Object.keys(layer.modules).sort(),\n          content = \"define([\\n\\t\\\"\" + modules.join(\"\\\",\\n\\t\\\"\") + \"\\\"\\n], function () {});\";\n        file.saveFile(path.join(buildDir, layer.name) + \".js\", content);\n      });\n      </processLayers>\n      <logSuccess>grunt.log.writeln('OK'.green);</logSuccess>\n      <optimizeModulesCall>optimizeModules();</optimizeModulesCall>\n    }),\n    lang.errorCallback\n  );\n  </runOptimizer>\n}\n"], "```"]