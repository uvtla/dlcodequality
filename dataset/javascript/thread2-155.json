[["isValueEqualOrBooleanAttribute", "\nfunction(name, value) {\n  if (name == value) {\n    return true;\n  }\n\n  <getBooleanAttributes>\n  var boolAttrs = prefs.get('profile.booleanAttributes');\n  if (!value && boolAttrs) {\n    boolAttrs = new RegExp(boolAttrs, 'i');\n    return boolAttrs.test(name);\n  }\n  </getBooleanAttributes>\n\n  return false;\n}\n"], ["setupDataAndPrint", "\nasync function setup () {\n\n  debugger;\n  <setAndGetAppData_store1>\n  store1.setAppData('aaa', {x: 1, y: 1});\n  let d = store1.getAppData();\n  prtUtil.printObj(d, 'After first set');\n  </setAndGetAppData_store1>\n\n  <setAndGetAppData_store2>\n  store2.setAppData('aaa', {x: 2, y: 2});\n  d = store2.getAppData();\n  prtUtil.printObj(d, 'After first set');\n  </setAndGetAppData_store2>\n\n  <getAndPrintAppData_store1>\n  d = store1.getAppData();\n  prtUtil.printObj(d, 'After first set');\n  </getAndPrintAppData_store1>\n  \n  return 'completed';\n}\n"], ["filterSourceByBlacklist", "\nfunction skip (source, blacklist) {\n  <validateSource>\n  if (isNil(source)) {\n    throw _makeTypeErrorFor(source, \"object\");\n  }\n  </validateSource>\n\n  <createResultObject>\n  var result = {};\n  var props = make(blacklist, []);\n\n  for (var key in source) {\n    if (!(key in props)) {\n      result[key] = source[key];\n    }\n  }\n  </createResultObject>\n\n  return result;\n}\n"], ["triggerBeforeGetFeatureInfoEvent", "\nfunction(evt) {\n  this.events.triggerEvent(\"beforegetfeatureinfo\", {xy: evt.xy});\n  <requestDataOnHover>\n  this.request(evt.xy, {hover: true});\n  </requestDataOnHover>\n}\n"], ["decodeAndAssignParameters", "\nfunction readInit(message, tokens) {\n  var i;\n  message.parameters = {};\n  for (i = 0; i < tokens.length; i = i + 4) {\n    message.parameters[protocol.decodeString(tokens[i + 1])] = protocol.decodeString(tokens[i + 3]);\n  }\n}\n"], ["categorizeTweetData", "\nfunction(tweet, streamChannels) {\n  <initializeTweetProperties>\n  tweet.$channels = {};\n  tweet.$keywords = [];\n  </initializeTweetProperties>\n  \n  <setupSearchingData>\n  var i, j, k;\n  var lowerCasedSearch = [];\n  var keywordsFound = [], tmpKeywords;\n  </setupSearchingData>\n\n  <prepareSearchContextFromTweet>\n  var tweetText = tweet.truncated ? tweet.extended_tweet.full_text : tweet.text;\n  lowerCasedSearch.push(tweetText.toLowerCase());\n  if(tweet.user && tweet.user.screen_name){\n    lowerCasedSearch.push(tweet.user.screen_name.toLowerCase());\n  }\n  if(tweet.entities && tweet.entities.urls && tweet.entities.urls.length > 0){\n    for(i=0; i<tweet.entities.urls.length; i++){\n      if(tweet.entities.urls[i].display_url){\n        lowerCasedSearch.push(tweet.entities.urls[i].display_url.toLowerCase());\n      }\n      if(tweet.entities.urls[i].expanded_url){\n        lowerCasedSearch.push(tweet.entities.urls[i].expanded_url.toLowerCase());\n      }\n    }\n  }\n  </prepareSearchContextFromTweet>\n\n  <matchKeywordsAndAssignToChannels>\n  for(var channel in streamChannels.channelsKeywordsLowerCasedRegExp) {\n    keywordsFound = [];\n    for(j=0; j<lowerCasedSearch.length; j++) {\n      tmpKeywords = lowerCasedSearch[j].match(streamChannels.channelsKeywordsLowerCasedRegExp[channel]);\n      if(tmpKeywords !== null) {\n        keywordsFound = keywordsFound.concat(tmpKeywords);\n      }\n    }\n    if(keywordsFound.length > 0) {\n      tweet.$channels[channel] = [];\n      for(k=0; k<keywordsFound.length; k++) {\n        if(tweet.$channels[channel].indexOf(keywordsFound[k]) === -1) {\n          tweet.$channels[channel].push(keywordsFound[k]);\n        }\n        if(tweet.$keywords.indexOf(keywordsFound[k]) === -1) {\n          tweet.$keywords.push(keywordsFound[k]);\n        }\n      }\n    }\n  }\n  </matchKeywordsAndAssignToChannels>\n  \n  return streamChannels;\n}\n"], ["submitAuthenticationData", "\nfunction(authData, background) {\n  <validateCompletionDeferred>\n  if (!this._completionDeferred) {\n    throw new Error(\"submitAuthDict() called before attemptAuth()\");\n  }\n  </validateCompletionDeferred>\n\n  <prepareAndRequestAuthentication>\n  const auth = {\n    session: this._data.session,\n  };\n  utils.extend(auth, authData);\n\n  this._doRequest(auth, background);\n  </prepareAndRequestAuthentication>\n}\n"], ["buildDependencyGraph", "\nfunction createDependencyGraph(pool, moduleNames, indegreeOnly) {\n  <initializeGraph>\n  const graph = Object.create(null);\n  </initializeGraph>\n\n  <processModuleDependencies>\n  const promises = moduleNames.map( (moduleName) => {\n    return pool.getModuleInfo(moduleName)\n      .then( (module) => {\n        let node = graph[moduleName];\n        if ( node == null ) {\n          node = new GraphNode(moduleName, indegreeOnly);\n          graph[moduleName] = node;\n        }\n        const p = module.dependencies.map( function(dep) {\n          if ( module.isConditionalDependency(dep) ) {\n            return;\n          }\n          return pool.getModuleInfo(dep).then( (depModule) => {\n            if ( moduleNames.indexOf(dep) >= 0 ) {\n              let depNode = graph[dep];\n              if ( depNode == null ) {\n                depNode = new GraphNode(dep, indegreeOnly);\n                graph[dep] = depNode;\n              }\n              node.outgoing.push(depNode);\n              if ( indegreeOnly ) {\n                depNode.indegree++;\n              } else {\n                depNode.incoming.push(node);\n              }\n            }\n          }, (erro) => null);\n        });\n        return Promise.all(p);\n      }, (err) => {\n        log.error(\"module %s not found in pool\", moduleName);\n      });\n  });\n  </processModuleDependencies>\n\n  <finalizeGraphCreation>\n  return Promise.all(promises).then(function() {\n    return graph;\n  });\n  </finalizeGraphCreation>\n}\n"], ["normalizeBaseStringUri", "\nfunction baseStringUri(uri) {\n  <parseUri>\n  var parsed = url.parse(uri);\n  </parseUri>\n\n  <removeDefaultPortsFromUri>\n  if (parsed.protocol === 'https:/') {\n    parsed.host = parsed.host.replace(/:443$/, '');\n  } else if (parsed.protocol === 'http:/') {\n    parsed.host = parsed.host.replace(/:80$/, '');\n  }\n  </removeDefaultPortsFromUri>\n\n  <formatNormalizedUri>\n  return url.format({\n    protocol: parsed.protocol,\n    host: parsed.host,\n    auth: parsed.auth,\n    pathname: parsed.pathname\n  });\n  </formatNormalizedUri>\n}\n"], ["addObserver", "\nfunction(key, fn) {\n  <setupObservers>\n  var attrs = this,\n      $$observers = (attrs.$$observers || (attrs.$$observers = {})),\n      listeners = ($$observers[key] || ($$observers[key] = []));\n  </setupObservers>\n\n  <registerListener>\n  listeners.push(fn);\n  $rootScope.$evalAsync(function() {\n    if (!listeners.$$inter) {\n      fn(attrs[key]);\n    }\n  });\n  </registerListener>\n  \n  return fn;\n}\n"], "```"]