[["Client", "\nfunction Client(API_URL, token, opts) {\n  <instanceCheck>\n  if (!(this instanceof Client)) return new Client(API_URL, token, opts);\n  </instanceCheck>\n\n  <optionHandling>\n  if (typeof token == 'object') {\n    opts = token;\n    token = null;\n  }\n  </optionHandling>\n\n  <emitterInitialization>\n  Emitter.call(this);\n  var self = this;\n  opts = opts || {};\n  </emitterInitialization>\n\n  <cacheAndPendingSetup>\n  self.cache = new LRU(opts.maxSize || 500);\n  self.pending = {};\n  </cacheAndPendingSetup>\n\n  <bindingMethods>\n  self.root = get.bind(self, API_URL);\n  self.get = get.bind(self);\n  </bindingMethods>\n\n  <superagentContextSetup>\n  var context = self.context = superagent();\n  </superagentContextSetup>\n\n  <authorizationHeaderSetup>\n  if (token) self.header('authorization', 'Bearer ' + token);\n  </authorizationHeaderSetup>\n\n  <parsersSetup>\n  var parsers = context.request.parse;\n  parsers['application/json'] = parsers['application/hyper+json'] = parseHyperJson;\n  </parsersSetup>\n\n  <patchSuperagent>\n  patchCrappySuperagent(context.request.Response, context.request.parse);\n  </patchSuperagent>\n}\n"], ["isPrimitiveType", "\nfunction isPrimitiveType (obj) {\n  return ( typeof obj === 'boolean' ||\n       typeof obj === 'number' ||\n       typeof obj === 'string' ||\n       obj === null ||\n       util.isDate(obj) ||\n       util.isArray(obj));\n}\n"], ["amf3encDouble", "\nfunction amf3encDouble(num) {\n    var buf = new Buffer(9);\n    buf.writeUInt8(0x05, 0);\n    buf.writeDoubleBE(num, 1);\n    return buf;\n}\n"], ["HSVA_TO_RGBA", "\nfunction HSVA_TO_RGBA() {\n  var h = this.h();\n  var s = this.s();\n  var v = this.v();\n  var a = this.a();\n  var hi = Math.floor(h / 60);\n  var f = h / 60 - hi;\n  var p = v * (1 - s);\n  var q = v * (1 - f * s);\n  var t = v * (1 - (1 - f) * s);\n  var rgba;\n\n  <colorConversionAlgorithm>\n  switch (hi) {\n      case 0:\n          rgba = [v, t, p, a]; break;\n      case 1:\n          rgba = [q, v, p, a]; break;\n      case 2:\n          rgba = [p, v, t, a]; break;\n      case 3:\n          rgba = [p, q, v, a]; break;\n      case 4:\n          rgba = [t, p, v, a]; break;\n      case 5:\n          rgba = [v, p, q, a]; break;\n      default:\n          rgba = [0, 0, 0, a];\n  }\n\n  for (var i = rgba.length - 1; i--;) {\n      rgba[i] *= 255;\n  }\n  </colorConversionAlgorithm>\n\n  return kolor.rgba(rgba);\n} \n"], ["selectIndex", "\nfunction selectIndex(idx){\n  <deselectionLogic>\n  if(selectedItem) selectedItem.className = selectedItem.className.replace(/\\s?selected/,'');\n  </deselectionLogic>\n\n  <retrievalAndBoundaryChecking>\n  var r = document.getElementById('searchresults');\n  var items = r.childNodes;\n  if(items.length === 0){\n    selectedSearchIndex = -1;\n    selectedItem = false;\n    return;\n  }\n  </retrievalAndBoundaryChecking>\n\n  <selectionLogic>\n  selectedSearchIndex = idx;\n  var s = selectedItem = items[idx];\n  s.className += ' selected';\n  </selectionLogic>\n\n  <scrollingAdjustment>\n  var o = s.offsetTop - r.offsetTop - r.scrollTop;\n  if(o < 0){\n    r.scrollTop = s.offsetTop - r.offsetTop;\n  }else if(o > r.offsetHeight - s.offsetHeight){\n    r.scrollTop = o + r.scrollTop - r.offsetHeight + s.offsetHeight;\n  }\n  </scrollingAdjustment>\n}\n"], ["distance", "\nfunction distance(str1, str2, options_p) {\n  <optionsSetup>\n  var options = _clone_and_set_option_defaults(options_p);\n  str1 = options.full_process ? full_process(str1, options) : str1;\n  str2 = options.full_process ? full_process(str2, options) : str2;\n  if (typeof options.subcost === \"undefined\") options.subcost = 1;\n  </optionsSetup>\n  \n  <distanceCalculation>\n  if (options.astral) return _iLeven(str1, str2, options, _toArray);\n  else return _wildLeven(str1, str2, options, _leven); \n  </distanceCalculation>\n}\n"], ["AuthenticationHandler", "\nfunction (context, run, done) {\n  <checkResponse>\n  if (!context.response) { return done(); }\n  </checkResponse>\n\n  <checkAuthentication>\n  if (!(context.auth && context.auth.type)) { return done(); }\n  </checkAuthentication>\n\n  <authenticationSetup>\n  var auth = context.auth,\n      originalAuth = context.originalItem.getAuth(),\n      originalAuthParams = originalAuth && originalAuth.parameters(),\n      authHandler = AuthLoader.getHandler(auth.type),\n      authInterface = createAuthInterface(auth);\n  </authenticationSetup>\n\n  <authenticationHandling>\n  if (!authHandler) {\n      run.triggers.console(context.coords, 'warn', 'runtime: could not find a handler for auth: ' + auth.type);\n      return done();\n  }\n  </authenticationHandling>\n\n  < authenticationPostRequest>\n  authHandler.post(authInterface, context.response, function (err, success) {\n      <syncOriginalAuthParams>\n      originalAuthParams && auth.parameters().each(function (param) {\n          param && param.system && originalAuthParams.upsert({key: param.key, value: param.value, system: true});\n      });\n      </syncOriginalAuthParams>\n\n      <contextAuthSetup>\n      _.set(context, 'item.request.auth', auth);\n      </contextAuthSetup>\n\n      <errorHandling>\n      if (err) {\n          run.triggers.console(\n              context.coords,\n              'warn',\n              'runtime~' + auth.type + '.auth: there was an error validating auth: ' + (err.message || err),\n              err\n          );\n          return done();\n      }\n      </errorHandling>\n\n      <authenticationSuccess>\n      if (success) { return done(); }\n      </authenticationSuccess>\n\n      <authenticationReplay>\n      done(null, {replay: true, helper: auth.type + DOT_AUTH});\n      </authenticationReplay>\n  });\n  </authenticationPostRequest>\n}\n"], ["displayStatusInfo", "\nasync function displayStatusInfo(rootFolder, metadata) {\n  <loadMetadata>\n  const local = path.join(rootFolder, constants.META_DIR, constants.META_LOCAL);\n  const remote = path.join(rootFolder, constants.META_DIR, constants.META_REMOTE);\n  const extensions = eaft.getCodeExtensions();\n\n  const files = [];\n  const keys = [];\n  const data = [];\n  data.local = JSON.parse(fs.readFileSync(local, 'utf8'));\n  data.remote = JSON.parse(fs.readFileSync(remote, 'utf8'));\n  </loadMetadata>\n\n  <prepareFileData>\n  for (const env in data) {\n      for (const codeFile of data[env].files) {\n          const extension = eaft.getExtensionFromFiletype(codeFile.type, extensions);\n          const key = `${codeFile.name}${extension}.${env}`;\n          keys.push(key);\n          codeFile.environment = env;\n          files[key] = codeFile;\n      }\n  }\n  keys.sort();\n  </prepareFileData>\n\n  <diffCalculation>\n  const addedFiles = [];\n  const modifiedFiles = [];\n  const deletedFiles = [];\n  for (let i = 0; i < keys.length; i++) {\n      const file = files[keys[i]];\n      const extension = eaft.getExtensionFromFiletype(file.type, extensions);\n      const nextFile = files[keys[i + 1]];\n\n      if (nextFile && file.name === nextFile.name && file.type === nextFile.type) {\n          i++;\n          if (file.source !== nextFile.source) {\n              modifiedFiles.push(file.name + extension);\n          }\n      } else if (file.environment === 'local') {\n          addedFiles.push(file.name + extension);\n      } else if (file.environment === 'remote') {\n          deletedFiles.push(file.name + extension);\n      }\n  }\n  </diffCalculation>\n\n  <outputStatus>\n  if (addedFiles.length === 0 && modifiedFiles.length === 0 && deletedFiles.length === 0) {\n      process.stdout.write(`Your local and remote project for '${metadata.name}' are in sync`);\n      checkbox.display(`green`);\n  } else {\n      process.stdout.write(`There are some differences between your local and remote projectfiles for '${metadata.name}'`);\n      console.log(``);\n\n      if (addedFiles.length > 0) {\n          console.log(``);\n      }\n      for (const added of addedFiles) {\n          console.log(`   + ${added}`.green);\n      }\n\n      if (modifiedFiles.length > 0) {\n          console.log(``);\n      }\n      for (const modified of modifiedFiles) {\n          console.log(`   ~ ${modified}`.yellow);\n      }\n\n      if (deletedFiles.length > 0) {\n          console.log(``);\n      }\n      for (const deleted of deletedFiles) {\n          console.log(`   - ${deleted}`.red);\n      }\n      console.log(``);\n  }\n  </outputStatus>\n}\n"], ["meetExpectations", "\nfunction (cb, expect) {\n  <functionValidation>\n  if (_.isFunction(cb) && cb.__normalised) {\n      return meetExpectations(cb, expect);\n  }\n  </functionValidation>\n\n  <callbackSetup>\n  var userback, \n      callback = (_.isFunction(cb) && cb) || (_.isFunction(cb && cb.done) && cb.done),\n      callbackError = _.isFunction(cb && cb.error) && cb.error,\n      callbackSuccess = _.isFunction(cb && cb.success) && cb.success;\n  </callbackSetup>\n\n  <callbackDefinition>\n  userback = _.assign(function (err) {\n      callback && callback.apply(this, arguments);\n      if (err) {\n          callbackError && callbackError.apply(this, arguments);\n      }\n      else {\n          callbackSuccess && callbackSuccess.apply(this, (Array.prototype.shift.call(arguments), arguments));\n      }\n  }, _.isPlainObject(cb) && cb, { \n      error: function () {\n          return userback.apply(this, arguments);\n      },\n      success: function () {\n          userback.apply(this, (Array.prototype.unshift.call(arguments, null), arguments));\n      },\n      done: function () {\n          return userback.apply(this, arguments);\n      },\n      __normalised: true\n  });\n  </callbackDefinition>\n\n  return meetExpectations(userback, expect);\n}\n"], ["doInsertHeading", "\nfunction doInsertHeading(level){\n  <preliminaryChecks>\n  var rep = this.rep,\n    documentAttributeManager = this.documentAttributeManager;\n  if (!(rep.selStart && rep.selEnd) || (level >= 0 && tags[level] === undefined))\n  {\n    return;\n  }\n  </preliminaryChecks>\n\n  <applyHeading>\n  var firstLine, lastLine;\n  firstLine = rep.selStart[0];\n  lastLine = Math.max(firstLine, rep.selEnd[0] - ((rep.selEnd[1] === 0) ? 1 : 0));\n  _(_.range(firstLine, lastLine + 1)).each(function(i){\n    if(level >= 0){\n      documentAttributeManager.setAttributeOnLine(i, 'heading', tags[level]);\n    }else{\n      documentAttributeManager.removeAttributeOnLine(i, 'heading');\n    }\n  });\n  </applyHeading>\n}\n"], "```"]