[["subscribeWhenReady", "\nfunction subscribeWhenReady(doctype, socket) {\n  <checkSocketState>\n  if (socket.readyState === WEBSOCKET_STATE.OPEN) </checkSocketState> {\n    try {\n      <socketSend>\n      socket.send(\n        JSON.stringify({\n          method: 'SUBSCRIBE',\n          payload: {\n            type: doctype\n          }\n        })\n      )\n      </socketSend>\n    } catch (error) {\n      <errorHandling>\n      console.warn(`Cannot subscribe to doctype ${doctype}: ${error.message}`)\n      throw error\n      </errorHandling>\n    }\n  } else {\n    <retrySubscription>\n    setTimeout(() => {\n      subscribeWhenReady(doctype, socket)\n    }, 10)\n    </retrySubscription>\n  }\n}\n"], ["onUpdating", "\nfunction onUpdating(model, attr, options) {\n    <omitChangedRelationships>\n    if (this.relationships) {\n        model.changed = _.omit(model.changed, this.relationships);\n    }\n    </omitChangedRelationships>\n\n    <setUpdatedBy>\n    if (schema.tables[this.tableName].hasOwnProperty('updated_by')) {\n        if (!options.importing && !options.migrating) {\n            this.set('updated_by', String(this.contextUser(options)));\n        }\n    }\n    </setUpdatedBy>\n\n    <handleCreatedAtAndCreatedBy>\n    if (options && options.context && !options.context.internal && !options.importing) {\n        if (schema.tables[this.tableName].hasOwnProperty('created_at')) {\n            if (model.hasDateChanged('created_at', {beforeWrite: true})) {\n                model.set('created_at', this.previous('created_at'));\n            }\n        }\n\n        if (schema.tables[this.tableName].hasOwnProperty('created_by')) {\n            if (model.hasChanged('created_by')) {\n                model.set('created_by', String(this.previous('created_by')));\n            }\n        }\n    }\n    </handleCreatedAtAndCreatedBy>\n\n    <handleUpdatedAt>\n    if (schema.tables[this.tableName].hasOwnProperty('updated_at') && !options.importing) {\n        if (options.migrating) {\n            model.set('updated_at', model.previous('updated_at'));\n        } else if (Object.keys(model.changed).length === 1 && model.changed.updated_at) {\n            model.set('updated_at', model.previous('updated_at'));\n            delete model.changed.updated_at;\n        }\n    }\n    </handleUpdatedAt>\n\n    <cloneChangedState>\n    model._changed = _.cloneDeep(model.changed);\n    </cloneChangedState>\n\n    return Promise.resolve(this.onValidate(model, attr, options));\n}\n"], ["join", "\nfunction join() {\n  <mergeSegments>\n  var segs = Array.prototype.slice.call(arguments);\n  var path = [];\n  for (var i=0; i < segs.length; i++) {\n    var segment = segs[i];\n    \n    var last = segment.length-1;\n    if (i > 0 && segment[0] === '/') segment = segment.substring(1);\n    if (segment[last] === '/') segment = segment.substring(0, last);\n    path.push(segment);\n  }\n  </mergeSegments>\n  return path.join('/');\n}\n"], ["serializeParams", "\nfunction serializeParams(params) {\n  <convertMediaObjects>\n  for (var key in params) {\n    var param = params[key];\n    if (param instanceof MediaObject || (param && (params.object !==\n        undefined ||\n        params.hub !== undefined || params.sink !== undefined))) {\n      if (param && param.id != null) {\n        params[key] = param.id;\n      }\n    }\n  };\n  </convertMediaObjects>\n\n  return params;\n}\n"], ["toBuddhist", "\nfunction toBuddhist(oGregorian) {\n  <convertToBuddhistYear>\n  var iEraStartYear = UniversalDate.getEraStartDate(CalendarType.Buddhist, 0).year,\n    iYear = oGregorian.year - iEraStartYear + 1;\n  \n  if (oGregorian.year < 1941 && oGregorian.month < 3) {\n    iYear -= 1;\n  }\n  if (oGregorian.year === null) {\n    iYear = undefined;\n  }\n  </convertToBuddhistYear>\n  return {\n    year: iYear,\n    month: oGregorian.month,\n    day: oGregorian.day\n  };\n}\n"], ["HyperConfig", "\nfunction HyperConfig(options) {\n  <handleInstanceCheck>\n  this.name = 'HyperConfig';\n  if (!(this instanceof HyperConfig)) {\n    return new HyperConfig(options);\n  }\n  </handleInstanceCheck>\n  <initializeOptions>\n  options = options || {};\n  this._refLabel = options.refLabel || '~';\n  this._annotationLabel = options.annotationLabel || '@';\n  this._macroBegin = options.macroBegin || '{';\n  this._macroEnd = options.macroEnd || '}';\n  </initializeOptions>\n\n  <setupInternalState>\n  this._config = traverse({});\n  this._isBuilded = false;\n  </setupInternalState>\n  <registerNormalizers>\n  this._normalizers = {};\n  this.addNormalizer('tags', extractTags);\n  </registerNormalizers>\n}\n"], ["generateTableHeaders", "\nfunction generateTableHeaders(table){\n  \n  table = table || this;\n  <convertColumnsNumber>\n  var columns = table.columns*1;\n  </convertColumnsNumber>\n\n  <prepareHeadersObject>\n  var headers = {};\n  headers['rank'] = table.headerRank;\n  headers['team'] = table.headerTeam;\n  headers['scores'] = getScoreHeadersNames(table);\n  headers['final'] = table.headerFinal;\n  </prepareHeadersObject>\n  \n  <assignHeadersToTable>\n  table.headers = headers;\n  </assignHeadersToTable>\n  return headers;\n}\n"], ["getValidOptions", "\nfunction getValidOptions (options, setDefaults) {\n    <ensureValidOptionsObject>\n    options = requireValidOptionalObject(options)\n    </ensureValidOptionsObject>\n    \n    <validateAutomock>\n    if (defined(options.automock)) {\n        if (typeof options.automock !== 'function') {\n            throw new Error('options error: automock must be function')\n        }\n    }\n    </validateAutomock>\n    \n    <validateCacheClient>\n    if (defined(options.cacheClient)) {\n        requireValidCacheClient(options.cacheClient)\n    }\n    </validateCacheClient>\n    \n    <validateLogClient>\n    if (defined(options.logClient)) {\n        requireValidLogClient(options.logClient)\n    }\n    </validateLogClient>\n\n    <applyDefaultOptions>\n    if (!setDefaults) {\n        return options\n    }\n    _.each(defaultOptions, (defaultOptionName, optionName) => {\n        if (!defined(options[optionName])) {\n            options[optionName] = immutable[defaultOptionName]\n        }\n    })\n    </applyDefaultOptions>\n\n    return options\n}\n"], ["exec", "\nfunction exec() {  \n  <assembleCommand>\n  var command = 'xdotool ' + Array.prototype.join.call(arguments, ' ');\n  </assembleCommand>\n\n  <executeCommand>\n  Exec(command, function(error, stdout, stderr) {\n    if (error) console.log('ERROR' + error);\n    if (stdout) console.log('STDOUT' + stdout);\n    if (stderr) console.log('STDERR' + stderr);\n  });\n  </executeCommand>\n}\n"], ["deepCopy", "\nfunction deepCopy(o) {\n  <initializeCopy>\n  var copy = Object.create(null);\n  </initializeCopy>\n  <copyProperties>\n  for (var i in o) {\n    if (typeof o[i] === \"object\" && o[i] !== null) {\n      copy[i] = deepCopy(o[i]);\n    }\n    else if (typeof o[i] === \"function\" && o[i] !== null) {\n      \n      eval(\" copy[i] = \" +  o[i].toString());\n      \n    }\n\n    else\n      copy[i] = o[i];\n  }\n  </copyProperties>\n  return copy;\n}\n"], ""]