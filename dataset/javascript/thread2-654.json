[["compareNodes", "\nfunction(newnode, oldnode) {\n\t\tvar res = true,\n\t\t\tprev = null;\n\t\tvar oldorder = <computeOldOrder>this._assistant.order(oldnode.childNodes);</computeOldOrder>\n\t\treturn Array.every(newnode.childNodes, function(node, index) {\n\t\t\tif (node.nodeType === Node.ELEMENT_NODE) {\n\t\t\t\tvar id = <computeId>this._assistant.id(node);</computeId>\n\t\t\t\tif (oldorder.has(id) && oldorder.has(prev)) {\n\t\t\t\t\tres = oldorder.get(id) > oldorder.get(prev);\n\t\t\t\t}\n\t\t\t\tprev = id;\n\t\t\t}\n\t\t\treturn res;\n\t\t}, this);\n\t}\n"], ["dataTypeAndValidatorCreation", "\nfunction(set) {\n        var dtype, valids, typeClass, self = this;\n        \n        if (utils.isString(set)) {\n            typeClass = <getTypeClass>this.dataTypes.get(set);</getTypeClass>\n            if (typeClass) { dtype = new typeClass(); }\n        }\n        else if (set) {\n            utils.each(set, function(key, val) {\n                if (!utils.hasOwn(set, key)) {\n                    return;\n                }\n                if (key.toLowerCase() === 'type') {\n                    typeClass = <getTypeClass>self.dataTypes.get(val);</getTypeClass>\n                    if (typeClass) { dtype = new typeClass(); }\n                } else {\n                    typeClass = <getValidator>self.validators.get(key);</getValidator>\n                    if (typeClass) {\n                        if (!valids) { valids = []; }\n                        valids.push(new typeClass(set[key]));\n                    }\n                }\n            });\n        }\n        return new modellingMetas(dtype, valids);\n    }\n"], ["throttlingFunction", "\nfunction throttled(fn, millis) {\n        var nextInvokeTime = 0;\n        var lastAnswer = null;\n        return function () {\n            var now = Date.now();\n            if (nextInvokeTime < now) {\n                nextInvokeTime = now + millis;\n                lastAnswer = fn();\n            }\n            else {\n                \n            }\n            return lastAnswer;\n        };\n    }\n"], ["computeBounds", "\nfunction calculateBoundsFromNestedArrays (array) {\n    var x1 = null, x2 = null, y1 = null, y2 = null;\n\n    for (var i = 0; i < array.length; i++) {\n      var inner = array[i];\n\n      for (var j = 0; j < inner.length; j++) {\n        <processLonLat>var lonlat = inner[j];\n\n        var lon = lonlat[0];\n        var lat = lonlat[1];\n\n        if (x1 === null) {\n          x1 = lon;\n        } else if (lon < x1) {\n          x1 = lon;\n        }\n\n        if (x2 === null) {\n          x2 = lon;\n        } else if (lon > x2) {\n          x2 = lon;\n        }\n\n        if (y1 === null) {\n          y1 = lat;\n        } else if (lat < y1) {\n          y1 = lat;\n        }\n\n        if (y2 === null) {\n          y2 = lat;\n        } else if (lat > y2) {\n          y2 = lat;\n        }</processLonLat>\n      }\n    }\n\n    return [x1, y1, x2, y2 ];\n  }\n"], ["RouterInitialization", "\nfunction Router(options) {\n    options = options || {};\n    <validateRouterOptions>\n    if (!options.routeNameFormat || typeof options.routeNameFormat !== 'string') {\n        options.routeNameFormat = '{method}{Name}_{version}';\n    }</validateRouterOptions>\n    \n    <RouterInstantiation>RouterI.call(this, options);\n\n    if (typeof this.options.url !== 'string') {\n        throw new TypeError('`url` option must be a string');\n    }\n\n    var basePath = this.App.config.get('basePath');\n    basePath = (basePath && basePath + '/') || '';\n    this.options.url = <normalizeUrl>this.$normalizeUrl(basePath + this.options.url);</normalizeUrl></RouterInstantiation>\n\n    \n    <RoutePrototypeInitialization>\n    this.Route = function RouterRoute() {\n        Route.apply(this, arguments);\n    };\n    this.Route.prototype = Object.create(Route.prototype);\n    this.Route.prototype.constructor = this.Route;\n    this.Route.prototype.Router = this;\n    </RoutePrototypeInitialization>\n}\n"], ["patchRequests", "\nfunction() {\n\t\t\tglobal.requestSSLInitializing = false;\n\t\t\tglobal.requestSSLInitialized = true;\n\t\t\tglobal.requestSSLHooks = null;\n\t\t\t\n\t\t\trequest.Request.prototype.init = patchedInit;\n\t\t\tdebug('init done');\n\t\t\treturn patchedInit.apply(self,args);\n\t\t}\n"], ["shiftStringCodes", "\nfunction(str, n) {\n    var result = '';\n    n = n || 0;\n    stringCodes(str, function(c) {\n      result += chr(c + n);\n    });\n    return result;\n  }\n"], ["validateStringFormat", "\nfunction validateFormat(attr, conf, err) {\n    if (nullCheck.call(this, attr, conf, err)) return;\n    <performValidation>\n    if (typeof this[attr] === 'string') {\n        if (!this[attr].match(conf['with'])) {\n            err();\n        }\n    } else {\n        err();\n    }\n    </performValidation>\n}\n"], ["translateGraphic", "\nfunction (x, y) {\n            if (this.settings.subPixel === false) {\n                this.backBufferContext2D.translate(~~x, ~~y);\n            } else {\n                this.backBufferContext2D.translate(x, y);\n            }\n        }\n"], ["loadTemplatePartials", "\nfunction loadPartials(template, templatePath) {\n    var templateDir = path.dirname(templatePath)\n    var partialRegexp = <compilePartialRegex>new RegExp(\n      escapeRegex(mustache.tags[0]) +\n        '>\\\\s*(\\\\S+)\\\\s*' +\n        escapeRegex(mustache.tags[1]),\n      'g'\n    )</compilePartialRegex>\n\n    var partialMatch\n    while ((partialMatch = partialRegexp.exec(template))) {\n      <handlePartialLoading>\n      var partialName = partialMatch[1]\n\n      if (!partials[partialName]) {\n        try {\n          var partialPath = null\n          var partial = null\n\n          <loadSpecificPartial>\n          \n          \n          \n          \n          if (path.extname(partialName) !== '') {\n            partialPath = path.resolve(templateDir, partialName)\n            partial = fs.readFileSync(partialPath, 'utf8')\n          } else {\n            \n            \n            \n            \n            partialPath = path.resolve(templateDir, partialName)\n\n            if (fs.existsSync(partialPath)) {\n              partial = fs.readFileSync(partialPath, 'utf8')\n            } else {\n              \n              \n              \n              \n              \n              if (typeof options.extension === 'string') {\n                partialPath = path.resolve(\n                  templateDir,\n                  partialName + options.extension\n                )\n\n                if (fs.existsSync(partialPath)) {\n                  partial = fs.readFileSync(partialPath, 'utf8')\n                }\n              }\n\n              \n              \n              \n              if (partial === null) {\n                partialPath = path.resolve(\n                  templateDir,\n                  partialName + '.mustache'\n                )\n\n                partial = fs.readFileSync(partialPath, 'utf8')\n              }\n            }\n          }</loadSpecificPartial>\n\n          partials[partialName] = partial\n          <recursePartials>loadPartials.call(this, partial, partialPath)</recursePartials>\n        } catch (ex) {\n          this.emit(\n            'error',\n            new PluginError(\n              'gulp-mustache',\n              \n              \n              \n              \n              'Unable to load partial file: ' + ex.message\n            )\n          )\n        }\n      }</handlePartialLoading>\n    }\n  }\n"], "```"]