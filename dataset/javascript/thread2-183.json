[["function", "\nfunction(format) {\n    <check-and-delete>\n    if (typeof format === \"undefined\") {\n      _deleteOwnProperties(_clipData);\n      _clipDataFormatMap = null;\n    } </check-and-delete>\n    <delete-specific-format>\n    else if (typeof format === \"string\" && _hasOwn.call(_clipData, format)) {\n      delete _clipData[format];\n    }\n    </delete-specific-format>\n}\n"], ["function", "\nfunction getOutputResourcePathMap(packedFiles, context, parseOpts, settings) {\n    <compute-need-output-require-config-pages>\n    var pages = getNeedOutputRequireConfigPages(packedFiles, parseOpts, settings);\n    </compute-need-output-require-config-pages>\n    var resMaps = [];\n    <iterate-pages>\n    pages.forEach(function(page) {\n        var file = page.file;\n        var loadScripts = page.loadScripts || [];\n        var loadOthers = page.loadOthers || [];\n        <get-not-load-packed-files>\n        var notLoadPackFiles = getNotLoadPackedFiles(\n            file, packedFiles, [].concat(loadScripts, loadOthers)\n        );\n        </get-not-load-packed-files>\n        \n        <get-pack-file-path-map>\n        var pkgPathMap = context.getPackFilePathMap(loadScripts,settings);\n        </get-pack-file-path-map>\n\n        <determine-path-map>\n        var pathMap = pkgPathMap;\n        var outputNotPackFiles = settings.outputNotPackPathMap;\n        if (outputNotPackFiles) {\n            <get-not-in-pkg-file-path-map>\n            var notPkgPathMap = context.getNotInPkgFilePathMap(loadScripts, {\n                filter: _.isFunction(outputNotPackFiles) ? outputNotPackFiles : filterOutputFiles\n            },settings);\n            </get-not-in-pkg-file-path-map>\n            <assign-path-maps>\n            pathMap = _.assign({}, notPkgPathMap, pkgPathMap);\n            </assign-path-maps>\n        } else {\n            <get-module-file-path-map>\n            var notPkgPathMap = context.getModuleFilePathMap(parseOpts.notPackPluginResFiles || []);\n            </get-module-file-path-map>\n            <assign-path-maps>\n            pathMap = _.assign({}, notPkgPathMap, pkgPathMap);\n            </assign-path-maps>\n        }\n        </determine-path-map>\n\n        <handle-async-mod-path-map>\n        if(settings.outputAsynModPathMap){\n            var outputAsynModPathMap = settings.outputAsynModPathMap;\n            var asyncScripts = [].concat([],file.asyncs,file.requires);\n            var arrScripts = getDepAsynScripts(asyncScripts,context); \n            var asynModPathMap = context.getModuleFilePathMap(arrScripts,{ \n                filter: _.isFunction(outputAsynModPathMap) ? outputAsynModPathMap : filterOutputFiles\n            },settings);\n            pathMap = asynModPathMap || {};\n        }\n        </handle-async-mod-path-map>\n\n        <push-res-maps>\n        resMaps.push({\n            file: file,\n            paths: pathMap\n        });\n        </push-res-maps>\n    });\n    </iterate-pages>\n    return resMaps;\n}\n"], ["function", "\nfunction basename (filePath) {\n  <determine-basename-windows>\n  if (isWindows) {\n    return path.basename(filePath, path.extname(filePath))\n  }\n  </determine-basename-windows>\n  <determine-basename-default>  \n  return path.basename(filePath)\n  </determine-basename-default>\n}\n"], ["function", "\nfunction getHeaders(config) {\n  <initialize-headers>\n  const headers = { 'X-Presto-User': config.user };\n  </initialize-headers>\n  <add-catalog-header>\n  if (config.catalog) {\n    headers['X-Presto-Catalog'] = config.catalog;\n  }\n  </add-catalog-header>\n  <add-schema-header>\n  if (config.schema) {\n    headers['X-Presto-Schema'] = config.schema;\n  }\n  </add-schema-header>\n  return headers;\n}\n"], ["function", "\nfunction step5a(token) {\n    <measure-token>\n    var m = measure(token);\n    </measure-token>\n    \n    <check-measure-and-strip-e>\n    if((m > 1 && token.substr(-1) == 'e') || (m == 1 && !(categorizeChars(token).substr(-4, 3) == 'CVC' && token.match(/[^wxy].$/))))\n        return token.replace(/e$/, '');\n    </check-measure-and-strip-e>\n\n    return token;\n}\n"], ["function", "\nfunction(filetype, option){\n\t\tvar puzzle = this.puzzle, bd = puzzle.board;\n\t\tvar pzl = new pzpr.parser.FileData('', puzzle.pid);\n\t\t\n\t\t<set-filetype>\n\t\tthis.currentType = filetype = filetype || pzl.FILE_PZPR; \n\t\toption = option || {};\n\t\t</set-filetype>\n\n\t\t<initialize-data-properties>\n\t\tthis.filever = 0;\n\t\tthis.datastr = \"\";\n\t\t</initialize-data-properties>\n\t\t<handle-pbox-xml-filetype> \n\t\tif(filetype===pzl.FILE_PBOX_XML){\n\t\t\tthis.xmldoc = (new DOMParser()).parseFromString('<?xml version=\"1.0\" encoding=\"utf-8\" ?><puzzle />', 'text/xml');\n\t\t\tvar puzzlenode = this.xmldoc.querySelector('puzzle');\n\t\t\tpuzzlenode.appendChild(this.createXMLNode('board'));\n\t\t\tpuzzlenode.appendChild(this.createXMLNode('answer'));\n\t\t}\n\t\t</handle-pbox-xml-filetype>\n\n\t\t<encode-based-on-filetype>\n\t\tswitch(filetype){\n\t\tcase pzl.FILE_PZPR:\n\t\t\tthis.encodeData();\n\t\t\tif(!option.history && option.trial && bd.trialstage>0){ this.encodeTrial();}\n\t\t\tbreak;\n\n\t\tcase pzl.FILE_PBOX:\n\t\t\tthis.kanpenSave();\n\t\t\tbreak;\n\n\t\tcase pzl.FILE_PBOX_XML:\n\t\t\tthis.kanpenSaveXML();\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tthrow \"invalid File Type\";\n\t\t}\n\t\t</encode-based-on-filetype>\n\n\t\t<set-parser-properties>\n\t\tpzl.type  = filetype;\n\t\tpzl.filever = this.filever;\n\t\tpzl.cols  = bd.cols;\n\t\tpzl.rows  = bd.rows;\n\t\tif(filetype!==pzl.FILE_PBOX_XML){\n\t\t\tpzl.body = this.datastr;\n\t\t}\n\t\telse{\n\t\t\tpzl.body = this.xmldoc;\n\t\t}\n\t\tpzl.metadata.update(puzzle.metadata);\n\t\tif(option.history && (filetype===pzl.FILE_PZPR)){\n\t\t\tpzl.history = puzzle.opemgr.encodeHistory({time:!!option.time});\n\t\t}\n\t\t</set-parser-properties>\n\n\t\t<cleanup-and-return>\n\t\tthis.datastr = \"\";\n\n\t\treturn pzl.generate();\n\t\t</cleanup-and-return>\n\t}\n"], ["function", "\nfunction getDataFromCustomEvent(nativeEvent) {\n  <check-and-retrieve-detail-data>\n  var detail = nativeEvent.detail;\n  if ((typeof detail === 'undefined' ? 'undefined' : _typeof(detail)) === 'object' && 'data' in detail) {\n    return detail.data;\n  }\n  </check-and-retrieve-detail-data>\n  return null;\n}\n"], ["function", "\nfunction getDeviceConnectionTypesData(deviceInfo) {\n            <log-device-info-debug>\n            if(false) {\n                console.log(\n                    'in getDeviceConnectionTypesData',\n                    deviceInfo.serialNumber,\n                    deviceInfo.ct,\n                    deviceInfo.port,\n                    deviceInfo.isActive,\n                    deviceInfo.isMockDevice\n                );\n            }\n            </log-device-info-debug>\n            var connectionTypes = [];\n\n            <initialize-connection-type-variables>\n            var foundUSB = false;\n            var usbInfo = {};\n            var foundEth = false;\n            var ethInfo = {};\n            var foundWiFi = false;\n            var wifiInfo = {};\n            </initialize-connection-type-variables>\n\n            <define-constants-for-connection-types>\n            var usbCT = driver_const.connectionTypes.usb;\n            var ethCT = driver_const.connectionTypes.ethernet;\n            var wifiCT = driver_const.connectionTypes.wifi;\n            </define-constants-for-connection-types>\n            \n            <check-and-create-usb-connection-info>\n            if(deviceInfo.ct === usbCT) {\n                usbInfo = createDeviceConnectionObj(\n                    deviceInfo.dt,\n                    deviceInfo.ct,\n                    deviceInfo.serialNumber.toString()\n                );\n                <set-usb-info-state>\n                usbInfo.isVerified = true;\n                usbInfo.verified = true;\n                \n                usbInfo.isScanned = true;\n                usbInfo.insertionMethod = 'scan';\n                usbInfo.isActive = deviceInfo.isActive;\n                if(deviceInfo.isActive) {\n                    usbInfo.insertionMethod = 'connected';\n                    usbInfo.isVerified = true;\n                    usbInfo.verified = true;\n                }\n                </set-usb-info-state>\n                foundUSB = true;\n            }\n            </check-and-create-usb-connection-info>\n            \n            <check-and-create-ethernet-connection-info>\n            else if(deviceInfo.ct === ethCT) {\n                ethInfo = createDeviceConnectionObj(\n                    deviceInfo.dt,\n                    deviceInfo.ct,\n                    \n                    deviceInfo.ethernetIP\n                );\n                <set-ethernet-info-state>\n                ethInfo.isScanned = true;\n                ethInfo.insertionMethod = 'scan';\n                ethInfo.isActive = deviceInfo.isActive;\n                if(deviceInfo.isActive) {\n                    ethInfo.insertionMethod = 'connected';\n                    ethInfo.isVerified = true;\n                    ethInfo.verified = true;\n                }\n                </set-ethernet-info-state>\n                foundEth = true;\n            }\n            </check-and-create-ethernet-connection-info>\n            \n            <check-and-create-wifi-connection-info>\n            else if(deviceInfo.ct === wifiCT) {\n                wifiInfo = createDeviceConnectionObj(\n                    deviceInfo.dt,\n                    deviceInfo.ct,\n                    \n                    deviceInfo.wifiIP\n                );\n                <set-wifi-info-state>\n                wifiInfo.isScanned = true;\n                wifiInfo.insertionMethod = 'scan';\n                wifiInfo.isActive = deviceInfo.isActive;\n                if(deviceInfo.isActive) {\n                    wifiInfo.insertionMethod = 'connected';\n                    wifiInfo.isVerified = true;\n                    wifiInfo.verified = true;\n                }\n                </set-wifi-info-state>\n                foundWiFi = true;\n            }\n            </check-and-create-wifi-connection-info>\n            <check-and-create-ethernet-connection-attribute-info>\n            else {\n                console.error('openall_d_s, Encountered Invalid Connection Type', deviceInfo.ct);\n            }\n            if(!foundEth) {\n                if(deviceInfo.ETHERNET_IP) {\n                    if(deviceInfo.ETHERNET_IP.isReal) {\n                        ethInfo = createDeviceConnectionObj(\n                            deviceInfo.dt,\n                            ethCT,\n                            deviceInfo.ethernetIP\n                        );\n                        foundEth = true;\n                        ethInfo.insertionMethod = 'attribute';\n                        ethInfo.foundByAttribute = true;\n                    }\n                }\n            }\n            </check-and-create-ethernet-connection-attribute-info>\n            <check-and-create-wifi-connection-attribute-info>\n            if(!foundWiFi) {\n                if(deviceInfo.WIFI_IP) {\n                    if(deviceInfo.WIFI_IP.isReal) {\n                        wifiInfo = createDeviceConnectionObj(\n                            deviceInfo.dt,\n                            wifiCT,\n                            deviceInfo.wifiIP\n                        );\n                        foundWiFi = true;\n                        wifiInfo.insertionMethod = 'attribute';\n                        wifiInfo.foundByAttribute = true;\n                    }\n                }\n            }\n            </check-and-create-wifi-connection-attribute-info>\n\n            <add-connection-types-to-array>\n            if(foundUSB) {connectionTypes.push(usbInfo);}\n            if(foundEth) {connectionTypes.push(ethInfo);}\n            if(foundWiFi) {connectionTypes.push(wifiInfo);}\n            </add-connection-types-to-array>\n\n            return connectionTypes;\n        }\n"], ["function", "\nfunction compareTo() {\n  <initialize-variables>\n  var set;\n  </initialize-variables>\n  <handle-arguments-length>\n  if (compareTo.arguments.length == 2)\n   {\n    <set-arguments-length-to-2>\n    set = compareTo.arguments[1];\n    </set-arguments-length-to-2>\n   }\n  else if (compareTo.arguments.length == 1)\n   {\n    <set-arguments-length-to-1>\n    set = this.plainMC;\n    </set-arguments-length-to-1>\n   }\n  else\n   {\n    <throw-exception-for-invalid-arguments>\n    throw \"compareTo(): \" + compareTo.arguments.length + \" arguments given; expected 1 or 2\";\n    </throw-exception-for-invalid-arguments>\n   }\n   </handle-arguments-length>\n  <initialize-comparison-variables>\n  var rhs = compareTo.arguments[0];\n  \n  var thislength=0;\n  \n  var i=0;\n  \n  var newrhs;\n  </initialize-comparison-variables>\n  \n  <handle-lost-digits>\n  if (set.lostDigits)\n   this.checkdigits(rhs,set.digits);\n  </handle-lost-digits>\n  \n  <compare-index-and-exponents>\n  if ((this.ind==rhs.ind)&&(this.exp==rhs.exp))\n   {\n    <set-this-length>\n    thislength=this.mant.length;\n    </set-this-length>\n    <check-mantissa-length>\n    if (thislength<rhs.mant.length)\n     return -this.ind;\n    if (thislength>rhs.mant.length)\n     return this.ind;\n    </check-mantissa-length>\n    <compare-significant-digits>\n    if ((thislength<=set.digits)||(set.digits==0))\n     {\n      <compare-mantissa-values>{var $6=thislength;i=0;i:for(;$6>0;$6--,i++){\n       if (this.mant[i]<rhs.mant[i])\n        return -this.ind;\n       if (this.mant[i]>rhs.mant[i])\n        return this.ind;\n       }}</compare-mantissa-values>\n      return 0; \n     }\n    </compare-significant-digits>\n   }\n  </compare-index-and-exponents>\n  else\n   {\n    <compare-indicators>\n    if (this.ind<rhs.ind)\n     return -1;\n    if (this.ind>rhs.ind)\n     return 1;\n    </compare-indicators>\n   }\n  <clone-and-compare-rhs>\n  newrhs=this.clone(rhs); \n  newrhs.ind=-newrhs.ind; \n  return this.add(newrhs,set).ind; \n  </clone-and-compare-rhs>\n  }\n"], ["function", "\nfunction(message) {\n        <check-message-start>\n        if (message.data.indexOf(\"<open \") === 0 || message.data.indexOf(\"<?xml\") === 0) {\n            <prepare-and-parse-data>\n            var data = message.data.replace(/^(<\\?.*?\\?>\\s*)*/, \"\");\n            if (data === '') return;\n\n            var streamStart = new DOMParser().parseFromString(data, \"text/xml\").documentElement;\n            this._conn.xmlInput(streamStart);\n            this._conn.rawInput(message.data);\n            </prepare-and-parse-data>\n\n            <handle-stream-start>\n            \n            if (this._handleStreamStart(streamStart)) {\n                <connect-callback>\n                \n                this._connect_cb(streamStart);\n                </connect-callback>\n            }\n            </handle-stream-start>\n        } \n        <check-message-close>\n        else if (message.data.indexOf(\"<close \") === 0) {\n            <handle-close-stream>\n            this._conn.rawInput(message.data);\n            this._conn.xmlInput(message);\n            </handle-close-stream>\n            <check-see-other-uri>\n            var see_uri = message.getAttribute(\"see-other-uri\");\n            if (see_uri) {\n                this._conn._changeConnectStatus(Strophe.Status.REDIRECT, \"Received see-other-uri, resetting connection\");\n                this._conn.reset();\n                this._conn.service = see_uri;\n                <reconnect>\n                this._connect();\n                </reconnect>\n            } \n            </check-see-other-uri>\n            <handle-connection-fail>\n            else {\n                this._conn._changeConnectStatus(Strophe.Status.CONNFAIL, \"Received closing stream\");\n                this._conn._doDisconnect();\n            }\n            </handle-connection-fail>\n        }\n        </check-message-close>\n        <handle-other-message-data>\n        else {\n            var string = this._streamWrap(message.data);\n            var elem = new DOMParser().parseFromString(string, \"text/xml\").documentElement;\n            <set-onmessage-handler>\n            this.socket.onmessage = this._onMessage.bind(this);\n            </set-onmessage-handler>\n            <call-connect-callback>\n            this._conn._connect_cb(elem, null, message.data);\n            </call-connect-callback>\n        }\n        </handle-other-message-data>\n    }\n"], "```\n\nThe annotations above identify specific responsibilities within the functions that serve particular subtasks as part of the overall function duty, adhering to SRP principles as much as possible without knowledge of the entire ecosystem the code is part of. Each segment of code with a distinct responsibility has been annotated separately. The annotations demonstrate an understanding of where the division of responsibilities could occur, ensuring that the SRP is followed as closely as can be understood from the given context."]