[["validateCurlyBeforeKeyword", "\nfunction validateCurlyBeforeKeyword(curlyToken) {\n  <getToken>\n  const keywordToken = sourceCode.getTokenAfter(curlyToken);\n  </getToken>\n\n  <reportMismatchStyle>\n  if (style === '1tbs' && !astUtils.isTokenOnSameLine(curlyToken, keywordToken)) {\n    context.report({\n      node: curlyToken,\n      messageId: 'nextLineClose',\n      fix: removeNewlineBetween(curlyToken, keywordToken),\n    });\n  }\n  </reportMismatchStyle>\n\n  <reportMismatchStyle>\n  if (style !== '1tbs' && astUtils.isTokenOnSameLine(curlyToken, keywordToken)) {\n    context.report({\n      node: curlyToken,\n      messageId: 'sameLineClose',\n      fix: (fixer) => fixer.insertTextAfter(curlyToken, '\\n'),\n    });\n  }\n  </reportMismatchStyle>\n}\n"], ["checkEventInArray", "\nfunction (event) {\n  <searchEvent>\n  for (var i = 0; i < this.events.length; i++) {\n    if (event === this.events[i]) {\n      return true;\n    }\n  }\n  </searchEvent>\n  return false;\n}\n"], ["applyStyleOnLoad", "\nfunction applyStyleOnLoad(reference, popper, options, modifierOptions, state) {\n  <computeReferenceOffsets>\n  const referenceOffsets = getReferenceOffsets(state, popper, reference, options.positionFixed);\n  </computeReferenceOffsets>\n  \n  <computePlacement>\n  const placement = computeAutoPlacement(options.placement, referenceOffsets, popper, reference, options.modifiers.flip.boundariesElement, options.modifiers.flip.padding);\n  </computePlacement>\n\n  <setPlacementAttribute>\n  popper.setAttribute('x-placement', placement);\n  </setPlacementAttribute>\n\n  <setStyles>\n  setStyles(popper, { position: options.positionFixed ? 'fixed' : 'absolute' });\n  </setStyles>\n\n  return options;\n}\n"], ["containedInOrder", "\nfunction containedInOrder(needle, haystack) {\n  <searchSubsequence>\n  var i, j = 0;\n  for (i = 0; i < needle.length; i++) {\n    while (j < haystack.length && needle[i] !== haystack[j]) j++;\n  }\n  </searchSubsequence>\n  return i === needle.length && j < haystack.length;\n}\n"], ["randomFileOrFolderName", "\nfunction randomFileOrFolderName(len = 32) {\n  <validateAndGenerateName>\n  if (Number.isFinite(len)) {\n    return crypto.randomBytes(Math.ceil(len / 2)).toString('hex').slice(0, len);\n  }\n  </validateAndGenerateName>\n  throw new Error(`illegal argument: ${len}`);\n}\n"], ["randCol", "\nfunction randCol (r, g, b, a) {\n  <generateRandomColor>\n  return \"rgba(\" + Math.floor(Math.random() * r).toString() + \",\" +\n                   Math.floor(Math.random() * g).toString() + \",\" +\n                   Math.floor(Math.random() * b).toString() + \",\" + a + \")\";\n  </generateRandomColor>\n}\n"], ["isValidCodepoint", "\nfunction(codepoint) {\n  <determineCodepointValidity>\n  return codepoint === 0x09\n    || codepoint === 0x0a\n    || (codepoint >= 0x20 && codepoint <= 0x7e)\n    || (codepoint >= 0xa0 && codepoint <= 0xd7ff)\n    || (codepoint >= 0xe000 && codepoint <= 0xfffd)\n    || (codepoint >= 0x10000 && codepoint <= 0x10ffff);\n  </determineCodepointValidity>\n}\n"], ["disableControlsTemporarily", "\nfunction disableControlsTemporarily() {\n  <disableMethods>\n  viewer.controls().disableMethod('touchView');\n  viewer.controls().disableMethod('pinch');\n  </disableMethods>\n  <timeoutEnableMethods>\n  setTimeout(function() {\n    viewer.controls().enableMethod('touchView');\n    viewer.controls().enableMethod('pinch');\n  }, 200);\n  </timeoutEnableMethods>\n}\n"], ["getRequestWithDeviceIdentifier", "\nfunction (deviceIdentifier, channelIdentifier, params) {\n  <pathConstruction>\n  var path;\n  if (deviceIdentifier) {\n    path = this.constructPath(constants.DEVICES, deviceIdentifier, constants.CHANNELS, channelIdentifier);\n  </pathConstruction>\n    <getRequest>\n    return this.Core.GET(path, params);\n    </getRequest>\n  } else {\n    <rejectRequest>\n    return this.rejectRequest('Bad Request: A device identifier is required.');\n    </rejectRequest>\n  }\n}\n"], ["cleanUpChildren", "\nfunction() {\n  <removeAllChildren>\n  var children = Kinetic.Collection.toCollection(this.children);\n  var child;\n  for (var i = 0; i < children.length; i++) {\n    child = children[i];\n    \n    delete child.parent;\n    child.index = 0;\n    if (child.hasChildren()) {\n      child.removeChildren();\n    }\n    child.remove();\n  }\n  children = null;\n  </removeAllChildren>\n  <resetChildrenCollection>\n  this.children = new Kinetic.Collection();\n  </resetChildrenCollection>\n  return this;\n}\n"], "```"]