[["addPropToValue", "\nfunction addPropToValue( prop, value ) {\n    <validateValue>\n    if ( value === undefined || value === null ) return;\n    if ( value.isContentChangeAware !== true ) return;\n    </validateValue>\n    <handleProperties>\n    var properties = value[ PROPERTY_SYMBOL ];\n    if ( !Array.isArray( properties ) ) {\n        properties = [ prop ];\n    } else if ( properties.indexOf( prop ) === -1 ) {\n        properties.push( prop );\n    }\n    value[ PROPERTY_SYMBOL ] = properties;\n    </handleProperties>\n}\n"], ["buildGradient", "\nfunction buildGradient() {\n    <createLinearGradient>\n    if (!linearGradient) {\n        linearGradient = svg.select('.metadata-group')\n          .append('linearGradient')\n            .attr('id', lineGradientId)\n            .attr('x1', '0%')\n            .attr('y1', '0%')\n            .attr('x2', '100%')\n            .attr('y2', '0%')\n            .attr('gradientUnits', 'userSpaceOnUse')\n            .selectAll('stop')\n            .data([\n                {offset:'0%', color: singleLineGradientColors[0]},\n                {offset:'100%', color: singleLineGradientColors[1]}\n            ])\n            .enter()\n              .append('stop')\n                .attr('offset', ({offset}) => offset)\n                .attr('stop-color', ({color}) => color)\n    }\n    </createLinearGradient>\n}\n"], ["factory", "\nfunction factory(\n    configuration,\n    Logger,\n    assert,\n    Errors,\n    Constants,\n    uuid,\n    Hogan,\n    Promise,\n    Rx,\n    _,\n    env,\n    waterline,\n    validator,\n    taskLibrary,\n    injector\n) {\n    <defineCommonConstants>\n    var COMMON_OPTIONS_SCHEMA = 'common-task-options.json';\n    var TaskStates = Constants.Task.States;\n    var logger = Logger.initialize(factory);\n    </defineCommonConstants>\n\n    \n\n    \n    <TaskDefinition>\n    function Task(definition, taskOverrides, context) {\n\n        \n        <basicAssertionsAndInitializations>\n        var self = this;\n        assert.object(context, 'Task shared context object');\n        self.definition = _.cloneDeep(definition);\n        self.cancelled = false;\n        taskOverrides = taskOverrides || {};\n        </basicAssertionsAndInitializations>\n\n        <processOverridesAndDefaults>\n        self.compileOnly = taskOverrides.compileOnly || false;\n        self.instanceId = taskOverrides.instanceId || uuid.v4();\n        if (_.has(context, 'target')) {\n            self.nodeId = context.target;\n        }\n        self.name = taskOverrides.name || self.definition.injectableName;\n        self.friendlyName = taskOverrides.friendlyName || self.definition.friendlyName;\n        self.waitingOn = taskOverrides.waitingOn || [];\n        self.ignoreFailure = taskOverrides.ignoreFailure || false;\n        self.error = null;\n        self.properties = definition.properties;\n        </processOverridesAndDefaults>\n\n        <linkContextAndSetInitialState>\n        self.context = context;\n        self.state = TaskStates.Pending;\n        self.successStates = [TaskStates.Succeeded];\n        self.failedStates = [TaskStates.Failed, TaskStates.Timeout, TaskStates.Cancelled];\n        </linkContextAndSetInitialState>\n\n        <setupServerAndFilesUri>\n        var server;\n        if (_.has(context, 'proxy')) {\n            server = context.proxy;\n        } else {\n            server = 'http://'+ Task.configCache.apiServerAddress + ':' + Task.configCache.apiServerPort;\n        }\n        var fileServerUri;\n        if (_.has(Task.configCache, 'fileServerAddress')) {\n            fileServerUri = 'http://' + Task.configCache.fileServerAddress;\n            if (_.has(Task.configCache, 'fileServerPort')) {\n                fileServerUri = fileServerUri + ':' + Task.configCache.fileServerPort;\n            }\n            if (_.has(Task.configCache, 'fileServerPath')) {\n                fileServerUri = fileServerUri + Task.configCache.fileServerPath;\n                fileServerUri = _.trimRight(fileServerUri, '/');\n            }\n        } else {\n            fileServerUri = server;\n        }\n        </setupServerAndFilesUri>\n\n        <defineRenderContext>\n        self.renderContext = {\n            server: Task.configCache,\n            api: { server: server },\n            file: {\n                server: fileServerUri\n            },\n            task: self,\n            options: self.definition.options,\n            context: self.context\n        };\n        self.renderContext.api.base = self.renderContext.api.server + '/api/current';\n        self.renderContext.api.templates = self.renderContext.api.base + '/templates';\n        self.renderContext.api.profiles = self.renderContext.api.base + '/profiles';\n        self.renderContext.api.lookups = self.renderContext.api.base + '/lookups';\n        self.renderContext.api.files = self.renderContext.api.base + '/files';\n        self.renderContext.api.nodes = self.renderContext.api.base + '/nodes';\n        </defineRenderContext>\n\n        <retrieveTaskTimeout>\n        self._taskTimeout = self.definition.options._taskTimeout;\n        </retrieveTaskTimeout>\n\n        return self;\n    }\n\n    <SkuIdMethods>\n    Task.prototype.getSkuId = function(nodeId) {\n        if(!nodeId)  {\n            return Promise.resolve();\n        }\n\n        return waterline.nodes.needByIdentifier(nodeId)\n            .then(function(node) {\n                if (node.sku) {\n                    return node.sku;\n                }\n            });\n    };\n    </SkuIdMethods>\n\n    <RenderMethods>\n    Task.prototype.renderAll = function(nodeId, options){\n        // Omitted for brevity\n    };\n    Task.prototype._isDeferredRender = function(renderKey) {\n        // Omitted for brevity\n    };\n    Task.prototype.renderString = function(str, context, depth, maxDepth) {\n        // Omitted for brevity\n    };\n    Task.prototype.parse = function(source) {\n        // Omitted for brevity\n    };\n    Task.prototype.renderComplex = function(source, context) {\n        // Omitted for brevity\n    };\n    Task.prototype.render = function(source, context, depth) {\n        // Omitted for brevity\n    };\n    Task.prototype.renderOptions = function(toRender, renderContext) {\n        // Omitted for brevity\n    };\n    Task.prototype.renderOwnOptions = function(toRender) {\n        // Omitted for brevity\n    };\n    </RenderMethods>\n\n    <JobManagementMethods>\n    Task.prototype.instantiateJob = function() {\n        // Omitted for brevity\n    };\n    Task.prototype.run = function() {\n        // Omitted for brevity\n    };\n    Task.prototype._run = function() {\n        // Omitted for brevity\n    };\n    Task.prototype.stop = function() {\n        // Omitted for brevity\n    };\n    Task.prototype.cancel = function(error) {\n        // Omitted for brevity\n    };\n    </JobManagementMethods>\n\n    <SerializationMethods>\n    Task.prototype.toJSON = function toJSON() {\n        return this.serialize();\n    };\n    Task.prototype.serialize = function serialize() {\n        // Omitted for brevity\n    };\n    </SerializationMethods>\n\n    <CompileAndValidationMethods>\n    Task.prototype.compile = function compile() {\n        // Omitted for brevity\n    };\n    \n    function handleCommonOptions(options) {\n        // Omitted for brevity\n    }\n\n    function _validateSchemaProperty(schema, title) {\n        // Omitted for brevity\n    }\n\n    Task.getBaseTask = function(query) {\n        // Omitted for brevity\n    };\n\n    Task.validateBaseTask = function(baseTask) {\n        // Omitted for brevity\n    };\n\n    \n    Task.validateDefinition = function validateDefinition(definition) {\n        // Omitted for brevity\n    };\n\n    \n    Task.create = function create(definition, taskOverrides, context) {\n        // Omitted for brevity\n    };\n\n    Task.getCommonSchema = function () {\n        // Omitted for brevity\n    };\n\n    Task.getTaskSpecificSchema = function(definition) {\n        // Omitted for brevity\n    };\n\n    Task.getJobSchema = function(definition) {\n        // Omitted for brevity\n    };\n\n    Task.getFullSchema = function getFullSchema(definition) {\n        // Omitted for brevity\n    };\n\n    Task.validateOptions = function (definition, options, flags) {\n        // Omitted for brevity\n    };\n    </CompileAndValidationMethods>\n\n    <ConfigurationCacheInitialization>\n    Task.configCache = configuration.getAll();\n    </ConfigurationCacheInitialization>\n\n    return Task;\n}\n"], ["min", "\nfunction min(x) {\n    <findMinimumValue>\n    var value;\n    for (var i = 0; i < x.length; i++) {\n        \n        if (x[i] < value || value === undefined) value = x[i];\n    }\n    </findMinimumValue>\n    return value;\n}\n"], ["bitDepth", "\nfunction bitDepth(input, original, target, output) {\n  <validateBitDepths>\n  validateBitDepth_(original);\n  validateBitDepth_(target);\n  </validateBitDepths>\n  \n  <computeTransformFunction>\n  let toFunction = getBitDepthFunction_(original, target);\n  </computeTransformFunction>\n  \n  <setupOptions>\n  let options = {\n    oldMin: Math.pow(2, parseInt(original, 10)) / 2,\n    newMin: Math.pow(2, parseInt(target, 10)) / 2,\n    oldMax: (Math.pow(2, parseInt(original, 10)) / 2) - 1,\n    newMax: (Math.pow(2, parseInt(target, 10)) / 2) - 1,\n  };\n  </setupOptions>\n  \n  <adjustInputOnOriginalBitDepth>\n  const len = input.length;\n  if (original == \"8\") {\n    for (let i=0; i<len; i++) {\n      output[i] = input[i] -= 128;\n    }\n  }\n  </adjustInputOnOriginalBitDepth>\n  \n  <performBitDepthConversion>\n  for (let i=0; i<len; i++) {        \n    output[i] = toFunction(input[i], options);\n  }\n  </performBitDepthConversion>\n  \n  <adjustOutputOnTargetBitDepth>\n  if (target == \"8\") {\n    for (let i=0; i<len; i++) {\n      output[i] = output[i] += 128;\n    }\n  }\n  </adjustOutputOnTargetBitDepth>\n}\n"], ["searchFunction", "\nfunction(input) {\n  input = input || {};\n  \n  <mergeAggregations>\n  input.aggregations = helpers.mergeAggregations(configuration.aggregations, input);\n  </mergeAggregations>\n\n  <performSearch>\n  return service.search(items, input, configuration, fulltext);\n  </performSearch>\n}\n"], ["getFormatterResults", "\nfunction getFormatterResults() {\n  <dependencies>\n  const stripAnsi = require(\"strip-ansi\");\n  </dependencies>\n\n  <loadFormatterFiles>\n  const formatterFiles = fs.readdirSync(\"./lib/formatters/\"),\n  <setupRules>\n      rules = {\n          \"no-else-return\": \"warn\",\n          indent: [\"warn\", 4],\n          \"space-unary-ops\": \"error\",\n          semi: [\"warn\", \"always\"],\n          \"consistent-return\": \"error\"\n      },\n  </setupRules>\n  <initializeCLI>\n      cli = new CLIEngine({\n          useEslintrc: false,\n          baseConfig: { extends: \"eslint:recommended\" },\n          rules\n      }),\n  </initializeCLI>\n  <prepareCodeStringAndExecute>\n      codeString = [\n          \"function addOne(i) {\",\n          \"    if (i != NaN) {\",\n          \"        return i ++\",\n          \"    } else {\",\n          \"      return\",\n          \"    }\",\n          \"};\"\n      ].join(\"\\n\"),\n      rawMessages = cli.executeOnText(codeString, \"fullOfProblems.js\", true),\n  </prepareCodeStringAndExecute>\n  <prepareRulesMapAndMeta>\n      rulesMap = cli.getRules(),\n      rulesMeta = {};\n  \n  Object.keys(rules).forEach(ruleId => {\n      rulesMeta[ruleId] = rulesMap.get(ruleId).meta;\n  });\n  </prepareRulesMapAndMeta>\n\n  <performFormatting>\n  return formatterFiles.reduce((data, filename) => {\n      const fileExt = path.extname(filename),\n          name = path.basename(filename, fileExt);\n  \n      if (fileExt === \".js\") {\n          const formattedOutput = cli.getFormatter(name)(\n              rawMessages.results,\n              { rulesMeta }\n          );\n  \n          data.formatterResults[name] = {\n              result: stripAnsi(formattedOutput)\n          };\n      }\n      return data;\n  }, { formatterResults: {} });\n  </performFormatting>\n}\n"], ["genericCircularLayout", "\nfunction genericCircularLayout(assign, graph, options) {\n  <validateGraph>\n  if (!isGraph(graph))\n    throw new Error('graphology-layout/random: the given graph is not a valid graphology instance.');\n  </validateGraph>\n\n  <setDefaultOptions>\n  options = defaults(options, DEFAULTS);\n  </setDefaultOptions>\n\n  <initializePositionsAndNodes>\n  var positions = {},\n      nodes = graph.nodes(),\n      center = options.center,\n      scale = options.scale,\n      tau = Math.PI * 2;\n  </initializePositionsAndNodes>\n\n  <calculatePositions>\n  var l = nodes.length,\n      node,\n      x,\n      y,\n      i;\n  \n  for (i = 0; i < l; i++) {\n    node = nodes[i];\n  \n    x = scale * Math.cos(i * tau / l);\n    y = scale * Math.sin(i * tau / l);\n  \n    if (center !== 0.5) {\n      x += center - 0.5 * scale;\n      y += center - 0.5 * scale;\n    }\n  \n    positions[node] = {\n      x: x,\n      y: y\n    };\n  \n    if (assign) {\n      graph.setNodeAttribute(node, options.attributes.x, x);\n      graph.setNodeAttribute(node, options.attributes.y, y);\n    }\n  }\n  </calculatePositions>\n\n  return positions;\n}\n"], ["getEntriesFromIterable", "\nfunction getEntriesFromIterable(collection) {\n  <handleArrayFrom>\n  if (isFunction(Array.from)) {\n    return Array.from(collection.entries());\n  }\n  </handleArrayFrom>\n\n  <fallbackEntriesImplementation>\n  let entries = [];\n  \n  collection.forEach((value, key) => {\n    entries.push([key, value]);\n  });\n  </fallbackEntriesImplementation>\n\n  return entries;\n}\n"], ["onRequestBefore", "\nfunction(xhr) {\n    <superCall>\n    CompositeComponent.prototype.onRequestBefore.call(this, xhr);\n    </superCall>\n\n    <showLoading>\n    if (this.options.showLoading) {\n        this.position(Toolkit.messages.loading);\n    }\n    </showLoading>\n}\n"], ""]