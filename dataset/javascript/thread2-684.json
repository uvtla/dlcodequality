[["mxSwimlaneModel", "\nfunction mxSwimlaneModel(layout, vertices, roots, parent, tightenToSource) {\n    <initialSetup>\n    var graph = layout.getGraph();\n    this.tightenToSource = tightenToSource;\n    this.roots = roots;\n    this.parent = parent;\n\n    this.vertexMapper = new mxDictionary();\n    this.edgeMapper = new mxDictionary();\n    this.maxRank = 0;\n    var internalVertices = [];\n\n    if (vertices == null) {\n        vertices = this.graph.getChildVertices(parent);\n    }\n\n    this.maxRank = this.SOURCESCANSTARTRANK;\n    </initialSetup>\n    \n    <createInternalCells>\n    this.createInternalCells(layout, vertices, internalVertices);\n    </createInternalCells>\n\n    <processVerticesAndEdges>\n    for (var i = 0; i < vertices.length; i++) {\n        var edges = internalVertices[i].connectsAsSource;\n\n        for (var j = 0; j < edges.length; j++) {\n            var internalEdge = edges[j];\n            var realEdges = internalEdge.edges;\n\n            <assignTargetToEdges>\n            if (realEdges != null && realEdges.length > 0) {\n                var realEdge = realEdges[0];\n                var targetCell = layout.getVisibleTerminal(realEdge, false);\n                var internalTargetCell = this.vertexMapper.get(targetCell);\n\n                if (internalVertices[i] == internalTargetCell) {\n                    targetCell = layout.getVisibleTerminal(realEdge, true);\n                    internalTargetCell = this.vertexMapper.get(targetCell);\n                }\n\n                if (internalTargetCell != null && internalVertices[i] != internalTargetCell) {\n                    internalEdge.target = internalTargetCell;\n\n                    if (internalTargetCell.connectsAsTarget.length == 0) {\n                        internalTargetCell.connectsAsTarget = [];\n                    }\n\n                    if (mxUtils.indexOf(internalTargetCell.connectsAsTarget, internalEdge) < 0) {\n                        internalTargetCell.connectsAsTarget.push(internalEdge);\n                    }\n                }\n            }\n            </assignTargetToEdges>\n        }\n\n        <setInitialTemp>\n        internalVertices[i].temp[0] = 1;\n        </setInitialTemp>\n    }\n    </processVerticesAndEdges>\n}\n"], ["getLayer", "\nfunction getLayer(index) {\n    <retrieveLayer>\n    var layer = layers[index];\n    if (!layer) {\n\n        <createLayer>\n        if (index === 0) {\n            layer = display.getDefaultLayer(); \n        } else if (index > 0) {\n            layer = display.createLayer();\n        } else {\n            layer = display.createBuffer();\n        }\n        </createLayer>\n        \n        <assignLayer>\n        layers[index] = layer;\n        </assignLayer>\n    }\n    </retrieveLayer>\n\n    return layer;\n}\n"], ["srcEnv", "\nfunction srcEnv(documentize, stream) {\n    return function (...args) {\n        <findArguments>\n        let src = Array.find(args, a => is.string(a) || is.array(a));\n        let env = Array.find(args, is.plainObject);\n        </findArguments>\n\n        <setupEnvironment>\n        env = ensureEnvironment(env);\n        </setupEnvironment>\n\n        <logEnvironmentInformation>\n        // A series of logging statements, showing debug information\n        </logEnvironmentInformation>\n\n        <determineAndExecuteTask>\n        let task = env.src ? documentize : stream;\n        return task(env);\n        </determineAndExecuteTask>\n    }\n}\n"], ["unnamedFunction", "\nfunction(value) {\n    <retrieveOrSetInnerHTML>\n    var elem = this[0] || {}, i = 0, l = this.length;\n\n    if (value === undefined && elem.nodeType === 1) {\n        return elem.innerHTML;\n    }\n\n    if (typeof value === 'string' && !rnoInnerhtml.test(value)) {\n        try {\n            value = vQ.htmlPrefilter(value);\n            for (; i < l; i++) {\n                elem = this[i] || {};\n                \n                if (elem.nodeType === 1) {\n                    elem.innerHTML = value;\n                }\n            }\n            elem = 0;\n        } catch (e) {\n        }\n    }\n    </retrieveOrSetInnerHTML>\n\n    return this[0].innerHTML;\n}\n"], ["GreyList", "\nfunction GreyList(options) {\n    <initialSetup>\n    this.white = getFlatArrayOfRegexAndOrString(options && options.white);\n    this.black = getFlatArrayOfRegexAndOrString(options && options.black);\n    </initialSetup>\n}\n"], ["next_word_is_cap", "\nfunction next_word_is_cap(sentence, i, parameter) {\n    if (i < sentence.taggedWords.length - 1) {\n        var next_word = sentence.taggedWords[i+1].token;\n        return(next_word[0] === next_word[0].toUpperCase());\n    }\n    return(false);\n}\n"], ["unnamedAuthFunction", "\nfunction(req, localAuth, cb) {\n    <determineLocalOrRemoteAuth>\n    if (process.env.FH_USE_LOCAL_DB) {\n        if (_.isFunction(localAuth)) {\n            return localAuth(req, cb);\n        } else if (_.isObject(localAuth)) {\n            return cb(undefined, localAuth);\n        } else {\n            return cb(undefined, { status: 200, body: {} });\n        }\n    } else {\n        return call(\"admin/authpolicy/auth\", req.body, cb);\n    }\n    </determineLocalOrRemoteAuth>\n}\n"], ["executeCommandDelegation", "\nfunction(delegate) {\n    this.execute = function(command, callback) {\n        delegate.then(function(executor) {\n            <executeCommand>\n            executor.execute(command, callback);\n            </executeCommand>\n        }, callback);\n    };\n}\n"], ["buildArrayFromFunction", "\nfunction(n, indexMapFn) {\n    var arr, result;\n    for (var i = 0; i < n; i++) {\n        <mapIndexToValue>\n        result = indexMapFn.call(n, i);\n        if (isDefined(result)) {\n            if (!arr) {\n                arr = [];\n            }\n            arr.push(result);\n        }\n        </mapIndexToValue>\n    }\n    return arr;\n}\n"], ["handleErrorResponse", "\nfunction(error, request, response) {\n    <prepareResponse>\n    if (!response) {\n        response = {};\n    }\n\n    if (!request && error) {\n        request = this.pendingRequests[error.reqId];\n    }\n    </prepareResponse>\n\n    <processResponse>\n    this.clearTimeout(request.id);\n    this._normalizeResponse(error, request, response);\n\n    request.res = response;\n    request.endDownload = (new Date()).getTime();\n    request.downloadTime = request.endDownload - request.beginDownload;\n    request.responseSize = response.responseText.length;\n    </processResponse>\n\n    <accumulateTraffic>\n    this.trafficDown += request.responseSize;\n    </accumulateTraffic>\n\n    <raiseResponseEvent>\n    this.$raiseEvent({\n        name: \"response\",\n        req: request\n    });\n    </raiseResponseEvent>\n\n    <finalizeRequest>\n    delete this.pendingRequests[request.id];\n\n    if (aria.core.IOFiltersMgr) {\n        aria.core.IOFiltersMgr.callFiltersOnResponse(request, {\n            fn: this._afterResponseFilters,\n            scope: this,\n            args: request\n        });\n    } else {\n        this._afterResponseFilters(null, request);\n    }\n    </finalizeRequest>\n}\n"], "```"]