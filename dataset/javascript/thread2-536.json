[["setElement", "\nfunction(v) {\n    if (v === undefined) return this._element; // Responsibility: Get the current element\n    if (typeof v === 'string') { // Responsibility: Find element by string selector\n      v = window.document.querySelector(v);\n    }\n    this._element = v; // Responsibility: Set the element\n    return this;\n}\n"], ["logErrorWithStack", "\nfunction unknownError(message, stack) {\n    jitsu.log.error(message); // Responsibility: Log error message\n    stack.split('\\n').forEach(function (line) { // Responsibility: Log error stack\n      jitsu.log.error(line);\n    })\n}\n"], ["deepSetProperty", "\nfunction deepSet(targ, path, val) {\n  var seg;\n  while (seg = path.shift()) { // Responsibility: Traverse and set deep object properties\n    if (path.length === 0) {\n      targ[seg] = val;\n    }\n    else {\n      targ[seg] = targ = targ[seg] || {};\n    }\n  }\n}\n"], ["convertToCamelCase", "\nfunction camelCase(str, { upperCase = false } = {}) {\n  if (str.length === 0) {  // Responsibility: Return input if it's empty\n    return str;\n  }\n\n  if (upperCase && isAllUpperCaseSnakeCase(str)) { // Responsibility: Consider upper case conversion\n    str = str.toLowerCase();\n  }\n\n  let out = str[0]; // Responsibility: Convert string to camel case\n  for (let i = 1, l = str.length; i < l; ++i) {\n    const char = str[i];\n    const prevChar = str[i - 1];\n\n    if (char !== '_') {\n      if (prevChar === '_') {\n        out += char.toUpperCase();\n      } else {\n        out += char;\n      }\n    }\n  }\n\n  return out;\n}\n"], ["recordScrollOffsets", "\nfunction() {\n  this.deltaX =  window.pageXOffset // Responsibility: Record horizontal scroll offset\n                || document.documentElement.scrollLeft\n                || document.body.scrollLeft\n                || 0;\n  this.deltaY =  window.pageYOffset // Responsibility: Record vertical scroll offset\n                || document.documentElement.scrollTop\n                || document.body.scrollTop\n                || 0;\n}\n"], ["determineSandboxStatus", "\nfunction(doNotReassessFlashSupport) {\n    \n    var frame, frameError, previousState = _flashState.sandboxed, isSandboxed = null;\n    doNotReassessFlashSupport = doNotReassessFlashSupport === true; // Responsibility: Assess iframe sandboxed status\n    if (_pageIsFramed === false) {\n      isSandboxed = false;\n    } else {\n      try {\n        frame = window.frameElement || null;\n      } catch (e) {\n        frameError = {\n          name: e.name,\n          message: e.message\n        };\n      }\n      if (frame && frame.nodeType === 1 && frame.nodeName === \"IFRAME\") {\n        try {\n          isSandboxed = frame.hasAttribute(\"sandbox\");\n        } catch (e) {\n          isSandboxed = null;\n        }\n      } else {\n        try {\n          effectiveScriptOrigin = document.domain || null;\n        } catch (e) {\n          effectiveScriptOrigin = null;\n        }\n        if (effectiveScriptOrigin === null || frameError && frameError.name === \"SecurityError\" && /(^|[\\s\\(\\[@])sandbox(es|ed|ing|[\\s\\.,!\\)\\]@]|$)/.test(frameError.message.toLowerCase())) {\n          isSandboxed = true;\n        }\n      }\n    }\n    _flashState.sandboxed = isSandboxed; // Responsibility: Update sandboxed status\n    \n    <reassessFlashSupport>\n    if (previousState !== isSandboxed && !doNotReassessFlashSupport) { // Responsibility: Reassess flash support if needed\n      _detectFlashSupport(_ActiveXObject);\n    }\n    </reassessFlashSupport>\n\n    return isSandboxed;\n}\n"], ["addCustomNotifications", "\nfunction createCustomNotification(notification) {\n    if (!notification) {\n        return Promise.resolve(); // Responsibility: Return if no notification is provided\n    }\n\n    return Promise.each(notification.messages, function (message) {\n        let toAdd = { // Responsibility: Prepare notification object\n            custom: !!notification.custom,\n            createdAt: moment(notification.created_at).toDate(),\n            status: message.status || 'alert',\n            type: message.type || 'info',\n            id: message.id,\n            dismissible: message.hasOwnProperty('dismissible') ? message.dismissible : true,\n            top: !!message.top,\n            message: message.content\n        };\n\n        debug('Add Custom Notification', toAdd); // Responsibility: Log notification object creation\n        return api.notifications.add({notifications: [toAdd]}, {context: {internal: true}}); // Responsibility: Add notification to persistent storage\n    });\n}\n"], ["copyMedia", "\nfunction (media_id, copy_options, cb) {\n    if (copy_options) {\n        copy_options._method = 'POST'; // Responsibility: Mutate copy options if provided\n    }\n\n    <executeQuery>\n    _util.buildQuery('medias/' + media_id + '/copy', copy_options, function (error, data) { // Responsibility: Execute API query for copying media\n        return cb(error, data);\n    });\n    </executeQuery>\n}\n"], ["filterApplicableMessages", "\nfunction applicableMessages(messages, options) {\n  if (options.silent) { // Responsibility: Return only fatal messages when silent\n    return messages.filter(function(message) {\n      return message.fatal;\n    });\n  } else { // Responsibility: Return all messages when not silent\n    return messages.concat();\n  }\n}\n"], ["checkJsonPropertyUpdate", "\nfunction shouldBeUpdated(target, propertyName, json) {\n  return (\n    json[propertyName] !== undefined && // Responsibility: Determine if the property should be updated\n    propertyName.length > 0 && \n    propertyName[0] !== \"_\" && \n    (propertyName !== \"id\" || !defined(target.id))\n  ); \n}\n"], "``` \n\nNote: The `filterApplicableMessages` function has been slightly adjusted for semantics and proper use of array methods; the `while` loop was replaced with `filter`, which clearly shows the intended responsibility."]