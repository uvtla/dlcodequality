[["handleObjectAndBrowserSpecificLogic", "\nfunction(proto, name, combo, root) {\n    <checkIfMethodAndDo>\n    if (this._ismethod(name)) {\n        this._domethod(proto, name, combo);\n    }\n    </checkIfMethodAndDo>\n    else {\n        <handleDifferentBrowsers>\n        if (gui.Client.isGecko) {\n            this._dogeckoaccessor(proto, name, combo, root);\n        } else if (gui.Client.isExplorer) {\n            this._doieaccessor(proto, name, combo);\n        } else {\n            \n        }\n        </handleDifferentBrowsers>\n    }\n}\n"], ["convertResourceToXml", "\nfunction resourceToXml(resource, rel, currentIndent, nextIndent) {\n    \n    <initializeXMLStructure>\n    var LF = (currentIndent || nextIndent) ? '\\n' : '';\n    var xml = currentIndent + '<resource';\n    if (rel) xml += ' rel=\"' + escapeXml(rel) + '\"';\n    if (resource.href || resource._links.self) xml += ' href=\"' + escapeXml(resource.href || resource._links.self.href) + '\"';\n    if (resource.name) xml += ' name=\"' + escapeXml(resource.name) + '\"';\n    xml += '>' + LF;\n    </initializeXMLStructure>\n    \n    <appendLinkElements>\n    for (var rel in resource._links) {\n        if (!resource.href && rel === 'self') continue;\n        xml += currentIndent + nextIndent + resource._links[rel].toXML() + LF;\n    }\n    </appendLinkElements>\n    \n    <appendEmbeddedResources>\n    for (var embed in resource._embedded) {\n        var rel = embed.replace(/s$/, '');\n        resource._embedded[embed].forEach(function (res) {\n            xml += resourceToXml(res, rel, currentIndent + nextIndent, currentIndent + nextIndent + nextIndent) + LF;\n        });\n    }\n    </appendEmbeddedResources>\n    \n    <appendProperties>\n    for (var prop in resource) {\n        if (resource.hasOwnProperty(prop) && prop !== '_links' && prop !== '_embedded') {\n            xml += currentIndent + nextIndent + '<' + prop + '>' + String(resource[prop]) + '</' + prop + '>' + LF;\n        }\n    }\n    </appendProperties>\n    \n    <finalizeXMLStructure>\n    xml += currentIndent + '</resource>';\n    </finalizeXMLStructure>\n\n    return xml;\n}\n"], ["autoUpdateProcessHandler", "\nfunction _updateProcessHandler(updates) {\n    <checkUpdateValidity>\n    if (!updates) {\n        console.warn(\"AutoUpdate : updates information not available.\");\n        return;\n    }\n    </checkUpdateValidity>\n    \n    <initializeRequiredVariables>\n    var OS = brackets.getPlatformInfo(),\n        checksum,\n        downloadURL,\n        installerName,\n        platforms,\n        latestUpdate;\n    latestUpdate = updates[0];\n    platforms = latestUpdate ? latestUpdate.platforms : null;\n    </initializeRequiredVariables>\n\n    <processPlatformSpecificUpdates>\n    if (platforms && platforms[OS]) {\n        checksum = platforms[OS].checksum ? platforms[OS].checksum : 0,\n        downloadURL = platforms[OS].downloadURL ? platforms[OS].downloadURL : \"\",\n        installerName = downloadURL ? downloadURL.split(\"/\").pop() : \"\";\n    } else {\n        return false;\n    }\n    </processPlatformSpecificUpdates>\n    \n    <validateAssetInformation>\n    if (!checksum || !downloadURL || !installerName) {\n        console.warn(\"AutoUpdate : asset information incorrect for the update\");\n        return false;\n    }\n    </validateAssetInformation>\n\n    <initiateUpdate>\n    var updateParams = {\n        downloadURL: downloadURL,\n        installerName: installerName,\n        latestBuildNumber: latestUpdate.buildNumber,\n        checksum: checksum\n    };\n    initiateAutoUpdate(updateParams);\n    </initiateUpdate>\n    \n    return true;\n}\n"], ["customErrorClass", "\nfunction NatsError(message, code, chainedError) {\n    Error.captureStackTrace(this, this.constructor);\n    this.name = this.constructor.name;\n    this.message = message;\n    this.code = code;\n    this.chainedError = chainedError;\n}\n"], ["base64ToHex", "\nfunction b64tohex(s) {\n    var ret = \"\"\n    var i;\n    var k = 0; \n    var slop;\n    for (i = 0; i < s.length; ++i) {\n        if (s.charAt(i) == b64pad) break;\n        v = b64map.indexOf(s.charAt(i));\n        if (v < 0) continue;\n        if (k == 0) {\n            ret += int2char(v >> 2);\n            slop = v & 3;\n            k = 1;\n        }\n        else if (k == 1) {\n            ret += int2char((slop << 2) | (v >> 4));\n            slop = v & 0xf;\n            k = 2;\n        }\n        else if (k == 2) {\n            ret += int2char(slop);\n            ret += int2char(v >> 2);\n            slop = v & 3;\n            k = 3;\n        }\n        else {\n            ret += int2char((slop << 2) | (v >> 4));\n            ret += int2char(v & 0xf);\n            k = 0;\n        }\n    }\n    if (k == 1)\n        ret += int2char(slop << 2);\n    return ret;\n}\n"], ["applyFiltersToQuery", "\nfunction filterWhere(q, filter) {\n    if (typeof filter !== 'object' || filter.where === undefined)\n      return;\n\n    if (Object.keys(filter.where).length !== 0) {\n      check(q, filter.where);\n      q.where(filter.where);\n    }\n}\n"], ["featureStylingAndLabeling", "\nfunction(feature, style) {\n    <styleAndLabelFeatureOrHide>\n    if(style == null) {\n        style = feature.style;\n    }\n    if (feature.geometry) {\n        var bounds = feature.geometry.getBounds();\n        if(bounds) {\n            var worldBounds;\n            if (this.map.baseLayer && this.map.baseLayer.wrapDateLine) {\n                worldBounds = this.map.getMaxExtent();\n            }\n            if (!bounds.intersectsBounds(this.extent, {worldBounds: worldBounds})) {\n                style = {display: \"none\"};\n            } else {\n                this.calculateFeatureDx(bounds, worldBounds);\n            }\n            var rendered = this.drawGeometry(feature.geometry, style, feature.id);\n            if(style.display != \"none\" && style.label && rendered !== false) {\n                var location = feature.geometry.getCentroid(); \n                if(style.labelXOffset || style.labelYOffset) {\n                    var xOffset = isNaN(style.labelXOffset) ? 0 : style.labelXOffset;\n                    var yOffset = isNaN(style.labelYOffset) ? 0 : style.labelYOffset;\n                    var res = this.getResolution();\n                    location.move(xOffset*res, yOffset*res);\n                }\n                this.drawText(feature.id, style, location);\n            } else {\n                this.removeText(feature.id);\n            }\n            return rendered;\n        }\n    }\n    </styleAndLabelFeatureOrHide>\n}\n"], ["cellMarkingAlgorithm", "\nfunction markCells(cells, adj, edges) {\n\n    <initializeDataStructures>\n    var flags = new Array(cells.length)\n    var constraint = new Array(3*cells.length)\n    for(var i=0; i<3*cells.length; ++i) {\n        constraint[i] = false\n    }\n    var active = []\n    var next   = []\n    for(var i=0; i<cells.length; ++i) {\n        var c = cells[i]\n        flags[i] = 0\n        for(var j=0; j<3; ++j) {\n            var a = c[(j+1)%3]\n            var b = c[(j+2)%3]\n            var constr = constraint[3*i+j] = isConstraint(edges, a, b)\n            if(adj[3*i+j] >= 0) {\n                continue\n            }\n            if(constr) {\n                next.push(i)\n            } else {\n                flags[i] = 1\n                active.push(i)\n            }\n        }\n    }\n    </initializeDataStructures>\n\n    <markingActiveAndNextCells>\n    var side = 1\n    while(active.length > 0 || next.length > 0) {\n        while(active.length > 0) {\n            var t = active.pop()\n            if(flags[t] === -side) {\n                continue\n            }\n            flags[t] = side\n            var c = cells[t]\n            for(var j=0; j<3; ++j) {\n                var f = adj[3*t+j]\n                if(f >= 0 && flags[f] === 0) {\n                    if(constraint[3*t+j]) {\n                        next.push(f)\n                    } else {\n                        active.push(f)\n                        flags[f] = side\n                    }\n                }\n            }\n        }\n        var tmp = next\n        next = active\n        active = tmp\n        next.length = 0\n        side = -side\n    }\n    </markingActiveAndNextCells>\n\n    return flags\n}\n"], ["cleanupInstanceRepresentation", "\nfunction cleanupInstanceName(name) {\n    let match = name.match(/^.+:(.+)::/);\n    if (!match) {\n        match = name.match(/^<(.+):/);\n    }\n    if (match) {\n        return match[1];\n    }\n    return name;\n}\n"], ["parseURLForChartData", "\nfunction parseURL2ChartData(url, callback) {\n    <handleAjaxRequest>\n    const success = code => {\n        const chartData = parseDSV2ChartData(code);\n        callback(chartData);\n    };\n    const fail = () => callback(null);\n    $.get(url).done(success).fail(fail);\n    </handleAjaxRequest>\n}\n"], "This function is compliant with SRP, tasked with handling an AJAX request to retrieve chart data from a URL."]