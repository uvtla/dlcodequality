[["calculateSetOperations", "\nfunction(gt, or) {\n  var or1 = or.values[0],\n      or2 = or.values[1];\n  var difference1 = set.difference(gt, or1);\n  var difference2 = set.difference(gt, or2);\n  return set.intersection(difference1, difference2);\n}\n"], ["initializeSession", "\nfunction Session(suite) {\n  Emitter.call(this);\n  this.files = [];\n  this.suite = suite;\n  this.global = global;\n  this.context = new Context(this);\n  this.engine = new Mocha({\n    ignoreLeaks: true,\n    useColors: true,\n    timeout: suite.options.timeout || 10000,\n    reporter: suite.options.reporter\n  });\n  this.engine.suite.emit('pre-require', this.global, null, this.engine);\n}\n"], ["configureApplicationPaths", "\nfunction configurePaths(cfg) {\n  <basePathConfigurations>\n  var sourcesBasePath = path.resolve(appPath, cfg.get('sourcesBasePath')),\n      sources = cfg.get('sources'),\n      build = cfg.get('build'),\n      buildDir = nodeEnv == 'development' ? build.baseDirNameDev : build.baseDirNameDist,\n      buildPath = path.join(path.resolve(appPath, cfg.get('buildBasePath')), buildDir);\n  </basePathConfigurations>\n\n  <uriConfigurations>\n  buildBaseUri = cfg.get('staticBaseUri') + '/' + buildDir + '/';\n  cfg.set('buildBaseUri', buildBaseUri);\n  cfg.set('cssUri', buildBaseUri + build.css.dirName + build.css.external[nodeEnv]);\n  cfg.set('jsUri', buildBaseUri + build.js.dirName + build.js.external[nodeEnv]);\n  cfg.set('testUri', buildBaseUri + build.js.dirName + 'test.js');\n  </uriConfigurations>\n\n  <pathSetters>\n  cfg.set('staticPath', path.resolve(appPath, cfg.get('staticPath')));\n  cfg.set('routesPath', path.resolve(appPath, cfg.get('routesPath')));\n  cfg.set('buildBasePath', path.resolve(appPath, cfg.get('buildBasePath')));\n  cfg.set('helpersPath', path.resolve(appPath, cfg.get('helpersPath')));\n  cfg.set('handlebarsHelpersPath', path.resolve(appPath, cfg.get('handlebarsHelpersPath')));\n  cfg.set('repoWebViewBaseUri', cfg.get('repository').replace('.git', '/') );\n  </pathSetters>\n\n  <sourcePathConfigurations>\n  keys = Object.keys(sources);\n  for (i = 0; i < keys.length; i++) {\n    key = keys[i];\n    cfg.set('sources.'+key, path.resolve(sourcesBasePath, sources[key]));\n  }\n  </sourcePathConfigurations>\n\n  <buildPathConfigurations>\n  if (build.css.inline[nodeEnv] && cfg.set('build.css.inline', path.resolve(buildPath, build.css.inline[nodeEnv])));\n  if (build.css.external[nodeEnv] && cfg.set('build.css.external', path.resolve(buildPath, build.css.external[nodeEnv])));\n  if (build.js.inline[nodeEnv] && cfg.set('build.js.inline', path.resolve(buildPath, build.js.inline[nodeEnv])));\n  if (build.js.external[nodeEnv] && cfg.set('build.js.external', path.resolve(buildPath, build.js.external[nodeEnv])));\n  cfg.set('build.spritesheets', path.resolve(buildPath, build.spriteSheets.dirName));\n  </buildPathConfigurations>\n\n  return cfg;\n}\n"], ["initializeVersion", "\nfunction V1(domain) {\n  Version.prototype.constructor.call(this, domain, 'v1');\n  this._commands = undefined;\n  this._ratePlans = undefined;\n  this._sims = undefined;\n}\n"], ["loadTimbits", "\nfunction loadTimbits(callback) {\n  var folder = path.join(config.home, \"/timbits\");\n  var files = filteredFiles(folder, /\\.(coffee|js)$/);\n  var pending = files.length;\n\n  files.forEach(function(file) {\n    var name = file.substring(0, file.lastIndexOf(\".\"));\n    timbits.add(name, require(path.join(folder, file)), function() {\n      pending--;\n      if (pending === 0) callback();\n    });\n  });\n}\n"], ["generateRandomBytes", "\nasync function(length) {\n  const buf = new Uint8Array(length);\n  <getRandomValuesBrowser>\n  if (typeof window !== 'undefined' && window.crypto && window.crypto.getRandomValues) {\n    window.crypto.getRandomValues(buf);\n  } else if (typeof window !== 'undefined' && typeof window.msCrypto === 'object' && typeof window.msCrypto.getRandomValues === 'function') {\n    window.msCrypto.getRandomValues(buf);\n  </getRandomValuesBrowser>\n  <getRandomValuesNode>\n  else if (nodeCrypto) {\n    const bytes = nodeCrypto.randomBytes(buf.length);\n    buf.set(bytes);\n  }\n  </getRandomValuesNode>\n  <getRandomValuesCustom>\n  else if (this.randomBuffer.buffer) {\n    await this.randomBuffer.get(buf);\n  }\n  </getRandomValuesCustom>\n  <errorNoGenerator>\n  else {\n    throw new Error('No secure random number generator available.');\n  }\n  </errorNoGenerator>\n  return buf;\n}\n"], ["convertStatusToText", "\nfunction statusToText(status) {\n  var words = [];\n\n  if (status.index=='A') {\n    words.push({\n      code: 'A',\n      color: '#00b111',\n      title: 'Added'\n    });\n  }\n\n  if (status.index=='M') {\n    words.push({\n      code: 'M',\n      color: '#9000b1',\n      title: 'Modified'\n    });\n  }\n\n  if (status.index=='R') {\n    words.push({\n      code: 'R',\n      color: '#0065b1',\n      title: 'Renamed'\n    });\n  }\n\n  if (status.index=='!') {\n    words.push({\n      code: 'I',\n      color: '#b16d00',\n      title: 'Ignored'\n    });\n  }\n\n  if (status.index=='C') {\n    words.push({\n      code: 'C',\n      color: '#b16d00',\n      title: 'Copied'\n    });\n  }\n\n  if (status.index==' ') {\n    words.push({\n      code: ' ',\n      color: '#b16d00',\n      title: 'Unmodified'\n    });\n  }\n\n  if (status.index=='D') {\n    words.push({\n      code: 'D',\n      color: '#de2d00',\n      title: 'Deleted'\n    });\n  }\n\n  return words;\n}\n"], ["showTooltip", "\nfunction showTooltipBind() {\n  if (hasEnableExp && !scope.$eval(attrs[prefix + 'Enable'])) {\n    return;\n  }\n\n  prepareTooltip();\n\n  if (ttScope.popupDelay) {\n    if (!popupTimeout) {\n      popupTimeout = $timeout(show, ttScope.popupDelay, false);\n      popupTimeout.then(function (reposition) { reposition(); });\n    }\n  } else {\n    show()();\n  }\n}\n"], ["splitWord", "\nfunction splitWord(word) {\n  Util.assert(word);\n\n  if (word.length < MAX_SAMPLE_SIZE) {\n    return [word];\n  }\n\n  let chunks = [];\n  for (let ii = 0; ii < word.length - MAX_SAMPLE_SIZE + 1; ++ii) {\n    chunks.push(word.substring(ii, ii + MAX_SAMPLE_SIZE));\n  }\n  return chunks;\n}\n"], ["loadAdapter", "\nfunction loadAdapter(type, location) {\n  <adapterInitialization>\n  var options = adapterConfig[type];\n  try {\n    var modulePath = adapterModulePath(type, options);\n\n    global.JuttleAdapterAPI = JuttleAdapterAPI;\n\n    var start = new Date();\n\n    if (!options.builtin) {\n      checkCompatible(type, modulePath, location);\n    }\n\n    var init = require(modulePath);\n\n    var loaded = new Date();\n    var adapter = init(options);\n\n    global.JuttleAdapterAPI = undefined;\n\n    if (adapter.name !== type) {\n      throw new Error('adapter name ', adapter.name, ' != type ', type);\n    }\n    var initialized = new Date();\n\n    logger.debug(adapter.name, 'adapter loaded in', (loaded - start), 'ms,', 'initialized in', (initialized - loaded), 'ms');\n\n    register(adapter.name, adapter);\n\n    return adapter;\n  }\n  </adapterInitialization>\n  <adapterErrorHandling>\n  catch (err) {\n    logger.error('error loading adapter ' + type + ': ' + err.message);\n    throw err;\n  }\n  </adapterErrorHandling>\n}\n"], "```"]