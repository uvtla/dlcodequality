[["setText", "\nfunction setText(value) {\n  value = \"\" + value;\n\n  <updateTextIfDifferent>\n  if (this._text !== value) {\n    <setTextFromArray>\n    if (Array.isArray(value)) {\n      this._text = value.join(\"\\n\");\n    } </setTextFromArray>\n    <setTextFromValue>\n    else {\n      this._text = value;\n    }\n    </setTextFromValue>\n\n    this.isDirty = true;\n  }\n  </updateTextIfDifferent>\n\n  return this;\n}\n"], ["compareSets", "\nfunction(compareSets)(set1, set2) {\n    <checkLengthEquality>\n    if(set1.length != set2.length) return false;\n    </checkLengthEquality>\n    var foundIndexMap = [];\n    <findMatchingValuesInSets>\n    for(var i=0; i < set1.length; i++) {\n      var val = set1[i];\n      for(var j=0; j < set2.length; j++) {\n        \n        <evaluateCandidates>\n        var candidate = set2[j];\n        if(this.eq(val, candidate) && (foundIndexMap.indexOf(j) < 0)) {\n          foundIndexMap.push(j);\n        }\n        </evaluateCandidates>\n      }\n    }\n    </findMatchingValuesInSets>\n    <returnComparisonResult>\n    return (foundIndexMap.length == set1.length);\n    </returnComparisonResult>\n  }\n"], ["mapObjectTree", "\nfunction mapObjectTree(obj, handler) {\n  var limit = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 10000;\n  \n  <initializeMapping>\n  var r;\n  var count = 0;\n  var stack = [{\n    value: obj\n  }];\n  </initializeMapping>\n\n  <processMapping>\n  var _loop2 = function _loop2() {\n    <checkLimit>\n    if (count >= limit) {\n      throw \"mapObjectTree: limit(\".concat(limit, \") reached, object may has circular reference\");\n    }\n    </checkLimit>\n\n    <incrementCounter>\n    count++;\n    </incrementCounter>\n\n    <destructureShiftedValue>\n    var _stack$shift = stack.shift(),\n        value = _stack$shift.value,\n        key = _stack$shift.key,\n        parent = _stack$shift.parent,\n        newParent = _stack$shift.newParent;\n    </destructureShiftedValue>\n\n    <runHandler>\n    var t = handler(value, key, parent);\n    </runHandler>\n\n    <defineAssignment>\n    var assign = function assign(value, key, canPush) {\n      <initializeAssignedValue>\n      if (isArray(value)) {\n        value = [];\n      } else if (isObject(value)) {\n        value = {};\n      }\n      </initializeAssignedValue>\n\n      <assignValueToParentOrRoot>\n      if (parent) {\n        if (isArray(newParent) && canPush) {\n          newParent.push(value);\n        } else {\n          newParent[key] = value;\n        }\n      } else {\n        r = value;\n      }\n      </assignValueToParentOrRoot>\n\n      return value;\n    };\n    </defineAssignment>\n\n    <processTransformedValue>\n    var newVal = void 0,\n        val = void 0,\n        toDelete = void 0,\n        stop = void 0,\n        skip = void 0;\n\n    if (!t) {\n      \n      val = value;\n      newVal = assign(value, key);\n    } else {\n      var key2 = t.key,\n          _value = t.value;\n      val = _value;\n\n      if (t.delete || key2 === false) {\n        toDelete = true;\n      } else if (key2 == null) {\n        newVal = assign(_value, key, true);\n      } else if (t.hasOwnProperty('value')) {\n        newVal = assign(_value, key2);\n      }\n\n      stop = t.stop;\n      skip = t.skip;\n    }\n    </processTransformedValue>\n\n    <handleDirectives>\n    if (toDelete) {\n      return \"continue\";\n    }\n\n    if (skip) {\n      return \"continue\";\n    }\n\n    if (stop) {\n      return \"break\";\n    }\n    </handleDirectives>\n\n    <pushChildrenOntoStack>\n    if (isArray(val)) {\n      var len = val.length;\n\n      for (var i = 0; i < len; i++) {\n        stack.push({\n          value: val[i],\n          key: i,\n          parent: val,\n          newParent: newVal\n        });\n      }\n    } else if (isObject(val)) {\n      Object.keys(val).forEach(function (key) {\n        stack.push({\n          value: val[key],\n          key: key,\n          parent: val,\n          newParent: newVal\n        });\n      });\n    }\n    </pushChildrenOntoStack>\n  };\n  </processMapping>\n\n  <executeLoop>\n  _loop: while (stack.length > 0) {\n    var _ret = _loop2();\n\n    switch (_ret) {\n      case \"continue\":\n        continue;\n\n      case \"break\":\n        break _loop;\n    }\n  }\n  </executeLoop>\n\n  <returnResult>\n  return r;\n  </returnResult>\n}\n"], ["padRight", "\nfunction padRight(x, padding) {\n  <initializeString>\n  if (x) {\n    x += '';\n  } else {\n    x = '';\n  }\n  </initializeString>\n  var buf = [];\n  <padWithZeros>\n  while (buf.length + x.length < padding) {\n    buf.push('0');\n  }\n  </padWithZeros>\n  <returnPaddedString>\n  return x + buf.join('');\n  </returnPaddedString>\n}\n"], ["getProperty", "\nfunction getProperty (service, resource, action, propertySpec) {\n  const parts = propertySpec.split('.')\n  \n  <determineTargetBasedOnPrefix>\n  var target\n  switch (parts[ 0 ]) {\n    case 'action':\n      target = action\n      break;\n    case 'resource':\n      target = resource\n      break;\n    default:\n      target = service\n  }\n  </determineTargetBasedOnPrefix>\n  \n  <fetchProperty>\n  const property = parts[ 1 ]\n  return { key: property, value: target ? target[ property ] : null }\n  </fetchProperty>\n}\n"], ["checkConditional", "\nfunction checkConditional(runner, conditional) {\n  try {\n    <evaluateConditional>\n    return conditional[1].call(runner, runner.target, runner.context);\n    </evaluateConditional>\n  } catch (e) {}\n}\n"], ["handleUnauthorizedAPIResponse", "\nfunction handleUnauthorizedAPIResponse(error) {\n    <parseErrorResponse>\n    const response = error && error.response;\n    const errorStatus = response && response.status;\n    const requestUrl = response && response.config && response.config.url;\n    const requestIsTokenRefresh = requestUrl === authenticatedAPIClient.refreshAccessTokenEndpoint;\n    </parseErrorResponse>\n\n    <logBasedOnErrorStatus>\n    switch (errorStatus) { \n      case 401:\n        if (requestIsTokenRefresh) {\n          logInfo(`Unauthorized token refresh response from ${requestUrl}. This is expected if the user is not yet logged in.`);\n        } else {\n          logInfo(`Unauthorized API response from ${requestUrl}`);\n        }\n        break;\n      case 403:\n        logInfo(`Forbidden API response from ${requestUrl}`);\n        break;\n    }\n    </logBasedOnErrorStatus>\n\n    <rejectPromiseWithError>\n    return Promise.reject(error);\n    </rejectPromiseWithError>\n  }\n"], ["generateCSS", "\nfunction(styles, elementName) {\n                    var name, value, css = '';\n\n                    <serializeStylesForElement>\n                    function serializeStyles(name) {\n                        var styleList, i, l, value;\n                        styleList = validStyles[name];\n                        if (styleList) {\n                            for (i = 0, l = styleList.length; i < l; i++) {\n                                name = styleList[i];\n                                value = styles[name];\n                                value && (css += (css.length > 0 ? ' ' : '') + name + ': ' + value + ';');\n                            }\n                        }\n                    }\n                    </serializeStylesForElement>\n\n                    <checkIfStyleIsValid>\n                    function isValid(name, elementName) {\n                        var styleMap;\n                        styleMap = invalidStyles['*'];\n                        if (styleMap && styleMap[name]) {\n                            return false;\n                        }\n                        styleMap = invalidStyles[elementName];\n                        if (styleMap && styleMap[name]) {\n                            return false;\n                        }\n                        return true;\n                    }\n                    </checkIfStyleIsValid>\n                    \n                    <applyValidStyles>\n                    if (elementName && validStyles) {\n                        \n                        serializeStyles('*');\n                        serializeStyles(elementName);\n                    } else {\n                        \n                        for (name in styles) {\n                            value = styles[name];\n                            !value || invalidStyles && !isValid(name, elementName) || (css += (css.length > 0 ? ' ' : '') + name + ': ' + value + ';');\n                        }\n                    }\n                    </applyValidStyles>\n                    <returnGeneratedCSS>\n                    return css;\n                    </returnGeneratedCSS>\n                }\n"], ["TrimArrayToBytes", "\nfunction TrimArrayToBytes(arr) {\n    var ix, newarr;\n    \n    <findInvalidIndices>\n    var len = arr.length;\n    for (ix=0; ix<len; ix++) {\n        if (arr[ix] < 0 || arr[ix] >= 0x100) \n            break;\n    }\n    </findInvalidIndices>\n    \n    <handleInvalidIndices>\n    if (ix == len) {\n        return arr;\n    }\n    newarr = Array(len);\n    for (ix=0; ix<len; ix++) {\n        if (arr[ix] < 0 || arr[ix] >= 0x100) \n            newarr[ix] = 63;  \n        else\n            newarr[ix] = arr[ix];\n    }\n    </handleInvalidIndices>\n    \n    <returnTrimmedArray>\n    return newarr;\n    </returnTrimmedArray>\n}\n"], ["setPipedTypesString", "\nfunction setPipedTypesString(node) {\n  <checkIfTypeExists>\n  if (!node.type) { return ''; }\n  </checkIfTypeExists>\n\n  <joinTypeNames>\n  node.typesString = node.type.names.join(' | ');\n  </joinTypeNames>\n}\n"], "```"]