[["validateHeader", "\nfunction validateHeader (key, value) {\n  if (typeof key !== 'string' || typeof value !== 'string')\n    return option.some(`Parts of header ${key}:${value} must be strings`)\n  return option.none\n}\n"], ["initOrUpdateTranslation", "\nfunction initOrUpdateTranslation(locale, translation, defaultLocale) {\n  <initializeVariables>\n  var defaultLocaleBundle, localeBundle, merged;\n  var aux = {};\n  \n  init();\n  </initializeVariables>\n\n  <loadCldrData>\n  loadCldr(defaultLocale);\n  loadCldr(locale);\n  </loadCldrData>\n\n  <prepareLocaleBundles>\n  defaultLocaleBundle = new Globalize(defaultLocale).cldr.attributes.bundle;\n  localeBundle = new Globalize(locale).cldr.attributes.bundle;\n  </prepareLocaleBundles>\n\n  <assertions>\n  assertLocale(locale);\n  assert(typeof translation === \"object\", \"missing or invalid `translation` argument, JSON expected (e.g., {\\\"en\\\": ...})\");\n  assert(typeof defaultLocale === \"string\", \"missing or invalid `defaultLocale` argument, String expected (e.g., \\\"en\\\")\");\n  </assertions>\n\n  <mergeTranslations>\n  aux[localeBundle] = generateDefaultTranslation(defaultLocale)[defaultLocaleBundle];\n  merged = merge({}, aux, translation);\n  if (orderedStringify(translation) !== orderedStringify(merged)) {\n    return merged;\n  }\n  </mergeTranslations>\n}\n"], ["getFieldTypeName", "\nfunction( str, dropIdUbar ){\n  <convertToUnderscore>\n  str = this.demodulize( str );\n  str = this.underscore( str ) + (( dropIdUbar ) ? ( '' ) : ( '_' )) + 'id';\n  </convertToUnderscore>\n\n  return str;\n}\n"], ["getFieldType", "\nfunction getFieldType(fld){\n  <determineFieldType>\n  var type = (fld.attr(\"type\") || \"\").toLowerCase();\n  if (\n    !type\n    && fld[0].tagName == \"SELECT\"\n  ) type = \"select\";\n  if (!type) type = \"json\";\n  fld.data(\"type\", type);\n  </determineFieldType>\n  \n  return type;\n}\n"], ["parseOperation", "\nfunction parse(op, target) {\n  <checkOperator>\n  if (OPERATORS.indexOf(op.op) !== -1) {\n    op = clone(op);\n    </checkOperator>\n    \n    <parsePointers>\n    if (op.from != null) {\n      op.from = parsePointer(op.from);\n    }\n    if (op.path != null) {\n      op.path = parsePointer(op.path);\n    } else {\n      throw new error.InvalidOperationError(op.op, 'Operation object must have a \"path\" member');\n    }\n    </parsePointers>\n    \n    <validatePathOperation>\n    validatePath(op.from || op.path, target);\n    return op;\n    </validatePathOperation>\n  }\n  throw new error.InvalidOperationError('Operation object \"op\" member must be one of ' + OPERATORS.join(', ') + ' ' + ('but got \"' + op.op + '\"'));\n}\n"], ["applyUpdateFunction", "\nfunction(obToApplyTo,pathitem,cloningFunction) {\n  <checkOperationExists>\n  if (!updateResult.hasOwnProperty('_op_'+pathitem.o)) {\n    throw new Error(\n      'SyncLib.updateResult No Operation: updateResult has no ' +\n      'operation '+\n      pathitem.o\n    );\n  }\n  </checkOperationExists>\n  \n  <invokeUpdateFunction>\n  var f = updateResult['_op_'+pathitem.o];\n  return f.call(this,obToApplyTo,pathitem,cloningFunction);\n  </invokeUpdateFunction>\n}\n"], ["checkContainerDiff", "\nfunction (containerGuid, relativePath) {\n  <initializeVariables>\n  var usedDiff, path, containerDiff, baseGuids, i, baseDiff, dataKnownInExtension;\n\n  containerDiff = getNodeByGuid(diffExtension, containerGuid);\n  </initializeVariables>\n\n  <determineContainerDiffLocation>\n  if (containerDiff === null) {\n    containerDiff = getNodeByGuid(diffBase, containerGuid);\n    usedDiff = diffBase;\n    path = getPathOfGuid(usedDiff, containerGuid);\n  } else {\n    dataKnownInExtension = true;\n    usedDiff = diffExtension;\n    path = getPathOfGuid(usedDiff, containerGuid);\n  }\n  </determineContainerDiffLocation>\n\n  <checkBaseGuids>\n  baseGuids = Object.keys(containerDiff.oBaseGuids || {})\n    .concat(Object.keys(containerDiff.ooBaseGuids || {}));\n\n  for (i = 0; i < baseGuids.length; i += 1) {\n    baseDiff = getPathOfDiff(getNodeByGuid(diffExtension, baseGuids[i]) || {}, relativePath);\n    if (baseDiff.removed === false || typeof baseDiff.movedFrom === 'string') {\n      \n      return true;\n    }\n  }\n  </checkBaseGuids>\n\n  <checkDataKnownInExtension>\n  if (dataKnownInExtension &&\n    containerDiff.pointer &&\n    typeof containerDiff.pointer.base === 'string') {\n    \n    return true;\n  }\n  </checkDataKnownInExtension>\n\n  <checkParentPath>\n  relativePath = CONSTANTS.PATH_SEP + getRelidFromPath(path) + relativePath;\n  if (getParentPath(path)) {\n    \n    return checkContainer(getParentGuid(diffExtension, path), relativePath);\n  }\n  </checkParentPath>\n\n  return false;\n}\n"], ["handleKeyEvents", "\nfunction onKey( event ) {\n  if (editor.mode != 'wysiwyg' )\n    return;\n\n  switch ( event.data.keyCode ) {\n    \n    case CKEDITOR.CTRL + 86: \n    case CKEDITOR.SHIFT + 45: \n      <prepareEditorForPaste>\n      var editable = editor.editable();\n      \n      \n      preventPasteEventNow();\n      \n      !CKEDITOR.env.ie && editable.fire( 'beforepaste' );\n      </prepareEditorForPaste>\n\n      return;\n\n    \n    case CKEDITOR.CTRL + 88: \n    case CKEDITOR.SHIFT + 46: \n      <triggerSnapshotForCutDelete>\n      \n      editor.fire( 'saveSnapshot' ); \n      setTimeout( function() {\n        editor.fire( 'saveSnapshot' ); \n      }, 50 ); \n      </triggerSnapshotForCutDelete>\n  }\n}\n"], ["watchProjectFiles", "\nfunction watch(conf, undertaker) {\n\n  const root = conf.themeConfig.root;\n\n  \n  undertaker.watch(\n    path.join(root, conf.themeConfig.sass.src, '**', '*.scss'),\n    undertaker.series(\n      require('../styles/lintStyles').bind(null, conf, undertaker),\n      require('../styles/buildStyles').bind(null, conf, undertaker),\n      require('../styles/holograph').bind(null, conf, undertaker)\n    )\n  );\n\n  \n  undertaker.watch(\n    path.join(root, conf.themeConfig.js.src, '**', '*.js'),\n    undertaker.series(\n      require('../scripts/lintScripts').bind(null, conf, undertaker),\n      require('../scripts/buildScripts').bind(null, conf, undertaker)\n    )\n  );\n\n  \n  undertaker.watch(\n    path.join(root, conf.themeConfig.images.src, '**', '*'),\n    undertaker.series(\n      require('../assets/buildImages').bind(null, conf, undertaker)\n    )\n  );\n\n  \n  undertaker.watch(\n    path.join(root, conf.themeConfig.fonts.src, '**', '*'),\n    undertaker.series(\n      require('../assets/buildFonts').bind(null, conf, undertaker)\n    )\n  );\n\n}\n"], ["freezeRemote", "\nfunction freezeRemote(filePaths, remote, callback) {\n    <initializeUrlObject>\n    var urlObj = url.parse(remote, false, true);\n    var basePath = urlObj.pathname + (urlObj.search || \"\");\n    </initializeUrlObject>\n    \n    <sendHeadRequests>\n    var await = 0;\n    for (var itemPath in filePaths) {\n        var item = filePaths[itemPath];\n        if (item.freezed) {\n            continue;\n        }\n        await++;\n        var req = http.request({\n                method: \"HEAD\",\n                host: urlObj.hostname,\n                port: urlObj.port || 80,\n                path: basePath + item.hashedName\n            }, function(res) {\n                if (res.statusCode === 200) {\n                    this.freezed = remote + this.hashedName;\n                }\n                await--;\n                if (!await) {\n                    await--; \n                    callback();\n                }\n            }.bind(item)\n        );\n        req.end();\n    }\n    </sendHeadRequests>\n    \n    <checkAllRequests>\n    if (await === 0) {\n        callback();\n    }\n    </checkAllRequests>\n}\n"], "```"]