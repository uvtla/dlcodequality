[["firstPass", "\nfunction firstPass(loadedComponents, messages) {\n  <logActivity>\n  messages.heading('Reference resolution - first pass')\n  </logActivity>\n\n  <setupComponents>\n  const components = loadedComponents.blueprintComponents\n  const tymlyRefs = loadedComponents.blueprintRefs\n  </setupComponents>\n\n  <findResolutions>\n  const resolutions = findFirstPassResolutions(tymlyRefs, components)\n  </findResolutions>\n\n  <handleNoResolutions>\n  if (!resolutions) {\n    messages.subHeading('Nothing to resolve')\n    return\n  }\n  </handleNoResolutions>\n\n  <resolveResolvedComponents>\n  resolveResolutions(resolutions, components, messages)\n  </resolveResolvedComponents>\n}\n"], ["xmlparser", "\nfunction xmlparser(options) {\n\n  <configureParserOptions>\n  var parserOptions = util._extend({\n      async: false,\n      explicitArray: true,\n      normalize: true,\n      normalizeTags: true,\n      trim: true\n    }, options || {});\n  </configureParserOptions>\n\n  <returnXmlBodyParser>\n  return xmlbodyparser;\n  </returnXmlBodyParser>\n\n  \n  function xmlbodyparser(req, res, next) {\n\n    <initializeDataAndParser>\n    var data = '';\n    var parser = new xml2js.Parser(parserOptions);\n    </initializeDataAndParser>\n\n    <responseHandler>\n    var responseHandler = function (err, xml) {\n        if (err) {\n          err.status = 400;\n          return next(err);\n        }\n\n        req.body = xml || req.body;\n        req.rawBody = data;\n        next();\n    };\n    </responseHandler>\n\n    <preParseChecks>\n    if (req._body) {\n      return next();\n    }\n\n    req.body = req.body || {};\n\n    if (!hasBody(req) || !module.exports.regexp.test(mime(req))) {\n      return next();\n    }\n\n    req._body = true;\n    </preParseChecks>\n    \n    <setDataEncoding>\n    req.setEncoding('utf-8');\n    </setDataEncoding>\n    <collectDataChunks>\n    req.on('data', function (chunk) {\n      data += chunk;\n    });\n    </collectDataChunks>\n\n    <handleParserEnd>\n    parser.saxParser.onend = function() {\n      if (req.complete && req.rawBody === undefined) {\n        return responseHandler(null);\n      }\n    };\n    </handleParserEnd>\n\n    <processDataOnEnd>\n    req.on('end', function () {\n\n      \n      if (data.trim().length === 0) {\n        return next(error(411));\n      }\n\n      parser.parseString(data, responseHandler);\n\n    });\n    </processDataOnEnd>\n  }\n\n}\n"], ["unlabeledFunction", "\nfunction(techName, techPath, bundleNode, magicNode, cmd, decls, force) {\n\n        <prepareNode>\n        var arch = this.ctx.arch,\n            node = this.useFileOrBuild(new BemDeclNode.BemDeclNode({\n                root: this.root,\n                level: this.level,\n                item: this.item,\n                techPath: techPath,\n                techName: techName,\n                cmd: cmd,\n                decls: decls,\n                force: force\n            }));\n        </prepareNode>\n\n        <checkAndSetNode>\n        if (!node) return;\n\n        \n        arch.setNode(node)\n            .addChildren(node, node.getDependencies());\n        </checkAndSetNode>\n\n        <manageParentsAndChildren>\n        bundleNode && arch.addParents(node, bundleNode);\n        magicNode && arch.addChildren(node, magicNode);\n        </manageParentsAndChildren>\n\n        <returnNode>\n        return node;\n        </returnNode>\n    }\n"], ["deterministicGenerateK", "\nfunction deterministicGenerateK(curve, hash, d, checkSig, nonce) {\n    <inputValidation>\n    enforceType(\"Buffer\", hash);\n    enforceType(BigInteger, d);\n    </inputValidation>\n\n    <modifyHash>\n    if (nonce) {\n        hash = sha256(Buffer.concat([hash, Buffer.alloc(nonce)]));\n    }\n    </modifyHash>\n\n    <assertHashLength>\n    assert.equal(hash.length, 32, \"Hash must be 256 bit\");\n    </assertHashLength>\n\n    <initializeVariables>\n    var x = d.toBuffer(32);\n    var k = Buffer.alloc(32);\n    var v = Buffer.alloc(32);\n    </initializeVariables>\n\n    <prepareKAndV>\n    \n    v.fill(1);\n\n    \n    k.fill(0);\n\n    \n    k = HmacSHA256(Buffer.concat([v, new Buffer([0]), x, hash]), k);\n\n    \n    v = HmacSHA256(v, k);\n\n    \n    k = HmacSHA256(Buffer.concat([v, new Buffer([1]), x, hash]), k);\n\n    \n    v = HmacSHA256(v, k);\n\n    \n    v = HmacSHA256(v, k);\n    </prepareKAndV>\n\n    <calculateT>\n    var T = BigInteger.fromBuffer(v);\n    </calculateT>\n\n    <findValidK>\n    while (T.signum() <= 0 || T.compareTo(curve.n) >= 0 || !checkSig(T)) {\n        k = HmacSHA256(Buffer.concat([v, new Buffer([0])]), k);\n        v = HmacSHA256(v, k);\n\n        \n        v = HmacSHA256(v, k);\n\n        T = BigInteger.fromBuffer(v);\n    }\n    </findValidK>\n\n    <returnK>\n    return T;\n    </returnK>\n}\n"], ["constructAxis", "\nfunction(properties, data) {\n            <initializeAxisConfig>\n            var axisType = data.xAxisType,\n                axisProperties = this.parseUtils.getXAxisProperties(properties),\n                orientation = (this.axesAreInverted) ? 'vertical' : 'horizontal',\n                colorScheme = this.getAxisColorScheme();\n            </initializeAxisConfig>\n            \n            <adaptAxisProperties>\n            axisProperties.chartType = properties.chart;\n            axisProperties.axisLength = $(this.renderTo).width();\n            if(axisProperties['axisTitle.text']){\n                axisProperties['axisTitle.text'] = Splunk.JSCharting.ParsingUtils.escapeHtml(axisProperties['axisTitle.text']);\n            }\n            </adaptAxisProperties>\n\n            <createDeterminedAxisType>\n            switch(axisType) {\n                case 'category':\n                    this.xAxis = new Splunk.JSCharting.CategoryAxis(axisProperties, data, orientation, colorScheme);\n                    break;\n                case 'time':\n                    this.xAxis = new Splunk.JSCharting.TimeAxis(axisProperties, data, orientation, colorScheme, this.exportMode);\n                    break;\n                default:\n                    \n                    this.xAxis = new Splunk.JSCharting.NumericAxis(axisProperties, data, orientation, colorScheme);\n                    break;\n\n            }\n            </createDeterminedAxisType>\n            <setHcConfigForAxis>\n            this.hcConfig.xAxis = this.xAxis.getConfig();\n            </setHcConfigForAxis>\n            <configureExportModeOptions>\n            if(this.exportMode && (axisType === 'time')) {\n                var xAxisMargin,\n                    spanSeries = data._spanSeries,\n                    span = (spanSeries && spanSeries.length > 0) ? parseInt(spanSeries[0], 10) : 1,\n                    secsPerDay = 60 * 60 * 24,\n                    secsPerYear = secsPerDay * 365;\n\n                if(span >= secsPerYear) {\n                    xAxisMargin = 15;\n                }\n                else if(span >= secsPerDay) {\n                    xAxisMargin = 25;\n                }\n                else {\n                    xAxisMargin = 35;\n                }\n                this.hcConfig.xAxis.title.margin = xAxisMargin;\n            }\n            </configureExportModeOptions>\n            <setDefaultAxisTitle>\n            if(typeof this.hcConfig.xAxis.title.text === 'undefined') {\n                this.hcConfig.xAxis.title.text = this.processedData.xAxisKey;\n            }\n            </setDefaultAxisTitle>\n        }\n"], ["getDomain", "\nfunction getDomain(url) {\n    <extractDomain>\n\tvar domain = _.isObject(url) ? url.host : urlib.parse(url).host;\n\treturn domain || url;\n\t</extractDomain>\n}\n"], ["clientConnects", "\nfunction clientConnects(p) {\n        <setupClientPage>\n        var pList;\n        var nPlayers;\n        var waitTime;\n        var widgetConfig;\n\n        node.remoteSetup('page', p.id, {\n            clearBody: true,\n            title: { title: 'Welcome!', addToBody: true }\n        });\n        </setupClientPage>\n\n        <initializeWidgets>\n        node.remoteSetup('widgets', p.id, {\n            destroyAll: true,\n            append: { 'WaitingRoom': {} }\n        });\n        </initializeWidgets>\n\n        <roomOpenCheck>\n        if (waitRoom.isRoomOpen()) {\n            console.log('Client connected to waiting room: ', p.id);\n\n            \n            channel.registry.markInvalid(p.id);\n            </roomOpenCheck>\n\n            <retrievePlayersData>\n            pList = waitRoom.clients.player;\n            nPlayers = pList.size();\n            </retrievePlayersData>\n\n            <calculateWaitTime>\n            if (waitRoom.START_DATE) {\n                waitTime = new Date(waitRoom.START_DATE).getTime() -\n                    (new Date().getTime());\n            }\n            else if (waitRoom.MAX_WAIT_TIME) {\n                waitTime = waitRoom.MAX_WAIT_TIME;\n            }\n            else {\n                waitTime = null; \n            }\n            </calculateWaitTime>\n\n            <configureWaitingRoomWidget>\n            widgetConfig = waitRoom.makeWidgetConfig();\n            widgetConfig.waitTime = waitTime;\n            node.remoteSetup('waitroom', p.id, widgetConfig);\n            </configureWaitingRoomWidget>\n\n            <logConnectedPlayers>\n            console.log('NPL ', nPlayers);\n            </logConnectedPlayers>\n\n            <notifyRoom>\n            node.say('PLAYERSCONNECTED', 'ROOM', nPlayers);\n            </notifyRoom>\n\n            <scheduleRoomTimeout>\n            waitRoom.makeTimeOut(p.id, waitTime);\n            </scheduleRoomTimeout>\n\n            <dispatchOnFullRoom>\n            if (nPlayers < waitRoom.POOL_SIZE) return;\n\n            if (waitRoom.EXECUTION_MODE === 'WAIT_FOR_N_PLAYERS') {\n                waitRoom.dispatch({\n                    action: 'AllPlayersConnected',\n                    exit: 0\n                });\n            }\n            </dispatchOnFullRoom>\n        }\n        else {\n            <notifyRoomClosed>\n            node.say('ROOM_CLOSED', p.id);\n            </notifyRoomClosed>\n        }\n    }\n"], ["createPingback", "\nfunction(req, res, body) {\n  <pingbackInstanceCheck>\n  if (!(this instanceof Pingback)) {\n    return new Pingback(req, res, body);\n  }\n  </pingbackInstanceCheck>\n  <initializePingback>\n  EventEmitter.call(this);\n\n  this.readable = true;\n  this.writable = true;\n\n  this.req = req;\n  this.res = res;\n  this.body = body = body || req.rawBody || req.body;\n  this.source = this.target = {};\n  </initializePingback>\n\n  <handleRequestBody>\n  if (body == null) {\n    if (!this.req.readable) {\n      return this.emit('error', new Error('No body.'));\n    }\n  }\n  else {\n    <processRequestBody>\n    var self = this;\n    process.nextTick(function() {\n      self._handle();\n    });\n    </processRequestBody>\n  }\n  </handleRequestBody>\n}\n"], ["invokeFileUpload", "\nfunction($placeholder) {\n\t\t\t<initializeFileSelection>\n\t\t\tvar that = this,\n\t\t\t\t\t$selectFile, files;\n\n\t\t\t$selectFile = $('<input type=\"file\" multiple=\"multiple\">').click();\n\t\t\t$selectFile.change(function () {\n\t\t\t\tfiles = this.files;\n\t\t\t\tthat.uploadFiles($placeholder, files, that);\n\t\t\t});\n\t\t\t</initializeFileSelection>\n\n\t\t\t<deselectMediumInsert>\n\t\t\t$.fn.mediumInsert.insert.deselect();\n\t\t\t</deselectMediumInsert>\n\n\t\t\t<returnFileInputElement>\n\t\t\treturn $selectFile;\n\t\t\t</returnFileInputElement>\n\t\t}\n"], ["codeGenerator", "\nasync function codeGenerator(length = 6) {\n    <generateCode>\n    const code = new Array(length)\n      .fill('0')\n      .map(() => CHARS_SET[Math.floor(random() * (charsSetLength - 1))])\n      .join('');\n    </generateCode>\n    <logGeneratedCode>\n    log('debug', `Generated a new code:`, code);\n    </logGeneratedCode>\n    <returnGeneratedCode>\n    return code;\n    </returnGeneratedCode>\n  }\n"], "```"]