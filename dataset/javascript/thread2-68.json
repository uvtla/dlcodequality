[["setOptions", "\nfunction(user_opts) {\n  <mergeDefaultOptions>\n  this.options = _.defaults(user_opts, this.options)\n  </mergeDefaultOptions>\n  \n  <configureInputStream>\n  process.stdin.setRawMode(true)\n  process.stdin.resume()\n  </configureInputStream>\n}\n"], ["getAddResultActionToCell", "\nfunction getAddResultActionToCell(cell) {\n    <determineActionBasedOnCell>\n    switch (where) {\n        case TableResultAction.where.Column:\n        if (cell.isColSpan) {\n            return TableResultAction.resultAction.SumSpanCount;\n        } else if(cell.isRowSpan && cell.isVirtual) {\n            return TableResultAction.resultAction.Ignore;\n        }\n        break;\n        case TableResultAction.where.Row:\n        if (cell.isRowSpan) {\n            return TableResultAction.resultAction.SumSpanCount;\n        } else if (cell.isColSpan && cell.isVirtual) {\n            return TableResultAction.resultAction.Ignore;\n        }\n        break;\n    }\n    return TableResultAction.resultAction.AddCell;\n    </determineActionBasedOnCell>\n}\n"], ["isObservable", "\nfunction (obj) {\n    <checkObservable>\n    return obj && (can.isArray(obj) || can.isPlainObject(obj) || (obj instanceof can.Observe));\n    </checkObservable>\n}\n"], ["resetCalendars", "\nfunction() {\n    <resetEachCalendar>\n    for (var p=0;p<this.pages.length;++p) {\n        var cal = this.pages[p];\n        cal.reset();\n    }\n    </resetEachCalendar>\n}\n"], ["createStrictQueryParamsMiddleware", "\nfunction strictQueryParams(options) {\n    <setupOptionsAndValidations>\n    var opts = options || {};\n    assert.optionalObject(opts, 'options');\n    assert.optionalString(opts.message, 'options.message');\n    </setupOptionsAndValidations>\n\n    <validateQueryParams>\n    function _strictQueryParams(req, res, next) {\n\n        var keyValQParams = !/(\\&(?!(\\w+=\\w+)))/.test(req.url);\n\n        if (!keyValQParams) {\n            var msg = opts.message ? opts.message :\n                'Url query params does not meet strict format';\n            return next(new BadRequestError(msg));\n        }\n\n        return next();\n    }\n    </validateQueryParams>\n\n    return (_strictQueryParams);\n}\n"], ["writePageDefinitions", "\nfunction(pagedef, pagedir){\n    <prepareAndWriteFiles>\n    var filenameBase = pagedir + pagedef.uniqueId;\n    var xmlDef = {ext: '.xml', contents: pd.xml(pagedef.body)};\n    var metaDef = {\n        ext: '.json',\n        contents: JSON.stringify(_.omit(pagedef, 'body'), null, 3)\n    };\n    _.each([xmlDef, metaDef], function(item){\n        var filename = filenameBase + item.ext;\n        grunt.file.write(filenameBase + item.ext, item.contents);\n        if(grunt.option('verbose')){\n            grunt.log.ok(filename + ' written to ' + pagedir);\n        }\n    });\n    </prepareAndWriteFiles>\n}\n"], ["getChart", "\nfunction getChart(chartName, date, cb) {\n    <handleOptionalParams>\n    if (typeof chartName === 'function') {\n        cb = chartName;\n        chartName = 'hot-100';\n        date = '';\n    }\n    \n    if (typeof date === 'function') {\n        cb = date;\n        date = '';\n    }\n    </handleOptionalParams>\n    <initializeChartData>\n    var chart = {};\n    chart.songs = [];\n    </initializeChartData>\n    <performWebRequest>\n    var requestURL = BILLBOARD_CHARTS_URL + chartName + '/' + date;\n    request(requestURL, function completedRequest(error, response, html) {\n        if (error) {\n            cb(error, null);\n            return;\n        }\n        <parseHTMLAndExtractData>\n        var $ = cheerio.load(html);\n        chart.week = yyyymmddDateFromMonthDayYearDate($('.chart-detail-header__date-selector-button')[0].children[0].data.replace(/\\n/g, ''));\n        chart.previousWeek = getNeighboringChart($('.dropdown__date-selector-option '), NeighboringWeek.Previous);\n        chart.nextWeek = getNeighboringChart($('.dropdown__date-selector-option '), NeighboringWeek.Next);\n        $('.chart-list-item').each(function(index, item) {\n            var rank = index + 1;\n            chart.songs.push({\n                \"rank\": rank,\n                \"title\": getTitleFromChartItem(item),\n                \"artist\": getArtistFromChartItem(item),\n                \"cover\": getCoverFromChartItem(item, rank),\n                \"position\" : {\n                    \"positionLastWeek\": getPositionLastWeekFromChartItem(item),\n                    \"peakPosition\": getPeakPositionFromChartItem(item),\n                    \"weeksOnChart\": getWeeksOnChartFromChartItem(item)\n                }\n            });\n        });\n        </parseHTMLAndExtractData>\n        <validateAndReturnResult>\n        if (chart.songs.length > 1){\n            cb(null, chart);\n            return;\n        } else {\n            cb(\"Songs not found.\", null);\n            return;\n        }\n        </validateAndReturnResult>\n    });\n    </performWebRequest>\n}\n"], ["TableNameConstructor", "\nfunction TableName(table, schema) {\n    <enforceConstructorUsage>\n    if (!(this instanceof TableName)) {\n        return new TableName(table, schema);\n    }\n    </enforceConstructorUsage>\n    <validateParameters>\n    if (typeof table !== 'string') {\n        table = npm.assertOptions(table, ['table', 'schema']);\n        schema = table.schema;\n        table = table.table;\n    }\n    if (!npm.utils.isText(table)) {\n        throw new TypeError('Table name must be a non-empty text string.');\n    }\n    if (!npm.utils.isNull(schema)) {\n        if (typeof schema !== 'string') {\n            throw new TypeError('Invalid schema name.');\n        }\n        if (schema.length > 0) {\n            this.schema = schema;\n        }\n    }\n    </validateParameters>\n    <setTableNameAndFormat>\n    this.table = table;\n    this.name = npm.formatting.as.name(table);\n    if (this.schema) {\n        this.name = npm.formatting.as.name(schema) + '.' + this.name;\n    }\n    this[npm.formatting.as.ctf.rawType] = true;\n    </setTableNameAndFormat>\n    <finalizeInstance>\n    Object.freeze(this);\n    </finalizeInstance>\n}\n"], ["parseSequence", "\nfunction parseSequence (val) {\n    <initializeStack>\n    var stack = [];\n    </initializeStack>\n    <handleResultHelper>\n    function handleResult (result) {\n        <calculateMaxValue>\n        var max = stack.length > 0 ? Math.max.apply(Math, stack) : -1;\n        </calculateMaxValue>\n        <processResultArray>\n        if (result instanceof Array) {\n            for (var i = 0, c = result.length; i < c; i++) {\n                var value = result[i];\n                <checkValueConstraints>\n                if (value < constraints[0] || value > constraints[1]) {\n                    throw new Error(\n                        'Constraint error, got value ' + value + ' expected range ' +\n                        constraints[0] + '-' + constraints[1]\n                    );\n                }\n                </checkValueConstraints>\n                <addToStackIfGreaterThanMax>\n                if (value > max) {\n                    stack.push(value);\n                }\n                </addToStackIfGreaterThanMax>\n                <updateMaxValue>\n                max = Math.max.apply(Math, stack);\n                </updateMaxValue>\n            }\n        } else {\n            <convertAndValidateSingleResult>\n            result = +result;\n            if (result < constraints[0] || result > constraints[1]) {\n                throw new Error(\n                    'Constraint error, got value ' + result + ' expected range ' +\n                    constraints[0] + '-' + constraints[1]\n                );\n            }\n            if (field == 'dayOfWeek') {\n                result = result % 7;\n            }\n            stack.push(result);\n            </convertAndValidateSingleResult>\n        }\n    }\n    </handleResultHelper>\n    <parseCommaSeparatedValues>\n    var atoms = val.split(',');\n    if (atoms.length > 1) {\n        for (var i = 0, c = atoms.length; i < c; i++) {\n            handleResult(parseRepeat(atoms[i]));\n        }\n    } else {\n        handleResult(parseRepeat(val));\n    }\n    </parseCommaSeparatedValues>\n    <sortStack>\n    stack.sort(function(a, b) {\n        return a - b;\n    });\n    </sortStack>\n    <returnStack>\n    return stack;\n    </returnStack>\n}\n"], ["detectValueType", "\nfunction type (value) {\n    <getTypeName>\n    const proto = toString.call(value)\n    return proto.substring(8, proto.length - 1)\n    </getTypeName>\n}\n"], "```\n\nIn the given functions, SRP compliance varies. Functions have been wrapped with tags indicating their dedicated responsibilities. Some functions might perform multiple operations but they are still considered a single responsibility because they work towards a single purpose. If a function involves distinct, separate operations serving different purposes, those sections are individually annotated to show SRP violations within the function."]