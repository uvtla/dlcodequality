[["createGroupHeaderListItem", "\nfunction (oGroup) {\n  var sTitle = \"{i18n>systemData}\";\n\n  if (oGroup.key === \"custom\") {\n    sTitle = \"{i18n>externalReferences}\";\n  }\n\n  return new GroupHeaderListItem({\n    title: sTitle,\n    upperCase: false\n  });\n}\n"], ["renderTree", "\nfunction render(files, baseDir, renderLabelFn, options = {}) {\n  <normalizeBaseDir>\n  baseDir = baseDir.replace(/\\/$/, '/');\n  </normalizeBaseDir>\n\n  <stripBaseDirFromFiles>\n  const strippedFiles = files.map(file => {\n    \n    if (file.lastIndexOf(baseDir, 0) === 0) {\n      return file.substr(baseDir.length)\n    }\n    \n    throw new Error('Basedir ' + baseDir + ' must be a prefix of ' + file)\n  });\n  </stripBaseDirFromFiles>\n\n  <createAndCondenseTree>\n  const rootNode = treeFromPaths(strippedFiles, baseDir, renderLabelFn, options)\n  const condensed = condense(rootNode)\n  </createAndCondenseTree>\n\n  return archy(condensed);\n}\n"], ["handleEventLog", "\nasync function handleLog(log, rule, contractVersion, context) {\n  <decodeLog>\n  log.decoded = web3.eth.abi.decodeLog(\n    rule.eventAbi.inputs,\n    log.data,\n    log.topics.slice(1)\n  );\n  </decodeLog>\n\n  <assignLogMetadata>\n  log.contractName = contractVersion.contractName;\n  log.eventName = rule.eventName;\n  log.contractVersionKey = contractVersion.versionKey;\n  log.networkId = context.networkId;\n  </assignLogMetadata>\n\n  <logToConsole>\n  console.log(\n    `Processing log \\\n    blockNumber=${log.blockNumber} \\\n    transactionIndex=${log.transactionIndex} \\\n    eventName=${log.eventName} \\\n    contractName=${log.contractName}`\n  );\n  </logToConsole>\n\n  <processRuleFunction>\n  let ruleResults = undefined;\n  await withRetrys(async () => {\n    ruleResults = await rule.ruleFn(log);\n  });\n  </processRuleFunction>\n\n  <prepareOutput>\n  const output = {\n    log: log,\n    related: ruleResults\n  };\n  </prepareOutput>\n\n  <serializeAndLogOutput>\n  const json = JSON.stringify(output, null, 2);\n  if (context.config.verbose) {\n    console.log(json);\n    console.log('\\n----\\n');\n  }\n  </serializeAndLogOutput>\n\n  <processRelatedEntities>\n  const userAddress = log.decoded.party;\n  const ipfsHash = log.decoded.ipfsHash;\n  \n  const listing = output.related.listing;\n  delete listing.ipfs.data.pictures;\n  const listingId = listing.id;\n\n  const ipfsListingId = listingId.split('-')[2];\n  if (ipfsListingId !== log.decoded.listingID) {\n    throw `ListingId mismatch: ${ipfsListingId} !== ${log.decoded.listingID}`;\n  }\n  </processRelatedEntities>\n\n  <checkAndReturn>\n  if(output.related.listing.ipfs.data.price === undefined){\n    return;\n  }\n  </checkAndReturn>\n\n  <indexDataIfConfigured>\n  if (context.config.elasticsearch) {\n    console.log('INDEXING ', listingId);\n    await withRetrys(async () => {\n      await search.Listing.index(\n        listingId,\n        userAddress,\n        ipfsHash,\n        listing\n      );\n    });\n    if (output.related.offer !== undefined) {\n      const offer = output.related.offer;\n      await withRetrys(async () => {\n        await search.Offer.index(offer, listing);\n      });\n    }\n    if (output.related.seller !== undefined) {\n      await withRetrys(async () => {\n        await search.User.index(output.related.seller);\n      });\n    }\n    if (output.related.buyer !== undefined) {\n      await withRetrys(async () => {\n        await search.User.index(output.related.buyer);\n      });\n    }\n  }\n  </indexDataIfConfigured>\n\n  <insertIntoDbIfConfigured>\n  if (context.config.db) {\n    await withRetrys(async () => {\n      await db.Listing.insert(\n        listingId,\n        userAddress,\n        ipfsHash,\n        listing.ipfs.data\n      );\n    });\n  }\n  </insertIntoDbIfConfigured>\n\n  <triggerWebhookIfConfigured>\n  if (context.config.webhook) {\n    console.log('\\n-- WEBHOOK to ' + context.config.webhook + ' --\\n');\n    await withRetrys(async () => {\n      await postToWebhook(context.config.webhook, json);\n    });\n  }\n  </triggerWebhookIfConfigured>\n}\n"], ["filterByYear", "\nfunction filterYear(arr, { disabledDateObj, minDate, maxDate }) {\n  <getDateTimeRange>\n  const minDateTime = new Date(minDate).getTime();\n  const maxDateTime = new Date(maxDate).getTime();\n  </getDateTimeRange>\n\n  <getYearRange>\n  const yearRangeArr = getDateRangeArr(disabledDateObj, minDateTime, maxDateTime);\n  </getYearRange>\n\n  <processYears>\n  const yearArr = [];\n  yearRangeArr.forEach((item) => {\n    let { start, end } = item;\n    start = new Date(start);\n    end = new Date(end);\n    const yearStart = start.getFullYear();\n    const monthStart = start.getMonth();\n    const dayStart = start.getDate();\n    const yearEnd = end.getFullYear();\n    const monthEnd = end.getMonth();\n    const dayEnd = new Date(end.getTime() + 86400000).getDate();\n    // Calculations to get the range of years\n    // ...\n  });\n  </processYears>\n\n  <filterArray>\n  return arr.filter((item) => {\n    const year = item.value;\n    return yearArr.indexOf(year) === -1;\n  });\n  </filterArray>\n}\n"], ["validateNestingStructure", "\nfunction validateNesting(node) {\n  <initializeQueue>\n  let queue = [...node.parent.children];\n  </initializeQueue>\n\n  let child;\n  let opener;\n\n  <traverseNodeTree>\n  while (queue.length) {\n    child = queue.shift();\n    opener = child.openingElement;\n\n    <checkIfInputElement>\n    if (child.type === 'JSXElement' && opener && (opener.name.name === 'input' || opener.name.name === 'textarea')) {\n      return true;\n    }\n    </checkIfInputElement>\n\n    <addToQueueIfChildrenExist>\n    if (child.children) {\n      queue = queue.concat(child.children);\n    }\n    </addToQueueIfChildrenExist>\n  }\n  </traverseNodeTree>\n\n  return false;\n}\n"], ["importAsset", "\nfunction(asset, options) {\n  <traverseToRootApp>\n  var app = this.app;\n  while (app.app) {\n    app = app.app;\n  }\n  </traverseToRootApp>\n\n  <performImport>\n  app.import(asset, options);\n  </performImport>\n}\n"], ["initStructorController", "\nfunction initStructorController () {\n  <setupEndpoint>\n  server.app.post('/structor-invoke', bodyParser.json({limit: '50mb'}), (req, res) => {\n    callControllerMethod(structorController, req, res);\n  });\n  </setupEndpoint>\n\n  <initializeStructorController>\n  structorController.setServer(server);\n  </initializeStructorController>\n}\n"], ["replaceCharacterInSubject", "\nfunction replaceCharacter(search, replace, subject, count) {\n  <initializeVariables>\n  var i = 0, j = 0, temp = '', repl = '', sl = 0,\n    fl = 0, f = [].concat(search), r = [].concat(replace),\n    s = subject, ra = Object.prototype.toString.call(r) === '[object Array]',\n    sa = Object.prototype.toString.call(s) === '[object Array]', s = [].concat(s);\n  </initializeVariables>\n\n  <handleSearchReplaceTypes>\n  if(typeof(search) === 'object' && typeof(replace) === 'string' ) {\n    // Logic to handle specific case\n    // ...\n  }\n  </handleSearchReplaceTypes>\n\n  <optionalCountInitialization>\n  if (count) {\n    this.window[count] = 0;\n  }\n  </optionalCountInitialization>\n\n  <replaceSubstring>\n  for (i = 0, sl = s.length; i < sl; i++) {\n    // Further logic to perform replacement\n    // ...\n  }\n  </replaceSubstring>\n\n  return sa ? s : s[0];\n}\n"], ["computeParentMatrix", "\nfunction parentsMatrix(e, focusingCamera) {\n  <checkAndComputeParentMatrix>\n  if (e.parent && e.parent.getMatrix) {\n    var m1 = e.parent.getMatrix();\n    var m2 = parentsMatrix(e.parent, focusingCamera);\n    if (m2) {\n      return m1.multiplyNew(m2);\n    }\n    return m1;\n  }\n  </checkAndComputeParentMatrix>\n\n  <handleFocusingCamera>\n  else {\n    if (focusingCamera) {\n      return focusingCamera.getMatrix();\n    }\n  }\n  </handleFocusingCamera>\n\n  return undefined;\n}\n"], ["generateTreeFromPaths", "\nfunction treeFromPaths(files, baseDir, renderLabelFn, options = {}) {\n  <createRootNode>\n  return {\n    label: options.label || '',\n    nodes: childNodesFromPaths(files, baseDir, renderLabelFn, files, baseDir)\n  };\n  </createRootNode>\n}\n"], "```"]