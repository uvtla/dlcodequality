[["convertShape", "\nfunction convertShape (shape, tag) {\n  return templates.element({\n    'tag': tag,\n    'width': shape.width,\n    'height': shape.height,\n    'fill': shape.properties.fill\n  });\n}\n"], ["Sonar", "\nfunction Sonar(runner, options, log) {\n  Base.call(this, runner);\n  var stats = this.stats\n    , tests = []\n    , logFd\n    , self = this;\n\n  \n  <handleOptions>\n  if (typeof options === 'function') {\n    log = options;\n  }\n\n  log = log || console.log;\n  </handleOptions>\n\n  <eventListeners>\n  runner.on('pending', function(test){\n    tests.push(test);\n  });\n\n  runner.on('pass', function(test){\n    tests.push(test);\n  });\n\n  runner.on('fail', function(test){\n    tests.push(test);\n  });\n  </eventListeners>\n\n  <onEndEvent>\n  runner.on('end', function(){\n    log = fileLogger() || log;\n    log(tag('testsuite', {\n        name: 'Mocha Tests'\n      , tests: stats.tests\n      , failures: stats.failures\n      , errors: stats.failures\n      , skipped: stats.tests - stats.failures - stats.passes\n      , timestamp: (new Date).toUTCString()\n      , time: (stats.duration / 1000) || 0\n    }, false));\n\n    tests.forEach(test);\n    log('</testsuite>');\n    closeFileLogger();\n  });\n  </onEndEvent>\n\n  <testFunction>\n  function test(test) {\n    var filename = extractClassName(test);\n\n    var attrs = {\n        classname: filename || process.env.npm_package_config_mocha_sonar_reporter_classname || 'Test'\n      , name: !test.parent.fullTitle() || test.parent.fullTitle() === '' ? test.title : test.parent.fullTitle() + ' ' + test.title\n      , time: (test.duration / 1000) || 0\n    };\n\n    if ('failed' == test.state) {\n      var err = test.err;\n      attrs.message = escape(err.message);\n      log(tag('testcase', attrs, false, tag('failure', attrs, false, cdata(err.stack))));\n    } else if (test.pending) {\n      log(tag('testcase', attrs, false, tag('skipped', {}, true)));\n    } else {\n      log(tag('testcase', attrs, true) );\n    }\n  }\n  </testFunction>\n\n  <extractClassNameFunction>\n  function extractClassName(test) {\n    var relativeTestDir = process.env.npm_package_config_mocha_sonar_reporter_testdir;\n    var classnameSuffix = process.env.npm_package_config_mocha_sonar_reporter_classnameSuffix || '';\n\n    if (relativeTestDir === undefined || test.file === undefined) {\n      return undefined;\n    }\n\n    var absoluteTestDir = path.join(process.cwd(), relativeTestDir);\n\n    var relativeFilePath = path.relative(absoluteTestDir, test.file);\n\n    var suffixIndex = relativeFilePath.lastIndexOf('.');\n\n    return (suffixIndex >= 0 ? relativeFilePath.substring(0, suffixIndex) : relativeFilePath) + classnameSuffix;\n  }\n  </extractClassNameFunction>\n\n  <fileLoggerFunction>\n  function fileLogger() {\n\n    var outputfile = process.env.npm_package_config_mocha_sonar_reporter_outputfile;\n\n    if (!outputfile) {\n      return undefined;\n    }\n\n    mkdirpSync(path.dirname(outputfile));\n    logFd = fs.openSync(outputfile, 'w');\n\n    return function logFile(data) {\n      fs.writeSync(logFd, data + os.EOL);\n    }\n  }\n  </fileLoggerFunction>\n\n  <closeFileLoggerFunction>\n  function closeFileLogger() {\n    if (logFd) {\n      fs.closeSync(logFd);\n    }\n  }\n  </closeFileLoggerFunction>\n}\n"], ["_rsapem_publicKeyToX509HexString", "\nfunction _rsapem_publicKeyToX509HexString(rsaKey) {\n    var encodedIdentifier = \"06092A864886F70D010101\";\n    var encodedNull = \"0500\";\n    var headerSequence = \"300D\" + encodedIdentifier + encodedNull;\n\n    var keys = _rsapem_derEncodeNumber(rsaKey.n);\n    keys += _rsapem_derEncodeNumber(rsaKey.e);\n\n    var keySequence = \"0030\" + _rsapem_encodeLength(keys.length / 2) + keys;\n    var bitstring = \"03\" + _rsapem_encodeLength(keySequence.length / 2) + keySequence;\n\n    var mainSequence = headerSequence + bitstring;\n\n    return \"30\" + _rsapem_encodeLength(mainSequence.length / 2) + mainSequence;\n}\n"], ["_createConfig", "\nfunction _createConfig(){\n        let file = repositoryPath + '/config.json';\n        let config = {\n            simulation: false\n        };\n        return new Promise(function(resolve, reject) {\n            jsonfile.writeFile(file, config, function (err) {\n                if(err){\n                    reject(err);\n                    return;\n                }\n                resolve();\n            });\n\n        });\n    }\n"], ["Peer", "\nfunction Peer (opts) {\n  var self = this\n  if (!(self instanceof Peer)) return new Peer(opts)\n\n  self._id = randombytes(4).toString('hex').slice(0, 7)\n  self._debug('new peer %o', opts)\n\n  <defaultOptions>\n  opts = Object.assign({\n    allowHalfOpen: false\n  }, opts)\n  </defaultOptions>\n\n  stream.Duplex.call(self, opts)\n\n  <initializeProperties>\n  self.channelName = opts.initiator\n    ? opts.channelName || randombytes(20).toString('hex')\n    : null\n\n  self.initiator = opts.initiator || false\n  self.channelConfig = opts.channelConfig || Peer.channelConfig\n  self.config = Object.assign({}, Peer.config, opts.config)\n  self.offerOptions = opts.offerOptions || {}\n  self.answerOptions = opts.answerOptions || {}\n  self.sdpTransform = opts.sdpTransform || function (sdp) { return sdp }\n  self.streams = opts.streams || (opts.stream ? [opts.stream] : []) \n  self.trickle = opts.trickle !== undefined ? opts.trickle : true\n  self.allowHalfTrickle = opts.allowHalfTrickle !== undefined ? opts.allowHalfTrickle : false\n  self.iceCompleteTimeout = opts.iceCompleteTimeout || ICECOMPLETE_TIMEOUT\n\n  self.destroyed = false\n  self.connected = false\n\n  self.remoteAddress = undefined\n  self.remoteFamily = undefined\n  self.remotePort = undefined\n  self.localAddress = undefined\n  self.localFamily = undefined\n  self.localPort = undefined\n  </initializeProperties>\n\n  <initializeWebRTC>\n  self._wrtc = (opts.wrtc && typeof opts.wrtc === 'object')\n    ? opts.wrtc\n    : getBrowserRTC()\n\n  if (!self._wrtc) {\n    if (typeof window === 'undefined') {\n      throw makeError('No WebRTC support: Specify `opts.wrtc` option in this environment', 'ERR_WEBRTC_SUPPORT')\n    } else {\n      throw makeError('No WebRTC support: Not a supported browser', 'ERR_WEBRTC_SUPPORT')\n    }\n  }\n  </initializeWebRTC>\n\n  <initializePeerConnection>\n  self._pcReady = false\n  self._channelReady = false\n  self._iceComplete = false \n  self._iceCompleteTimer = null \n  self._channel = null\n  self._pendingCandidates = []\n\n  self._isNegotiating = !self.initiator \n  self._batchedNegotiation = false \n  self._queuedNegotiation = false \n  self._sendersAwaitingStable = []\n  self._senderMap = new Map()\n  self._firstStable = true\n  self._closingInterval = null\n\n  self._remoteTracks = []\n  self._remoteStreams = []\n\n  self._chunk = null\n  self._cb = null\n  self._interval = null\n\n  try {\n    self._pc = new (self._wrtc.RTCPeerConnection)(self.config)\n  } catch (err) {\n    self.destroy(err)\n  }\n  </initializePeerConnection>\n\n  <eventHandlers>\n  self._isReactNativeWebrtc = typeof self._pc._peerConnectionId === 'number'\n\n  self._pc.oniceconnectionstatechange = function () {\n    self._onIceStateChange()\n  }\n  self._pc.onicegatheringstatechange = function () {\n    self._onIceStateChange()\n  }\n  self._pc.onsignalingstatechange = function () {\n    self._onSignalingStateChange()\n  }\n  self._pc.onicecandidate = function (event) {\n    self._onIceCandidate(event)\n  }\n  </eventHandlers>\n\n  <dataChannelSetup>\n  if (self.initiator) {\n    self._setupData({\n      channel: self._pc.createDataChannel(self.channelName, self.channelConfig)\n    })\n  } else {\n    self._pc.ondatachannel = function (event) {\n      self._setupData(event)\n    }\n  }\n  </dataChannelSetup>\n\n  <streamAndTrackSetup>\n  if (self.streams) {\n    self.streams.forEach(function (stream) {\n      self.addStream(stream)\n    })\n  }\n  self._pc.ontrack = function (event) {\n    self._onTrack(event)\n  }\n  </streamAndTrackSetup>\n\n  <initiatorSetup>\n  if (self.initiator) {\n    self._needsNegotiation()\n  }\n  </initiatorSetup>\n\n  <finishEventBinding>\n  self._onFinishBound = function () {\n    self._onFinish()\n  }\n  self.once('finish', self._onFinishBound)\n  </finishEventBinding>\n}\n"], ["getType", "\nfunction getType (str, typeLinks) {\n  if (str in typeLinks) {\n    return dom.create('a').class('qm-api-type-link').attr('href', typeLinks[str]).text(str)\n  } else {\n    return str\n  }\n}\n"], ["cloneMethod", "\nfunction() {\n  var clone = new this.constructor();\n  for (var key in this) {\n    if (key == \"query\") {\n      clone[key] = lib.factory.clone(this[key]);\n    } else {\n      clone[key] = this[key];\n    }\n  }\n  return clone;\n}\n"], ["errorsAllIds", "\nfunction errorsAllIds(state = [], { meta, type }) {\n  switch (type) {\n    <errorCases>\n    case LISTENER_ERROR:\n    case ERROR:\n      if (state.indexOf(getQueryName(meta)) !== -1) {\n        return state;\n      }\n      return [...state, getQueryName(meta)];\n    </errorCases>\n    <clearAllErrorsCase>\n    case CLEAR_ERRORS:\n      return [];\n    </clearAllErrorsCase>\n    <clearSingleErrorCase>\n    case CLEAR_ERROR:\n      return state.filter(lId => lId !== getQueryName(meta));\n    </clearSingleErrorCase>\n    <defaultCase>\n    default:\n      return state;\n    </defaultCase>\n  }\n}\n"], ["render_with_layout", "\nfunction render_with_layout(template, locals, cb) {\n  <renderFile>\n  render_file(locals, function(err, str) {\n    if (err) {\n      return cb(err);\n    }\n    locals.body = str;\n  </renderFile>\n\n  var res = template(locals, handlebarsOpts);\n  <asyncDone>\n  self.async.done(function(values) {\n    Object.keys(values).forEach(function(id) {\n      res = res.replace(id, values[id]);\n    });\n\n    cb(null, res);\n  });\n  </asyncDone>\n});\n"], ["parseParams", "\nfunction parseParams (str) {\n  var items\n  var result = {}\n  <parseString>\n  if (str && baseExports.isString(str)) {\n    baseExports.each(str.split('&'), function (param) {\n      items = param.split('=')\n      result[decode(items[0])] = decode(items[1] || '')\n    })\n  }\n  </parseString>\n  return result\n}\n"], "```"]