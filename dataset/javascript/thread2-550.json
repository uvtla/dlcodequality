[["dirsExist", "\nfunction dirsExist(dirs) {\n  <checkEmptyDirs>\n  if (0 === dirs.length) {\n    return new Promise((resolve) => {\n      resolve({});\n    });\n  }\n  </checkEmptyDirs>\n\n  <organizeDirsByDepth>\n  const dirsByDepth = dirs.reduce(function(prev, curItem) {\n    const depth = curItem.split(path.sep).length;\n    (prev[depth] = prev[depth] || []).push(curItem);\n\n    return prev;\n  }, {});\n  </organizeDirsByDepth>\n\n  <findCurrentDirs>\n  const allDepths = Object.keys(dirsByDepth).map(Number);\n  const currDepth = Math.min(...allDepths);\n  const currDirs = dirsByDepth[currDepth];\n  </findCurrentDirs>\n\n  <initializeResultObject>\n  const result = dirs.reduce(function(prev, item) {\n    prev[item] = null;\n\n    return prev;\n  }, {});\n  </initializeResultObject>\n\n  <checkCurrentDirsExistence>\n  return stupidDirsExist(currDirs).then((localResult) => {\n    Object.keys(result).forEach((dir) => {\n      if (null !== result[dir]) {\n        return;\n      }\n\n      Object.keys(localResult).forEach((localDir) => {\n        \n        result[localDir] = localResult[localDir];\n\n        \n        \n        if (false === localResult[localDir] &&\n          dir.slice(0, localDir.length + 1) === localDir + path.sep) {\n          result[dir] = false;\n        }\n      });\n    });\n    </checkCurrentDirsExistence>\n\n    <filterRestAndRecurse>\n    const restDirs = dirs.filter((dir) => {\n      return null === result[dir];\n    });\n\n    return dirsExist(restDirs);\n    </filterRestAndRecurse>\n  }).then((finalResult) => {\n    <mergeFinalResult>\n    Object.keys(finalResult).forEach((finalDir) => {\n      result[finalDir] = finalResult[finalDir];\n    });\n\n    return result;\n    </mergeFinalResult>\n  });\n}\n"], ["processOutput", "\nfunction (o, cb) {\n    <checkOutputDir>\n    if (!o.out) {\n      throw new Error('output dir missing');\n    }\n    </checkOutputDir>\n\n    <pipeToDestination>\n    this.src(o)\n      .on('error', handleCallbackError(cb))\n      .pipe(vfs.dest(function (file) {\n        return file.base;\n      }))\n      .on('error', handleCallbackError(cb))\n      .on('end', function () {\n        <executeCallback>\n        if (_.isFunction(cb) && !error) {\n          cb();\n        }\n        </executeCallback>\n      });\n    </pipeToDestination>\n}\n"], ["applyChangesAttributes", "\nfunction() {\n    <applyChanges>\n    for (var name in this.changes) {\n      if (this.changes.hasOwnProperty(name)) {\n        this.attributes[name] = this.changes[name][0]\n      }\n    }\n    </applyChanges>\n\n    <resetChanges>\n    this.changes = {}\n    return this\n    </resetChanges>\n}\n"], ["andEvaluator", "\nfunction andEvaluator(conditions, leafEvaluator) {\n  var sawNullResult = false;\n  <evaluateConditions>\n  for (var i = 0; i < conditions.length; i++) {\n    var conditionResult = evaluate(conditions[i], leafEvaluator);\n    if (conditionResult === false) {\n      return false;\n    }\n    if (conditionResult === null) {\n      sawNullResult = true;\n    }\n  }\n  </evaluateConditions>\n  return sawNullResult ? null : true;\n}\n"], ["parseRGB", "\nfunction parseSimpleColor(color) {\n  <normalizeAndMatch>\n\tcolor = normalizeColor(color);\n\tvar matches = /^rgb\\(([0-9]+), ([0-9]+), ([0-9]+)\\)$/.exec(color);\n  \n  if (matches) {\n    <constructHexColor>\n\t\treturn \"#\"\n\t\t\t+ parseInt(matches[1]).toString(16).replace(/^.$/, \"0$&\")\n\t\t\t+ parseInt(matches[2]).toString(16).replace(/^.$/, \"0$&\")\n\t\t\t+ parseInt(matches[3]).toString(16).replace(/^.$/, \"0$&\");\n    </constructHexColor>\n\t}\n  </normalizeAndMatch>\n\treturn null;\n}\n"], ["addWeight", "\nfunction addWeight (canonicalNodeWithPath, query) {\n  \n  <initializeVariable>\n  const cnwp = canonicalNodeWithPath\n  </initializeVariable>\n\n  <computePresentableName>\n  const name = presentableName(cnwp.node, preferredLocale)\n  </computePresentableName>\n\n  <computeSynonym>\n  const synonym = cnwp.path\n    .map(pathNode => presentableName(pathNode.node, pathNode.locale))\n    .map(nameInPath => nameInPath.toLowerCase())\n    .pop()\n  </computeSynonym>\n\n  <indexOfQueryCalculation>\n  const indexOfQuery = indexOfLowerCase(name, query)\n  </indexOfQueryCalculation>\n\n  <countryChecks>\n  const isUk = name === 'United Kingdom'\n  const isUs = name === 'United States'\n  </countryChecks>\n\n  <countryBiases>\n  const ukBias = 2\n  const usBias = 1.5\n  const defaultCountryBias = 1\n  </countryBiases>\n\n  <matchChecks>\n  const isExactMatchToCanonicalName = name.toLowerCase() === query.toLowerCase()\n  const canonicalNameStartsWithQuery = indexOfQuery === 0\n  const wordInCanonicalNameStartsWithQuery = name\n      .split(' ')\n      .filter(w => w.toLowerCase().indexOf(query.toLowerCase()) === 0)\n      .length > 0\n  </matchChecks>\n\n  <synonymMatchChecks>\n  var synonymIsExactMatch = false\n  var synonymStartsWithQuery = false\n  var wordInSynonymStartsWith = false\n  var indexOfSynonymQuery = false\n  var synonymContainsQuery = false\n\n  if (synonym) {\n    synonymIsExactMatch = synonym === query.toLowerCase()\n\n    synonymStartsWithQuery = synonym\n      .indexOf(query.toLowerCase()) === 0\n\n    wordInSynonymStartsWith = synonym\n      .split(' ')\n      .filter(w => w.toLowerCase().indexOf(query.toLowerCase()) === 0)\n      .length > 0\n\n    indexOfSynonymQuery = indexOfLowerCase(synonym, query)\n  }\n  </synonymMatchChecks>\n\n  <updateWeightBasedOnName>\n  const canonicalNameContainsQuery = indexOfQuery > 0\n  synonymContainsQuery = indexOfSynonymQuery > 0\n\n  if (isExactMatchToCanonicalName) {\n    cnwp.weight = 100\n  } else if (canonicalNameStartsWithQuery) {\n    cnwp.weight = 76\n  } else if (wordInCanonicalNameStartsWithQuery) {\n    cnwp.weight = 60\n  } else if (synonymIsExactMatch) { \n    cnwp.weight = 50\n  } else if (synonymStartsWithQuery) {\n    cnwp.weight = 45\n  } else if (wordInSynonymStartsWith) {\n    cnwp.weight = 37\n  } else if (canonicalNameContainsQuery) { \n    cnwp.weight = 25\n  } else if (synonymContainsQuery) {\n    cnwp.weight = 22\n  } else { \n    cnwp.weight = 15\n  }\n  </updateWeightBasedOnName>\n\n  <weightAdjustments>\n  cnwp.weight -= cnwp.path.length\n  </weightAdjustments>\n\n  <applyCountryBias>\n  var countryBias = isUk ? ukBias : defaultCountryBias\n  countryBias = isUs ? usBias : countryBias\n  cnwp.weight *= countryBias\n  </applyCountryBias>\n\n  return cnwp\n}\n"], ["GoogleDriveStrategy", "\nfunction GoogleDriveStrategy (options, verify) {\n  <setDefaultsForOptions>\n    options = options || {};\n    options.authorizationURL = options.authorizationURL || 'https:\n    options.tokenURL = options.tokenURL || 'https:\n  </setDefaultsForOptions>\n\n  <initializeOAuthStrategy>\n    OAuth2Strategy.call(this, options, verify)\n    this.name = 'google-drive'\n  </initializeOAuthStrategy>\n}\n"], ["defer_resolver", "\nfunction defer_resolver(defer, err, result) {\n  <resolveOrReject>\n\tif(err) {\n\t\tdefer.reject(err);\n\t} else {\n\t\tdefer.resolve(result);\n\t}\n  </resolveOrReject>\n}\n"], ["UfoConnection", "\nfunction (action) {\n  <setExitFlag>\n  printHelpOnExit = false;\n  </setExitFlag>\n\n  <parseCliOptions>\n  const cliOptions = getOptions();\n  </parseCliOptions>\n\n  <validateHostAndConnect>\n  if (cliOptions.host) {\n    if (net.isIPv4(cliOptions.host)) {\n      <initializeUfo>\n      theUfo = new Ufo(cliOptions);\n      </initializeUfo>\n      <establishConnection>\n      theUfo.connect()\n        .then(action.bind(theUfo))\n        .catch(quitError);\n      </establishConnection>\n    } else {\n      <invalidHostError>\n      quitError(`Invalid UFO IP address provided: ${cliOptions.host}.`);\n      </invalidHostError>\n    }\n  } else {\n    <missingHostError>\n    quitError('No UFO IP address provided.');\n    </missingHostError>\n  }\n  </validateHostAndConnect>\n}\n"], ["layoutToHTML", "\nfunction layoutToHTML( d ) {\n  <initializeContentAndClasses>\n  var content = [];\n  var laCls = '';\n  var layoutId = '';\n  </initializeContentAndClasses>\n\n  <processLayoutId>\n  if ( d.layoutId && d.layoutId != '' ) { \n    <assignClasses>\n    laCls = ' class=\"'+d.layoutId+'\"'; \n    layoutId = d.layoutId; \n    </assignClasses>\n  }\n  </processLayoutId>\n\n  <buildContent>\n  content.push( '<div id=\"header\" '+laCls+'></div>' );\n  content = content.concat( rowsToHTML( d.rows, d.page_width, layoutId ) );\n  content.push( '<div id=\"footer\" '+laCls+'></div>' );\n  </buildContent>\n\n  return content;\n}\n"], "```"]