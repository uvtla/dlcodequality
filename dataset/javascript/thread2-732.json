[["inherits", "\nfunction inherits(ctor, superCtor) {\n  ctor.super_ = superCtor;\n  Object.setPrototypeOf(ctor.prototype, superCtor.prototype);\n}\n"], ["updateComponentState", "\nfunction (newProps) {\n  <deriveValueFromArray>\n  var value = this._or(ensureArray(newProps.value), this.state.value);\n  this.tempArray = value.slice();\n  </deriveValueFromArray>\n\n  <updateStateValues>\n  for (var i = 0; i < value.length; i++) {\n    this.state.value[i] = this._trimAlignValue(value[i], newProps);\n  }\n  if (this.state.value.length > value.length)\n    this.state.value.length = value.length;\n  </updateStateValues>\n\n  <handleUpperBoundResize>\n  if (this.state.upperBound === 0) {\n    this._resize();\n  }\n  </handleUpperBoundResize>\n}\n"], ["fitRect", "\nfunction fitRect(rect, target, mode) {\n  <calculateScaling>\n  mode = mode || 'contain';\n  var sw = target[2]/rect[2];\n  var sh = target[3]/rect[3];\n  var scale = 1;\n  if (mode == 'contain') {\n      scale = Math.min(sw, sh);\n  }\n  else if (mode == 'cover') {\n      scale = Math.max(sw, sh);\n  }\n  </calculateScaling>\n\n  <returnScaledRectangle>\n  return [\n      target[0] + (target[2] - rect[2]*scale)/2,\n      target[1] + (target[3] - rect[3]*scale)/2,\n      rect[2]*scale,\n      rect[3]*scale\n  ];\n  </returnScaledRectangle>\n}\n"], ["_resolveMouseInputConflicts", "\nfunction _resolveMouseInputConflicts(tool, element, options) {\n  <normalizeOptions>\n  const mouseButtonMask = _getNormalizedOptions(options).mouseButtonMask;\n  const hasMouseButtonMask =\n    Array.isArray(mouseButtonMask) && mouseButtonMask.length > 0;\n  </normalizeOptions>\n\n  <resolveConflicts>\n  if (!hasMouseButtonMask) {\n    return;\n  }\n  const activeToolWithMatchingMouseButtonMask = store.state.tools.find(\n    t =>\n      t.element === element &&\n      t.mode === 'active' &&\n      t.options.isMouseActive === true &&\n      Array.isArray(t.options.mouseButtonMask) &&\n      t.options.mouseButtonMask.some(v => mouseButtonMask.includes(v))\n  );\n  </resolveConflicts>\n\n\n  <updateOrDisableActiveTool>\n  if (activeToolWithMatchingMouseButtonMask) {\n    \n    activeToolWithMatchingMouseButtonMask.options.mouseButtonMask = activeToolWithMatchingMouseButtonMask.options.mouseButtonMask.filter(\n      mask => !mouseButtonMask.includes(mask)\n    );\n\n    \n    if (\n      activeToolWithMatchingMouseButtonMask.options.mouseButtonMask.length === 0\n    ) {\n      activeToolWithMatchingMouseButtonMask.options.isMouseActive = false;\n    }\n  }\n  </updateOrDisableActiveTool>\n}\n"], ["resolveRouters", "\nfunction resolveRouters(request) {\n  <iterateRouters>\n  for (var i = 0, l = routers.length; i < l; i++) {\n    var callback = routers[i].resolve(request);\n    if (null != callback) {\n      return Promise.resolve(callback);\n    }\n  }\n  </iterateRouters>\n  \n  <handleUnresolvedRoute>\n  return Promise.reject('Route not defined for \"' + request.url + '\"');\n  </handleUnresolvedRoute>\n}\n"], ["initializeAndOpenPopup", "\nfunction () {\n  <preparePopupConfiguration>\n  var cfg = this._cfg;\n  var refreshParams = {\n      section : \"__popup_\" + this._domId,\n      writerCallback : {\n          fn : this._writerCallback,\n          scope : this\n      }\n  };\n  var section = this._context.getRefreshedSection(refreshParams);\n  </preparePopupConfiguration>\n\n  <createAndConfigurePopupObject>\n  var popup = new aria.popups.Popup();\n  this._popup = popup;\n  popup.$on({\n      \"onAfterClose\" : this.disposePopup,\n      scope : this\n  });\n  </createAndConfigurePopupObject>\n\n  <setDefaultPopupPosition>\n  if (cfg.domReference === null && cfg.referenceId === null && cfg.absolutePosition === null\n          && cfg.center === false) {\n      cfg.absolutePosition = {\n          top : 0,\n          left : 0\n      };\n  }\n  </setDefaultPopupPosition>\n\n  <assignDomReference>\n  var domReference = null;\n  if (cfg.domReference) {\n      domReference = cfg.domReference;\n  } else if (cfg.referenceId) {\n      domReference = ariaUtilsDom.getElementById(this._context.$getId(cfg.referenceId));\n  }\n  </assignDomReference>\n\n  <openPopupWithConfiguredOptions>\n  popup.open({\n      section : section,\n      keepSection : true,\n      modal : cfg.modal,\n      maskCssClass : cfg.maskCssClass,\n      domReference : domReference,\n      absolutePosition : cfg.absolutePosition,\n      center : cfg.center,\n      maximized : cfg.maximized,\n      closeOnMouseClick : cfg.closeOnMouseClick,\n      closeOnMouseScroll : cfg.closeOnMouseScroll,\n      closeOnMouseOut : cfg.closeOnMouseOut,\n      closeOnMouseOutDelay : cfg.closeOnMouseOutDelay,\n      preferredPositions : cfg.preferredPositions,\n      offset : cfg.offset,\n      ignoreClicksOn : cfg.ignoreClicksOn,\n      parentDialog : cfg.parentDialog,\n      zIndexKeepOpenOrder : cfg.zIndexKeepOpenOrder,\n      preferredWidth : cfg.preferredWidth,\n      animateOut : cfg.animateOut,\n      animateIn : cfg.animateIn\n  });\n  </openPopupWithConfiguredOptions>\n}\n"], ["SequenceOf", "\nfunction SequenceOf(factory, value) {\n  spec.Asn1Spec.call(this, new spec.Asn1Tag(spec.TagClass.Universal, spec.TagFormat.Constructed, UniversalTag.Sequence));\n  this.factory = factory;\n  this.value = value || [];\n}\n"], ["closePolygon", "\nfunction (path, segment, translatedThreshold) {\n  <definePolygonClosure>\n  path.push(\n    L,\n    segment[segment.length - 1].plotX,\n    translatedThreshold,\n    L,\n    segment[0].plotX,\n    translatedThreshold\n  );\n  </definePolygonClosure>\n}\n"], ["outputHelpIfNecessary", "\nfunction outputHelpIfNecessary(cmd, options) {\n  <processOptionsForHelp>\n  options = options || [];\n  for (var i = 0; i < options.length; i++) {\n    if (options[i] == '--help' || options[i] == '-h') {\n      process.on('exit', function() {\n        consoleFlush(cmd.helpInformation());\n        cmd.emit('--help');\n        consoleFlush(\"\");\n      });\n      process.exit();\n    }\n  </processOptionsForHelp>\n\n  <defaultReturn>\n  return true;\n  </defaultReturn>\n}\n"], ["throttleTime", "\nfunction throttleTime(duration, scheduler, config) {\n  <setDefaultParameters>\n  if (scheduler === void 0) {\n      scheduler = _scheduler_async__WEBPACK_IMPORTED_MODULE_2__[\"async\"];\n  }\n  if (config === void 0) {\n      config = _throttle__WEBPACK_IMPORTED_MODULE_3__[\"defaultThrottleConfig\"];\n  }\n  </setDefaultParameters>\n\n  <returnThrottledSource>\n  return function (source) { return source.lift(new ThrottleTimeOperator(duration, scheduler, config.leading, config.trailing)); };\n  </returnThrottledSource>\n}\n"], ""]