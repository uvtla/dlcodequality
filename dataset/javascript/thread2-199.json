[["divide", "\nfunction divide(arr, arg) {\n    <checkArgUsability>\n    if (isUsable(arg)) </checkArgUsability> {\n        <normalizeArgument>\n        if (!isUsable(arg[0])) arg = [ arg ]; </normalizeArgument>\n        <matrixDivide>\n        return jStat.multiply(arr, jStat.inv(arg)); </matrixDivide>\n    }\n    <arrayDivide>\n    return jStat.map(arr, function(value) { return value / arg; }); </arrayDivide>\n}\n"], ["_fnBlur", "\nfunction _fnBlur() {\n    <removeFocus>\n    _fnRemoveFocus(_nOldFocus); </removeFocus>\n    <resetOldCoordinates>\n    _iOldX = null;\n    _iOldY = null; </resetOldCoordinates>\n    <resetOldFocus>\n    _nOldFocus = null; </resetOldFocus>\n    <releaseKeys>\n    _fnReleaseKeys(); </releaseKeys>\n}\n"], ["generateContent", "\nfunction generateContent(file) {\n    var content,\n    <getConfig>\n    isOptimizer = config.get('isOptimizer'), </getConfig>\n    escodegenOpts = {},\n    exports;\n    \n    <checkFileType>\n    if (!file.isLikeJs) {\n        content = file.getContent();\n    } else { </checkFileType>\n        <setEscodegenOptions>\n        if (isOptimizer) {\n            escodegenOpts = {\n                format: {\n                    indent: {\n                        style: '',\n                        base: 0\n                    },\n                    compact: true,\n                    newLine: ''\n                }\n            }\n        } </setEscodegenOptions>\n\n        <processFileContent>\n        if (file.getContent().match(requireRegExp)) {\n            \n            content = escodegen.generate(file.ast, escodegenOpts);\n            content = content.replace(/(<<<require>>>\\s*;+)|(<<<require>>>\\s*,+)/gim, \"\");\n            if (isOptimizer) {\n                content = content.replace(/([;,][\\s\\n\\r]*(?=[;,]))/gi, \"\").replace(/(,[\\s\\n\\r]*(?=(var)))/gi, \";\");\n            } else {\n                content = content.replace(/([\\s\\n\\r]+);/gi, \"\");\n            }\n            content = content.replace(closureReg(file.nsRegExp), '');\n            exports = file.exports;\n            if (exports && 'type' in exports && exports.type === Syntax.Identifier) {\n                content = content.replace(new RegExp(file.nsRegExp, 'igm'), '');\n            }\n        } else {\n            content = file.getContent();\n        } </processFileContent>\n    }\n\n    <emptyContentCheck>\n    if (!content) {\n        file.setContent('');\n        return;\n    } </emptyContentCheck>\n\n    <setContent>\n    file.setContent(content); </setContent>\n}\n"], ["extendClassWithMethods", "\nfunction(cls, methods) {\n    <prepareMethodKeys>\n    var keys = Object.keys(methods);\n    var len = keys.length; </prepareMethodKeys>\n    <assignMethodsToClass>\n    for (var i = 0; i < len; i++) {\n        var key = keys[i];\n        cls.prototype[key] = lib.method.createMethod(methods[key]);\n    } </assignMethodsToClass>\n    <returnClass>\n    return cls; </returnClass>\n}\n"], ["FlowEventConstructor", "\nfunction FlowEvent(category, id, title, colorId, start, args, opt_duration) {\n    <initTimedEvent>\n    tr.model.TimedEvent.call(this, start); </initTimedEvent>\n\n    <setEventMetadata>\n    this.category = category || '';\n    this.title = title;\n    this.colorId = colorId;\n    this.start = start;\n    this.args = args;\n    this.id = id;\n    </setEventMetadata>\n\n    <initializeSlices>\n    this.startSlice = undefined;\n    this.endSlice = undefined; </initializeSlices>\n\n    <initializeStackFrames>\n    this.startStackFrame = undefined;\n    this.endStackFrame = undefined; </initializeStackFrames>\n\n    <setDuration>\n    if (opt_duration !== undefined)\n        this.duration = opt_duration; </setDuration>\n}\n"], ["ConstructorWithValidations", "\nfunction(error, body) {\n    <validateErrorCode>\n    if (error < -1 || error > 4) {\n        throw \"Invalid error code: \" + error;\n    } </validateErrorCode>\n    <setError>\n    this.error = error; </setError>\n    <validateBodyBuffer>\n    if (!Buffer.isBuffer(body)) {\n        throw \"The body parameter must be a Buffer object.\";\n    } </validateBodyBuffer>\n    <setBodyAndLength>\n    this.body = body;\n    this.length = body.length + 2; </setBodyAndLength>\n}\n"], ["RedisVaultConstructor", "\nfunction RedisVault(name, logger) {\n    <setName>\n\tthis.name = name; </setName>\n    <initializeArchive>\n\tthis.archive = new Archive(this); </initializeArchive>\n    <initializeClient>\n\tthis.client = null; </initializeClient>\n    <setLogger>\n\tthis.logger = logger; </setLogger>\n}\n"], ["webpackRequireWrapper", "\nfunction(module, exports, __webpack_require__) {\n    <vueModuleInitialization>\n    (function(Vue) {'use strict';\n    \n    __webpack_require__(2);\n    // ... (similar __webpack_require__ calls omitted for brevity)\n    \n    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n    \n    window.vm = new Vue({\n        // ... Vue rendering logic omitted for brevity\n    }).$mount('#app');\n    }.call(exports, __webpack_require__(1))) \n    </vueModuleInitialization>\n}\n"], ["ckeditorSetDataFunction", "\nfunction(data, options, internal) {\n    var fireSnapshot = true,\n    <optionsProcessing>\n    callback = options,\n    eventData; </optionsProcessing>\n\n    <determineOptions>\n\tif (options && typeof options == 'object') {\n\t\tinternal = options.internal;\n\t\tcallback = options.callback;\n\t\tfireSnapshot = !options.noSnapshot;\n\t} </determineOptions>\n\n\t<snapshotLogic>\n\tif (!internal && fireSnapshot)\n\t\tthis.fire('saveSnapshot'); </snapshotLogic>\n\n\t<callbackAndSnapshotHandling>\n\tif (callback || !internal) {\n\t\tthis.once('dataReady', function(evt) {\n\t\t\tif (!internal && fireSnapshot)\n\t\t\t\tthis.fire('saveSnapshot');\n\n\t\t\tif (callback)\n\t\t\t\tcallback.call(evt.editor);\n\t\t});\n\t} </callbackAndSnapshotHandling>\n\n\t<setDataEventTriggering>\n\teventData = { dataValue: data };\n\t!internal && this.fire('setData', eventData); </setDataEventTriggering>\n\n\t<setDataValue>\n\tthis._.data = eventData.dataValue; </setDataValue>\n\n\t<afterSetDataEventTriggering>\n\t!internal && this.fire('afterSetData', eventData); </afterSetDataEventTriggering>\n}\n"], ["_each", "\nfunction _each(dom, parent, expr) {\n    <removeEachAttribute>\n    remAttr(dom, 'each') </removeEachAttribute>\n\n    <initializeVariables>\n    var mustReorder = typeof getAttr(dom, 'no-reorder') !== T_STRING || remAttr(dom, 'no-reorder'),\n        tagName = getTagName(dom),\n        impl = __tagImpl[tagName] || { tmpl: dom.outerHTML },\n        // ... more variable initialization omitted for brevity\n    </initializeVariables>\n\n    <prepareForUpdate>\n    expr = tmpl.loopKeys(expr) </prepareForUpdate>\n\n    // ... remaining code omitted for brevity due to the complexity of this function without context\n    // Normally this function should be split into smaller functions due to high complexity making it\n    // non-compliant with the Single Responsibility Principle (SRP), but without the context and full\n    // implementation details, it is challenging to provide exact annotations.\n}\n"], "```"]