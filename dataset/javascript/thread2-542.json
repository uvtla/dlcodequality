[["idbReadableStream", "\nfunction idbReadableStream(db, storeName, opts) {\n  <inputValidation>\n  if (typeof db !== 'object') throw new TypeError('db must be an object')\n  if (typeof storeName !== 'string') throw new TypeError('storeName must be a string')\n  if (opts == null) opts = {}\n  if (typeof opts !== 'object') throw new TypeError('opts must be an object')\n  </inputValidation>\n\n  <setupTransformer>\n  var transformer = new stream.Transform(xtend(opts, {\n    objectMode: true,\n    transform: function(obj, enc, cb) {\n      cb(null, obj)\n    }\n  }))\n  opts = xtend({\n    snapshot: false\n  }, opts)\n  var lastIteratedKey = null\n  transformer._cursorsOpened = 0\n  </setupTransformer>\n\n  <startCursor>\n  function startCursor() {\n    <cursorConfiguration>\n    var lower, upper, lowerOpen, upperOpen\n    var direction = opts.direction || 'next'\n    var range = opts.range || {}\n    lower = range.lower\n    upper = range.upper\n    lowerOpen = !!range.lowerOpen\n    upperOpen = !!range.upperOpen\n    if (lastIteratedKey) {\n      if (direction === 'next') {\n        lowerOpen = true \n        lower = lastIteratedKey\n      } else {\n        upperOpen = true \n        upper = lastIteratedKey\n      }\n    }\n    var keyRange\n    if (lower && upper)\n      keyRange = IDBKeyRange.bound(lower, upper, lowerOpen, upperOpen)\n    else if (lower)\n      keyRange = IDBKeyRange.lowerBound(lower, lowerOpen)\n    else if (upper)\n      keyRange = IDBKeyRange.upperBound(upper, upperOpen)\n    </cursorConfiguration>\n\n    <transactionAndStoreSetup>\n    var tx = db.transaction(storeName, 'readonly')\n    var store = tx.objectStore(storeName)\n    transformer._cursorsOpened++\n    var req = store.openCursor(keyRange, opts.direction)\n    </transactionAndStoreSetup>\n\n    <cursorOperation>\n    function proceed(cursor) {\n      try {\n        cursor.continue() \n      } catch(err) {\n        if (err.name === 'TransactionInactiveError' && !opts.snapshot)\n          startCursor()\n        else\n          transformer.emit('error', err)\n      }\n    }\n    req.onsuccess = function() {\n      var cursor = req.result\n      if (cursor) {\n        lastIteratedKey = cursor.key\n        var go = transformer.write({ key: cursor.key, value: cursor.value })\n        if (opts.snapshot || go)\n          proceed(cursor)\n        else\n          transformer.once('drain', function() {\n            proceed(cursor)\n          })\n      } else\n        transformer.end()\n    }\n    tx.onabort = function() {\n      transformer.emit('error', tx.error)\n    }\n    tx.onerror = function() {\n      transformer.emit('error', tx.error)\n    }\n    </cursorOperation>\n  }\n  </startCursor>\n\n  <initiateCursor>\n  startCursor()\n  </initiateCursor>\n\n  return transformer\n}\n"], ["eventHandlerSetup", "\nfunction on (state, eventName, handler) {\n  state.emitter.on(eventName, handler)\n  return state.api\n}\n"], ["stickify", "\nfunction stickify(node) {\n  <childrenHandling>\n  var children = node.children;\n  if (children && children.length) {\n    <rectangleSetup>\n    var rect = pad(node),\n        remaining = children.slice(),\n        child,\n        row = [];\n    scale(remaining, rect.dx * rect.dy / node.value);\n    row.area = 0;\n    </rectangleSetup>\n    <childPositioning>\n    while (child = remaining.pop()) {\n      row.push(child);\n      row.area += child.area;\n      if (child.z != null) {\n        position(row, child.z ? rect.dx : rect.dy, rect, !remaining.length);\n        row.length = row.area = 0;\n      }\n    }\n    children.forEach(stickify);\n    </childPositioning>\n  }\n  </childrenHandling>\n}\n"], ["formatIcuString", "\nfunction (icuString, options) {\n  <cleanWhiteSpace>\n  icuString = this.cleanWhiteSpace(icuString);\n  </cleanWhiteSpace>\n\n  <optionParsing>\n  if (typeof options !== 'undefined') {\n    <stringOptionReplacement>\n    if (typeof options.string !== 'undefined') {\n      var stringRe = new RegExp(('\\{' + options.string + '\\}'), 'g');\n      icuString = icuString.replace(stringRe, '%s');\n    }\n    </stringOptionReplacement>\n    <numberOptionReplacement>\n    if (typeof options.number !== 'undefined') {\n      var numberRe = new RegExp(('\\{' + options.number + ', number\\}'), 'g');\n      icuString = icuString.replace(numberRe, '%d');\n    }\n    </numberOptionReplacement>\n  }\n  </optionParsing>\n  \n  <generalPlaceholderReplacements>\n  icuString = icuString.replace(/\\{[a-zA-Z0-9_.|]+\\}/g, function (variable_name) {\n    var name = variable_name.substring(1, (variable_name.length - 1));\n    return '%(' + name + ')s';\n  });\n  icuString = icuString.replace(/\\{[a-zA-Z0-9_.|]+, number\\}/g, function (variable_name) {\n    var name = variable_name.substring(1, (variable_name.length - 9));\n    return '%(' + name + ')d';\n  });\n  </generalPlaceholderReplacements>\n\n  return icuString;\n}\n"], ["assertImmutableEqual", "\nfunction assertImmutableEqual(_super) {\n  return function(collection) {\n    <assertionLogic>\n    const obj = this._obj;\n    if (isImmutable(obj)) {\n      this.assert(\n        Immutable.is(obj, collection),\n        'expected #{act} to equal #{exp}',\n        'expected #{act} to not equal #{exp}',\n        collection.toJS(),\n        obj.toJS(),\n        true\n      );\n    } else {\n      _super.apply(this, arguments);\n    }\n    </assertionLogic>\n  };\n}\n"], ["k8sutilInitialization", "\nfunction K8sutil() {\n  <podInformationRetrieval>\n  podName = os.hostname();\n  podGenerateName = podName.substr(0, podName.lastIndexOf('-'));\n  logger.debug('k8sutil', 'K8sutil()', 'The pod name: ', podName);\n  fetchContainerID();\n  </podInformationRetrieval>\n  <k8sConfigManagement>\n  try {\n    var kubeconfig = Api.config.getInCluster();\n    kubeconfig.promises = true;\n    logger.debug('k8sutil', 'K8sutil()', 'Kubeconfig', kubeconfig);\n    core = new Api.Core(kubeconfig);\n    ext = new Api.Extensions(kubeconfig);\n    namespace = core.namespaces.namespace;\n    logger.info('k8sutil', 'K8sutil()', 'Current namespace', namespace);\n    if (!podJson) {\n      core.ns(namespace).pods(this.getPodName()).get().then(parsePodInfo).catch(\n        function(err) {\n          logger.error('k8sutil', 'K8sutil()', err.message);\n        }\n      );\n    }\n  } catch (e) {\n    logger.debug('k8sutil', 'K8sutil()',\n                 'Failed to load K8S configuration, is not a ICp environment.');\n  }\n  </k8sConfigManagement>\n  <additionalK8sutilFunctionCalls>\n  findIngressSvc();\n  setNodeIPs();\n  </additionalK8sutilFunctionCalls>\n}\n"], ["leafletLayerSetup", "\nfunction(layerModel, leafletLayer, leafletMap) {\n  <initialConfigurations>\n  this.leafletLayer = leafletLayer;\n  this.leafletMap = leafletMap;\n  this.model = layerModel;\n  this.setModel(layerModel);\n  this.type = layerModel.get('type') || layerModel.get('kind');\n  this.type = this.type.toLowerCase();\n  </initialConfigurations>\n}\n"], ["curryFunction", "\nfunction curry(fn, obj) {\n  <bindFunction>\n  var newFunction = _.bind(fn, (obj || null));\n  </bindFunction>\n\n  <curryLogic>\n  return function () {\n    <partialApplication>\n    var me = _.partial(newFunction, arguments);\n    </partialApplication>\n\n    <curryDecision>\n    if (!me.length) return me();\n    return curry(me);\n    </curryDecision>\n  };\n  </curryLogic>\n}\n"], ["findFirstMatch", "\nfunction (array, pred) {\n  <searchLoop>\n  for (var idx = 0, len = array.length; idx < len; idx ++) {\n    var item = array[idx];\n    if (pred(item)) {\n      return item;\n    }\n  }\n  </searchLoop>\n}\n"], ["constructCommitMetadata", "\nfunction (repo, destExists, sha) {\n  <metadataCreation>\n  return {\n    repo: repo,\n    branch: {\n      src: branchSrc,\n      dest: branchDest,\n      destExists: destExists\n    },\n    commit: {\n      sha: sha\n    }\n  };\n  </metadataCreation>\n}\n"], "```"]