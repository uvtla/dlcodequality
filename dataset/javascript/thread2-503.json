[["findConfig", "\nfunction findConfig(sType, vObject, fnCheck) {\n    <determineComponentId>\n    var sComponentId = vObject && typeof vObject === \"string\" ? vObject : (vObject && Component.getOwnerIdFor(vObject));</determineComponentId>\n    if (sComponentId) {\n        \n        <retrieveComponentInfo>\n        var oComponent = Component.get(sComponentId);\n        var sComponentName = oComponent && oComponent.getMetadata().getComponentName();</retrieveComponentInfo>\n        \n        <checkComponentConfig>\n        var oConfig = mComponentConfigs[sComponentName + \"::\" + sComponentId];\n        if (oConfig && oConfig[sType] && fnCheck(oConfig[sType])) {\n            return false;\n        } else {\n            oConfig = mComponentConfigs[sComponentName];\n            if (oConfig && oConfig[sType] && fnCheck(oConfig[sType])) {\n                return false;\n            }\n        }</checkComponentConfig>\n    } else {\n        \n        <checkAllComponentConfigs>\n        jQuery.each(mComponentConfigs, function(sComponentName, oConfig) {\n            if (oConfig && oConfig[sType] && fnCheck(oConfig[sType])) {\n                return false;\n            }\n        });</checkAllComponentConfigs>\n    }\n}\n"], ["appendImagesToNodes", "\nfunction(src, el) {\n    <getNodes>\n    var nodes = DOM.getNodeArray(el);</getNodes>\n    <createImagesAndAppend>\n    nodes.forEach(function (node) {\n        var img = DOM.newEl('img');\n        var domProps = {};\n        domProps[App.setup.dataAttr] = src;\n        <setAttributeToImage>\n        DOM.setAttr(img, domProps);</setAttributeToImage>\n        node.appendChild(img);\n    });</createImagesAndAppend>\n    return this;\n}\n"], ["deferPromise", "\nfunction deferPromise() {\n    var resolve = null, reject = null;\n    <initializePromise>\n    var promise = new Bluebird(function () {\n        resolve = arguments[0];\n        reject = arguments[1];\n    });</initializePromise>\n    return {\n        resolve: resolve,\n        reject: reject,\n        <returnNewPromise>\n        promise: promise</returnNewPromise>\n    };\n}\n"], ["gatherOverrides", "\nfunction(containerUIMap, groupUIMap)\n{\n    containerOverrides = [];\n    groupOverrides = [];\n    \n    <processContainerUIMap>\n    for (var cI in containerUIMap)\n    {\n        var c = containerUIMap[cI]\n        var overrides = {\"fields\" : {}, \"terminals\" : {}};\n        \n        <processFieldsForContainer>\n        for (var fName in c.fields)\n        {\n            var f = c.fields[fName];\n            var o = {}\n            o.visible = f.visible.checked;\n            var rename = f.externalName.value;\n            \n            if (rename.length > 0)\n                o.rename = rename;\n\n            overrides.fields[fName] = o;\n        }</processFieldsForContainer>\n        \n        <processTerminalsForContainer>\n        for (var tName in c.terminals)\n        {\n            var t = c.terminals[tName];\n            var o = {}\n            o.visible = t.visible.checked;\n            var rename = t.externalName.value;\n            \n            if (rename.length > 0)\n                o.rename = rename;\n\n            o.side = t.side.value;\n            \n            overrides.terminals[tName] = o;\n        }</processTerminalsForContainer>\n        \n        containerOverrides.push(overrides);\n    }</processContainerUIMap>\n    \n    <processGroupUIMap>\n    for (var gI in groupUIMap)\n    {\n        var g = groupUIMap[gI]\n        var overrides = {\"fields\" : {}, \"terminals\" : {}};\n        \n        <processFieldsForGroup>\n        for (var fName in g.fields)\n        {\n            var f = g.fields[fName];\n            var o = {}\n            o.visible = f.visible.checked;\n            var rename = f.externalName.value;\n            \n            if (rename.length > 0)\n                o.rename = rename;\n\n            overrides.fields[fName] = o;\n        }</processFieldsForGroup>\n        \n        <processTerminalsForGroup>\n        for (var tName in g.terminals)\n        {\n            var t = g.terminals[tName];\n            var o = {}\n            o.visible = t.visible.checked;\n            var rename = t.externalName.value;\n            \n            if (rename.length > 0)\n                o.rename = rename;\n\n            o.side = t.side.value;\n\n            overrides.terminals[tName] = o;\n        }</processTerminalsForGroup>\n    }</processGroupUIMap>\n    \n    return {\"containerOverrides\" : containerOverrides, \"groupOverrides\" : groupOverrides};\n}\n"], ["addToReturnedOrThrown", "\nfunction addToReturnedOrThrown(dest, others, all, segments) {\n    <processSegments>\n    for (var i = 0; i < segments.length; ++i) {\n        var segment = segments[i];\n\n        dest.push(segment);\n        if (others.indexOf(segment) === -1) {\n            all.push(segment);\n        }\n    }\n    </processSegments>\n}\n"], ["undefineModule", "\nfunction (moduleName) {\n    <createAndUndefineModule> \n    var requiresModule = createModule(moduleName);\n    var mods = requiresModule.getNormalizedModules();\n    Utils.each(mods, function (m) {\n        m.undef();\n    });\n    </createAndUndefineModule>\n}\n"], ["replaceSelected", "\nfunction replaceSelected(string, editor = null) {\n  <getDefaultEditor>\n  let workEditor = editor;\n  if (isEmptyString(workEditor)) {\n    workEditor = atom.workspace.getActiveTextEditor();\n    if (isEmptyString(workEditor)) {\n      return;\n    }\n  }\n  </getDefaultEditor>\n\n  <insertTextWithConfig>\n  workEditor.insertText(string, {\n    \"select\": true,\n    \"autoIndent\": false,\n    \"autoIndentNewline\": false,\n    \"autoDecreaseIndent\": false,\n    \"normalizeLineEndings\": true, \n    \"undo\": null,\n  });\n  </insertTextWithConfig>\n}\n"], ["setupTestEnvironment", "\nfunction(credentials, mocha) {\n  var that = this;\n  <initializeConnection>\n  this._connection        = new taskcluster.PulseConnection(credentials);</initializeConnection>\n  this._listeners         = null;\n  this._promisedMessages  = null;\n\n  <requireMocha>\n  if (!mocha) {\n    mocha = require('mocha');\n  }</requireMocha>\n\n  <mochaHooks>\n  mocha.before(function() {\n    return that._connection.connect();\n  });\n\n  mocha.beforeEach(function() {\n    that._listeners         = [];\n    that._promisedMessages  = {};\n  });\n\n  mocha.afterEach(function() {\n    return Promise.all(that._listeners.map(function(listener) {\n      listener.close();\n    })).then(function() {\n      that._listeners         = null;\n      that._promisedMessages  = null;\n    });\n  });\n\n  mocha.after(function() {\n    return that._connection.close().then(function() {\n      that._connection = null;\n    });\n  });\n  </mochaHooks>\n}\n"], ["buildSassFiles", "\nasync function buildSassFiles(files, outputDir, config) {\n  <renderAllFiles>\n  const renderedFiles = await Promise.all(files.map(async file => {\n    const css = await renderFile(file, config);\n    return {file, css};\n  }));</renderAllFiles>\n\n  <ensureOutputDir>\n  await fs.ensureDir(outputDir);</ensureOutputDir>\n\n  <writeRenderedFiles>\n  return Promise.all(renderedFiles.map(({file, css}) => {\n    const outputFile = getOutputFile(file, outputDir);\n    return writeFile(outputFile, css);\n  }));\n  </writeRenderedFiles>\n}\n"], ["parseExpression", "\nfunction parseExpression(str) {\n  <matchExpression>\n  var expMatches = str.match(expressionRegex)</matchExpression>\n\n  <parseArgumentsAndOptions>\n  var options = {}\n  var args = compact((expMatches[2] || '').split(argsRegex))\n    .filter(function (arg) {\n      var keyValue = arg.split('=')\n      return keyValue.length === 1 || (options[keyValue[0]] = keyValue[1], false)\n    })</parseArgumentsAndOptions>\n\n  <returnParsedResult>\n  return {\n    expression: expMatches[1] || null,\n    args: args,\n    options: options\n  }</returnParsedResult>\n}\n"], "```"]