[["starttls", "\nfunction starttls(socket, options, callback) {\n    var sslcontext, pair, cleartext;\n    socket.removeAllListeners('data');\n    \n    options.ciphers = options.ciphers || <sslCiphersConfiguration>'EDH+CAMELLIA:EDH+aRSA:EECDH+aRSA+AESGCM:EECDH+aRSA+SHA384'+\n            ':EECDH+aRSA+SHA256:EECDH:+CAMELLIA256:+AES256:+CAMELLIA128:+AES128:+SSLv3:!aNULL:!eNULL'+\n            ':!LOW:!3DES:!MD5:!EXP:!PSK:!SRP:!DSS:!RC4:!SEED:!ECDSA:CAMELLIA256-SHA:AES256-SHA:'+\n            'CAMELLIA128-SHA:AES128-SHA'</sslCiphersConfiguration>;\n    sslcontext = require('crypto').createCredentials(options);\n    pair = require('tls').createSecurePair(sslcontext, true, false, false);\n    cleartext = pipe(pair, socket);\n\n    pair.on('secure', <handleSecureEvent>function() {\n        var verifyError = (pair._ssl || pair.ssl).verifyError();\n\n        if (verifyError) {\n            cleartext.authorized = false;\n            cleartext.authorizationError = verifyError;\n        } else {\n            cleartext.authorized = true;\n        }\n\n        callback(cleartext);\n    }</handleSecureEvent>);\n\n    cleartext._controlReleased = true;\n    return pair;\n}\n"], ["_githubOrgRepo", "\nfunction _githubOrgRepo (gitUrl) {\n  if (!gitUrl) {\n    return null\n  }\n  const match = gitUrl.match(/.*?(:\\/\\/|@)github\\.com[/:](.*?)(#.*?)?$/)\n  return match && match[2] && match[2].replace(/\\.git$/, '')\n}\n"], ["genBitmapImage", "\nfunction genBitmapImage (oData) {\n  \n  // Image header information calculations\n  const biWidth = oData.width\n  const biHeight = oData.height\n  const biSizeImage = biWidth * biHeight * 3\n  const bfSize = biSizeImage + 54 \n\n  // BITMAPFILEHEADER creation\n  const BITMAPFILEHEADER = [\n    0x42, 0x4D,\n    bfSize & 0xff, bfSize >> 8 & 0xff, bfSize >> 16 & 0xff, bfSize >> 24 & 0xff,\n    0, 0,\n    0, 0,\n    54, 0, 0, 0\n  ]\n\n  // BITMAPINFOHEADER creation\n  const BITMAPINFOHEADER = [\n    40, 0, 0, 0,\n    biWidth & 0xff, biWidth >> 8 & 0xff, biWidth >> 16 & 0xff, biWidth >> 24 & 0xff,\n    biHeight & 0xff, biHeight >> 8 & 0xff, biHeight >> 16 & 0xff, biHeight >> 24 & 0xff,\n    1, 0,\n    24, 0,\n    0, 0, 0, 0,\n    biSizeImage & 0xff, biSizeImage >> 8 & 0xff, biSizeImage >> 16 & 0xff, biSizeImage >> 24 & 0xff,\n    0, 0, 0, 0,\n    0, 0, 0, 0,\n    0, 0, 0, 0,\n    0, 0, 0, 0\n  ]\n\n  // Calculate padding for scanlines\n  const iPadding = (4 - ((biWidth * 3) % 4)) % 4\n\n  // Process pixel data\n  const aImgData = oData.data\n  let strPixelData = ''\n  const biWidth4 = biWidth << 2\n  let y = biHeight\n  const fromCharCode = String.fromCharCode\n\n  do {\n    const iOffsetY = biWidth4 * (y - 1)\n    let strPixelRow = ''\n    for (let x = 0; x < biWidth; x++) {\n      let iOffsetX = x << 2\n      strPixelRow += fromCharCode(aImgData[iOffsetY + iOffsetX + 2]) +\n                     fromCharCode(aImgData[iOffsetY + iOffsetX + 1]) +\n                     fromCharCode(aImgData[iOffsetY + iOffsetX])\n    }\n\n    for (let c = 0; c < iPadding; c++) {\n      strPixelRow += String.fromCharCode(0)\n    }\n\n    strPixelData += strPixelRow\n  } while (--y)\n\n  // Combine and encode headers and pixel data\n  const strEncoded = encodeData(BITMAPFILEHEADER.concat(BITMAPINFOHEADER)) + encodeData(strPixelData)\n\n  return strEncoded\n}\n"], ["Noptify", "\nfunction Noptify(args, options) {\n  events.EventEmitter.call(this);\n  options = this.options = options || {};\n  this.args = args || process.argv;\n  this._program = options.program || <pathBasename>(path.basename(this.args[this.args[0] === 'node' ? 1 : 0]))</pathBasename>;\n\n  this._shorthands = {};\n  this._commands = {};\n  this._routes = [];\n  this._steps = [];\n  this.nopt = {};\n\n  <optionConfiguration>\n  this.option('help', '-h', 'Show help usage');\n  this.option('version', '-v', 'Show package version');\n  </optionConfiguration>\n}\n"], ["functionProxy", "\nfunction(to, from, fnName, setupFn) {\n  to[fnName] = function() {\n    if (setupFn) {\n      <setupFunction>setupFn();</setupFunction>\n    }\n    return from[fnName].apply(from, arguments);\n  };\n}\n"], ["processClass", "\nfunction processClass(clazz, computation) {\n  if (!clazz.methods.method) {\n    return;\n  }\n  if (clazz.methods.method instanceof Array) {\n\n    clazz.methods.method.forEach(function(method) {\n      ++computation.total;\n      \n      computation.passed = parseInt(method.hits) > 0 ? ++computation.passed : computation.passed;\n    });\n\n  } else { \n    ++computation.total;\n    computation.passed = parseInt(clazz.methods.method.hits) > 0 ? ++computation.passed : computation.passed;\n  }\n}\n"], ["LGraphFXLens", "\nfunction LGraphFXLens() {\n    this.addInput(\"Texture\", \"Texture\");\n    this.addInput(\"Aberration\", \"number\");\n    this.addInput(\"Distortion\", \"number\");\n    this.addInput(\"Blur\", \"number\");\n    this.addOutput(\"Texture\", \"Texture\");\n    this.properties = {\n        aberration: 1.0,\n        distortion: 1.0,\n        blur: 1.0,\n        precision: LGraphTexture.DEFAULT\n    };\n\n    if (!LGraphFXLens._shader) {\n        LGraphFXLens._shader = new GL.Shader(\n            GL.Shader.SCREEN_VERTEX_SHADER,\n            LGraphFXLens.pixel_shader\n        );\n        LGraphFXLens._texture = new GL.Texture(3, 1, {\n            format: gl.RGB,\n            wrap: gl.CLAMP_TO_EDGE,\n            magFilter: gl.LINEAR,\n            minFilter: gl.LINEAR,\n            pixel_data: [255, 0, 0, 0, 255, 0, 0, 0, 255]\n        });\n    }\n}\n"], ["findExpression", "\nfunction(editor, fn) {\n    var content = String(editor.getContent());\n    var il = content.length;\n    var exprStart = editor.getCaretPos() - 1;\n    var exprEnd = exprStart + 1;\n            \n    // Determine the start of expression\n    while (exprStart >= 0 && fn(content.charAt(exprStart), exprStart, content)) exprStart--;\n            \n    // Determine the end of expression\n    while (exprEnd < il && fn(content.charAt(exprEnd), exprEnd, content)) exprEnd++;\n            \n    // Return the found range if any\n    if (exprEnd > exprStart) {\n        return range([++exprStart, exprEnd]);\n    }\n}\n"], ["webpackObservableExtension", "\nfunction(module, exports, __webpack_require__) {\n\n    \"use strict\";\n    var Observable_1 = __webpack_require__(5);\n    var window_1 = __webpack_require__(593);\n    Observable_1.Observable.prototype.window = window_1.window;\n    \n}\n"], ["processGroupsKeys", "\nfunction processGroupsKeys(){\n    var GroupsKeys = [];\n\n    module.groups.forEach(function(table){\n        GroupsKeys.push({\n            value: table.get('id'),\n            text: table.get('name'),\n        });\n    });\n\n    module.GroupsKeys = GroupsKeys;\n}\n"], "```\n\nEach of the functions is enclosed in tags indicating its primary responsibility. In this case, no internal tags were necessary because each function had a single cohesive responsibility, hence being compliant with the Single Responsibility Principle (SRP)."]