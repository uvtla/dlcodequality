[["buildConstraints", "\nfunction buildConstraints(ctx) {\n    const res = [];\n\n    <fillLinearCombination>\n    function fillLC(dst, src) {\n        if (src.type != \"LINEARCOMBINATION\") throw new Error(\"Constraint is not a LINEARCOMBINATION\");\n        for (let s in src.values) {\n            const v = src.values[s].toString();\n            const id = ctx.signalName2Idx[s];\n            dst[id] = v;\n        }\n    }\n    </fillLinearCombination>\n\n    <createConstraintsList>\n    for (let i=0; i<ctx.constraints.length; i++) {\n        const A = {};\n        const B = {};\n        const C = {};\n\n        fillLC(A, ctx.constraints[i].a);\n        fillLC(B, ctx.constraints[i].b);\n        fillLC(C, ctx.constraints[i].c.negate());\n\n        res.push([A,B,C]);\n    }\n    </createConstraintsList>\n\n    return res;\n}\n"], ["addAllFilesAndSubdirectories", "\nfunction addAllFilesAndSubdirectories(dir, doneCallback) {\n    <resolveDirectory>\n    FileSystem.resolve(dir, function (err, directory) {\n        \n\n        <entryVisitor>\n        function visitor(entry) {\n            if (entry.isFile) {\n                if (!isFileExcluded(entry)) { \n                    addFilesToTern([entry.fullPath]);\n                }\n            } else {\n                \n\n\n                return !isDirectoryExcluded(entry.fullPath) &&\n                    entry.name.indexOf(\".\") !== 0 &&\n                    !stopAddingFiles;\n            }\n        }\n        </entryVisitor>\n\n        if (err) {\n            return;\n        }\n\n        <visitDirectoryCallback>\n        if (dir === FileSystem.getDirectoryForPath(rootTernDir)) {\n            doneCallback();\n            return;\n        }\n\n        directory.visit(visitor, doneCallback);\n        </visitDirectoryCallback>\n    });\n    </resolveDirectory>\n}\n"], ["evaluate", "\nfunction evaluate(expr) {\n    <expressionParser>\n    switch (expr[0]) {\n        case \"string\":\n        case \"num\":\n            return expr[1];\n        case \"name\":\n        case \"atom\":\n            <parsePrimitives>\n            switch (expr[1]) {\n                case \"true\": return true;\n                case \"false\": return false;\n                case \"null\": return null;\n            }\n            </parsePrimitives>\n            break;\n        case \"unary-prefix\":\n            <evaluateUnaryExpressions>\n            switch (expr[1]) {\n                case \"!\": return !evaluate(expr[2]);\n                case \"typeof\": return typeof evaluate(expr[2]);\n                case \"~\": return ~evaluate(expr[2]);\n                case \"-\": return -evaluate(expr[2]);\n                case \"+\": return +evaluate(expr[2]);\n            }\n            </evaluateUnaryExpressions>\n            break;\n        case \"binary\":\n            <evaluateBinaryExpressions>\n            var left = expr[2], right = expr[3];\n            switch (expr[1]) {\n                \n                case \"&&\"         : return evaluate(left) &&         evaluate(right);\n                case \"||\"         : return evaluate(left) ||         evaluate(right);\n                \n                case \"|\"          : return evaluate(left) |          evaluate(right);\n                case \"&\"          : return evaluate(left) &          evaluate(right);\n                case \"^\"          : return evaluate(left) ^          evaluate(right);\n                \n                case \"+\"          : return evaluate(left) +          evaluate(right);\n                case \"*\"          : return evaluate(left) *          evaluate(right);\n                case \"/\"          : return evaluate(left) /          evaluate(right);\n                case \"%\"          : return evaluate(left) %          evaluate(right);\n                case \"-\"          : return evaluate(left) -          evaluate(right);\n                \n                case \"<<\"         : return evaluate(left) <<         evaluate(right);\n                case \">>\"         : return evaluate(left) >>         evaluate(right);\n                case \">>>\"        : return evaluate(left) >>>        evaluate(right);\n                \n                case \"==\"         : return evaluate(left) ==         evaluate(right);\n                case \"===\"        : return evaluate(left) ===        evaluate(right);\n                case \"!=\"         : return evaluate(left) !=         evaluate(right);\n                case \"!==\"        : return evaluate(left) !==        evaluate(right);\n                \n                case \"<\"          : return evaluate(left) <          evaluate(right);\n                case \"<=\"         : return evaluate(left) <=         evaluate(right);\n                case \">\"          : return evaluate(left) >          evaluate(right);\n                case \">=\"         : return evaluate(left) >=         evaluate(right);\n                \n                case \"in\"         : return evaluate(left) in         evaluate(right);\n                case \"instanceof\" : return evaluate(left) instanceof evaluate(right);\n            }\n            </evaluateBinaryExpressions>\n    }\n    </expressionParser>\n    throw $NOT_CONSTANT;\n}\n"], ["extendObservableFromPromise", "\nfunction(module, exports, __webpack_require__) {\n\n    \"use strict\";\n    <attachFromPromiseToObservable>\n    var Observable_1 = __webpack_require__(5);\n    var fromPromise_1 = __webpack_require__(28);\n    Observable_1.Observable.fromPromise = fromPromise_1.fromPromise;\n    </attachFromPromiseToObservable>\n}\n"], ["bnpDLShiftTo", "\nfunction bnpDLShiftTo(n, r) {\n    <shiftArrayByN>\n    var i;\n    for (i = this.t - 1; i >= 0; --i)\n        r[i + n] = this[i];\n    for (i = n - 1; i >= 0; --i)\n        r[i] = 0;\n    r.t = this.t + n;\n    r.s = this.s;\n    </shiftArrayByN>\n}\n"], ["removeCallbacksFromArray", "\nfunction (callbacksMap, name, scope, fn, src, firstOnly) {\n    \n    if (callbacksMap == null) {\n        return; \n    }\n\n    <findAndRemoveCallbacks>\n    var arr = callbacksMap[name];\n\n    if (arr) {\n        var length = arr.length, removeThis = false, cb;\n        for (var i = 0; i < length; i++) {\n            cb = arr[i];\n\n            \n\n\n            removeThis = (!src || cb.src == src)\n                        \n                    && (!scope || scope == cb.scope)\n                    \n                    && (!fn || fn == cb.fn);\n\n            if (removeThis) {\n                \n                \n                \n                cb.removed = true;\n                arr.splice(i, 1);\n                if (firstOnly) {\n                    break;\n                } else {\n                    i--;\n                    length--;\n                }\n            }\n        }\n        if (arr.length === 0) {\n            \n            callbacksMap[name] = null;\n            delete callbacksMap[name];\n        }\n    }\n    </findAndRemoveCallbacks>\n}\n"], ["generateCosineMap", "\nfunction(N) {\n  <initializeCosMap>\n  cosMap = cosMap || {};\n  cosMap[N] = new Array(N*N);\n  </initializeCosMap>\n\n  <cosineComputation>\n  var PI_N = Math.PI / N;\n\n  for (var k = 0; k < N; k++) {\n    for (var n = 0; n < N; n++) {\n      cosMap[N][n + (k * N)] = Math.cos(PI_N * (n + 0.5) * k);\n    }\n  }\n  </cosineComputation>\n}\n"], ["setCookie", "\nfunction(name, value, options) {\n    <buildCookieObject>\n    var cookie = typeof options == 'object'\n        ? {value: value, expires: options.expires, secure: options.secure || false, new: options.new || false}\n        : {value: value}\n    </buildCookieObject>\n    <storeCookieIfNotExpired>\n    if (this.checkNotExpired(name, cookie)) {\n      this.cookies[name] = cookie\n    }\n    </storeCookieIfNotExpired>\n}\n"], ["initializeContext", "\nfunction Context(state, generics) {\n  <assignProperties>\n  this.state = state;\n  this.generics = generics;\n  this.namespace = state.g.opts.namespace;\n  this.target = state.g.opts.target;\n  this.module = state.g.opts.module;\n  this.skipImport = state.g.opts.skipImport;\n  </assignProperties>\n}\n"], ["TaskQueue", "\nfunction TaskQueue(listener) {\n    <initializeTaskQueue>\n    const _t = this;\n    _t._worker = null;\n    _t._taskList = [];\n    _t._requests = [];\n    if (listener == null) {\n        listener = function() { };\n    }\n    </initializeTaskQueue>\n\n    <defineTaskQueueMethod>\n    _t.taskQueue = function(tid, fn, pri) {\n        _t._taskList.push({\n            tid: tid,\n            fn: fn,\n            status: 0,\n            priority: pri,\n            step: function(tid) {\n                \n                \n                _log.t(tid, 'load:step');\n                listener(_t, 'load:step', {\n                    task: tid\n                });\n            },\n            end: function() {\n                this.status = 2;\n                let _h = this;\n                _log.t(_h.tid, 'load:next', 'timer:task:stop');\n                listener(_t, 'load:next', {\n                    task: _h.tid\n                });\n                _t._taskList.splice(this.index, 1);\n                _t.taskCheck();\n                if (this._callback != null) {\n                    this._callback.call(this);\n                }\n            },\n            callback: function(callback) {\n                this._callback = callback;\n            }\n        });\n        _log.t(tid, 'task added', pri, 'priority');\n        _t._taskList.sort(function(a, b) {\n            return (a.priority > b.priority) ?\n                1 :\n                ((b.priority > a.priority)\n                    ? -1 : 0);\n        } );\n        _t.taskCheck();\n    };\n    </defineTaskQueueMethod>\n\n    <defineTaskCheckMethod>\n    _t.taskCheck = function() {\n        for (let i = 0; i < _t._taskList.length; i++) {\n            if (_t._taskList[i].status === 0) {\n                _t._taskList[i].status = 1;\n                _log.t(_t._taskList[i].tid, 'load:begin', 'timer:task:start');\n                listener(_t, 'load:begin', {\n                    task: _t._taskList[i].tid\n                });\n                _t._taskList[i].index = i;\n                (_t._taskList[i].fn).call(_t._taskList[i]);\n                return;\n            } else if (_t._taskList[i].status === 1) {\n                \n                return;\n            } else if (_t._taskList[i].status === 2) {\n                \n                return;\n            }\n        }\n        _log.t('load:end');\n        listener(_t, 'load:end');\n    };\n    </defineTaskCheckMethod>\n}\n"], ""]