[["function1", "\nfunction(opts) {\n  <EventEmitterSetup>\n  EventEmitter.call(this);</EventEmitterSetup>\n  \n  <OptionsSetup>\n  this.opts = opts;\n  this.servers = {}; \n  this.serversMap = {}; \n  this.onlines = {}; \n  this.mailboxFactory = opts.mailboxFactory || defaultMailboxFactory;</OptionsSetup>\n\n  <HookSetup>\n  this.befores = [];\n  this.afters = [];</HookSetup>\n\n  <PendingSetup>\n  this.pendings = {};\n  this.pendingSize = opts.pendingSize || constants.DEFAULT_PARAM.DEFAULT_PENDING_SIZE;</PendingSetup>\n\n  <ConnectingSetup>\n  this.connecting = {};</ConnectingSetup>\n\n  <MailboxesSetup>\n  this.mailboxes = {};</MailboxesSetup>\n\n  <StateSetup>\n  this.state = STATE_INITED;</StateSetup>\n}\n"], ["function2", "\nfunction split_lines_by_child_nodes(lines) {\n  <NodeEntryLinesCalculation>\n  const node_entry_lines = lines.map((line, index) => {\n    return { tabs: line.tabs, index }\n  })\n  .filter(line => line.tabs === 0)\n  .map(line => line.index)</NodeEntryLinesCalculation>\n\n  <NodeEndingLinesCalculation>\n  const node_ending_lines = node_entry_lines.map(line_index => line_index - 1)\n  node_ending_lines.shift()\n  node_ending_lines.push(lines.length - 1)</NodeEndingLinesCalculation>\n\n  <ZipOperation>\n  const from_to = zip(node_entry_lines, node_ending_lines)</ZipOperation>\n\n  <SplittingLines>\n  return from_to.map(from_to => lines.slice(from_to[0], from_to[1] + 1))</SplittingLines>\n}\n"], ["function3", "\nfunction (simulated) {\n  <EventProcessing>\n  var processingEventQueue = eventQueue;\n  eventQueue = null;\n  if (simulated) {\n    forEachAccumulated_1(processingEventQueue, executeDispatchesAndReleaseSimulated);\n  } else {\n    forEachAccumulated_1(processingEventQueue, executeDispatchesAndReleaseTopLevel);\n  }</EventProcessing>\n  \n  <InvariantCheck>\n  !!eventQueue ? invariant(false, 'processEventQueue(): Additional events were enqueued while processing an event queue. Support for this has not yet been implemented.') : void 0;</InvariantCheck>\n  \n  <ErrorRethrowing>\n  ReactErrorUtils_1.rethrowCaughtError();</ErrorRethrowing>\n}\n"], ["function4", "\nfunction mimeTypeFromFilename(filename) {\n  <MimeTypeCalculation>\n  var ext = filename.split(\".\").pop().toLowerCase();\n  return mime.lookup(filename) || \"application/octet-stream\";</MimeTypeCalculation>\n}\n"], ["function5", "\nfunction UMLAttributeView() {\n  <LabelViewExtension>\n  LabelView.apply(this, arguments);</LabelViewExtension>\n  \n  <AttributeViewInit>\n  this.selectable = Core.SK_YES;\n  this.sizable = Core.SZ_NONE;\n  this.movable = Core.MM_NONE;\n  this.parentStyle = true;\n  this.horizontalAlignment = Graphics.AL_LEFT;</AttributeViewInit>\n}\n"], ["function6", "\nfunction initHeight(carousel, index) {\n  <ImageLoadingSetup>\n  let newImage = new Image()\n  newImage.src = carousel.querySelectorAll('.mip-carousel-slideBox')[index].querySelector('img').src\n  newImage.onload = () => {\n    [...carousel.querySelectorAll('.mip-placeholder')].map(value => value.parentNode.removeChild(value))\n    changeCarouselHeight(carousel, index, 0)\n  }</ImageLoadingSetup>\n}\n"], ["function7", "\nfunction toTypeRef(type) {\n  <TypeReferenceConversion>\n  if (!type) {\n    return (0, _typeOf.typeOf)(type);\n  } else if (type.constructor === String || type instanceof Function) {\n    return type;\n  }\n\n  return (0, _typeOf.typeOf)(type);</TypeReferenceConversion>\n}\n"], ["function8", "\nfunction add(data, unfilteredOptions) {\n  \n  \n  \n  \n  let options = this.filterOptions(unfilteredOptions, 'add', {extraAllowedProperties: ['id']});\n\n  <AddPostFunctionCreation>\n  const addPost = (() => {\n    return ghostBookshelf.Model.add.call(this, data, options)\n      .then((post) => {\n        return this.findOne({\n          status: 'all',\n          id: post.id\n        }, _.merge({transacting: options.transacting}, unfilteredOptions));\n      });\n  });</AddPostFunctionCreation>\n\n  <TransactionCheck>\n  if (!options.transacting) {\n    return ghostBookshelf.transaction((transacting) => {\n      options.transacting = transacting;\n\n      return addPost();\n    });\n  }</TransactionCheck>\n\n  <ExecuteAddPost>\n  return addPost();</ExecuteAddPost>\n}\n"], ["function9", "\nfunction getModel(app, name, Model) {\n  <MongooseClientRetrieval>\n  const mongooseClient = app.get('mongoose');\n  assert(mongooseClient, 'mongoose client not set by app');</MongooseClientRetrieval>\n  \n  <ModelNameCheck>\n  const modelNames = mongooseClient.modelNames();\n  if (modelNames.includes(name)) {\n    return mongooseClient.model(name);\n  } else {\n    assert(Model && typeof Model === 'function', 'Model function not privided.');\n    return Model(app, name);\n  }</ModelNameCheck>\n}\n"], ["function10", "\nfunction _toggleLivePreviewMultiBrowser(value) {\n  <PreferenceToggle>\n  var val = _togglePref(PREF_MULTIBROWSER, value);</PreferenceToggle>\n\n  <CommandStateUpdate>\n  CommandManager.get(Commands.TOGGLE_LIVE_PREVIEW_MB_MODE).setChecked(val);</CommandStateUpdate>\n      \n  <ProjectSettingsAvailability>\n  CommandManager.get(Commands.FILE_PROJECT_SETTINGS).setEnabled(!val);</ProjectSettingsAvailability>\n}\n"], "```\n\nThe annotations provide a visual breakdown of the responsibilities within each function. Functions 1, 2, 3, 6, 8, and 9 have been segmented into multiple parts due to the identification of different responsibilities that could potentially be managed by separate functions or objects to better adhere to the Single Responsibility Principle. Functions 4, 5, 7, and 10 are compliant with SRP as written, with a single cohesive responsibility."]