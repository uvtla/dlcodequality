[["serveFileResponse", "\nfunction serveFileResponse(cfg, fileResponse, res) {\n    <checkStandardResponse>\n    if (cfg.standardResponses && cfg.standardResponses[fileResponse.statusCode]) {\n        return cfg.standardResponses[fileResponse.statusCode](fileResponse);\n    }\n    </checkStandardResponse>\n\n    <writeResponseHeaders>\n    res.writeHead(fileResponse.statusCode, fileResponse.headers);\n    </writeResponseHeaders>\n\n    <sendResponseBody>\n    if (fileResponse.body && fileResponse.body.pipe) {\n        fileResponse.body.pipe(res);\n    }\n    else {\n        res.end(fileResponse.body);\n    }\n    </sendResponseBody>\n}\n"], ["isObjectASpecialForm", "\nfunction (obj) {\n    return _.has(obj, '$type') && _.has(obj, '$value') && _.size(obj) === 2;\n}\n"], ["authorize", "\nfunction authorize(newDoc, oldDoc, userContext, securityInfo, docDefinition) {\n    <checkUserContext>\n    if (utils.isValueNullOrUndefined(userContext)) {\n        throw unauthorizedResult();\n    }\n    </checkUserContext>\n\n    <resolveAuthorizations>\n    var authorizedRoles = resolveRequiredAuthorizations(newDoc, oldDoc, docDefinition.authorizedRoles);\n    var authorizedUsers = resolveRequiredAuthorizations(newDoc, oldDoc, docDefinition.authorizedUsers);\n    var grantAllMembersWriteAccess = utils.resolveDocumentConstraint(docDefinition.grantAllMembersWriteAccess);\n    </resolveAuthorizations>\n\n    <authorizeAccessChecks>\n    if (grantAllMembersWriteAccess) {\n        return authorizationSuccessResult(authorizedRoles, authorizedUsers);\n    } else if (isAdminUser(userContext, securityInfo)) {\n        return authorizationSuccessResult(authorizedRoles, authorizedUsers);\n    } else if (!authorizedRoles && !authorizedUsers) {\n        throw forbiddenResult();\n    }\n    </authorizeAccessChecks>\n\n    <matchRolesAndUsernames>\n    var roleMatch = hasAuthorizedRole(authorizedRoles, userContext.roles);\n    var usernameMatch = hasAuthorizedUsername(authorizedUsers, userContext.name);\n    if (!roleMatch && !usernameMatch) {\n        throw forbiddenResult();\n    } else {\n        return authorizationSuccessResult(authorizedRoles, authorizedUsers);\n    }\n    </matchRolesAndUsernames>\n}\n"], ["getBuild", "\nfunction getBuild(data, builder) {\n    <retrieveOrBuildData>\n    if (data.build !== undefined) return data.build;\n    data.build = builder(data);\n    return data.build;\n    </retrieveOrBuildData>\n}\n"], ["copy", "\nfunction copy(obj, map) {\n    <checkMapForCopy>\n    if (map.has(obj)) {\n        return map.get(obj);\n    }\n    </checkMapForCopy>\n\n    <copyArray>\n    else if (Array.isArray(obj)) {\n        const result = [];\n        map.set(obj, result);\n        obj.forEach(item => {\n            result.push(copy(item, map));\n        });\n        return result;\n    }\n    </copyArray>\n\n    <copyObject>\n    else if (typeof obj === 'object' && obj) {\n        const result = {};\n        map.set(obj, result);\n        Object.keys(obj).forEach(key => {\n            result[key] = copy(obj[key], map);\n        });\n        return result;\n    }\n    </copyObject>\n\n    <copyPrimitive>\n    else {\n        return obj;\n    }\n    </copyPrimitive>\n}\n"], ["resolveConfig", "\nfunction resolveConfig(fileName, options) {\n    options = options || {}\n    <configureSchemaAndFileNames>\n    var schema = options.schema\n    var resolvePackageJson = options.resolvePackageJson || false\n    var fileNames = [fileName, resolvePackageJson ? 'package.json' : null].filter(\n      item => !!item\n    )\n    </configureSchemaAndFileNames>\n\n    <readAndParseConfigs>\n    const results = upResolve(fileNames)\n    return Promise.all(results.map(readFileAsync))\n      .then(parseFiles(options))\n      .then(validateSchema(schema))\n      .then(reduceConfigs)\n    </readAndParseConfigs>\n}\n"], ["updateTexture2D", "\nfunction updateTexture2D(ctx, texture, opts) {\n    <setupTextureParameters>\n    const gl = ctx.gl\n    // A series of variable assignments relating to texture options and WebGL states...\n    var anisoExt = gl.getExtension('EXT_texture_filter_anisotropic')\n    const textureUnit = 0\n    gl.activeTexture(gl.TEXTURE0 + textureUnit)\n    gl.bindTexture(texture.target, texture.handle)\n    ctx.state.activeTextures[textureUnit] = texture\n    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, flipY)\n    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, premultiplayAlpha)\n    // gl.texParameteri code block\n    if (anisoExt && aniso > 0) {\n        gl.texParameterf(target, anisoExt.TEXTURE_MAX_ANISOTROPY_EXT, aniso)\n    }\n    </setupTextureParameters>\n\n    <updateTextureFromSource>\n    const img = opts.data ? opts.data : opts\n    // Code block that checks types of img and sets texture with texImage2D...\n    </updateTextureFromSource>\n\n    <generateMipmap>\n    if (opts.mipmap) {\n        gl.generateMipmap(texture.target)\n    }\n    </generateMipmap>\n\n    <updateTextureProperties>\n    texture.target = target\n    texture.pixelFormat = pixelFormat\n    texture.encoding = encoding\n    texture.min = min\n    texture.mag = mag\n    texture.wrapS = wrapS\n    texture.wrapT = wrapT\n    texture.format = format\n    texture.flipY = flipY\n    texture.internalFormat = internalFormat\n    texture.type = type\n    texture.info = ''\n    texture.info += Object.keys(ctx.PixelFormat).find(\n      (key) => ctx.PixelFormat[key] === pixelFormat\n    )\n    texture.info += '_'\n    texture.info += Object.keys(ctx.Encoding).find(\n      (key) => ctx.Encoding[key] === encoding\n    )\n    </updateTextureProperties>\n}\n"], ["Tick", "\nfunction Tick(pos, minor) {\n\tvar tick = this;\n    <initializeTick>\n\ttick.pos = pos;\n\ttick.minor = minor;\n\ttick.isNew = true;\n    </initializeTick>\n\n    <addLabelToTick>\n\tif (!minor) {\n\t\ttick.addLabel();\n\t}\n    </addLabelToTick>\n}\n"], ["getMixin1", "\nfunction getMixin1() {\n    const type = NodeType.MixinType;\n    const token = tokens[pos];\n    const line = token.ln;\n    const column = token.col;\n    <getMixinContent>\n    let content = [];\n    content.push(checkClass(pos) ? getClass() : getShash());\n    content = content.concat(getSC());\n    if (checkArguments(pos)) content.push(getArguments());\n    content = content.concat(getSC());\n    if (checkBlock(pos)) content.push(getBlock());\n    </getMixinContent>\n\n    <createMixinNode>\n    return newNode(type, content, line, column);\n    </createMixinNode>\n}\n"], ["newDestroy", "\nfunction newDestroy(sid, cb) {\n      <retrieveSession>\n      db.get(sid, function(err, session) {\n        if (err) return cb(err);\n        if (!session) return cb();\n        </retrieveSession>\n        <markSessionForDeletion>\n        db.set(sid + '_d', session, function(err) {\n          if (err) return cb(err);\n          </markSessionForDeletion>\n          \n          <performOldDestroy>\n          oldDestroy.call(db, sid, cb);\n          </performOldDestroy>\n        });\n      });\n}\n"], "```"]