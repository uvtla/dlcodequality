[["shiftLinesLeft", "\nfunction shiftLinesLeft(text) {\n    \n    <determineLinebreakAndSplit>\n    let linebreak = determineLinebreaks(text);\n    if (linebreak === \"\") return text;\n\n    let lines = [];\n    lines = text.split(linebreak);\n    </determineLinebreakAndSplit>\n\n    \n    <findCommonPrefix>\n    let commonPrefix = null;\n\n    for (let i = 0; i < lines.length; i++) {\n        if (!lines[i].length) continue;\n\n        let whitespace = lines[i].match(/^\\s*/);\n        if (whitespace) whitespace = whitespace[0];\n        else whitespace = \"\";\n\n        if (commonPrefix === null || commonPrefix.startsWith(whitespace)) commonPrefix = whitespace;\n    }\n    </findCommonPrefix>\n\n    \n    <shiftLinesAndReassembleText>\n    text = \"\";\n    let shift = commonPrefix.length;\n\n    for (let i = 0; i < lines.length; i++) {\n        if (lines[i].length) {\n            lines[i] = lines[i].slice(shift, lines[i].length);\n        }\n\n        text += lines[i] + linebreak;\n    }\n    </shiftLinesAndReassembleText>\n\n    return text;\n}\n"], ["sanitizeValue", "\nfunction (value) {\n\t\tif (value === null || value === undefined) {\n\t\t\treturn '';\n\t\t}\n\t\tswitch (typeof value) {\n\t\t\t<handleObject>\n\t\t\tcase 'object' :\n\t\t\t\tif (value instanceof Blob) {\n\t\t\t\t\treturn value;\n\t\t\t\t} else {\n\t\t\t\t\treturn JSON.stringify(value);\n\t\t\t\t}\n\t\t\t</handleObject>\n\t\t\t<handleString>\n\t\t\tcase 'string':\n\t\t\t\treturn value;\n\t\t\t</handleString>\n\t\t\t<handleDefault>\n\t\t\tdefault :\n\t\t\t\treturn value;\n\t\t\t</handleDefault>\n\t\t}\n\t}\n"], ["toggleSortOrder", "\nfunction (sortName, sortKeyGetter) {\n    this.$assert(326, sortName != null && sortKeyGetter != null);\n    if (this.sortOrder != this.SORT_INITIAL && this.sortName == sortName) {\n        <updateExistingSortOrder>\n        if (this.sortOrder == this.SORT_ASCENDING) {\n            this.sortOrder = this.SORT_DESCENDING;\n        } else {\n            this.$assert(330, this.sortOrder == this.SORT_DESCENDING);\n            this.sortOrder = this.SORT_ASCENDING;\n        }\n        </updateExistingSortOrder>\n    } else {\n        <initializeSortOrder>\n        this.sortName = sortName;\n        this.sortKeyGetter = this.$normCallback(sortKeyGetter);\n        this.sortOrder = this.SORT_ASCENDING;\n        </initializeSortOrder>\n    }\n}\n"], ["parseOptions", "\nfunction parseOptions (options) {\n  return {\n    <parseNormalOptions>\n    [ELEMENT_TYPE.NORMAL]: (options && options.html && options.html.normal) || 'always',\n    </parseNormalOptions>\n    <parseVoidOptions>\n    [ELEMENT_TYPE.VOID]: (options && options.html && options.html.void) || 'never',\n    </parseVoidOptions>\n    <parseComponentOptions>\n    [ELEMENT_TYPE.COMPONENT]: (options && options.html && options.html.component) || 'always',\n    </parseComponentOptions>\n    <parseSvgOptions>\n    [ELEMENT_TYPE.SVG]: (options && options.svg) || 'always',\n    </parseSvgOptions>\n    <parseMathOptions>\n    [ELEMENT_TYPE.MATH]: (options && options.math) || 'always'\n    </parseMathOptions>\n  }\n}\n"], ["refresh", "\nfunction refresh () {\n      <abortPreviousStream>\n      if (aborter) {\n        aborter.abort()\n      }\n      </abortPreviousStream>\n\n      <initializeStreamAbortion>\n      aborter = pullAbortable()\n      </initializeStreamAbortion>\n\n      <resetUIComponents>\n      updates.set(0)\n      content.set(h('section.content'))\n      </resetUIComponents>\n\n      <initializeScroller>\n      var scroller = Scroller(container, content(), renderMsg, err => {\n        if (err) console.log(err)\n        done.set(true)\n      })\n      </initializeScroller>\n\n      <executeDataStream>\n      pull(\n        getStream(query, false),\n        pull.through(() => count.set(count() + 1)),\n        aborter,\n        pull.filter(msg => msg.value),\n        scroller\n      )\n      </executeDataStream>\n\n      <setLoadingState>\n      loading.set(computed([done, scroller.queue], (done, queue) => {\n        return !done\n      }))\n      </setLoadingState>\n    }\n"], ["resizeAndProcessImage", "\nfunction (imagen, width, height, quality, type, ratio, centerCrop, resizeIf) {\n    <initializePromisesAndElements>\n    var deferred = $q.defer();\n    var canvasElement = document.createElement('canvas');\n    var imageElement = document.createElement('img');\n    imageElement.setAttribute('style', 'visibility:hidden;position:fixed;z-index:-100000');\n    document.body.appendChild(imageElement);\n    </initializePromisesAndElements>\n\n    <loadAndResizeImage>\n    imageElement.onload = function () {\n      try {\n        var imgWidth = imageElement.width, imgHeight = imageElement.height;\n        imageElement.parentNode.removeChild(imageElement);\n        if (resizeIf != null && resizeIf(imgWidth, imgHeight) === false) {\n            deferred.reject('resizeIf');\n            return;\n        }\n        <calculateDimensions>\n        if (ratio) {\n            var ratioFloat = upload.ratioToFloat(ratio);\n            var imgRatio = imgWidth / imgHeight;\n            if (imgRatio < ratioFloat) {\n                width = imgWidth;\n                height = width / ratioFloat;\n            } else {\n                height = imgHeight;\n                width = height * ratioFloat;\n            }\n        }\n        if (!width) {\n            width = imgWidth;\n        }\n        if (!height) {\n            height = imgHeight;\n        }\n        </calculateDimensions>\n        var dimensions = calculateAspectRatioFit(imgWidth, imgHeight, width, height, centerCrop);\n        canvasElement.width = Math.min(dimensions.width, width);\n        canvasElement.height = Math.min(dimensions.height, height);\n        var context = canvasElement.getContext('2d');\n        context.drawImage(imageElement,\n            Math.min(0, -dimensions.marginX / 2), Math.min(0, -dimensions.marginY / 2),\n            dimensions.width, dimensions.height);\n        deferred.resolve(canvasElement.toDataURL(type || 'image/WebP', quality || 0.934));\n      } catch (e) {\n        deferred.reject(e);\n      }\n    };\n    </loadAndResizeImage>\n\n    <handleImageError>\n    imageElement.onerror = function () {\n      imageElement.parentNode.removeChild(imageElement);\n      deferred.reject();\n    };\n    </handleImageError>\n\n    <setSourceAndReturnPromise>\n    imageElement.src = imagen;\n    return deferred.promise;\n    </setSourceAndReturnPromise>\n  }\n"], ["drawPacman", "\nfunction(node,x,y,size,color,context) {\n    <drawPacmanBody>\n    context.fillStyle = 'yellow';\n    context.beginPath();\n    context.arc(x,y,size,1.25*Math.PI,0,false);\n    context.arc(x,y,size,0,0.75*Math.PI,false);\n    context.lineTo(x,y);\n    context.closePath();\n    context.fill();\n    </drawPacmanBody>\n\n    <drawPacmanEye>\n    context.fillStyle = 'white';\n    context.strokeStyle = 'black';\n    context.beginPath();\n    context.arc(x+size/3,y-size/3,size/4,0,2*Math.PI,false);\n    context.closePath();\n    context.fill();\n    context.stroke();\n    </drawPacmanEye>\n\n    <drawPacmanPupil>\n    context.fillStyle = 'black';\n    context.beginPath();\n    context.arc(x+4*size/9,y-size/3,size/8,0,2*Math.PI,false);\n    context.closePath();\n    context.fill();\n    </drawPacmanPupil>\n  }\n"], ["precendence", "\nfunction precendence(operator) {\n    <getExistingPrecendence>\n    let result;\n    result = precendenceValues[operator];\n    if (result !== undefined) {\n        return result;\n    }\n    </getExistingPrecendence>\n\n    <calculatePrecendenceValue>\n    switch (operator) {\n        case AND:\n        case ALL:\n        case ANY:\n        case NOT:\n        case OR:\n            return 1;\n        case VALUE:\n            return 2;\n        case EQUALS:\n        default:\n            return -1;\n    }\n    </calculatePrecendenceValue>\n}\n"], ["destroyDocument", "\nfunction destroyDocument(params) {\n  <getCollection>\n  var collection = collections[params.collection]\n  if (collection === undefined) {\n    return false\n  }\n  </getCollection>\n\n  <deleteDocument>\n  var doc = collection[params.id]\n  delete collection[params.id]\n  </deleteDocument>\n\n  <emitEvent>\n  eventEmitter.emit('documentDestroyed', params.collection, doc)\n  </emitEvent>\n\n  return true\n}\n"], ["getEnrichedConfig", "\nfunction getEnrichedConfig(rule, config) {\n\tif (!config) { return rule; }\n\n\t<modifyInclude>\n\tif (config.include) {\n\t\trule.include = config.include;\n\t}\n\t</modifyInclude>\n\t<modifyExclude>\n\tif (config.exclude) {\n\t\trule.exclude = config.exclude;\n\t}\n\t</modifyExclude>\n\treturn rule;\n}\n"], ""]