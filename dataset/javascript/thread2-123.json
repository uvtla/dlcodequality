[["function1", "\nfunction(key, done) {\n  <checkForKey>\n  if(!this._key) {\n    done('no key found for metadata');\n    return;\n  }\n  </checkForKey>\n  <searchForKey>\n  var ret = null; \n  for(var i = 0; i < this._data.length; i++) {\n    if(this._data[i][this._key.getName()] === key) {\n      ret = this._clone(this._data[i]);\n      break;\n    }\n  }\n  </searchForKey>\n  done(null, ret);\n}\n"], ["sanitisePath", "\nfunction sanitisePath(path, queueObject) {\n  <normalizePath>\n  path = path.replace(/^\\//, \"\").replace(/^\\\\/, \"\");\n  </normalizePath>\n\n  <initializePathStack>\n  var pathStack = [];\n  </initializePathStack>\n\n  <sanitizeAndSplitPath>\n  var sanitisedPath = path.length ? path.replace(/\\s*$/ig, \"\") : \"index.html\";\n  </sanitizeAndSplitPath>\n\n  <parseHeaders>\n  var headers = queueObject.stateData.headers, sanitisedPathParts;\n  </parseHeaders>\n\n  <processQueryStrings>\n  if (sanitisedPath.match(/\\?/)) {\n    sanitisedPathParts = sanitisedPath.split(/\\?/g);\n    var resource = sanitisedPathParts.shift();\n    var hashedQS = crypto.createHash(\"sha1\").update(sanitisedPathParts.join(\"?\")).digest(\"hex\");\n    sanitisedPath = resource + \"?\" + hashedQS;\n  }\n  </processQueryStrings>\n\n  <splitAndSanitizeChunks>\n  pathStack = sanitisedPath.split(/\\//);\n  pathStack = pathStack.map(function(pathChunk) {\n    if (pathChunk.length >= 250) {\n      return crypto.createHash(\"sha1\").update(pathChunk).digest(\"hex\");\n    }\n    return pathChunk;\n  });\n  </splitAndSanitizeChunks>\n\n  <joinPathStack>\n  sanitisedPath = pathStack.join(\"/\");\n  </joinPathStack>\n\n  <appendFileExtension>\n  if (!sanitisedPath.match(/\\.[a-z0-9]{1,6}$/i) || headers[\"content-type\"] && headers[\"content-type\"].match(/text\\/html/i) && !sanitisedPath.match(/\\.htm[l]?$/i)) {\n    var subMimeType = \"\";\n    var mimeParts = [];\n    if (headers[\"content-type\"] && headers[\"content-type\"].match(/text\\/html/i)) {\n      if (sanitisedPath.match(/\\/$/)) {\n        sanitisedPath += \"index.html\";\n      } else {\n        sanitisedPath += \".html\";\n      }\n    } else if (headers[\"content-type\"] && (mimeParts = headers[\"content-type\"].match(/(image|video|audio|application)\\/([a-z0-9]+)/i))) {\n      subMimeType = mimeParts[2];\n      sanitisedPath += \".\" + subMimeType;\n    }\n  }\n  </appendFileExtension>\n\n  return sanitisedPath;\n}\n"], ["Falcon", "\nfunction Falcon(options) {\n  <logAction>\n  debug('constructor', options)\n  </logAction>\n  <initializeOptions>\n  options = options || {}\n  </initializeOptions>\n\n  <setupProperties>\n  this._lock = false\n  this._queue = []\n  this._increment = {}\n  </setupProperties>\n\n  <configureStep>\n  this.step(options.step === undefined ? Falcon.DEFAULT_STEP : options.step)\n  </configureStep>\n  <configureProjectTag>\n  if (Falcon.PROJECT) {\n    this.tag('project', Falcon.PROJECT)\n  }\n  </configureProjectTag>\n  <setupDefaultHandler>\n  this._handler = options.handler || Falcon.DEFAULT_HANDLER\n  </setupDefaultHandler>\n  <processAdditionalTags>\n  if (options.tags) {\n    this.tag(options.tags)\n  }\n  </processAdditionalTags>\n}\n"], ["indentClassLeft", "\nfunction indentClassLeft( node, classes ) {\n  <checkIndentClass>\n  var indentClass = node.$.className.match( this.classNameRegex ),\n    isIndent = this.isIndent;\n  </checkIndentClass>\n\n  <determineClass>\n  if ( indentClass )\n    return isIndent ? indentClass[ 1 ] != classes.slice( -1 ) : true;\n  else\n    return isIndent;\n  </determineClass>\n}\n"], ["duplicatePeriod", "\nfunction (period) {\n  <checkOnDuplicatePeriod>\n  if (!this.settings.onDuplicatePeriod.call(this, period, this.element)) {\n  </checkOnDuplicatePeriod>\n    <calculatePositionAndHeight>\n    var options = this.periodData(period);\n    var position = Math.round(period.position().top / this.periodPosition);\n    var height = Math.round(period.height() / this.periodPosition);\n    </calculatePositionAndHeight>\n\n    <addPeriodToEachDay>\n    var $this = this;\n    $('.jqs-day', this.element).each(function (index, parent) {\n      $this.add(parent, position, height, options);\n    });\n    </addPeriodToEachDay>\n\n    <closeOptionsInterface>\n    this.closeOptions();\n    </closeOptionsInterface>\n  }\n}\n"], ["wrapInlinesInParagraphs", "\nfunction ($from) {\n  if ($from.length !== 0) {\n    <wrapAndCreateParagraph>\n    var $finalParagraph = $from.nextUntil(blockElementsSelector).addBack().wrapAll('<p/>').parent(),\n      $nextElement = $finalParagraph.nextAll(inlineElementsSelector).first();\n    </wrapAndCreateParagraph>\n    <cleanupAndContinue>\n    $finalParagraph.next('br').remove();\n    wrapInlinesInParagraphsFrom($nextElement);\n    </cleanupAndContinue>\n  }\n}\n"], ["readData", "\nfunction readData(raw){\n  <deserializeData>\n  var dataObj = micro.toJSON(new Buffer(raw));\n  var type = dataObj._type;\n  delete dataObj._type;\n  </deserializeData>\n\n  <processDataByType>\n  switch (type){\n    case \"Ping\":\n      <updateLatencyAndEcho>\n      latency = dataObj.latency || latency;\n      socket.send(raw);\n      </updateLatencyAndEcho>\n      break;\n\n    case \"GameData\" :\n      <setGameData>\n      gameData.set(dataObj);\n      currentZone = gameData.currentZone.update(latency);\n      </setGameData>\n      break;\n\n    case \"Zone\":\n      <updateZone>\n      if (!gameData.get(\"isRunning\")) return;\n      dataObj = new Zone(dataObj).update(latency).toJSON();\n      currentZone.set(dataObj, {easing:true, silent:true});\n      </updateZone>\n      break;\n\n    case \"Player\":\n      <updatePlayer>\n      if (!gameData.get(\"isRunning\")) return;\n      dataObj = new Player(dataObj).update(latency).toJSON();\n      currentZone.players.set(dataObj, {easing:true, remove:false, silent:true});\n      </updatePlayer>\n      break;\n\n    case \"PlayerUpdate\":\n      <processPlayerUpdate>\n      if (!gameData.get(\"isRunning\")) return;\n      currentZone.players.set(dataObj, {add:false, remove:false, silent:true});\n      </processPlayerUpdate>\n      break;\n\n    default:\n      <handleUnknownType>\n      console.warn(\"Unknown schema type received: \"+type);\n      </handleUnknownType>\n      break;\n  }\n  </processDataByType>\n}\n"], ["bnBitCount", "\nfunction bnBitCount() {\n  <bitCountCalculation>\n  var r = 0, x = this.s&this.DM;\n  for(var i = 0; i < this.t; ++i) r += cbit(this.data[i]^x);\n  return r;\n  </bitCountCalculation>\n}\n"], ["roundSHA2", "\nfunction roundSHA2(block, H, variant) {\n  <initializeSHA2Variables>\n  var a, b, c, d, e, f, g, h, T1, T2, numRounds, t, binaryStringMult,\n      safeAdd_2, safeAdd_4, safeAdd_5, gamma0, gamma1, sigma0, sigma1,\n      ch, maj, Int, W = [], int1, int2, offset, K;\n  </initializeSHA2Variables>\n\n  <configureSHA2Computation>\n  numRounds = 64;\n  binaryStringMult = 1;\n  Int = Number;\n  safeAdd_2 = safeAdd_32_2;\n  safeAdd_4 = safeAdd_32_4;\n  safeAdd_5 = safeAdd_32_5;\n  gamma0 = gamma0_32;\n  gamma1 = gamma1_32;\n  sigma0 = sigma0_32;\n  sigma1 = sigma1_32;\n  maj = maj_32;\n  ch = ch_32;\n  K = K_sha2;\n  </configureSHA2Computation>\n\n  <initWorkingVars>\n  a = H[0];\n  b = H[1];\n  c = H[2];\n  d = H[3];\n  e = H[4];\n  f = H[5];\n  g = H[6];\n  h = H[7];\n  </initWorkingVars>\n\n  <performSHA2Core>\n  for (t = 0; t < numRounds; t += 1) {\n    if (t < 16) {\n      <initializeMessageSchedule>\n      offset = t * binaryStringMult;\n      int1 = (block.length <= offset) ? 0 : block[offset];\n      int2 = (block.length <= offset + 1) ? 0 : block[offset + 1];\n      W[t] = new Int(int1, int2);\n      </initializeMessageSchedule>\n    } else {\n      W[t] = safeAdd_4(\n              gamma1(W[t - 2]), W[t - 7],\n              gamma0(W[t - 15]), W[t - 16]\n          );\n    }\n    T1 = safeAdd_5(h, sigma1(e), ch(e, f, g), K[t], W[t]);\n    T2 = safeAdd_2(sigma0(a), maj(a, b, c));\n    h = g;\n    g = f;\n    f = e;\n    e = safeAdd_2(d, T1);\n    d = c;\n    c = b;\n    b = a;\n    a = safeAdd_2(T1, T2);\n  }\n  </performSHA2Core>\n\n  <updateHashValues>\n  H[0] = safeAdd_2(a, H[0]);\n  H[1] = safeAdd_2(b, H[1]);\n  H[2] = safeAdd_2(c, H[2]);\n  H[3] = safeAdd_2(d, H[3]);\n  H[4] = safeAdd_2(e, H[4]);\n  H[5] = safeAdd_2(f, H[5]);\n  H[6] = safeAdd_2(g, H[6]);\n  H[7] = safeAdd_2(h, H[7]);\n  </updateHashValues>\n\n  return H;\n}\n"], ["parseConfig", "\nfunction(config) {\n  <mapServices>\n  var services = _.map(config, function(data, key) {\n    <mapRoutes>\n    var routes = _.map(data, function(route) {\n      return {\n        port: route.port,\n        urls: getRouteUrls(route)\n      };\n    });\n    </mapRoutes>\n    return {\n      name: key,\n      routes: routes\n    };\n  });\n  </mapServices>\n\n  <countURLs>\n  var urlCount = getUrlsCounts(services);\n  </countURLs>\n  <checkForDuplicateURLs>\n  var hasDupes = _.reduce(urlCount, function(result, count) {\n    return count > 1 || result;\n  }, false);\n  </checkForDuplicateURLs>\n\n  <throwErrorOnDuplicates>\n  if (hasDupes) {\n    throw new Error(format('Duplicate URL detected: %j', urlCount));\n  }\n  </throwErrorOnDuplicates>\n\n  return services;\n}\n"], ""]