[["shutdownServer", "\nfunction() {\n  <logShutdown>\n  debug('shutting down...');\n  </logShutdown>\n\n  var app = this;\n  var server = this.server;\n\n  if (!server) return Promise.resolve();\n\n  return co.wrap(function* () {\n    <executeShutdownHook>\n    yield this.hookFor('shutdown');\n    </executeShutdownHook>\n  }).call(this).then(function() {\n    <closeServer>\n    server.close(function() { \n      <logGoodbye>\n      debug('goodbye!'); \n      </logGoodbye>\n    });\n    </closeServer>\n  });\n}\n"], ["swapValuesInArray", "\nfunction swapValuesInArray (A, i, j) {\n  if (i !== j) {\n    const tmp = A[i];\n    A[i] = A[j];\n    A[j] = tmp;\n  }\n  return A;\n}\n"], ["showRequiredStar", "\nfunction showRequiredStar(validators) {\n  if (!validators) {\n    return false;\n  }\n  return validators.find(({type, type2}) => type === 'required' || type2 === 'required') !== undefined;\n}\n"], ["each", "\nfunction each (opts, callback) {\n  if (!callback) {\n    callback = opts\n    opts = { order: 'created' }\n  }\n\n  var store = this.store\n  return new Promise(function (resolve) {\n    function nextPage (get) {\n      get().then(function (page) {\n        var result\n        for (var i = page.entries.length - 1; i >= 0; i--) {\n          var entry = page.entries[i]\n          result = callback(entry[0], entry[1])\n          if (result === false) break\n        }\n\n        if (result === false || !page.next) {\n          resolve()\n        } else {\n          nextPage(page.next)\n        }\n      })\n    }\n\n    nextPage(store.get.bind(store, opts))\n  })\n}\n"], ["setAttributeSVG", "\nfunction(svg){\n  if (!svg){\n    throw new Error('.toString: No SVG found.');\n  }\n\n  [\n    ['version', 1.1],\n    ['xmlns', \"http://www.w3.org/2000/svg\"]\n  ].forEach(function(item){\n    svg.setAttribute(item[0], item[1]);\n  });\n  return svg.outerHTML;\n}\n"], ["processFile", "\nfunction processFile() {\n  const options = {};\n  return (file, callback) => {\n    <minifyCSS>\n    const data = csso.minify(file.data, options).css;\n    </minifyCSS>\n    <callbackWithData>\n    async.nextTick(callback, null, Object.assign({}, file, { data }));\n    </callbackWithData>\n  };\n}\n"], ["sanitizeHTML", "\nfunction( inputHtml ) {\n  inputHtml = inputHtml.toString();\n  return inputHtml.replace(/&/g, \"&amp;\").replace(/</g, \"&lt;\").replace(/>/g, \"&gt;\").replace(/<script(.*?)script>/gi, \"\");\n}\n"], ["removeKeysFromArray", "\nfunction removeKeysFromArray (array, props, recursive = false) {\n  const res = []\n  let val = {}\n\n  if (!array.length) {\n    return res\n  }\n\n  for (let i = 0; i < array.length; i++) {\n    if (isObject(array[i])) {\n      val = removeKeysFromObject(array[i], props, recursive)\n    } else if (isArray(array[i])) {\n      val = removeKeysFromArray(array[i], props, recursive)\n    } else {\n      val = array[i]\n    }\n\n    res.push(val)\n  }\n\n  return res\n}\n"], ["updateTooltipPosition", "\nfunction(event_name, event_object) {\n  this._tooltip.set('x', event_object.page.x); \n  this._tooltip.set('y', event_object.page.y); \n}\n"], ["blocksToMarkdown", "\nfunction blocksToMarkdown(blocks, level, threshold) {\n  var md = [];\n\n  <sanitizeLevelVariable>\n  if (level < 1 || level > 6) {\n    level = 1;\n  }\n  </sanitizeLevelVariable>\n\n  nextBlock: for (i = 0; i < blocks.length; i++) {\n    let tagArgs = null;\n    let isClass = false;\n    let visibility = '';\n    let type = '';\n    let name = '';\n    let implem = '';\n    let params = [];\n    let returnType = '';\n    let returnDesc = '';\n\n    <processTags>\n    for (j = 0; j < blocks[i].tags.length; j++) {\n      let tag = blocks[i].tags[j];\n      // ... code for processing tags ...\n    }\n    </processTags>\n\n    <prepareMarkdownOutput>\n    // ... code to compile the markdown string based on previous processing ...\n    </prepareMarkdownOutput>\n  }\n\n  return md.join('');\n}\n"], "```\n\nIn the first function, there are discrete responsibilities such as logging, hook execution, and server closing, which makes it non-compliant with SRP within the larger function tag. The second and third functions do not contain separate blocks of responsibilities and are tagged as one responsibility each. The fourth function (<each>) may have nuanced responsibilities, such as setting defaults and actual iteration logic; however, because the iterations' intent is to execute a passed callback which could encompass various operations, I've kept it under one tag. \n\nFor functions like processFile and removeKeysFromArray, the recursive aspect or separate steps within file processing could imply separate responsibilities, but in the essence of a single overarching task, I've kept them each under one tag. The sanitizeHTML function is a straightforward case following a single responsibility for HTML sanitization.\n\nLastly, the blocksToMarkdown function processes JSDoc comments into markdown and has several discrete tasks, such as sanitizing levels, processing tags, and preparing the markdown output. These have been divided into separate responsibilities."]