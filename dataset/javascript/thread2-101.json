[["getPageClonePutOperations", "\nfunction getPageClonePutOperations(pageData, locals) {\n  return bluebird.all(_.reduce(pageData, (promises, pageValue, pageKey) => {\n    if (typeof pageValue === 'string' && getComponentName(pageValue)) {\n      <getPutOperations>\n      promises.push(components.get(pageValue, locals)\n        .then(refData => composer.resolveComponentReferences(refData, locals, isInstanceReferenceObject))\n        .then(resolvedData => {\n          <renameReferences>\n          _.each(references.listDeepObjects(resolvedData, isInstanceReferenceObject), obj => {\n            obj._ref = renameReferenceUniquely(obj._ref);\n          });\n          </renameReferences>\n\n          <trackPageDataAssignment>\n          const ref = renameReferenceUniquely(pageValue);\n          pageData[pageKey] = ref;\n          </trackPageDataAssignment>\n\n          <getComponentPutOperations>\n          return dbOps.getPutOperations(components.cmptPut, ref, resolvedData, locals);\n          </getComponentPutOperations>\n        }));\n      </getPutOperations>\n    } else {\n      <recursivePageClonePutOperations>\n      promises = promises.concat(getPageClonePutOperations(pageValue, locals));\n      </recursivePageClonePutOperations>\n    }\n    return promises;\n  }, [])).then(_.flatten); \n}\n"], ["baseDifference", "\nfunction baseDifference(array, values) {\n  <initializeVariables>\n  var index = -1,\n      indexOf = getIndexOf(),\n      length = array ? array.length : 0,\n      isLarge = length >= largeArraySize && indexOf === baseIndexOf,\n      result = [];\n  </initializeVariables>\n\n  <largeArrayOptimization>\n  if (isLarge) {\n    var cache = createCache(values);\n    if (cache) {\n      indexOf = cacheIndexOf;\n      values = cache;\n    } else {\n      isLarge = false;\n    }\n  }\n  </largeArrayOptimization>\n\n  <filterArray>\n  while (++index < length) {\n    var value = array[index];\n    if (indexOf(values, value) < 0) {\n      result.push(value);\n    }\n  }\n  </filterArray>\n\n  <releaseLargeArrayCache>\n  if (isLarge) {\n    releaseObject(values);\n  }\n  </releaseLargeArrayCache>\n  return result;\n}\n"], ["lockUnlockedInputs", "\nfunction lockUnlockedInputs(container, disable) {\n  var j, i, inputs, nInputs;\n  <defaultParameterSetup>\n  if ('undefined' === typeof disable) disable = true;\n  </defaultParameterSetup>\n\n  <toggleInputLocks>\n  for (j = -1; ++j < len; ) {\n      inputs = container.getElementsByTagName(inputTags[j]);\n      nInputs = inputs.length;\n      for (i = -1 ; ++i < nInputs ; ) {\n          if (disable) {\n              if (!inputs[i].disabled) {\n                  inputs[i].disabled = true;\n                  W.waitScreen.lockedInputs.push(inputs[i]);\n              }\n          }\n          else {\n              if (inputs[i].disabled) {\n                  inputs[i].disabled = false;\n              }\n          }\n      }\n  }\n  </toggleInputLocks>\n\n  <resetLockedInputs>\n  if (!disable) W.waitScreen.lockedInputs = [];\n  </resetLockedInputs>\n}\n"], ["removeEventListeners", "\nfunction () {\n  eventUtil.removeListener(Aria.$window.document.body, \"mousedown\", {\n    fn : this._onMouseDown,\n    scope : this\n  });\n  eventUtil.removeListener(Aria.$window.document.body, \"touchstart\", {\n    fn : this._onMouseDown,\n    scope : this\n  });\n  disconnectMouseEvents(this);\n}\n"], ["zeroFillArray", "\nfunction zero_fill_array(n) {\n  var o = new Array(n);\n  for(var i = 0; i < n; ++i) o[i] = 0;\n  return o;\n}\n"], ["cook", "\nfunction cook (trv) {\n  <replaceEscapeSequences>\n  return trv.replace(\n    ESCAPE_SEQUENCE,\n    (escSeq) => {\n      const chr = escSeq.charAt(1)\n      const repl = SV_TABLE[chr]\n      if (repl === undefined) { \n        return chr\n      }\n      if (typeof repl === 'function') {\n        return repl(escSeq)\n      }\n      return repl\n    })\n  </replaceEscapeSequences>\n}\n"], ["maxValueNode", "\nfunction maxValueNode(root) {\n  <traverseRightTree>\n  var current = root;\n  while (current.right) {\n    current = current.right;\n  }\n  </traverseRightTree>\n  return current;\n}\n"], ["decryptData", "\nfunction(data) {\n  <validateDataFormat>\n  if (!(data && 'function' === typeof data.isBase64 && data.isBase64())) {\n    throw new CError('wrong data format to decrypt').log();\n  }\n  </validateDataFormat>\n  <parseDecryptedData>\n  return JSON.parse(this.encoder.decryptAes(data, this.getSecret()));\n  </parseDecryptedData>\n}\n"], ["unmount", "\nfunction unmount(asSub) {\n  var vm = this;\n  \n  var node = vm.node;\n  var parEl = node.el.parentNode;\n\n  <removeChildElement>\n  removeChild(parEl, node.el);\n  </removeChildElement>\n\n  <nullifyNodeElement>\n  node.el = null;\n  </nullifyNodeElement>\n\n  <triggerDidHooks>\n  if (!asSub) { drainDidHooks(vm, true); }\n  </triggerDidHooks>\n}\n"], ["cleanup", "\nfunction cleanup() {\n  <awaitCloseLiveBrowser>\n  var closeDeferred = (brackets.platform === \"mac\") ? NativeApp.closeLiveBrowser() : $.Deferred().resolve();\n  closeDeferred.done(function () {\n    <setStatusInactive>\n    _setStatus(STATUS_INACTIVE, reason || \"explicit_close\");\n    </setStatusInactive>\n\n    <removeLiveDevServers>\n    _regServers.forEach(function (server) {\n        LiveDevServerManager.removeServer(server);\n    });\n    _regServers = [];\n    </removeLiveDevServers>\n\n    <resolveCloseDeferred>\n    _closeDeferred.resolve();\n    </resolveCloseDeferred>\n  }).fail(function (err) {\n    <errorHandling>\n    if (err) {\n        reason +=  \" (\" + err + \")\";\n    }\n    _setStatus(STATUS_INACTIVE, reason || \"explicit_close\");\n    _closeDeferred.resolve();\n    </errorHandling>\n  });\n}\n"], "```"]