[["saveItemService", "\nfunction saveItemService(app) {\n    <apiSetup>\n    apiService.call(this);\n    this.setApp(app);\n    </apiSetup>\n\n    var service = this;\n\n    <needRequiredFields>\n    service.needRequiredFields = function(params, list) {\n\n        <fieldValidation>\n        for(var i=0; i<list.length; i++)\n        {\n            if (!params[list[i]]) {\n                service.outcome.errfor[list[i]] = 'required';\n                service.httpstatus = 400; \n                service.outcome.success = false;\n            }\n        }\n        </fieldValidation>\n\n        <errorHandling>\n        if (service.hasErrors()) {\n            service.deferred.reject(new Error('Missing mandatory fields'));\n            return true;\n        }\n        </errorHandling>\n\n        return false;\n    };\n    </needRequiredFields>\n}\n"], ["startServer", "\nfunction startServer() {\n    <serverInitialization>\n    this._flo = flo(\n      this.config.publicPath,\n      extend(\n        pick(this.config, FB_FLO_OPTIONS),\n        { glob: ['***.css'] }\n      ),\n      this.resolver\n    );\n    </serverInitialization>\n}\n"], ["findMaximumPropertyValue", "\nfunction(items, propertyName) {\n    if(!items) return false;\n\n    var maxProperty;\n    <computeMaxProperty>\n    for(var i = 0; i < items.length; i++) {\n        if(maxProperty == undefined)\n            maxProperty = items[i][propertyName];\n        else if(items[i][propertyName] > maxProperty)\n            maxProperty = items[i][propertyName];\n    }\n    </computeMaxProperty>\n    return maxProperty;\n}\n"], ["sourcePath", "\nfunction sourcePath(path_request) {\n    <normalizeRequest>\n    if (path_request.path) {\n      path_request = path_request.path;\n    }\n    path_request = clean_path(path_request);\n    </normalizeRequest>\n\n    <splitPath>\n    var tmp = path_request.split('/');\n    </splitPath>\n\n    <languageCheck>\n    if (_.get(project, 'site.languages.' + tmp[0])) {\n      tmp.shift();\n    }\n    </languageCheck>\n\n    return tmp.join('/');\n}\n"], ["configureTextAttributes", "\nfunction(o) {\n    <setAttribute>\n    for (var k in o)\n        k == 'leading' ?\n            this.leading(o[k]) :\n        k == 'anchor' ?\n            this.attr('text-anchor', o[k]) :\n        k == 'size' || k == 'family' || k == 'weight' || k == 'stretch' || k == 'variant' || k == 'style' ?\n            this.attr('font-'+ k, o[k]) :\n            this.attr(k, o[k])\n    </setAttribute>\n\n    return this\n}\n"], ["handleRouter", "\nfunction handle(router, method, file) {\n    <methodCheck>\n    if (method && typeof method === 'object') return router.all(method);\n    if (!router.routes.has(method)) {\n        throw new Error(`Router handler \"${method}\" does not exist`);\n    }\n    </methodCheck>\n    <applyRouteHandlers>\n    for (let route of router.routes.get(method)) route.handle(file);\n    </applyRouteHandlers>\n    return file;\n}\n"], ["SocketClient", "\nfunction SocketClient (socket) {\n    var that = this;\n\n    <socketSetup>\n    this.socket = socket;\n    this.socket_closing = false;\n\n    this.remoteAddress = this.socket.remoteAddress;\n    winston.info('Control connection from %s opened', this.socket.remoteAddress);\n\n    this.bindEvents();\n\n    socket.write(\"\\nHello, you are connected to the Kiwi server :)\\n\\n\");\n    </socketSetup>\n\n    <configureControlInterface>\n    this.control_interface = new ControlInterface(socket);\n    _.each(socket_commands, function(fn, command_name) {\n        that.control_interface.addCommand(command_name, fn.bind(that));\n    });\n    </configureControlInterface>\n}\n"], ["preparePlatforms", "\nfunction preparePlatforms (platformList, projectRoot, options) {\n    <platformPreparation>\n    return Q.all(platformList.map(function(platform) {\n        \n        <projectSetup>\n        var project = {\n            root: projectRoot,\n            projectConfig: new ConfigParser(cordova_util.projectConfig(projectRoot)),\n            locations: {\n                plugins: path.join(projectRoot, 'plugins'),\n                www: cordova_util.projectWww(projectRoot)\n            }\n        };\n        </projectSetup>\n\n        <restorePlugins>\n        return restoreMissingPluginsForPlatform(platform, projectRoot, options)\n        </restorePlugins>\n        .then(function () {\n            <platformPrepare>\n            var platformApi = platforms.getPlatformApi(platform);\n            return platformApi.prepare(project, _.clone(options))\n            </platformPrepare>\n            .then(function () {\n                if (platform === 'windows' && !(platformApi instanceof PlatformApiPoly)) {\n                    \n                    <prePackageHook>\n                    return new HooksRunner(projectRoot).fire('pre_package', {\n                        wwwPath: platformApi.getPlatformInfo().locations.www,\n                        platforms: ['windows'],\n                        nohooks: options.nohooks\n                    });\n                    </prePackageHook>\n                }\n            })\n            .then(function () {\n                if (options.browserify) {\n                    <runBrowserify>\n                    var browserify = require('../plugman/browserify');\n                    return browserify(project, platformApi);\n                    </runBrowserify>\n                }\n            })\n            .then(function () {\n                <updateProject>\n                var platformRoot = path.join(projectRoot, 'platforms', platform);\n                var platformJson = PlatformJson.load(platformRoot, platform);\n                var munger = new PlatformMunger(platform, platformRoot, platformJson);\n                munger.add_config_changes(project.projectConfig, true).save_all();\n                </updateProject>\n            });\n        });\n    }));\n    </platformPreparation>\n}\n"], ["checkCallExpression", "\nfunction checkCallExpression(node) {\n            \n            <grammarAndSignatureChecks>\n            checkGrammarTypeArguments(node, node.typeArguments) || checkGrammarArguments(node, node.arguments);\n            var signature = getResolvedSignature(node);\n            </grammarAndSignatureChecks>\n            <expressionKindCheck>\n            if (node.expression.kind === 95 ) {\n                return voidType;\n            }\n            </expressionKindCheck>\n            <newExpression>\n            if (node.kind === 175 ) {\n                <declarationCheck>\n                var declaration = signature.declaration;\n                if (declaration &&\n                    declaration.kind !== 148  &&\n                    declaration.kind !== 152  &&\n                    declaration.kind !== 157  &&\n                    !ts.isJSDocConstructSignature(declaration)) {\n                    \n                    \n                    \n                    \n                    \n                    \n                    <functionExpressionResolution>\n                    var funcSymbol = node.expression.kind === 69  ?\n                        getResolvedSymbol(node.expression) :\n                        checkExpression(node.expression).symbol;\n                    if (funcSymbol && funcSymbol.members && (funcSymbol.flags & 16  || ts.isDeclarationOfFunctionExpression(funcSymbol))) {\n                        return getInferredClassType(funcSymbol);\n                    }\n                    else if (compilerOptions.noImplicitAny) {\n                        error(node, ts.Diagnostics.new_expression_whose_target_lacks_a_construct_signature_implicitly_has_an_any_type);\n                    }\n                    return anyType;\n                    </functionExpressionResolution>\n                }\n                </declarationCheck>\n            }\n            </newExpression>\n            <javascriptFileCheck>\n            if (ts.isInJavaScriptFile(node) && ts.isRequireCall(node,  true)) {\n                return resolveExternalModuleTypeByLiteral(node.arguments[0]);\n            }\n            </javascriptFileCheck>\n            return getReturnTypeOfSignature(signature);\n        }\n"], ["listenerAtPhase", "\nfunction listenerAtPhase(inst, event, propagationPhase) {\n    <getListenerForRegistrationName>\n    var registrationName = event.dispatchConfig.phasedRegistrationNames[propagationPhase];\n    return getListener(inst, registrationName);\n    </getListenerForRegistrationName>\n}\n"], ""]