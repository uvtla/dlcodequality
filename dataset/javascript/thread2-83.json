[["colorRangeMerge", "\nfunction( rc ){\n    if( is.ColorRange(rc) ){\n        <mergeConstraints>\n        addAll(this.hueConstraint, rc.hueConstraint);\n        addAll(this.saturationConstraint, rc.saturationConstraint);\n        addAll(this.brightnessConstraint, rc.brightnessConstraint);\n        addAll(this.alphaConstraint, rc.alphaConstraint);\n        this.black.min = Math.min( this.black.min, rc.black.min );\n        this.black.max = Math.max( this.black.max, rc.black.max );\n        this.white.min = Math.min( this.white.min, rc.white.min );\n        this.white.max = Math.max( this.white.max, rc.white.max );\n        </mergeConstraints>\n    } else {\n        <createConstraintsFromValues>\n        this.hueConstraint.push( new FloatRange(rc.hue(),rc.hue()) );\n        this.saturationConstraint.push( new FloatRange(rc.saturation(),rc.saturation()) );\n        this.brightnessConstraint.push( new FloatRange(rc.brightness(),rc.brightness()) );\n        this.alphaConstraint.push( new FloatRange(rc.alpha(),rc.alpha()) );\n        </createConstraintsFromValues>\n    }\n    return this;\n}\n"], ["MapboxEventManager", "\nfunction MapboxEventManager(options) {\n  <initializeProperties>\n  this.origin = options.origin || 'https://api.mapbox.com';\n  this.endpoint = 'events/v2';\n  this.access_token = options.accessToken;\n  this.version = '0.2.0'\n  this.sessionID = this.generateSessionID();\n  this.userAgent = this.getUserAgent();\n  this.options = options;\n  this.send = this.send.bind(this);\n  </initializeProperties>\n  \n  <parseOptions>\n  this.countries = (options.countries) ? options.countries.split(\",\") : null;\n  this.types = (options.types) ? options.types.split(\",\") : null;\n  this.bbox = (options.bbox) ? options.bbox : null;\n  this.language = (options.language) ? options.language.split(\",\") : null;\n  this.limit = (options.limit) ? +options.limit : null;\n  this.locale = navigator.language || null;\n  this.enableEventLogging = this.shouldEnableLogging(options);\n  </parseOptions>\n  \n  <setupEventQueue>\n  this.eventQueue = new Array();\n  this.flushInterval = options.flushInterval || 1000;\n  this.maxQueueSize = options.maxQueueSize || 100;\n  this.timer = (this.flushInterval) ? setTimeout(this.flush.bind(this), this.flushInterval) : null;\n  </setupEventQueue>\n  \n  this.lastSentInput = \"\";\n  this.lastSentIndex = 0;\n}\n"], ["calculate", "\nfunction (type, number1, number2) {\n  var result;\n  \n  <parseNumbers>\n  number1 = helper.number(number1);\n  number2 = helper.number(number2);\n  </parseNumbers>\n\n  <checkForErrors>\n  if (isNaN(number1) || isNaN(number2)) {\n    if (number1[0] === '=' || number2[0] === '=') {\n      throw Error('NEED_UPDATE');\n    }\n    throw Error('VALUE');\n  }\n  </checkForErrors>\n\n  <performOperation>\n  switch (type) {\n    case '+':\n      result = number1 + number2;\n      break;\n    case '-':\n      result = number1 - number2;\n      break;\n    case '/':\n      result = number1 / number2;\n      if (result == Infinity) {\n        throw Error('DIV_ZERO');\n      } else if (isNaN(result)) {\n        throw Error('VALUE');\n      }\n      break;\n    case '*':\n      result = number1 * number2;\n      break;\n    case '^':\n      result = Math.pow(number1, number2);\n      break;\n  }\n  </performOperation>\n\n  return result;\n}\n"], ["xmlSerialization", "\nfunction xmlText(node, opt_cdata) {\n  <serializeNodeToXmlText>\n  var buf = [];\n  xmlTextR(node, buf, opt_cdata);\n  return buf.join('');\n  </serializeNodeToXmlText>\n}\n"], ["dataService", "\nfunction (params) {\n  <validateParams>\n  assert.ok(params.__fhdb, \"__fhdb parameter required for shared database\");\n  </validateParams>\n\n  <optionsHandler>\n  this.copyDefaultOptions = function (target) {\n    target.__fhdb = params.__fhdb;\n    target.__dbperapp = params.__dbperapp;\n    return target;\n  };\n  </optionsHandler>\n\n  <createCollection>\n  this.createCollection = function (name, options, callback) {\n    assert.ok(name, \"collection name required\");\n    options = this.copyDefaultOptions(options || {});\n    options.type = name;\n    <createCollectionBody>\n    if (callback) {\n      params.ditcher.doCreate(options, callback);\n    } else {\n      return new Promise(function (resolve, reject) {\n        params.ditcher.doCreate(options, function (err, collection) {\n          if (err) {\n            return reject(err);\n          }\n          resolve(collection);\n        });\n      });\n    }\n    </createCollectionBody>\n  };\n  </createCollection>\n\n  <dropCollection>\n  this.dropCollection = function (name, callback) {\n    assert.ok(name, \"collection name required\");\n    var options = { type: name };\n    options = this.copyDefaultOptions(options || {});\n    <dropCollectionBody>\n    if (callback) {\n      params.ditcher.doDropCollection(options, callback);\n    } else {\n      return new Promise(function (resolve, reject) {\n        params.ditcher.doDropCollection(options, function (err, result) {\n          if (err) {\n            return reject(err);\n          }\n          resolve(result);\n        });\n      });\n    }\n    </dropCollectionBody>\n  };\n  </dropCollection>\n\n  <listCollections>\n  this.listCollections = function (filter, options) {\n    options = this.copyDefaultOptions(options || {});\n    return params.ditcher.doGetCollectionsListCursor(filter, options);\n  };\n  </listCollections>\n\n  <getCollectionInstance>\n  this.collection = function (name, options, callback) {\n    assert.ok(name, \"collection name required\");\n    options = this.copyDefaultOptions(options || {});\n    options.type = name;\n    return params.ditcher.doGetCollectionInstance(options, callback);\n  };\n  </getCollectionInstance>\n\n  <createIndex>\n  this.createIndex = function (name, fieldOrSpec, options, callback) {\n    assert.ok(name, \"collection name required\");\n    assert.ok(fieldOrSpec, \"index spec required\");\n    options = this.copyDefaultOptions(options || {});\n    options.type = name;\n    options.index = fieldOrSpec;\n    <createIndexBody>\n    if (callback) {\n      params.ditcher.doIndex(options, callback);\n    } else {\n      return new Promise(function (resolve, reject) {\n        params.ditcher.doIndex(options, function (err, result) {\n          if (err) {\n            return reject(err);\n          }\n          resolve(result);\n        });\n      });\n    }\n    </createIndexBody>\n  };\n  </createIndex>\n\n  <renameCollection>\n  this.renameCollection = function (fromCollection, toCollection, options, callback) {\n    assert.ok(fromCollection, \"current collection name required\");\n    assert.ok(toCollection, \"new collection name required\");\n    options = this.copyDefaultOptions(options || {});\n    options.type = fromCollection;\n    options.toCollection = toCollection;\n    <renameCollectionBody>\n    if (callback) {\n      params.ditcher.doRenameCollection(options, callback);\n    } else {\n      return new Promise(function (resolve, reject) {\n        params.ditcher.doRenameCollection(options, function (err, result) {\n          if (err) {\n            return reject(err);\n          }\n          resolve(result);\n        });\n      });\n    }\n    </renameCollectionBody>\n  };\n  </renameCollection>\n\n  <closeDatabaseConnection>\n  this.close = function (force, callback) {\n    if (typeof force === \"function\") {\n      callback = force;\n      force = false;\n    }\n    return params.ditcher.database.close(force, callback);\n  };\n  </closeDatabaseConnection>\n}\n"], ["initializeSplitButton", "\nfunction SplitButton(label) {\n  <inheritFromEmitter>\n  ui.Emitter.call(this);\n  </inheritFromEmitter>\n  <setupElement>\n  this.el = $(html);\n  this.events();\n  this.render({ label: label });\n  </setupElement>\n  this.state = 'hidden';\n}\n"], ["compareVector3Equality", "\nfunction vector3AreEqual (x, y, eps) {\n  <performEqualityCheck>\n  return (isZero(x.x - y.x, eps) &&\n    isZero(x.y - y.y, eps) &&\n    isZero(x.z - y.z, eps));\n  </performEqualityCheck>\n}\n"], ["authenticationFlow", "\nfunction() {\n    <chooseNextStage>\n    const nextStage = this._chooseStage();\n    if (!nextStage) {\n        throw new Error(\"No incomplete flows from the server\");\n    }\n    this._currentStage = nextStage;\n    </chooseNextStage>\n\n    <handleDummyLogin>\n    if (nextStage == 'm.login.dummy') {\n        this.submitAuthDict({\n            type: 'm.login.dummy',\n        });\n        return;\n    }\n    </handleDummyLogin>\n\n    <reportError>\n    if (this._data.errcode || this._data.error) {\n        this._stateUpdatedCallback(nextStage, {\n            errcode: this._data.errcode || \"\",\n            error: this._data.error || \"\",\n        });\n        return;\n    }\n    </reportError>\n\n    <prepareStageStatus>\n    const stageStatus = {};\n    if (nextStage == EMAIL_STAGE_TYPE) {\n        stageStatus.emailSid = this._emailSid;\n    }\n    this._stateUpdatedCallback(nextStage, stageStatus);\n    </prepareStageStatus>\n}\n"], ["removeStringAccents", "\nfunction removeAccent(str) {\n    <patternDefinition>\n    var reAccents = /[\u00e0\u00e1\u00e2\u00e3\u00e4\u00e7\u00e8\u00e9\u00ea\u00eb\u00ec\u00ed\u00ee\u00ef\u00f1\u00f2\u00f3\u00f4\u00f5\u00f6\u00f9\u00fa\u00fb\u00fc\u00fd\u00ff\u00c0\u00c1\u00c2\u00c3\u00c4\u00c7\u00c8\u00c9\u00ca\u00cb\u00cc\u00cd\u00ce\u00cf\u00d1\u00d2\u00d3\u00d4\u00d5\u00d6\u00d9\u00da\u00db\u00dc\u00dd]/g;\n    </patternDefinition>\n\n    <replacementsDefinition>\n    var replacements = '_aaaaaceeeeiiiinooooouuuuyyAAAAACEEEEIIIINOOOOOUUUUY';\n    </replacementsDefinition>\n\n    <performReplacement>\n    return str.replace(reAccents, function (match) {\n        return replacements[reAccents.source.indexOf(match)];\n    });\n    </performReplacement>\n}\n"], ["expandPropertiesInLines", "\nfunction replaceProperties (lines, properties) {\n  <filterLinesWithProperties>\n  var filteredLines = [];\n  lines.forEach((line) => {\n    <expandLineProperties>\n    for (var prop in properties) {\n      line = expandReference(line, prop, properties[prop]);\n    }\n    </expandLineProperties>\n    filteredLines.push(line);\n  });\n  </filterLinesWithProperties>\n  return filteredLines;\n}\n"], "```"]