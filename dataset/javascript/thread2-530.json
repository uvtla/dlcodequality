[["findVarItem", "\nfunction findVarItem(valueNode) {\n  <resolveVariableName>\n  var varNames = [];\n  var varName;\n  if (valueNode.type === 'name') {\n    varName = valueNode.value;\n  } else if (valueNode.type === 'dot' || valueNode.type === 'call') {\n    varNames = expressionNames(valueNode);\n    if (!varNames) {\n      return;\n    }\n    varName = varNames.shift();\n  }\n  if (!varName) {\n    return;\n  }\n  </resolveVariableName>\n  \n  <findVariableItemInScope>\n  var varItem = valueNode.item('var.' + varName);\n  if (typeof varItem === 'undefined') {\n    return;\n  }\n  varItem = findVarProperty(varNames, varItem);\n  return varItem;\n  </findVariableItemInScope>\n}\n"], ["placeholder", "\nfunction placeholder(word) {\n  <initializeInputAndClone>\n  var input = this;\n  var clone = input.prev(\".hint\");\n  \n  input.css({\n    backgroundColor: \"transparent\",\n    position: \"relative\",\n  });\n\n  if (!clone.length) {\n    input.wrap(\n      $(\"<div>\").css({position: \"relative\", height: input.css(\"height\")})\n    );\n    clone = input\n      .clone()\n      .attr(\"tabindex\", -1)\n      .removeAttr(\"id name placeholder\")\n      .addClass(\"hint\")\n      .insertBefore(input);\n    clone.css({\n      position: \"absolute\",\n    });\n  }\n  </initializeInputAndClone>\n  \n  <calculateAndSetHint>\n  var hint = \"\";\n  if (typeof word !== \"undefined\") {\n    var value = input.val();\n    hint = value + word.substr(value.split(/ |\\n/).pop().length);\n  }\n  \n  clone.val(hint);\n  </calculateAndSetHint>\n}\n"], ["normalizeModules", "\nfunction normalizeModules(modules) {\n  <normalizeModuleStructure>\n  var normalized = {};\n  Object.keys(modules).forEach(function (key) {\n      var module = modules[key];\n      \n      normalized[key] = {\n          actions: module.actions || {},\n          getters: module.getters || {},\n          modules: module.modules ? normalizeModules(module.modules) : {},\n          mutations: module.mutations || {},\n          namespaced: module.namespaced || false,\n          state: {}\n      };\n  </normalizeModuleStructure>\n  \n  <handleModuleStates>\n      if (typeof module.state === 'function') {\n          normalized[key].state = module.state();\n      } else if (_typeof(module.state) === 'object') {\n          normalized[key].state = JSON.parse(JSON.stringify(module.state));\n      }\n  </handleModuleStates>\n  });\n  \n  return normalized;\n}\n"], ["EventOn", "\nfunction(name, callback, context) {\n  <validateAndSetupEventListening>\n      if (!(eventsApi(this, 'on', name, [callback, context]) && callback)) return this;\n      this._events || (this._events = {});\n  </validateAndSetupEventListening>\n  \n  <storeEventHandlers>\n      var list = this._events[name] || (this._events[name] = []);\n      list.push({callback: callback, context: context, ctx: context || this});\n      return this;\n  </storeEventHandlers>\n}\n"], ["getColHeaderInfos", "\nfunction getColHeaderInfos(table) {\n  <collectColumnHeaders>\n  var cols = this.getCols(table);\n  var arr = cols.map(function (col) {\n    <formatColumnHeaderInformation>\n    var text = tiaEJ.convertTextToFirstLocKey(col.text);\n    if (text === col.emptyCellText) {\n      text = ''; \n    }\n    var info = col.getConfig('xtype') + ': \"' + text + '\"';\n    var toolTip = col.getConfig().toolTip;\n    if (toolTip) {\n      info += ', toolTip: ' + tiaEJ.convertTextToFirstLocKey(toolTip);\n    }\n    return info;\n    </formatColumnHeaderInformation>\n  });\n  </collectColumnHeaders>\n  return arr;\n}\n"], ["scopeRemoting", "\nfunction scopeRemoting (scopeName, scope, define) {\n  <setupRemotingConfiguration>\n  var pathName = (scope.options &&\n    scope.options.http &&\n    scope.options.http.path) ||\n    scopeName\n  var isStatic = scope.isStatic\n  var toModelName = scope.modelTo.modelName\n  \n  \n  var relation = this.relations[scopeName]\n  </setupRemotingConfiguration>\n  \n  <determineTargetModel>\n  if (relation && relation.modelTo) {\n    toModelName = relation.modelTo.modelName\n  }\n  </determineTargetModel>\n\n  <defineRemotingMethod>\n  define('__get__' + scopeName, {\n    isStatic: isStatic,\n    accessType: 'READ',\n    description: 'Queries ' + scopeName + ' of ' + this.modelName + '.',\n    http: {\n      verb: 'get',\n      path: '/' + pathName\n    },\n    accepts: {\n      arg: 'filter',\n      type: 'object'\n    },\n    returns: {\n      arg: scopeName,\n      type: [toModelName],\n      root: true\n    }\n  })\n  </defineRemotingMethod>\n}\n"], ["clickRegion", "\nfunction clickRegion(e) {\n  <determineMousePosition>\n  let pos  = {\n    x : e.clientX,\n    y : e.clientY\n  };\n  </determineMousePosition>\n  \n  <computeClickRegion>\n  region     = '',\n  dividant   = 4,\n  right      = window.innerWidth - (window.innerWidth / dividant),\n  left       = (window.innerWidth / dividant),\n  top        = (window.innerHeight / dividant),\n  bottom     = window.innerHeight - (window.innerHeight / dividant);\n\n  if (pos.y <= top) { region = 'top'; }\n  else if (pos.y >= bottom) { region = 'bottom'; }\n  if (pos.x <= left) { region = 'left'; }\n  else if (pos.x >= right) { region = 'right'; }\n  </computeClickRegion>\n\n  return region;\n}\n"], ["sequentialAsyncProcessor", "\nfunction (arr, handler) {\n  <setupAsyncSequence>\n        var tmp = when.defer();\n        var index = -1;\n        var results = [];\n  </setupAsyncSequence>\n  \n  <asyncOperationLoop>\n        var doNext = function () {\n            try {\n                index++;\n                if (index > arr.length) {\n                    tmp.resolve(results);\n                }\n                var file = arr[index];\n                var promise = handler(file);\n                if (promise) {\n                    when(promise).then(function (result) {\n                        results.push(result);\n                        process.nextTick(doNext);\n                    }, function () {\n                        process.nextTick(doNext);\n                    });\n                }\n                else {\n                    process.nextTick(doNext);\n                }\n            }\n            catch (ex) {\n                logger.error(\"pdas error: \" + ex);\n            }\n        };\n  </asyncOperationLoop>\n  \n  <initiateAsyncProcess>\n        process.nextTick(doNext);\n  </initiateAsyncProcess>\n        \n        return tmp.promise;\n    }\n"], ["focusEvent", "\nfunction (event, avoidCallback) {\n  <focusEventSetup>\n            this._hasFocus = true;\n            if (!this._keepFocus) {\n                var cfg = this._cfg;\n                if (cfg.readOnly) {\n                    return;\n                }\n                this.setHelpText(false);\n                if (this._isPrefilled) {\n                    this.setPrefillText(false);\n                    this.checkValue({\n                        value : cfg.prefill\n                    });\n                }\n                this.checkValue({\n                    stopValueProp : true\n                });\n\n                if (this._cfg) {\n                    cfg = this._cfg;\n                    if (cfg.validationEvent === 'onFocus'\n                            && ((cfg.formatError && cfg.formatErrorMessages.length) || (cfg.error && cfg.errorMessages.length))) {\n                        this._validationPopupShow();\n                    }\n                }\n                this._updateState();\n            } else {\n                var caretPosition = this._currentCaretPosition;\n                this._currentCaretPosition = null;\n                if (caretPosition) {\n                    this.setCaretPosition(caretPosition.start, caretPosition.end);\n                }\n            }\n  </focusEventSetup>\n            \n  <invokeFocusCallback>\n            if (!!this._cfg.onfocus && !avoidCallback) {\n                this.evalCallback(this._cfg.onfocus);\n            }\n  </invokeFocusCallback>\n  \n  <triggerAutoSelection>\n            ariaCoreTimer.addCallback({\n                fn : this._autoselect,\n                scope : this,\n                delay : 1\n            });\n  </triggerAutoSelection>\n        }\n"], ["updateGreyColorBuffer", "\nfunction updateGreyColorBuffer(buf) {\n  <applyGreyScaleToBuffer>\n  for (let i = 0; i < buf.length; ++i) {\n    buf[i] = 0.5;\n  }\n  </applyGreyScaleToBuffer>\n  return buf;\n}\n"], "```"]