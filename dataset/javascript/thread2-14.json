[["initializeGLContext", "\nfunction() {\n    this.gl = this.context.gl;\n    var gl = this.gl;\n    this.vertexBuffer = gl.createBuffer();  \n    this.indexBuffer = this.numIndices > 0\n                ? gl.createBuffer()\n                : null;\n    this.dirty = true;\n}\n"], ["processUniqArray", "\nfunction uniq(array, isSorted, iteratee, thisArg) {\n  var length = array ? array.length : 0;\n  if (!length) {\n    return [];\n  }\n  if (isSorted != null && typeof isSorted != 'boolean') {\n    thisArg = iteratee;\n    iteratee = isIterateeCall(array, isSorted, thisArg) ? undefined : isSorted;\n    isSorted = false;\n  }\n  var callback = getCallback();\n  if (!(iteratee == null && callback === baseCallback)) {\n    iteratee = callback(iteratee, thisArg, 3);\n  }\n  return (isSorted && getIndexOf() === baseIndexOf)\n    ? sortedUniq(array, iteratee)\n    : baseUniq(array, iteratee);\n}\n"], ["updateCharactersCounter", "\nfunction updateCharactersCounter() {\n  var remaining = options.chars - charsCount();\n  if (remaining === 0) {\n    $countdownDomNode.addClass('ut-text-countdown-max');\n  } else {\n    $countdownDomNode.removeClass('ut-text-countdown-max');\n  }\n  $countdownDomNode.text(remaining + ' / ' + options.chars);\n}\n"], ["createJsonEventData", "\nfunction createJsonEventData(eventId, event, metadata, type) {\n  if (!event || typeof event !== 'object') throw new TypeError(\"data must be an object.\");\n  var eventBuf = new Buffer(JSON.stringify(event));\n  var metaBuf = metadata ? new Buffer(JSON.stringify(metadata)) : null;\n  return new EventData(eventId, type || event.constructor.name, true, eventBuf, metaBuf);\n}\n"], ["initializeCanvasEnvironment", "\nfunction() {\n    var _this = this;\n    this.canvas = document.createElement('canvas');\n    this.resize(true);\n    document.body.appendChild(this.canvas);\n    this.ctx = this.canvas.getContext('2d');\n    window.addEventListener('resize', function() {\n        setTimeout(function(){ GameController.resize.call(_this); }, 10);\n    });\n    this.setTouchEvents();\n    this.loadSide('left');\n    this.loadSide('right');\n    this.render();\n    if( !this.touches || !this.touches.length ) this.paused = true;\n}\n"], ["diff", "\nfunction diff(node) {\n    var oldBundle = (cachedData.loader.bundle || []).slice();\n    return getDependencies(node.load).then(function(result){\n        var newBundle = (cachedData.loader.bundle || []).slice();\n        if(same(node.deps, result.deps) &&\n           same(oldBundle, newBundle)) {\n            clean(node, result.source);\n            if(result.virtualModules.length) {\n                var promises = result.virtualModules.map(function(l){\n                    var node = cachedData.graph[l.name];\n                    node.load.source = l.source;\n                    node.load.metadata.useSource = true;\n                    return diff(node);\n                });\n                return Promise.all(promises).then(function(results){\n                    result.same = results.every(function(res){\n                        return res.same;\n                    });\n                    return result;\n                });\n            }\n            result.same = true;\n        }\n        return result;\n    });\n}\n"], ["getViewState", "\nfunction getViewState(props) {\n  if (!props.viewState && 'latitude' in props && 'longitude' in props && 'zoom' in props) {\n    const {latitude, longitude, zoom, pitch = 0, bearing = 0} = props;\n    return {latitude, longitude, zoom, pitch, bearing};\n  }\n  return props.viewState;\n}\n"], ["registerDevice", "\nasync function registerDevice(options) {\n    options = options || {};\n    const atlasClient = options.atlasClient || await AtlasClient.factory();\n    const accountInfo = await atlasClient.fetch('/v1/provision/account');\n    <checkFirstDeviceRegistration>\n    if (!accountInfo.devices.length) {\n        console.error(\"Must use `registerAccount` for first device\");\n        throw new TypeError(\"No Account\");\n    }\n    </checkFirstDeviceRegistration>\n    const signalClient = new SignalClient(null, null, accountInfo.serverUrl);\n    const autoProvision = options.autoProvision !== false;\n    const name = options.name || defaultName;\n    <checkProvisioningCallback>\n    if (!options.onProvisionReady && !autoProvision) {\n        throw new TypeError(\"Missing: onProvisionReady callback\");\n    }\n    </checkProvisioningCallback>\n    const returnInterface = {waiting: true};\n    const provisioningCipher = new ProvisioningCipher();\n    const pubKey = provisioningCipher.getPublicKey().toString('base64');\n    let wsr;\n    const webSocketWaiter = new Promise((resolve, reject) => {\n        wsr = new WebSocketResource(signalClient.getProvisioningWebSocketURL(), {\n            keepalive: {path: '/v1/keepalive/provisioning'},\n            handleRequest: request => {\n                if (request.path === \"/v1/address\" && request.verb === \"PUT\") {\n                    const proto = protobufs.ProvisioningUuid.decode(request.body);\n                    request.respond(200, 'OK');\n                    if (autoProvision) {\n                        atlasClient.fetch('/v1/provision/request', {\n                            method: 'POST',\n                            json: {\n                                uuid: proto.uuid,\n                                key: pubKey\n                            }\n                        }).catch(reject);\n                    }\n                    if (options.onProvisionReady) {\n                        const r = options.onProvisionReady(proto.uuid, pubKey);\n                        if (r instanceof Promise) {\n                            r.catch(reject);\n                        }\n                    }\n                } else if (request.path === \"/v1/message\" && request.verb === \"PUT\") {\n                    const msgEnvelope = protobufs.ProvisionEnvelope.decode(request.body);\n                    request.respond(200, 'OK');\n                    wsr.close();\n                    resolve(msgEnvelope);\n                } else {\n                    reject(new Error('Unknown websocket message ' + request.path));\n                }\n            }\n        });\n    });\n    await wsr.connect();\n    returnInterface.done = (async () => {\n        const provisionMessage = await provisioningCipher.decrypt(await webSocketWaiter);\n        returnInterface.waiting = false;\n        <registerNewDevice>\n        const addr = provisionMessage.addr;\n        </registerNewDevice>\n        <generateAndSaveCredentials>\n        const identity = provisionMessage.identityKeyPair;\n        const registrationId = libsignal.keyhelper.generateRegistrationId();\n        const password = generatePassword();\n        const signalingKey = generateSignalingKey();\n        </generateAndSaveCredentials>\n        const response = await signalClient.request({\n            httpType: 'PUT',\n            call: 'devices',\n            urlParameters: '/' + provisionMessage.provisioningCode,\n            json: {\n                signalingKey: signalingKey.toString('base64'),\n                supportsSms: false,\n                fetchesMessages: true,\n                registrationId,\n                name\n            },\n            username: addr,\n            password,\n            validateResponse: {deviceId: 'number'}\n        });\n        <persistDeviceData>\n        const username = `${addr}.${response.deviceId}`;\n        await storage.clearSessionStore();\n        await storage.removeOurIdentity();\n        await storage.removeIdentity(addr);\n        await storage.saveIdentity(addr, identity.pubKey);\n        await storage.saveOurIdentity(identity);\n        await storage.putState('addr', addr);\n        await storage.putState('serverUrl', signalClient.url);\n        await storage.putState('deviceId', response.deviceId);\n        await storage.putState('name', name);\n        await storage.putState('username', username);\n        await storage.putState('password', password);\n        await storage.putState('registrationId', registrationId);\n        await storage.putState('signalingKey', signalingKey);\n        </persistDeviceData>\n        <registerDeviceKeys>\n        const authedClient = new SignalClient(username, password, signalClient.url);\n        await authedClient.registerKeys(await authedClient.generateKeys());\n        </registerDeviceKeys>\n    })();\n    returnInterface.cancel = async () => {\n        wsr.close();\n        try {\n            await webSocketWaiter;\n        } catch(e) {\n            console.warn(\"Ignoring web socket error:\", e);\n        }\n    };\n    return returnInterface;\n}\n"], ["scanDocument", "\nfunction(from, to) {\n    var currentCursor = this.cursor();\n    var selection = this._scan(true, from, to);\n    if(!selection){\n        selection = this._scan(false, from, to);\n    }\n    this.setCursor(currentCursor);\n    return selection;\n}\n"], ["runRollupTask", "\nfunction runRollupTask(entry, filename) {\n    <generateCommonJSBundle>\n    rollup.rollup({\n            entry: entry,\n            plugins: [\n                babel({\n                    loose: 'all'\n                })\n            ]\n        })\n        .then(function(bundle) {\n            return write('dist/' + filename + '.common.js', bundle.generate({\n                format: 'cjs',\n                banner: banner\n            }).code)\n        })\n    </generateCommonJSBundle>\n    <generateDevelopmentBundle>\n    .then(function() {\n            return rollup.rollup({\n                    entry: entry,\n                    plugins: [\n                        replace({\n                            'process.env.NODE_ENV': \"'development'\"\n                        }),\n                        babel({\n                            loose: 'all'\n                        })\n                    ]\n                })\n                .then(function(bundle) {\n                    return write('dist/' + filename + '.js', bundle.generate({\n                        format: 'umd',\n                        banner: banner,\n                        moduleName: 'React'\n                    }).code)\n                })\n        })\n    </generateDevelopmentBundle>\n    <generateProductionBundle>\n    .then(function() {\n            return rollup.rollup({\n                    entry: entry,\n                    plugins: [\n                        replace({\n                            'process.env.NODE_ENV': \"'production'\"\n                        }),\n                        babel({\n                            loose: 'all'\n                        })\n                    ]\n                })\n                .then(function(bundle) {\n                    var code = bundle.generate({\n                        format: 'umd',\n                        moduleName: 'React'\n                    }).code\n                    var minified = banner + '\\n' + uglify.minify(code, {\n                        fromString: true\n                    }).code\n                    return write('dist/' + filename + '.min.js', minified)\n                })\n                .then(zip)\n        })\n    </generateProductionBundle>\n    .catch(logError)\n    <compressProductionBundle>\n    function zip() {\n        return new Promise(function(resolve, reject) {\n            fs.readFile('dist/' + filename + '.min.js', function(err, buf) {\n                if (err) return reject(err)\n                zlib.gzip(buf, function(err, buf) {\n                    if (err) return reject(err)\n                    write('dist/' + filename + '.min.js.gz', buf).then(resolve)\n                })\n            })\n        })\n    }\n    </compressProductionBundle>\n}\n"], "```"]