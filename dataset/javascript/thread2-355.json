[["parseMLComment", "\nfunction parseMLComment(css) {\n    var start = pos;\n\n    <findCommentEnd>\n    for (pos += 2; pos < css.length; pos++) {\n      if (css.charAt(pos) === '*' && css.charAt(pos + 1) === '/') {\n        pos++;\n        break;\n      }\n    }\n    </findCommentEnd> \n\n    var comment = css.substring(start, pos + 1);\n    <tokenizeComment>\n    pushToken(TokenType.CommentML, comment, col);\n    </tokenizeComment>\n\n    <updateLineAndColumn>\n    var newlines = comment.split('\\n');\n    if (newlines.length > 1) {\n      ln += newlines.length - 1;\n      col = newlines[newlines.length - 1].length;\n    } else {\n      col += (pos - start);\n    }\n    </updateLineAndColumn>\n  }\n"], ["makeId", "\nfunction makeId(length = RANDOM_CHARACTER_LENGTH) {\n    let text = \"\";\n    <generateId>\n    for (let i = 0; i < length; i++) {\n        text += RANDOM_CHARACTER_SOURCE.charAt(Math.floor(Math.random() * RANDOM_CHARACTER_SOURCE.length));\n    }\n    </generateId>\n\n    return text;\n}\n"], ["addMatchers", "\nfunction addMatchers(sections, tree, resultSections, results, index){\n\t<addWildcardAll>\n\tvar hasAll = getChild(tree, WILDCARD_ALL);\n\tif(hasAll) addValue(resultSections.concat(WILDCARD_ALL), hasAll, results);\n\t</addWildcardAll>\n\n\t<checkEndCondition>\n\tvar isEnd = index === sections.length;\n\tif(isEnd) {\n\t\taddValue(resultSections, tree, results);\n\t\treturn;\n\t}\n\t</checkEndCondition>\n\n\t<addWildcardOne>\n\tvar hasOne = getChild(tree, WILDCARD_ONE);\n\tif (hasOne) addMatchers(\n\t\tsections,\n\t\thasOne,\n\t\tresultSections.concat(WILDCARD_ONE),\n\t\tresults,\n\t\tindex + 1\n\t);\n\t</addWildcardOne>\n\n\t<addSpecificSection>\n\tvar section = sections[index];\n\tvar hasSection = getChild(tree, section);\n\tif (hasSection) addMatchers(\n\t\tsections,\n\t\thasSection,\n\t\tresultSections.concat(section),\n\t\tresults,\n\t\tindex + 1\n\t);\n\t</addSpecificSection>\n}\n"], ["lookupCountryByIdShouldBeCalled", "\nfunction lookupCountryByIdShouldBeCalled(q) {\n  \n  <defineHasCountryId>\n  var hasCountryId = function(result) {\n    return _.some(result.Hierarchy, (h) => { return h.hasOwnProperty('country_id');});\n  };\n  </defineHasCountryId>\n\n  <checkIfLookupCountryByIdShouldNotBeCalled>\n  if (!_.some(q.results, hasCountryId)) {\n    return false;\n  }\n\n  \n  if (q.lookupCountryByIdHasBeenCalled) {\n    return false;\n  }\n\n  \n  return !_.some(q.results, (result) => { return result.Placetype === 'country'; } );\n  </checkIfLookupCountryByIdShouldNotBeCalled>\n}\n"], ["getModulePath", "\nfunction getModulePath (mod, useAbsolutePath) {\n  <deriveModulePath>\n  const modPath =\n    mod === 'regenerator-runtime'\n      ? 'regenerator-runtime/runtime'\n      : `core-js/modules/${mod}`\n  return useAbsolutePath ? require.resolve(modPath) : modPath\n  </deriveModulePath>\n}\n"], ["updatePositionAndDirection", "\nfunction(){\n\t\tvar pos = this.getpos(0);\n\t\t<checkForSamePosition>\n\t\tif(this.prevPos.equals(pos)){ return;}\n\t\t</checkForSamePosition>\n\n\t\tvar cell = this.prevPos.getc();\n\t\t\n\t\tif(!cell.isnull){\n\t\t\tif(cell.qnum!==-1){\n\t\t\t\t<determineDirection>\n\t\t\t\tvar dir = this.prevPos.getdir(pos,2);\n\t\t\t\tif(dir!==cell.NDIR){\n\t\t\t\t\t<setNewDirection>\n\t\t\t\t\tcell.setQdir(cell.qdir!==dir?dir:0);\n\t\t\t\t\tcell.draw();\n\t\t\t\t\t</setNewDirection>\n\t\t\t\t}\n\t\t\t\t</determineDirection>\n\t\t\t}\n\t\t}\n\t\tthis.prevPos = pos;\n\t}\n"], ["AnnotationStyler", "\nfunction AnnotationStyler (view, annotationModel) {\n\t\tthis._view = view;\n\t\tthis._annotationModel = annotationModel;\n\t\tvar self = this;\n\t\t<addEventListeners>\n\t\tthis._listener = {\n\t\t\tonDestroy: function(e) {\n\t\t\t\tself._onDestroy(e);\n\t\t\t},\n\t\t\tonLineStyle: function(e) {\n\t\t\t\tself._onLineStyle(e);\n\t\t\t},\n\t\t\tonChanged: function(e) {\n\t\t\t\tself._onAnnotationModelChanged(e);\n\t\t\t}\n\t\t};\n\t\tview.addEventListener(\"Destroy\", this._listener.onDestroy); \n\t\tview.addEventListener(\"postLineStyle\", this._listener.onLineStyle); \n\t\tannotationModel.addEventListener(\"Changed\", this._listener.onChanged); \n\t\t</addEventListeners>\n\t}\n "], ["checkIngredients", "\nfunction checkIngredients(flapjack, options) {\n    options = options || {};\n\n    \n    <adjustForOptions>\n    if (flapjack && !_.isFunction(flapjack) && flapjack.client) {\n        flapjack = flapjack.client;\n    }\n    \n    else if (flapjack && options.ngType === 'factory' && !options.isClient) {\n        <getModuleInfo>\n        var moduleInfo = this.getModuleInfo(flapjack) || {};\n        if (!moduleInfo.client) { return null; }\n        </getModuleInfo>\n    }\n    </adjustForOptions>\n\n    return flapjack;\n}\n"], ["createFiles", "\nfunction createFiles(next) {\n    <normalizeAndParseDirectories>\n    var files = common.directories.normalize(\n      common.mixin({}, flatiron.constants.DIRECTORIES, { '#ROOT': root }),\n      JSON.parse(fs.readFileSync(path.join(scaffold, 'files.json'), 'utf8'))\n    );\n    </normalizeAndParseDirectories>\n\n    <copyFiles>\n    function copyFile(file, nextFile) {\n      app.log.info('Writing file ' + file.grey);\n      common.cpr(path.join(scaffold, file), files[file], nextFile);\n    }\n    </copyFiles>\n\n    <iterateAndCopyFiles>\n    common.async.mapSeries(Object.keys(files), copyFile, next);\n    </iterateAndCopyFiles>\n  }\n"], ["RateCenterSearchAndOrdeNumbersQuery", "\nfunction RateCenterSearchAndOrdeNumbersQuery(query) {\n\t<convertToXml>\n\tthis.toXml = function () {\n\t\treturn {\n\t\t\t\"RateCenterSearchAndOrderType\": {\n\t\t\t\t\"RateCenter\": {_text: query.rateCenter},\n\t\t\t\t\"State\": {_text: query.state},\n\t\t\t\t\"Quantity\": {_text: query.quantity || 1}\n\t\t\t}\n\t\t};\n\t};\n\t</convertToXml>\n}\n"], ""]