[["setAttribute", "\nfunction setAttribute(element, name, value) {\n  assertType(element, Node, false, 'Invalid element specified'); // Validation of input\n  <setAttributeValue>\n  if (value === undefined || value === null || value === false)\n    element.removeAttribute(name);\n  else if (value === true)\n    element.setAttribute(name, '');\n  else\n    element.setAttribute(name, value);\n  </setAttributeValue>\n  <setDirty>\n  if (name === 'disabled' && element.setDirty)\n    element.setDirty(DirtyType.STATE);\n  </setDirty>\n}\n"], ["isTargetPath", "\nfunction isTargetPath(srcPath, pathTest) {\n  return !srcPath ||\n    (Array.isArray(pathTest) ? pathTest : [pathTest]).some(function(test) {\n      return test && (test instanceof RegExp ? test.test(srcPath) : srcPath.indexOf(test) === 0);\n    });\n}\n"], ["debugLoggerStart", "\nfunction debugLoggerStart(logger, str) {\n    console.log();\n    console.log();\n    logger.debug(\"======================= [%s Start] =======================\", str);\n}\n"], ["replaceTableNames", "\nfunction replaceTableNames(sql, identifiers, sequelize) {\n\tconst {queryInterface} = sequelize;\n\t_.forIn(identifiers, (model, identifier) => { // Iterate over identifiers and replace in SQL\n\t\tconst tableName = model.getTableName();\n\t\tsql = sql.replace(\n\t\t\tnew RegExp(`\\\\*${identifier}(?![a-zA-Z0-9_])`, 'g'), // Build regex pattern and replace\n\t\t\ttableName.schema ? tableName.toString() : queryInterface.quoteIdentifier(tableName) // Handle schema existence\n\t\t);\n\t});\n\treturn sql; // Return the modified SQL statement\n}\n"], ["makeOpportunities", "\nfunction makeOpportunities(agent) {\n    <groups>\n    let groups = function (id) {\n        if (id === undefined) {\n            return agent.request('get_opportunities_groups', undefined); // Fetch groups when no ID\n        }\n        else {\n            return new GroupImpl(agent, id); // Instantiate group implementation with ID\n        }\n    };\n    </groups>\n    <tasks>\n    let tasks = function (id) {\n        if (id === undefined) {\n            return agent.request('get_opportunities_tasks', undefined); // Fetch tasks when no ID\n        }\n        else {\n            return new TaskImpl(agent, id); // Instantiate task implementation with ID\n        }\n    };\n    </tasks>\n    return { groups, tasks }; // Return an object with groups and tasks functions\n}\n"], ["el", "\nfunction el(tag, attrs) {\n  var n = el.air(create(tag)); // Create an element\n  if(attrs && n.attr) {\n    return n.attr(attrs); // Set attributes if provided\n  }\n  return n; // Return the created element\n}\n"], ["anonymousFunction", "\nfunction () {\n    <dec3>\n    function dec3 (v) {\n      return Math.floor(v * 1000) / 1000; // Round decimal to 3 places\n    }\n    </dec3>\n    <paramInitialization>\n    var params = [];\n    var usingPreset = this.data.preset != 'none' ? this.presets[this.data.preset] : false;\n    </paramInitialization>\n    <presetSelection>\n    if (usingPreset) {\n      params.push('preset: ' + this.data.preset);\n    }\n    </presetSelection>\n    <schemaIteration>\n    for (var i in this.schema) {\n      <presetChecks>\n      if (i == 'preset' || (usingPreset && usingPreset[i] === undefined)) {\n        continue;\n      }\n      </presetChecks>\n      var def = usingPreset ? usingPreset[i] : this.schema[i].default;\n      <parameterGeneration>\n      var data = this.data[i];\n      var type = this.schema[i].type;\n      if (type == 'vec3') {\n        var coords = def;\n        if (typeof(def) == 'string') {\n          def = def.split(' ');\n          coords = {x: def[0], y: def[1], z: def[2]};\n        }\n        if (dec3(coords.x) != dec3(data.x) || dec3(coords.y) != dec3(data.y) || dec3(coords.z) != dec3(data.z)) {\n          params.push(i + ': ' + dec3(data.x) + ' ' + dec3(data.y) + ' ' + dec3(data.z));\n        }\n      }\n      else {\n        if (def != data) {\n          if (this.schema[i].type == 'number') {\n            data = dec3(data);\n          }\n          params.push(i + ': ' + data);\n        }\n      }\n      </parameterGeneration>\n    }\n    </schemaIteration>\n    console.log('%c' + params.join('; '), 'color: #f48;font-weight:bold'); // Output the formatted parameters\n}\n"], ["RenderManager", "\nfunction RenderManager(generator, config, logger) {\n        events.EventEmitter.call(this);\n\n        this._generator = generator;\n        this._config = config;\n        this._logger = logger;\n\n        this._svgRenderers = {};\n        this._pixmapRenderers = {};\n\n        this._componentsByDocument = {};\n        this._pending = {};\n        this._working = {};\n\n        this._renderedAssetCount = 0;\n}\n"], ["gulpSassMonster", "\nfunction gulpSassMonster (opts = {}, sync = false) {\n\t<readBuffer>\n\tfunction readBuffer (file, ...args) {\n\t\tlet cb = args[1];\n\t\t<notSupportedFileCheck>\n\t\tlet notSupported = notSupportedFile(file, pluginError, {\n\t\t\tsilent: true\n\t\t});\n\t\tif (Array.isArray(notSupported)) {\n\t\t\tlet status = notSupported.shift();\n\t\t\tif (status === 'isEmpty') {\n\t\t\t\tfile.extname = '.css';\n\t\t\t\treturn cb(null, file);\n\t\t\t}\n\t\t\treturn cb(notSupported[0], notSupported[1]);\n\t\t}\n\t\t</notSupportedFileCheck>\n\t\t<setupOptions>\n\t\tconst options = setupOptions(opts, file);\n\t\t</setupOptions>\n\t\t<renderSass>\n\t\tif (sync) {\n\t\t\ttry {\n\t\t\t\tlet result = sass.renderSync(options);\n\t\t\t\tpushFile(file, result, options, cb);\n\t\t\t} catch (error) {\n\t\t\t\treturn cb(errorHandler(error, file));\n\t\t\t}\n\t\t} else {\n\t\t\tsass.render(options, (error, result) => {\n\t\t\t\tif (error) {\n\t\t\t\t\terror = errorHandler(error, file);\n\t\t\t\t\treturn cb(error);\n\t\t\t\t}\n\t\t\t\tpushFile(file, result, options, cb);\n\t\t\t});\n\t\t}\n\t\t</renderSass>\n\t}\n\t</readBuffer>\n\treturn through2.obj(readBuffer);\n}\n"], ["buildLambdaSecurityGroup", "\nfunction buildLambdaSecurityGroup({ name = 'LambdaExecutionSecurityGroup' } = {}) {\n  return {\n    [name]: {\n      Type: 'AWS::EC2::SecurityGroup',\n      Properties: {\n        GroupDescription: 'Lambda Execution Group',\n        VpcId: {\n          Ref: 'VPC',\n        },\n        Tags: [\n          {\n            Key: 'Name',\n            Value: {\n              'Fn::Join': [\n                '-',\n                [\n                  {\n                    Ref: 'AWS::StackName',\n                  },\n                  'lambda-exec',\n                ],\n              ],\n            },\n          },\n        ],\n      },\n    },\n  };\n}\n"], "```\n\nPlease note that simple variable assignments and single line statements do not count as separate responsibilities, so they are not tagged unless they form part of a larger coherent block of instructions that serve a specific identifiable purpose within the function."]