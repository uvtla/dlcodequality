[["loadCompressedPublicKey", "\nfunction loadCompressedPublicKey(xBuffer) {\n\tlet x = new BN(xBuffer);\n\n\tif (x.cmp(ecparams.p) >= 0) return null;\n\tx = x.toRed(ecparams.red);\n\n\tlet y = x.redSqr().redIMul(x).redIAdd(ecparams.b).redSqrt();\n\n\treturn ec.keyPair({ pub: { x, y } });\n}\n"], ["unnamed_tree_constructor", "\nfunction (blockList) {\n        this.errors = [];\n        <initialize_tree>\n        this.tree = new Node(\"file\", null);\n        this.tree.content = [];\n        </initialize_tree>\n\n        <process_blocks>\n        this._advance(blockList, 0, this.tree.content);\n\n        this._postProcessTree();\n        </process_blocks>\n    }\n"], ["unnamed_rrule_text_conversion", "\nfunction() {\n        var gettext = this.gettext;\n\n        if (!(this.options.freq in ToText.IMPLEMENTED)) {\n            return gettext('RRule error: Unable to fully convert this rrule to text');\n        }\n\n        <build_base_text>\n        this.text = [gettext('every')];\n\n        this[RRule.FREQUENCIES[this.options.freq]]();\n        </build_base_text>\n\n        <add_conditions_to_text>\n        if (this.options.until) {\n            this.add(gettext('until'));\n            var until = this.options.until;\n            this.add(this.language.monthNames[until.getMonth()])\n                .add(until.getDate() + ',')\n                .add(until.getFullYear());\n        } else if (this.options.count) {\n            this.add(gettext('for'))\n                .add(this.options.count)\n                .add(this.plural(this.options.count)\n                        ? gettext('times')\n                        : gettext('time'));\n        }\n        </add_conditions_to_text>\n\n        <handle_partial_conversion>\n        if (!this.isFullyConvertible()) {\n            this.add(gettext('(~ approximate)'));\n        }\n        </handle_partial_conversion>\n        \n        return this.text.join('');\n    }\n"], ["sanicJoin", "\nfunction sanicJoin(array, separator = ',') {\n    if (!(array instanceof Array)){\n        throw new TypeError('array is not an Array');\n    }\n\n    if (!array.length){\n        return '';\n    }\n\n    if (array.length === 1){\n        return array[0];\n    }\n\n    let res = String(array[0]), i = 1;\n    const iMax = array.length;\n\n    for (; i < iMax; i++){\n        res += separator + array[i];\n    }\n\n    return res;\n}\n"], ["calculate_distances", "\nfunction (X) {\n\t\tvar N = X.length;\n\t\tvar dist = zeros(N * N); \n\t\tfor (var i = 0; i < N; i++) {\n\t\t\tfor (var j = i + 1; j < N; j++) {\n\t\t\t\t<calculate_distance>\n\t\t\t\tvar d = L2(X[i], X[j]);\n\t\t\t\tdist[i * N + j] = d;\n\t\t\t\tdist[j * N + i] = d;\n\t\t\t\t</calculate_distance>\n\t\t\t}\n\t\t}\n\t\treturn dist;\n\t}\n"], ["typeOf", "\nfunction typeOf (rule) {\n  var ruleType = typeof rule\n  \n  return ruleType === 'function'\n    ? ruleType\n    : ruleType !== 'object'\n      ? (rule.length === 0\n          ? 'noop'\n          : (rule === 0\n              ? 'zero'\n              : ruleType\n            )\n        )\n      : Buffer.isBuffer(rule)\n        ? 'buffer'\n        : !isArray(rule)\n          ? ((has(rule, 'start') && has(rule, 'end')\n              ? 'range'\n              : has(rule, 'start')\n                ? 'rangestart'\n                : has(rule, 'end')\n                  ? 'rangeend'\n                  : has(rule, 'firstOf')\n                    ? (( (isArray(rule.firstOf) && sameTypeArray(rule.firstOf) )\n                        || typeof rule.firstOf === 'string'\n                        )\n                      && rule.firstOf.length > 1\n                      )\n                        ? 'firstof'\n                        : 'invalid firstof'\n                    : 'invalid'\n              )\n              + '_object'\n            )\n          : !sameTypeArray(rule)\n            ? 'multi types array'\n            : ((Buffer.isBuffer( rule[0] )\n                ? 'buffer'\n                : typeof rule[0]\n                )\n                + '_array'\n              )\n}\n"], ["loadRoute", "\nasync function loadRoute ( dir )\n{\nreturn new Promise( async function(resolve, reject){\n    \n    <scan_files>\n    let files = await scanFile ( path.join(dir_app, './'+dir), 'js', true );\n    </scan_files>\n\n    let whole_router;\n    \n    <setup_routers>\n    files.forEach(function( f ){\n        let mod = require(f)\n          , name = path.basename(f, '.js');\n        \n        let router = mod(app.Context);\n        router.__renderForContext(app.Context); \n    });\n    </setup_routers>\n\n    resolve();\n\n});\n}\n"], ["gestureEnd", "\nfunction gestureEnd(ev) {\n    if (!pointer || !typesMatch(ev, pointer)) return;\n\n    updatePointerState(ev, pointer);\n    pointer.endTime = +Date.now();\n\n    <run_gesture_handlers>\n    if (ev.type !== 'pointercancel') {\n      runHandlers('end', ev);\n    }\n    </run_gesture_handlers>\n\n    lastPointer = pointer;\n    pointer = null;\n  }\n"], ["getArgParam", "\nfunction getArgParam(argName, fullArgName) {\n  \n    <search_for_args>\n    for (const arg of [argName, fullArgName]) {\n      if (restArgs.includes(arg)) {\n        return restArgs[restArgs.indexOf(argName) + 1];\n      }\n    }\n    </search_for_args>\n  \n    return undefined;\n}\n"], ["Memcached_constructor", "\nfunction Memcached () {\n  var self = this;\n\n  self.klass = Memcached;\n  self.klass.super_.apply(self, arguments);\n\n  <build_auth_string>\n  var auth = [\n        self.options.server.username,\n        self.options.server.password\n      ].compact().join(':');\n  </build_auth_string>\n\n  <build_domain_and_port>\n  var domain_and_port = [\n        self.options.server.hostname,\n        self.options.server.port\n      ].compact().join(':');\n  </build_domain_and_port>\n\n  <set_server_endpoint>\n  self.options.server.endpoint = auth.isBlank() ? domain_and_port : [auth, domain_and_port].join('@');\n  </set_server_endpoint>\n}\n"], "```\n\nNote: For the \"Memcached\" constructor function, I've inferred that the \"compact\" and \"isBlank\" methods are doing some sort of filtering/validation, which is why I've marked them as separate responsibilities even though they're one-liners. However, if these are just simple property accessor methods with no real logic, they might not warrant their own SRP annotations."]