[["propertyChangeListenerMaintenance", "\nfunction() {\n\n\t\tif (this._property_changed_listener && (this._value_container.getValue() != this._property_container)) {\n\n\t\t\t<removeListeners>\n\t\t\tthis._property_changed_listener && this._property_container.removePropertyListener(this._property_changed_listener);\n\t\t\tthis._enumerable_changed_listener && this._property_container.removeListener(this._enumerable_changed_listener);\n\t\t\tthis._property_changed_listener = null;\n\t\t\tthis._enumerable_changed_listener = null;\n\t\t\tthis._property_container = null;\n\t\t\t</removeListeners>\n\n\t\t}\n\n\t\t<queueForRefresh>\n\t\tthis._queueForRefresh();\n\t\t</queueForRefresh>\n\n\t}\n"], ["handleMouseEvent", "\nfunction(e){\n\t\tif(!this.enableMouse){ return true;}\n\t\t\n\t\t<setMouseButton>\n\t\tthis.setMouseButton(e);\n\t\t</setMouseButton>\n\t\tif(!this.btn){ this.mousereset(); return;}\n\t\t<getBoardAddress>\n\t\tvar addrtarget = this.getBoardAddress(e);\n\t\t</getBoardAddress>\n\t\t<moveTo>\n\t\tthis.moveTo(addrtarget.bx, addrtarget.by);\n\t\t</moveTo>\n\t\t\n\t\t<preventDefaultActions>\n\t\te.stopPropagation();\n\t\te.preventDefault();\n\t\t</preventDefaultActions>\n\t}\n"], ["updateRenderableBoundsPos", "\nfunction updateBoundsPos(x, y) {\n         if (typeof this.body !== \"undefined\") {\n           <updatePositionWithBody>\n           var _pos = this.body.pos;\n\n           this._super(me.Renderable, \"updateBoundsPos\", [x + _pos.x, y + _pos.y]);\n           </updatePositionWithBody>\n         } else {\n           <updatePositionWithoutBody>\n           this._super(me.Renderable, \"updateBoundsPos\", [x, y]);\n           </updatePositionWithoutBody>\n         }\n\n         <getBounds>\n         return this.getBounds();\n         </getBounds>\n       }\n"], ["getCellsInRectangle", "\nfunction (start, end) {\n      <calculateCornerCoordinates>\n      var corners = grid.getCornerCoords([start, end]);\n      </calculateCornerCoordinates>\n      <collectCells>\n      var r, c, output = [];\n      for (r = corners.TL.row; r <= corners.BR.row; r++) {\n        for (c = corners.TL.col; c <= corners.BR.col; c++) {\n          output.push(self.view.getCellAtCoords({\n            row: r,\n            col: c\n          }));\n        }\n      }\n      </collectCells>\n      return output;\n    }\n"], ["createDatabaseSetup", "\nfunction createDB(mongoose, mongoConnectionString, modelPath) {\n    <validateModelPath>\n    if (modelPath[modelPath.length - 1] === \"\\\\\" || modelPath[modelPath.length - 1] === \"/\") {\n        throw new Error(`modelpath should be w.o. trailing \"/\" or \"\\\\\", was ${modelPath} `);\n    }\n    </validateModelPath>\n    \n    <initializeJSONSchema>\n    require('mongoose-schema-jsonschema')(mongoose);\n    </initializeJSONSchema>\n    <openMongooseConnection>\n    return MongoUtils.openMongoose(mongoose, mongoConnectionString)\n    </openMongooseConnection>\n    .then(() => \n    <createDBWithModels>\n    SchemaLoad.createDBWithModels(mongoose, modelPath))\n    </createDBWithModels>\n    .then(() => {\n        <loadModelData>\n        var models = SchemaLoad.loadModelNames(modelPath);\n        return Promise.all(models.map(modelName => loadModelData(mongoose, modelPath, modelName)));\n        </loadModelData>\n    }).then(() => {\n        <disconnectReset>\n        MongoUtils.disconnectReset(mongoose);\n        </disconnectReset>\n    });\n}\n"], ["setTextAnnotationVisibility", "\nfunction(types) {\n\t\t\tif (textUtil.compare(this._textAnnotationTypesVisible, types)) return;\n\t\t\t<setVisibility>\n\t\t\tthis._textAnnotationTypesVisible = types;\n\t\t\t</setVisibility>\n\t\t\tif (!this._annotationStyler || !this._textView) { return; }\n\t\t\t<setAnnotationTypeVisible>\n\t\t\tthis._annotationStyler.setAnnotationTypeVisible(types);\n\t\t\t</setAnnotationTypeVisible>\n\t\t\t<redrawTextView>\n\t\t\tthis._textView.redrawLines(0, undefined);\n\t\t\t</redrawTextView>\n\t\t}\n"], ["checkStartupShutdownLogics", "\nfunction() {\n        if (!this._startupSchedule || !this._shutdownSchedule) {\n            return true;\n        }\n\n        <calculateLastStartup>\n        var lastStartup = later.schedule(this._startupSchedule).prev().getTime();\n        </calculateLastStartup>\n        <calculateLastShutdown>\n        var lastShutdown = later.schedule(this._shutdownSchedule).prev().getTime();\n        </calculateLastShutdown>\n        <evaluateTimings>\n        return lastStartup > lastShutdown;\n        </evaluateTimings>\n    }\n"], ["shutdownSystem", "\nfunction(cb) {\n\t\t<logShutdownAttempt>\n\t\tmodules.logger.log(\"shutdown\",\"ISNode System > Attempting to close all open modules.\");\n\t\t</logShutdownAttempt>\n\t\t<initializeCounters>\n\t\tvar modCount = 0;\n\t\tvar stdModCount = 0;\n\t\tvar interfaceModCount = 0;\n\t\tvar counter = 0;\n\t\t</initializeCounters>\n\t\t<initializeTimeout>\n\t\tif(config.loader.timeouts.closeModules)\n\t\t\tvar timeout = config.loader.timeouts.closeModules\n\t\telse\n\t\t\tvar timeout = 2000;\n\t\tvar timeoutTimer = 0;\n\t\t</initializeTimeout>\n\n\t\t<countModules>\n\t\tObject.keys(modules).forEach(function(key) { stdModCount ++; });\n\t\tstdModCount = stdModCount - 1;\n\t\tObject.keys(modules.interfaces).forEach(function(key) { interfaceModCount ++; });\n\t\tmodCount = stdModCount + interfaceModCount;\n\t\t</countModules>\n\n\t\t<shutdownInterval>\n\t\tvar interval = setInterval(function(){\n\t    \tif(counter >= (modCount - 1)) {\n\t    \t\t<logSuccess>\n\t    \t\tif(modules.logger.log) {\n\t    \t\t\tmodules.logger.log(\"shutdown\",\"ISNode System > Modules all shutdown successfully (\"+counter+\"/\"+(modCount - 1)+\").\");\n\t    \t\t} else {\n\t\t\t\t\tvar currentDate = new Date();\n\t\t\t\t\tcurrentDate = currentDate.toISOString();\n\t\t\t\t\tconsole.log(currentDate + \"(shutdown) ISNode System > Modules all shutdown successfully (\"+counter+\"/\"+(modCount - 1)+\").\");\n\t    \t\t}\n\t    \t\t</logSuccess>\n\t\t\t    clearInterval(interval);\n\t\t\t    <successfulCallback>\n\t\t\t    cb(null, {success:true, message: \"Modules all shutdown successfully\"});\n\t\t\t    </successfulCallback>\n\t\t\t    return;\t\n\t    \t}\n\t    \tif(timeoutTimer > timeout) {\n\t    \t\t<logTimeout>\n\t    \t\tif(modules.logger.log) {\n\t    \t\t\tmodules.logger.log(\"shutdown\",\"ISNode System > Module shutdown timed out (\"+counter+\"/\"+(modCount - 1)+\" Closed Successfully).\");\n\t    \t\t} else {\n\t\t\t\t\tvar currentDate = new Date();\n\t\t\t\t\tcurrentDate = currentDate.toISOString();\n\t\t\t\t\tconsole.log(currentDate + \"(shutdown) ISNode System > Module shutdown timed out (\"+counter+\"/\"+(modCount - 1)+\" Closed Successfully).\");\n\t    \t\t}\n\t    \t\t</logTimeout>\n\t    \t\tclearInterval(interval);\n\t    \t\t<timedOutCallback>\n\t    \t\tvar error = { message: \"Module shutdown timed out\" };\n\t    \t\tcb(error, null);\n\t    \t\t</timedOutCallback>\n\t    \t\treturn;\n\t    \t}\n\t    \ttimeoutTimer += 500;\n\t    }, 500);\n\t\t</shutdownInterval>\n\n\t\t<emitShutdownEvent>\n\t\tprocess.nextTick(function(){\n\t\t\tisnode.on(\"module-shut-down\", function(){\n\t\t\t\tcounter ++;\n\t\t\t});\n\t\t\tisnode.emit(\"shutdown\", \"Shutdown All Modules\");\n\t    \treturn;\n    \t});\n    \t</emitShutdownEvent>\n\t}\n"], ["branchExploration", "\nfunction _exploreBranch(baseWord, currentBranch) {\n    var predictedList = [];\n\n    <exploreAndPredict>\n    for (var b in currentBranch.branches) { \n      var prefix = currentBranch.branches[b].prefix; \n\n      if (currentBranch.branches[b].$ === true) { \n        predictedList.push(baseWord + prefix);\n      }\n\n      \n      var predictedWords = this._exploreBranch(baseWord + prefix, currentBranch.branches[b]);\n\n      predictedList = predictedList.concat(predictedWords);\n\n    }\n    </exploreAndPredict>\n    return predictedList;\n  }\n"], ["createAnimitter", "\nfunction createAnimitter(options, fn){\n\n    <processArguments>\n    if( arguments.length === 1 && typeof options === 'function'){\n        fn = options;\n        options = {};\n    }\n    </processArguments>\n\n    <initializeAnimitterInstance>\n    var _instance = new Animitter( options );\n    </initializeAnimitterInstance>\n\n    <bindUpdateFunction>\n    if( fn ){\n        _instance.on('update', fn);\n    }\n    </bindUpdateFunction>\n\n    return _instance;\n}\n"], "```\n\nThese annotations should provide a clear guide to which parts of the functions are serving specific responsibilities and where SRP violations may occur. If any function contains clearly distinct responsibilities, they are annotated as such, whereas functions that operate cohesively towards a single purpose are annotated as compliant."]