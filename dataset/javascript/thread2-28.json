[["isTablet", "\nfunction isTablet(mockUserAgent) {\n  var userAgent = mockUserAgent || window.navigator.userAgent;\n  return /ipad|Nexus (7|9)|xoom|sch-i800|playbook|tablet|kindle/i.test(userAgent);\n}\n"], ["_add_table_row", "\nfunction _add_table_row(item, color, prefix, suffix){\n  \n  <constructOutputRepresentation>\n  var out_rep = bbopx.noctua.type_to_span(item, color);\n  if( prefix ){ out_rep = prefix + out_rep; }\n  if( suffix ){ out_rep = out_rep + suffix; }\n  </constructOutputRepresentation>\n  \n  <createTableRowString>\n  var trstr = null;\n  if( color ){\n      trstr = '<tr class=\"bbop-mme-stack-tr\" ' +\n    'style=\"background-color: ' + color +\n    ';\"><td class=\"bbop-mme-stack-td\">' + out_rep + '</td></tr>';   \n  }else{\n      trstr = '<tr class=\"bbop-mme-stack-tr\">' +\n    '<td class=\"bbop-mme-stack-td\">' + out_rep + '</td></tr>';   \n  }\n  </createTableRowString>\n  \n  <addToNodeStackTable>\n  enode_stack_table.add_to(trstr);\n  </addToNodeStackTable>\n"], ["createTrackBuffer", "\nfunction (chords, settings) {\n  \n  <makeChordEvents>\n  var chordEvents = makeChordEvents(chords, settings);\n  </makeChordEvents>\n\n  <setPatches>\n  var setPatches = _.reduce(_.range(0xf), function (buffer, channel) {\n    return Buffer.concat([buffer, makePatchEvent(channel, settings.chordPatch)]);\n  }, new Buffer(0));\n  </setPatches>\n\n  <calculateLengthAndReturnBuffer>\n  var length = setPatches.length + chordEvents.length + trackFooter.length;\n  return Buffer.concat([trackHeader, padNumber(length, 4), setPatches, chordEvents, trackFooter]);\n  </calculateLengthAndReturnBuffer>\n}\n"], ["clearErrorMessages", "\nfunction(el) {\n      \n  <collectErrorMessages>\n  var _errorMessages = {};\n  if (typeof el === 'undefined' || (el.length > 1 && el[0].type !== 'checkbox')) {\n    _errorMessages = this.form.querySelectorAll('.' + this.options.errorTemplateClass);\n  } else {\n    _errorMessages = this.parents(el[0]).querySelectorAll('.' + this.options.errorTemplateClass);\n  }\n  </collectErrorMessages>\n  \n  <closeErrorMessages>\n  for (var i = 0, _lengthErrorMessages = _errorMessages.length; i < _lengthErrorMessages; i++) {\n    this.window.close.call(this, _errorMessages[i]);\n  }\n  </closeErrorMessages>\n  \n  this.handler = false;\n}\n"], ["extendRouter", "\nfunction (methods) {\n  \n  <configureRouter>\n  this.lazyRouter();\n  this.router.method(methods);\n  </configureRouter>\n  \n  <defineMethodFunctions>\n  utils.arrayify(methods).forEach(function (method) {\n    this.define(method, function(path) {\n      var route = this.router.route(path);\n      var args = [].slice.call(arguments, 1);\n      route[method].apply(route, args);\n      return this;\n    }.bind(this));\n  }.bind(this));\n  </defineMethodFunctions>\n"], ["parseJavaScriptVariable", "\nfunction parseJavaScriptVariable(body) {\n  \n  <initializeVariablesAndSelectors>\n  let res;\n  let jsonString = '';\n  const $ = cheerio.load(body);\n  </initializeVariablesAndSelectors>\n\n  <extractQuakeInfoJson>\n  $('script').each(function (i, elem) {\n    if (/(VI\\.quakeInfo = .+);/.test($(this).text())) {\n      jsonString = $(elem).html().match(/(VI\\.quakeInfo = )(.+);/)[2];\n    }\n  });\n  </extractQuakeInfoJson>\n  \n  <normalizeJsonString>\n  const resString = jsonString.replace(/(:\\'[-0-9]\\d*)(,)(\\d*)/g, '$1.$3');\n  </normalizeJsonString>\n\n  <convertDatesAndParseJson>\n  const regexDate = /(\\'t\\':)new Date\\((([0-9.,-]+),([0-9.,-]+),([0-9.,-]+),([0-9.,-]+),([0-9.,-]+),([0-9.,-]+))\\)(,\\'a\\')/g;\n  const dateReplace = (match, p1, p2, p3, p4, p5, p6, p7, p8, p9) => {\n    const parsedDate = new Date(\n      parseInt(p3, 10),\n      parseInt(p4.split('-')[0], 10) - 1, parseInt(p5, 10),\n      parseInt(p6, 10),\n      parseInt(p7, 10),\n      parseInt(p8, 10)\n    );\n    return `${p1}\\\\${parsedDate.toISOString()}\\\\${p9}`;\n  };\n  try {\n    res = JSON.parse(resString.replace(regexDate, dateReplace).replace(/\\'/g, '\"'));\n  } catch (ex) {\n    return JSON.parse([{ error: 'Error parsing source.' }]);\n  }\n  </convertDatesAndParseJson>\n  \n  <constructResultFields>\n  const resFields = [];\n  res.forEach((element) => {\n    const tmpRow = {};\n    tmpRow.timestamp = element.t;\n    tmpRow.latitude = element.lat;\n    tmpRow.longitude = element.lon;\n    tmpRow.depth = element.dep;\n    tmpRow.size = element.s;\n    tmpRow.quality = element.q;\n    tmpRow.humanReadableLocation = `${element.dL} km ${element.dD} af ${element.dR}`;\n    resFields.push(tmpRow);\n  });\n  </constructResultFields>\n\n  return resFields;\n}\n"], ["resizeTableColumns", "\nfunction(oColumn) {\n    \n    var allKeys = this._oColumnSet.keys,\n        allKeysLength = allKeys.length,\n        elRow = this.getFirstTrEl();\n\n    \n    if (ua.ie) {\n        this._setOverhangValue(1);\n    }\n\n    if (allKeys && elRow && (elRow.childNodes.length === allKeysLength)) {\n        \n        var sWidth = this.get(\"width\");\n        if (sWidth) {\n            this._elHdContainer.style.width = \"\";\n            this._elBdContainer.style.width = \"\";\n        }\n        this._elContainer.style.width = \"\";\n        \n        \n        if (oColumn && lang.isNumber(oColumn.getKeyIndex())) {\n            this._validateColumnWidth(oColumn, elRow.childNodes[oColumn.getKeyIndex()]);\n        }\n        \n        \n        else {\n            var elTd, todos = [], thisTodo, i, len;\n            for (i = 0; i < allKeysLength; i++) {\n                oColumn = allKeys[i];\n                \n                \n                if (!oColumn.width && !oColumn.hidden && oColumn._calculatedWidth) {\n                    todos[todos.length] = oColumn;\n                }\n            }\n            \n            \n            this._elTbody.style.display = \"none\";\n            for (i = 0, len = todos.length; i < len; i++) {\n                this._setColumnWidth(todos[i], \"auto\", \"visible\");\n            }\n            this._elTbody.style.display = \"\";\n            \n            todos = [];\n\n            \n            for (i = 0; i < allKeysLength; i++) {\n                oColumn = allKeys[i];\n                elTd = elRow.childNodes[i];\n                \n                \n                if (!oColumn.width && !oColumn.hidden) {\n                    var elTh = oColumn.getThEl();\n\n                    \n                    if (elTh.offsetWidth !== elTd.offsetWidth) {\n                        var elWider = (elTh.offsetWidth > elTd.offsetWidth) ?\n                                oColumn.getThLinerEl() : elTd.firstChild;\n                \n                \n                        \n                        var newWidth = Math.max(0,\n                            (elWider.offsetWidth -(parseInt(Dom.getStyle(elWider,\"paddingLeft\"),10)|0) - (parseInt(Dom.getStyle(elWider,\"paddingRight\"),10)|0)),\n                            oColumn.minWidth);\n                            \n                        var sOverflow = 'visible';\n                        \n                        \n                        if ((oColumn.maxAutoWidth > 0) && (newWidth > oColumn.maxAutoWidth)) {\n                            newWidth = oColumn.maxAutoWidth;\n                            sOverflow = \"hidden\";\n                        }\n                \n                        todos[todos.length] = [oColumn, newWidth, sOverflow];\n                    }\n                }\n            }\n            \n            this._elTbody.style.display = \"none\";\n            for (i = 0, len = todos.length; i < len; i++) {\n                thisTodo = todos[i];\n                \n                this._setColumnWidth(thisTodo[0], thisTodo[1]+\"px\", thisTodo[2]);\n                thisTodo[0]._calculatedWidth = thisTodo[1];\n            }\n            this._elTbody.style.display = \"\";\n        }\n    \n        \n        if (sWidth) {\n            this._elHdContainer.style.width = sWidth;\n            this._elBdContainer.style.width = sWidth;\n        }\n    }\n    \n    <syncAndRestoreScroll>\n    this._syncScroll();\n    this._restoreScrollPositions();\n    </syncAndRestoreScroll>\n}\n"], ["getQualifiedName", "\nfunction(namespaceContext) {\n    var canonicalPrefix = namespaceContext ? namespaceContext.getPrefix(this.namespaceURI, this.prefix) : this.prefix;\n    return this.prefix + (this.prefix === '' ? '' : ':') + this.localPart;\n}\n"], ["GENERATE_ENUM", "\nfunction GENERATE_ENUM(name, spec, parent) {\n  return GENERATE_DOC(spec.description + '\\n'\n    + '@property ' + name + '\\n'\n    + '@type Enum ' + spec.type + '\\n'\n    + '@for ' + (parent ? parent : 'common') + '\\n');\n}\n"], ["initializeRadioButton", "\nfunction initialize() {\n      if (!rgCtrl) {\n        throw 'RadioButton: No RadioGroupController could be found.';\n      }\n\n      <addRadioButtonRender>\n      rgCtrl.add(render);\n      </addRadioButtonRender>\n      \n      <observeValueAttribute>\n      attr.$observe('value', render);\n      </observeValueAttribute>\n\n      <setupElementInteractions>\n      element\n        .on('click', listener)\n        .on('$destroy', function() {\n          rgCtrl.remove(render);\n        });\n      </setupElementInteractions>\n}\n"], "```\n\nIn these annotations, individual responsibilities are tagged within each function. The main function tag encompasses the entire function if it meets SRP, or it wraps around nested tags that represent sub-responsibilities within the function that could potentially violate SRP. Simple variable declarations or one-liner expressions have not been tagged as distinct responsibilities unless they significantly change the purpose or behavior of the function."]