[["initRelease", "\nfunction initRelease(fis) {\n    <requireDependencies>\n    var path = require('path');\n\n    var plugins = {\n        concat: require('./prepackager/concat')\n    };\n    </requireDependencies>\n\n    <pluginFunction>\n    var plugin = function (name, options) {\n        var localPlugin = plugins[name];\n        if (typeof localPlugin === 'function') {\n            localPlugin.options = options;\n            return localPlugin\n        } else {\n            return fis.plugin.apply(fis, arguments)\n        }\n    };\n    </pluginFunction>\n\n    <fisConfiguration>\n    fis\n        <projectFiles>\n        .set('project.files', ['views'])\n        </projectFiles>\n        <fileMatchConfigurations>\n        .match('**', {\n            useHash: false,\n        })\n        [...]\n        .match(/^\\/components\\/framework\\/dialog\\/(.*)\\.html$/i, {\n            url: '/assets/$1.html',\n            release: '${statics}/${name}/${version}/assets/$1.html'\n        })\n        </fileMatchConfigurations>\n        <packageConfigurations>\n        .match('::package', {\n            spriter: plugin('csssprites', {\n                htmlUseSprite: true,\n                layout: 'matrix',\n                margin: '15',\n                styleReg: /(<style(?:(?=\\s)[\\s\\S]*?[\"'\\s\\w\\/\\-]>|>))([\\s\\S]*?)(<\\/style\\s*>|$)/ig\n            }),\n            [...]\n            packager: plugin('map')\n        })\n        </packageConfigurations>\n\n        <productionEnvironmentConfigurations>\n        fis.media('prod')\n        [...]\n        .match(\"component_modules*.(css)\", {\n            packTo: \"/vendor.css\"\n        });\n        </productionEnvironmentConfigurations>\n\n        <conditionalComboHandling>\n        if(frameworkConfig.combo) {\n            fis.media('prod').match(\"components/framework*.js\", {\n                packTo: \"/framework.js\"\n            })\n            [...]\n            });\n        }\n        else {\n            fis.media('prod').match(\"components*.js\", {\n                preprocessor: plugin('annotate'),\n                optimizer: plugin('uglify-js', {\n                    compress: {\n                        warnings: false,\n                        drop_console: true,\n                        dead_code: true,\n                    },\n                    output: {\n                        ascii_only: true\n                    },\n                    comments: true,\n                    mangle: frameworkConfig.mangleJS || false\n                }),\n                packTo: \"/modules.js\"\n            });\n        }\n        </conditionalComboHandling>\n\n        <domainConfiguration>\n        var map = {\n            'rd': {\n                host: '',\n                path: ''\n            },\n            [...]\n        };\n        </domainConfiguration>\n\n        <mediaConfiguration>\n        Object.keys(map).forEach(function (v) {\n            var o = map[v];\n            var domain = o.host + o.path;\n\n            fis.media(v)\n            [...]\n            .match('/modules/app/**.{es,js}', {\n                packTo: '/pkg/aio.js'\n            });\n        });\n        </mediaConfiguration>\n\n        <compressionOptimization>\n        Object.keys(map)\n        .filter(function (v) {\n            return v.indexOf('debug') < 0\n        })\n        [...]\n        </compressionOptimization>\n\n        <productionDeployConfiguration>\n        fis.media('production')\n        [...]\n        });\n        </productionDeployConfiguration>\n\n        <developmentDeployConfiguration>\n        ['rd', 'rd-debug'].forEach(function (v) {\n            fis.media(v)\n            [...]\n            });\n        });\n        </developmentDeployConfiguration>\n    });\n}\n"], ["processMultiBytePacket", "\nfunction processMultiBytePacket (o) {\n  <multiPacketBufferHandling>\n  if (o.multiPacketBuffer) {\n    o.multiPacketBuffer = Buffer.concat([Buffer.from(o.multiPacketBuffer), Buffer.from(o.rawDataPacket.slice(k.OBCIGanglionPacket19Bit.dataStart, k.OBCIGanglionPacket19Bit.dataStop))]);\n  } else {\n    o.multiPacketBuffer = o.rawDataPacket.slice(k.OBCIGanglionPacket19Bit.dataStart, k.OBCIGanglionPacket19Bit.dataStop);\n  }\n  </multiPacketBufferHandling>\n}\n"], ["init", "\nfunction init(options, callback, proxies, logLevel) {\n    <defaultOptionsLoading>\n    globalOptions = createDefaultOptions();\n    </defaultOptionsLoading>\n\n    <optionsExtension>\n    if (options) {\n        _.extend(globalOptions, options);\n    }\n    </optionsExtension>\n\n    <rateLimitsAdjustment>\n    if (globalOptions.rateLimits !== 0) {\n        globalOptions.maxConnections = 1;\n    }\n    </rateLimitsAdjustment>\n\n    <storeInitialization>\n    store.createStore(globalOptions.storeModuleName, globalOptions.storeParams ? globalOptions.storeParams : null);\n    </storeInitialization>\n\n    <updateDepth>\n    if (globalOptions.updateDepth) {\n        updateDepthFn = globalOptions.updateDepth;\n    }\n    </updateDepth>\n\n    <endCallbackSetting>\n    endCallback = callback;\n    requestQueue.init(globalOptions, crawl, recrawl, endCallback, proxies);\n    </endCallbackSetting>\n\n    <logLevelSetting>\n    if (logLevel) {\n        console.log(\"Change Log level into :\" + logLevel);\n        log.level(logLevel);\n    }\n    else {\n        log.level(\"info\"); // If log level is not passed, set to 'info' by default\n    }\n    </logLevelSetting>\n\n    <callbackVerification>\n    if (!callback) {\n        log.error(\"The end callback is not defined\");\n    }\n    </callbackVerification>\n}\n"], ["settingsApiHttpHandling", "\nfunction () {\n    <apiRequest>\n    var self = this;\n    $http.get(settingsApi)\n      .success(function (data) {\n        self.set(data);\n        $timeout(function () {\n          self.loaded = true;\n        });\n      })\n      .error(function () {\n        self.reset();\n        $timeout(function () {\n          self.loaded = true;\n        });\n      });\n    </apiRequest>\n  }\n"], ["processFilterRestrictions", "\nfunction (oProperty, oEntitySet) {\n    <filterRestrictionsInitialization>\n    var aFilterRestrictions,\n        sFilterRestrictionValue = mFilterRestrictions[oProperty[\"sap:filter-restriction\"]];\n    </filterRestrictionsInitialization>\n\n    aFilterRestrictions = oEntitySet[\"com.sap.vocabularies.Common.v1.FilterExpressionRestrictions\"] || [];\n\n    aFilterRestrictions.push({\n        \"Property\" : { \"PropertyPath\" : oProperty.name},\n        \"AllowedExpressions\" : {\n            \"EnumMember\" : \"com.sap.vocabularies.Common.v1.FilterExpressionType/\"\n                + sFilterRestrictionValue\n        }\n    });\n    oEntitySet[\"com.sap.vocabularies.Common.v1.FilterExpressionRestrictions\"] = aFilterRestrictions;\n\n    <warningUnsupportedFilterRestriction>\n    if (!sFilterRestrictionValue) {\n        if (Log.isLoggable(iWARNING, sLoggingModule)) {\n            Log.warning(\"Unsupported sap:filter-restriction: \"\n                    + oProperty[\"sap:filter-restriction\"],\n                oEntitySet.entityType + \".\" + oProperty.name, sLoggingModule);\n        }\n        return;\n    }\n    </warningUnsupportedFilterRestriction>\n}\n"], ["rename", "\nfunction rename(filepath, options) {\n    <filepathProcessing>\n    var base = filepath.substr(0, filepath.lastIndexOf('.'));\n    return base + (options.extname || '.html');\n    </filepathProcessing>\n}\n"], ["convertTextNode", "\nfunction convertTextNode(node) {\n    <processLeaves>\n    if (node.leaves) {\n        const processedLeaves = node.leaves.map(processLeaves);\n        [...]\n        const condensedNodes = processedLeaves.reduce(condenseNodesReducer, { nodes: [] });\n        return condensedNodes.nodes;\n    }\n    </processLeaves>\n\n    <inlineNodesTransform>\n    if (node.object === 'inline') {\n        return transform(node);\n    }\n    </inlineNodesTransform>\n\n    <textNodeCreation>\n    return u('html', node.text);\n    </textNodeCreation>\n}\n"], ["horizontalBarsTween", "\nfunction horizontalBarsTween(d) {\n    <interpolationFunction>\n    let node = d3Selection.select(this),\n        i = d3Interpolate.interpolateRound(0, xScale(getValue(d))),\n        j = d3Interpolate.interpolateNumber(0, 1);\n\n    return function (t) {\n        node.attr('width', i(t))\n            .style('opacity', j(t));\n    }\n    </interpolationFunction>\n}\n"], ["labJackResults", "\nfunction(me) {\n    <resultsInitialization>\n    var results = {\n        'deviceType': me.deviceType,\n        'deviceTypeNum': me.devType,\n        'connectionType': me.connectionType,\n        'connectionTypeNum': me.connType,\n    };\n    </resultsInitialization>\n\n    <openedDevices>\n    var numOpened = me.numOpened.deref();\n    var handles = [];\n    for(var i = 0; i < numOpened; i++) {\n        var handle = me.aHandles.readInt32LE(i * ARCH_INT_NUM_BYTES);\n        handles.push(handle);\n    }\n    results.numOpened = numOpened;\n    results.handles = handles;\n    </openedDevices>\n\n    <errorAnalysis>\n    var numErrors = me.numErrors.deref();\n    var failedOpens = [];\n    results.numErrors = numErrors;\n    results.failedOpens = failedOpens;\n\n    var errorHandle = me.errorHandle.readInt32LE(0);\n\n    var pointerToCharStar = ref.readPointer(me.errors, 0, ARCH_POINTER_SIZE);\n    var parsedCharStar = ref.readCString(pointerToCharStar, 0);\n    var errorsString = parsedCharStar;\n    var errorsObj = {};\n    try {\n        errorsObj = JSON.parse(errorsString);\n    } catch(err) {\n        errorsObj = {\n            'exceptions': [],\n            'networkInterfaces': [],\n            'returnedDevices': [],\n            'specificIPs': [],\n        };\n    }\n\n    results.errorHandle = errorHandle;\n    results.errors = errorsObj;\n    </errorAnalysis>\n\n    <returnResults>\n    return results;\n    </returnResults>\n}\n"], ["main", "\nfunction main(args, pid) {\n    <usageValidation>\n    if (args.length <3) {\n        console.log('Usage: fuck [you] PROCESS_NAME');\n        process.exit(1);\n    }\n    </usageValidation>\n\n    <processPattern>\n    var pattern = last(args).get();\n    </processPattern>\n    \n    <processFiltering>\n    var processes = ps.list();\n    </processFiltering>\n\n    <processKilling>\n    var killed = processes.map(function(data) {\n                    return data.filter(match(pid, pattern))\n                               .map(kill);\n                  });\n    </processKilling>\n\n    <killSequence>\n    killed.chain(sequence(Task)).map(collectUnique).fork(\n        function onError(e) {\n            console.log('');\n            shock('It\u2019s not very effective...');\n        },\n        function onSuccess(xs) {\n            console.log('');\n            if (xs.length > 0)\n                xs.forEach(function(process){\n                    rage(flip(process.name), '(x', process.pids.length, ': ', process.pids.join(', '), ')');\n                });\n            else\n                shock('I\u2019ve got nothing on ', pattern);\n        }\n    );\n    </killSequence>\n}\n"], ""]