[["watchValidity", "\nfunction watchValidity() {\n\t\tif( !unwatch ) {\n\t\t\tunwatch = $scope.$watch(\n\t\t\t\tfunction() {\n\t\t\t\t\t<evaluateAndValidate>\n\t\t\t\t\tvar results = evaluateConstraints(ngModel.$modelValue, true);\n\t\t\t\t\treturn isValid(results);\n\t\t\t\t\t</evaluateAndValidate>\n\t\t\t\t},\n\t\t\t\tfunction(newval, oldval) {\n\t\t\t\t\tif( newval !== oldval ) {\n\t\t\t\t\t\t<ngModelValidation>\n\t\t\t\t\t\tngModel.$validate();\n\t\t\t\t\t\t</ngModelValidation>\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t);\n\t\t}\n\t}\n"], ["jql", "\nfunction jql(queryChunks, ...injects) {\n    try {\n        let res = '';\n        for (let i = 0; i < injects.length; i++) {\n            let value = injects[i];\n            let q = queryChunks[i];\n            \n            <prepareValues>\n            if (typeof value === 'string') {\n                value = cleanString(value);\n            }\n            else if (Array.isArray(value)) {\n                value = value.map((it) => {\n                    if (Array.isArray(it))\n                        throw new Error('JQL: Nested arrays not supported . Consider using a nativeFunction for that query instead.')\n                    if (typeof it === 'string') {\n                        it = cleanString(it);\n                    }\n                    return it;\n                })\n                value = \"(\" + value.join(', ') + \")\";\n            }\n            </prepareValues>\n            \n            res += q + value;\n        }\n        res += queryChunks[queryChunks.length - 1];\n        return res;\n    } catch (err) {\n        <handleJqlErrors>\n        throw new Boom.badRequest('Bad JQL:', err)\n        </handleJqlErrors>\n    }\n}\n"], ["setHttpMetadata", "\nfunction setHttpMetadata (file, res) {\n  <parseContentTypeHeader>\n  var header = res.headers['content-type'];\n  if (header && typeof header === 'string') {\n    var parsed = contentType.parse(header);\n    file.mimeType = lowercase(parsed.type);\n    file.encoding = lowercase(parsed.parameters.charset || null);\n  }\n  </parseContentTypeHeader>\n}\n"], ["extendSelect", "\nfunction (cols) {\n            <parseAndConcatArguments>\n            cols = argsToArray(arguments);\n            var currentSelect = this.__opts.select;\n            if (!currentSelect || !currentSelect.length) {\n                currentSelect = [this._static.WILDCARD];\n            }\n            </parseAndConcatArguments>\n            return this.select.apply(this, currentSelect.concat(cols));\n        }\n"], ["updateAllPackages", "\nfunction updateAllPackages(rootPkgPath, packagesPath) {\n  <findAndReducePkgPaths>\n  const paths = findPackages(packagesPath);\n  return paths.reduce((promise, pkgPath) => promise.then(() => updateSinglePackage(rootPkgPath, pkgPath)), Promise.resolve());\n  </findAndReducePkgPaths>\n}\n"], ["Serialize", "\nfunction Serialize (elem) {\n  <serializeInitialization>\n  if (!(this instanceof Serialize))\n    return new Serialize(elem)\n  if (!elem || elem.nodeType !== Node.ELEMENT_NODE)\n    throw TypeError('Serialize can only serialize element nodes.')\n  </serializeInitialization>\n  var text = ''\n  this.length = 0\n  this.markups = []\n  this.type = elem.nodeName.toLowerCase()\n  \n  <textProperty>\n  Object.defineProperty(this, 'text', {\n    configurable: true,\n    enumerable: true,\n    get: function () {\n      return text\n    },\n    set: function (newText) {\n      this.length = newText.length\n      text = newText\n    }\n  })\n  </textProperty>\n  \n  <convertElement>\n  convert(elem, this)\n  </convertElement>\n}\n"], ["generateFieldDefinitions", "\nfunction(){\n        var f = [],\n            i, n = this._fieldCount,\n            fieldOrder = this.fieldOrder\n        ;\n        for (i = 0; i < n; i++) f[i] = this.fieldDef(fieldOrder[i]);\n        return f;\n    }\n"], ["hasFileWithHigherPriorityExtension", "\nfunction hasFileWithHigherPriorityExtension(file, literalFiles, wildcardFiles, extensions, keyMapper) {\n        <checkForHigherPriorityFiles>\n        var extensionPriority = ts.getExtensionPriority(file, extensions);\n        var adjustedExtensionPriority = ts.adjustExtensionPriority(extensionPriority);\n        for (var i = 0 ; i < adjustedExtensionPriority; i++) {\n            var higherPriorityExtension = extensions[i];\n            var higherPriorityPath = keyMapper(ts.changeExtension(file, higherPriorityExtension));\n            if (higherPriorityPath in literalFiles || higherPriorityPath in wildcardFiles) {\n                return true;\n            }\n        }\n        </checkForHigherPriorityFiles>\n        return false;\n    }\n"], ["shutdownHandler", "\nfunction shutdownHandler(job) {\n   <attemptInProgressStatus>\n   job.inProgress({ operation: job.operation, step: 'attempting' }, function(err) { \n      showJobsError(err);\n   </attemptInProgressStatus>\n      <extractAndPersistDelay>\n      var delay = (isUndefined(job.document.delay) ? '0' : job.document.delay.toString());\n      </extractAndPersistDelay>\n      \n      <initiateShutdown>\n      exec('sudo /sbin/shutdown -k +' + delay, function (err) { \n         if (!isUndefined(err)) {\n            <handleShutdownFailure>\n            job.failed({ operation: job.operation, errorCode: 'ERR_SYSTEM_CALL_FAILED', errorMessage: 'unable to execute shutdown, check passwordless sudo permissions on agent', \n                         error: errorToString(err) }, showJobsError);\n            </handleShutdownFailure>\n         } else {\n            <confirmShutdownInitiation>\n            job.succeeded({ operation: job.operation, step: 'initiated' }, function (err) {\n               showJobsError(err);\n               exec('sudo /sbin/shutdown +' + delay);\n            });\n            </confirmShutdownInitiation>\n         }\n      });\n   });\n}\n"], ["parseChannelEvent", "\nfunction parseChannelEvent(delay, type, channel, cursor) {\n    <parseChannelEventSpecs>\n    var specs = {};\n    switch (type) {\n    case ChannelEvent.TYPE.NOTE_OFF:\n        specs.note = cursor.readUInt8();\n        specs.velocity = cursor.readUInt8();\n        break;\n    case ChannelEvent.TYPE.NOTE_ON:\n        specs.note = cursor.readUInt8();\n        specs.velocity = cursor.readUInt8();\n        break;\n    case ChannelEvent.TYPE.NOTE_AFTERTOUCH:\n        specs.note = cursor.readUInt8();\n        specs.pressure = cursor.readUInt8();\n        break;\n    case ChannelEvent.TYPE.CONTROLLER:\n        specs.controller = cursor.readUInt8();\n        specs.value = cursor.readUInt8();\n        break;\n    case ChannelEvent.TYPE.PROGRAM_CHANGE:\n        specs.program = cursor.readUInt8();\n        break;\n    case ChannelEvent.TYPE.CHANNEL_AFTERTOUCH:\n        specs.pressure = cursor.readUInt8();\n        break;\n    case ChannelEvent.TYPE.PITCH_BEND:\n        specs.value = cursor.readUInt8() +\n            (cursor.readUInt8() << 7) - 8192;\n        break;\n    }\n    </parseChannelEventSpecs>\n    \n    return new ChannelEvent(type, specs, channel, delay);\n}\n"], ""]