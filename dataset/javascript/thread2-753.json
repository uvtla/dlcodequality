[["getBlogUrl", "\nfunction getBlogUrl(secure) {\n    var blogUrl;\n\n    <toggleSecureProtocol>\n    if (secure) {\n        blogUrl = config.get('url').replace('http:', 'https:');\n    } else {\n        blogUrl = config.get('url');\n    }\n    </toggleSecureProtocol>\n\n    <ensureTrailingSlash>\n    if (!blogUrl.match(/\\/$/)) {\n        blogUrl += '/';\n    }\n    </ensureTrailingSlash>\n\n    return blogUrl;\n}\n"], ["anonymousFunction", "\nfunction(resources, start, min, max) {\n  <convertStartToDateFormat>\n  start = start ? new Date(start) : new Date();\n  </convertStartToDateFormat>\n  <getReservationCall>\n  return getReservation(resources, start.getTime(), min || 1, max);\n  </getReservationCall>\n}\n"], ["parseMultiPolygonGeometry", "\nfunction parseMultiPolygonGeometry(coordinates) {\n    var multiPolygonWkt = [];\n    <parseCoordinates>\n    for (var i = 0; i < coordinates.length; i++) {\n        multiPolygonWkt.push('(' + parsePolygonGeometry(coordinates[i]) + ')');\n    }\n    </parseCoordinates>\n    return multiPolygonWkt.join(', ');\n}\n"], ["derive", "\nfunction derive(makeDefaultOpt, initialize, proto) {\n\n    <resolveInitializeProto>\n    if (typeof initialize == 'object') {\n        proto = initialize;\n        initialize = null;\n    }\n    </resolveInitializeProto>\n\n    var _super = this;\n\n    <derivePropertyList>\n    var propList;\n    if (!(makeDefaultOpt instanceof Function)) {\n        propList = [];\n        for (var propName in makeDefaultOpt) {\n            if (makeDefaultOpt.hasOwnProperty(propName)) {\n                propList.push(propName);\n            }\n        }\n    }\n    </derivePropertyList>\n\n    <deriveSubFunction>\n    var sub = function(options) {\n        _super.apply(this, arguments);\n\n        <applyDefaults>\n        if (makeDefaultOpt instanceof Function) {\n            extend(this, makeDefaultOpt.call(this, options));\n        }\n        else {\n            extendWithPropList(this, makeDefaultOpt, propList);\n        }\n        </applyDefaults>\n\n        <callInitializers>\n        if (this.constructor === sub) {\n            var initializers = sub.__initializers__;\n            for (var i = 0; i < initializers.length; i++) {\n                initializers[i].apply(this, arguments);\n            }\n        }\n        </callInitializers>\n    };\n    </deriveSubFunction>\n    \n    <setupPrototypeChain>\n    sub.__super__ = _super;\n    if (!_super.__initializers__) {\n        sub.__initializers__ = [];\n    } else {\n        sub.__initializers__ = _super.__initializers__.slice();\n    }\n    if (initialize) {\n        sub.__initializers__.push(initialize);\n    }\n    var Ctor = function() {};\n    Ctor.prototype = _super.prototype;\n    sub.prototype = new Ctor();\n    sub.prototype.constructor = sub;\n    extend(sub.prototype, proto);\n    </setupPrototypeChain>\n\n    <extendSub>\n    sub.extend = _super.extend;\n    sub.derive = _super.extend;\n    </extendSub>\n\n    return sub;\n}\n"], ["_applys_to_us_p", "\nfunction _applys_to_us_p(data){\n    var ret = false;\n\n    <checkForApplicableModelId>\n    var mid = data['model_id'] || null;\n    if( ! mid || mid != anchor.model_id ){\n        ll('skip packet--not for us');\n    }else{\n        ret = true;\n    }\n    </checkForApplicableModelId>\n\n    return ret;\n}\n"], ["pathExpressions", "\nfunction pathExpressions (token, tokens) {\n  <initializeExpressions>\n  const expressions = []\n  token = tokens.shift()\n  </initializeExpressions>\n  <parsePathExpressions>\n  while (true) {\n    if (!token) {\n      throw new Error(`A path expression should end with \")\"`)\n    }\n    if (token === ')') {\n      break\n    }\n    expressions.push(pathExpression(token, tokens))\n    token = tokens.shift()\n  }\n  </parsePathExpressions>\n  return { _type: pathExpressions.name, expressions }\n}\n"], ["importEnvironmentVariablesFromObject", "\nfunction importEnvironmentVariablesFromObject(object) {\n    const environmentVariables = <mergeEnvironmentVariables>\n    Object.assign(\n        {},\n        Object(object).environmentVariables || Object(object)['environment-variables']\n    );\n    </mergeEnvironmentVariables>\n\n    <parseEnvironmentVariables>\n    for (const key in environmentVariables) {\n        environmentVariables[key] = valueParser(environmentVariables[key]).parse().nodes;\n    }\n    </parseEnvironmentVariables>\n\n    return environmentVariables;\n}\n"], ["RTCChannelStream", "\nfunction RTCChannelStream(channel) {\n  <validateInstanceOf>\n  if (! (this instanceof RTCChannelStream)) {\n    return new RTCChannelStream(channel);\n  }\n  </validateInstanceOf>\n\n  <initializeStream>\n  stream.Duplex.call(this, {\n    decodeStrings: false,\n    objectMode: true\n  });\n  </initializeStream>\n\n  <initializeQueues>\n  this._rq = [];\n  this._wq = [];\n  </initializeQueues>\n\n  <setClosedState>\n  this._closed = channel.readyState === 'closed';\n  </setClosedState>\n\n  <assignChannel>\n  this.channel = channel;\n  </assignChannel>\n\n  <setBinaryType>\n  channel.binaryType = 'arraybuffer';\n  </setBinaryType>\n\n  <assignEventHandlers>\n  this._handlers = {\n    message: this._handleMessage.bind(this),\n    close: this._handleClose.bind(this),\n    open: this._handleOpen.bind(this)\n  };\n  </assignEventHandlers>\n\n  <addEventListener>\n  if (typeof channel.addEventListener == 'function') {\n    channel.addEventListener('message', this._handlers.message);\n    channel.addEventListener('close', this._handlers.close);\n    channel.addEventListener('open', this._handlers.open);\n  } else {\n    channel.onmessage = this._handlers.message;\n    channel.onclose = this._handlers.close;\n    channel.onopen = this._handlers.open;\n  }\n  </addEventListener>\n\n  <handleOpenState>\n  if (channel.readyState === 'open') {\n    this._handlers.open();\n  }\n  </handleOpenState>\n\n  <bindFinishEvent>\n  this.once('finish', this._dcsend.bind(this, ENDOFSTREAM));\n  </bindFinishEvent>\n}\n"], ["camelcase", "\nfunction camelcase(flag) {\n  <convertToCamelCase>\n  return flag.split('-').reduce(function(str, word){\n    return str + word[0].toUpperCase() + word.slice(1);\n  });\n  </convertToCamelCase>\n}\n"], ["linterResults", "\nfunction linterResults(_results, code) {\n        \n        var results = <parseResults>JSON.parse(_results);</parseResults>\n        var res = [{\n            filePath: resourcePath,\n            messages: Object.assign([], results[resourcePath])\n        }];\n\n        <processMessages>\n        if (res[0].messages.length > 0) {\n            (function () {\n                var warnings = 0;\n                var errors = 0;\n                var messages = res[0].messages;\n                messages.forEach(function (linter) {\n                    if (linter.severity === 'warning') {\n                        warnings++;\n                    } else if (linter.severity === 'error') {\n                        errors++;\n                    }\n                });\n                var msg = (0, _scsslintStylish2.default)(res);\n                var emitter = void 0;\n                if (errors > 0) {\n                    emitter = webpack.emitError;\n                } else {\n                    emitter = webpack.emitWarning;\n                }\n                emitter(msg);\n            })();\n        }\n        </processMessages>\n    }\n"], "```"]