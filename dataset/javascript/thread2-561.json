[["validateChildrenAreOptionsAndMaximumOnePlaceholder", "\nfunction validateChildrenAreOptionsAndMaximumOnePlaceholder(props, propName, componentName) {\n  <filterValidChildren>\n  const validChildren = filterReactChildren(props[propName], (node) => (\n    (isOption(node) || isSeparator(node) || isPlaceholder(node))\n  ));\n  if (React.Children.count(props[propName]) !== React.Children.count(validChildren)) {\n    return new Error(`Invalid children supplied to \\`${componentName}\\`, expected an Option, Separator or Placeholder component from Belle.`);\n  }\n  </filterValidChildren>\n\n  <checkPlaceholdersCount>\n  const placeholders = filterReactChildren(props[propName], (node) => isPlaceholder(node));\n  if (React.Children.count(placeholders) > 1) {\n    return new Error(`Invalid children supplied to \\`${componentName}\\`, expected only one Placeholder component.`);\n  }\n  </checkPlaceholdersCount>\n\n  return undefined;\n}\n"], ["_cleanURL", "\nfunction _cleanURL(url) {\n  <cleanURLLogic>\n  var index = url.search(/[#\\?]/);\n  if (index >= 0) {\n    url = url.substr(0, index);\n  }\n  </cleanURLLogic>\n  return url;\n}\n"], ["defaultStrategy", "\nfunction defaultStrategy(projectDir, builder, cb)\n{\n  <buildFromPackage>\n  const pkg = fs.realpathSync(INSTALLER_PACKAGE);\n  builder.buildFromPackage(pkg, projectDir, cb);\n  </buildFromPackage>\n}\n"], ["validateMaxValue", "\nfunction(value, attr, maxValue, model) {\n  <validateNumberAndMaxValue>\n  if (!isNumber(value) || value > maxValue) {\n    return this.format(getMessageKey(this.msgKey, defaultMessages.max), this.formatLabel(attr, model), maxValue);\n  }\n  </validateNumberAndMaxValue>\n}\n"], ["AudioConnection", "\nfunction( connection, sessionId, options ) {\n  if( sessionId === undefined ) { sessionId = null; }\n\n  <initializeProperties>\n  var self = this;\n  this.connection = connection;\n  this.sessionId = sessionId;\n\n  this.eventEmitter = new EventEmitter();\n  this.frames = [];\n\n  this.writtenUntil = Date.now();\n  if( options ) {\n    this.noEmptyFrames = options.noEmptyFrames;\n  }\n\n  if( !this.noEmptyFrames ) {\n    this.emptyFrame = new Buffer( this.connection.FRAME_SIZE * 2 );\n    this.emptyFrame.fill( 0 );\n  }\n  </initializeProperties>\n\n  <setupVoiceListener>\n  this.voiceListener = function( data ) { self._addAudio( data ); };\n\n  if( sessionId === null ) {\n    connection.on( 'voice', this.voiceListener );\n  } else {\n    connection.on( 'voice-user-' + sessionId, this.voiceListener );\n  }\n  </setupVoiceListener>\n\n  <extendReadableStream>\n  ReadableStream.call( this, options );\n  </extendReadableStream>\n}\n"], ["_removeHints", "\nfunction _removeHints() {\n  <queryAndRemoveHints>\n  var hints = this._targetElement.querySelectorAll('.introjs-hint');\n\n  if (hints && hints.length > 0) {\n    for (var i = 0; i < hints.length; i++) {\n      _removeHint.call(this, hints[i].getAttribute('data-step'));\n    }\n  }\n  </queryAndRemoveHints>\n}\n"], ["parseObjectPropertyKey", "\nfunction parseObjectPropertyKey() {\n  <initializeAndLexToken>\n  var token;\n\n  index = lookahead.start;\n  token = lex();\n  </initializeAndLexToken>\n\n  <checkTokenTypeAndFinish>\n  if (token.type === TokenStringLiteral || token.type === TokenNumericLiteral) {\n    if (token.octal) {\n      throwError(token, MessageStrictOctalLiteral);\n    }\n    return finishLiteral(token);\n  }\n  \n  return finishIdentifier(token.value);\n  </checkTokenTypeAndFinish>\n}\n"], ["handleRequest", "\nfunction (endPoint, request, response) {\n  <initializeValues>\n  var self = this,\n      context,\n      requestHandler,\n      handledWithErrorHandler = false,\n      buffers = [],\n      bufferLength = 0;\n  </initializeValues>\n\n  <setupDomain>\n  var domain = Domain.create();\n\n  domain.add(request);\n  domain.add(response);\n  </setupDomain>\n\n  <handleRequestData>\n  request.on('data', function (chunk) {\n    buffers.push(chunk);\n    bufferLength += chunk.length;\n  });\n  \n  response.on('close', function () {\n    domain.dispose();\n  });\n\n  domain.on('error', handleError);\n  </handleRequestData>\n\n  <processRequestEnd>\n  request.on('end', function () {\n    <compileRequestBody>\n    request.body = new Buffer(bufferLength);\n\n    var pos = 0;\n\n    for (var i = 0; i < buffers.length; i++) {\n      buffers[i].copy(request.body, pos);\n      pos += buffers[i].length;\n    }\n\n    request.body.content = request.body.toString();\n\n    buffers = null;\n    </compileRequestBody>\n\n    <handleRequestInDomain>\n    domain.run(function () {\n      <createCommandContext>\n      context = new Context(self, endPoint, request, response);\n      requestHandler = self.$handlers.getRequestHandler(context);\n      context.handler = requestHandler;\n      </createCommandContext>\n\n      <executeRequestFlow>\n      flow()\n        .seq(function (cb) {\n          context._executeHook(\"beginRequest\", cb);\n        })\n        .seq(function (cb) {\n          if (requestHandler.$.autoStartSession) {\n            context.session.start(cb);\n          } else {\n            cb();\n          }\n        })\n        .seq(function (cb) {\n          requestHandler.handleRequest(context, cb);\n        })\n        .exec(function (err) {\n          if (err) {\n            handleError(err);\n          } else {\n            context.response.end();\n          }\n        });\n      </executeRequestFlow>\n    });\n    </handleRequestInDomain>\n  });\n  </processRequestEnd>\n\n  <handleErrorFunction>\n  function handleError(err) {\n    if (!handledWithErrorHandler) {\n      handledWithErrorHandler = true;\n\n      <handleErrorWithExceptionHandler>\n      var exceptionHandler = new ExceptionHandler(err);\n      try {\n        exceptionHandler.handleRequest(context, function (err) {\n          err && handleErrorTheHardWay(err);\n        });\n      } catch (e) {\n        handleErrorTheHardWay(err);\n      }\n      </handleErrorWithExceptionHandler>\n\n    } else {\n      <handleErrorDirectly>\n      handleErrorTheHardWay(err);\n      </handleErrorDirectly>\n    }\n  }\n  </handleErrorFunction>\n\n  <handleErrorTheHardWayFunction>\n  function handleErrorTheHardWay(error) {\n    <logAndSend500Error>\n    console.error(error);\n\n    try {\n      response.writeHead(500);\n    } catch (error) {\n      console.error('Error sending 500', error, request.url);\n    }\n\n    response.end('Internal Server Error');\n    domain.dispose();\n    </logAndSend500Error>\n  }\n  </handleErrorTheHardWayFunction>\n}\n"], ["localizeElements", "\nfunction(language){\n  \n  <queryElementsWithDataI18n>\n  var els, x, id, html;\n\n  els = document.querySelectorAll('[data-i18n]');\n  </queryElementsWithDataI18n>\n\n  <updateElementInnerHTML>\n  for(x=0; x<els.length; x++){\n    id = els[x].getAttribute('data-i18n');\n\n    if(id == ''){\n      id = els[x].innerText();\n    }\n\n    html = hashedit.i18n(id);\n\n    els[x].innerHTML = html;\n  }\n  </updateElementInnerHTML>\n}\n"], ["readFileAsText", "\nfunction (o, cb) {\n  <tryReadFile>\n  try {\n    <setupFileReader>\n    var reader = new FileReader();\n    reader.onload = function (event) {\n      cb && cb(reader.result);\n    };\n    </setupFileReader>\n    <performFileRead>\n    reader.readAsText(o);\n    </performFileRead>\n  } catch (error) {\n    throw error\n  }\n  </tryReadFile>\n}\n"], ""]