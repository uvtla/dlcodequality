[["initializeComponent", "\nfunction () {\n  <applyBaseInitialization>\n  base.init.apply(this, arguments);\n  </applyBaseInitialization>\n\n  <setupElementAndBindings>\n  var element = this.get_element();\n\n  var amap = AtomUI.attributeMap(element, /^atom\\-(name|local\\-scope)$/gi);\n\n  var aname = amap[\"atom-name\"];\n  if (!aname) {\n    var eid = element.id;\n    if (!/^\\_\\_waID/.test(eid)) {\n      aname = element.id;\n    }\n  } else {\n    element.removeAttributeNode(aname.node);\n    aname = aname.value;\n  }\n  if (aname) {\n    if (/^(app|window|owner|scope|localScope|parent)$/gi.test(aname))\n      throw new Error(\"Invalid Control Name '\" + aname + \"'\");\n    var s = this.get_scope();\n    AtomBinder.setValue(s, aname, this);\n    this._name = aname;\n  }\n\n  ls = amap[\"atom-local-scope\"];\n  if (ls) {\n    this._localScope = new AtomScope(this, this.get_scope(), atomApplication);\n    this._scope = this._localScope;\n    if (this._name) {\n      this._localScope[this._name] = this;\n    }\n    element.removeAttributeNode(ls.node);\n  }\n\n  var st = this._scopeTemplates;\n  if (st) {\n    var s = this.get_scope();\n    for (var i in st) {\n      var t = st[i];\n      AtomBinder.setValue(s, i, t);\n    }\n  }\n  </setupElementAndBindings>\n\n  <schedulePropertyInitialization>\n  var _this = this;\n  WebAtoms.dispatcher.callLater(function () {\n    _this.initProperties();\n  });\n  </schedulePropertyInitialization>\n\n  <initChildComponents>\n  this.initChildren(this._element);\n  </initChildComponents>\n\n  <schedulePostInitialization>\n  WebAtoms.dispatcher.callLater(function () {\n    _this.onInitialized();\n  });\n  </schedulePostInitialization>\n}\n"], ["validateASTStructure", "\nfunction validate(ast) {\n  if (!ast || !ast.inParams || !ast.tasks || !ast.outTask) return [AST_IS_OBJECT];\n  var errors = [];\n  <performValidations>\n  errors = errors.concat(validateInParams(ast.inParams));\n  errors = errors.concat(validateTasks(ast.tasks));\n  errors = errors.concat(validateTaskNamesUnique(ast.tasks));\n  errors = errors.concat(taskUtil.validateOutTask(ast.outTask));\n  errors = errors.concat(validateLocals(ast.locals));\n  </performValidations>\n  if (errors.length === 0) { \n    <performAdditionalValidations>\n    if (ast.outTask.type !== 'finalcbFirst') errors = errors.concat(validateOuputsUnique(ast.tasks));\n    errors = errors.concat(taskUtil.validateLocalFunctions(ast.inParams, ast.tasks, ast.locals));\n    errors = errors.concat(validateNoMissingNames(ast));\n    </performAdditionalValidations>\n  }\n  return errors;\n}\n"], ["queryElement", "\nfunction query (el) {\n  <selectOrGenerateElement>\n  if (typeof el === 'string') {\n    var selected = document.querySelector(el);\n    if (!selected) {\n      process.env.NODE_ENV !== 'production' && warn(\n        'Cannot find element: ' + el\n      );\n      return document.createElement('div')\n    }\n    return selected\n  } else {\n    return el\n  }\n  </selectOrGenerateElement>\n}\n"], ["chunkAndAppendText", "\nfunction (clip, sData) {\n  var asData = this._fnChunkData(sData, 8192);\n\n  clip.clearText();\n  <appendChunks>\n  for (var i = 0, iLen = asData.length; i < iLen; i++) {\n    clip.appendText(asData[i]);\n  }\n  </appendChunks>\n}\n"], ["nameMatchCheck", "\nfunction() {\n  var name = this.getName();\n  <checkNameAgainstArguments>\n  for (var i = 0; i < arguments.length; i++) {\n    if (arguments[i] == name)\n      return true;\n  }\n  </checkNameAgainstArguments>\n  return false;\n}\n"], ["determineMaxHeightByVersion", "\nfunction determineMaxHeight(json, version) {\n  var maxHeight = 0;\n\n  <checkVersionAndExtractMaxHeight>\n  if (version == '1.3.0') {\n    if (json.WMS_Capabilities.Service) {\n      if (json.WMS_Capabilities.Service[0]) {\n        if (json.WMS_Capabilities.Service[0].MaxHeight) {\n          if (json.WMS_Capabilities.Service[0].MaxHeight[0]) {\n            maxHeight = json.WMS_Capabilities.Service[0].MaxHeight[0];\n          }\n        }\n      }\n    }\n  }\n  </checkVersionAndExtractMaxHeight>\n\n  return maxHeight;\n}\n"], ["generateLegendItems", "\nfunction () {\n  var axis = this,\n    chart = this.chart,\n    legendItems = this.legendItems,\n    legendOptions = chart.options.legend,\n    valueDecimals = legendOptions.valueDecimals,\n    valueSuffix = legendOptions.valueSuffix || '',\n    name;\n\n  <buildLegendItems>\n  if (!legendItems.length) {\n    each(this.dataClasses, function (dataClass, i) {\n      var vis = true,\n        from = dataClass.from,\n        to = dataClass.to;\n\n      \n      name = '';\n      if (from === UNDEFINED) {\n        name = '< ';\n      } else if (to === UNDEFINED) {\n        name = '> ';\n      }\n      if (from !== UNDEFINED) {\n        name += Highcharts.numberFormat(from, valueDecimals) + valueSuffix;\n      }\n      if (from !== UNDEFINED && to !== UNDEFINED) {\n        name += ' - ';\n      }\n      if (to !== UNDEFINED) {\n        name += Highcharts.numberFormat(to, valueDecimals) + valueSuffix;\n      }\n      \n\n      \n      legendItems.push(extend({\n        chart: chart,\n        name: name,\n        options: {},\n        drawLegendSymbol: LegendSymbolMixin.drawRectangle,\n        visible: true,\n        setState: noop,\n        setVisible: function () {\n          vis = this.visible = !vis;\n          each(axis.series, function (series) {\n            each(series.points, function (point) {\n              if (point.dataClass === i) {\n                point.setVisible(vis);\n              }\n            });\n          });\n\n          chart.legend.colorizeItem(this, vis);\n        }\n      }, dataClass));\n    });\n  }\n  </buildLegendItems>\n  return legendItems;\n}\n"], ["constrainWithinBounds", "\nfunction constrain(value, max, size) {\n  <applyConstraints>\n  if (value < 0) {\n    return 0;\n  }\n\n  if (value + size > max) {\n    value = max - size;\n    return value < 0 ? 0 : value;\n  }\n  </applyConstraints>\n\n  return value;\n}\n"], ["parseFormula", "\nfunction _parseFormula(self, currentString, currentPrecedence, currentJSON) {\n  <validateInitialCondition>\n  if (!currentString.length && !currentJSON) {\n    throw new SyntaxError('Invalid formula! Unexpected end of input.');\n  }\n  </validateInitialCondition>\n\n  <parseInitialSubformula>\n  const parsedHead =\n    currentJSON ? { json: currentJSON, remainder: currentString } :\n      _parseUnarySubformula(self, currentString) ||\n      _parseParenthesizedSubformula(self, currentString) ||\n      _parseVariable(self, currentString);\n  </parseInitialSubformula>\n\n  if (!parsedHead) {\n    throw new SyntaxError('Invalid formula! Could not find an initial subformula.');\n  }\n\n  <parseBinarySubformulaAndRecurse>\n  const parsedBinary = _parseBinarySubformula(self, parsedHead.remainder, currentPrecedence, parsedHead.json);\n  if (!parsedBinary) {\n    \n    return parsedHead;\n  }\n\n  \n  return _parseFormula(self, parsedBinary.remainder, currentPrecedence, parsedBinary.json);\n  </parseBinarySubformulaAndRecurse>\n}\n"], ["splitAndPushLines", "\nfunction breaklines() {\n  return through2.obj(function(chunk, _, cb) {\n    <splitChunkIntoLines>\n    String(chunk)\n      .split('\\n')\n      .filter(Boolean)\n      .forEach(line => this.push(line));\n    </splitChunkIntoLines>\n    cb();\n  });\n}\n"], "```"]