[["getFee", "\nfunction getFee(callback) {\n  var fee = this.remote.createTransaction()._computeFee();\n  callback(null, {fee: utils.dropsToXrp(fee)});\n}\n"], ["anonymous", "\nfunction(path, data, oldvalue, newvalue) {\n    if(!path) return;\n\n    <prepareDispatchQueue>\n    var dispatchQueue = [];\n    var scopeModifications = SpahQL.DataHelper.compare(oldvalue, newvalue, path);    \n    for(var modifiedPath in scopeModifications) {\n      var modificationData = scopeModifications[modifiedPath];\n      var currentPath = modifiedPath;\n      while(currentPath.lastIndexOf(\"/\") >= 0) {\n        if(dispatchQueue.indexOf(currentPath) < 0) dispatchQueue.push(currentPath);\n        currentPath = (currentPath.lastIndexOf(\"/\") == 0 && currentPath.length>1)? \"/\" : currentPath.substring(0, currentPath.lastIndexOf(\"/\"));\n      }\n    }\n    dispatchQueue.sort(function(a, b) {\n      if(a == \"/\") return 1;\n      if(b == \"/\") return -1;\n      return (a.split(\"/\").length > b.split(\"/\").length)? -1: 1;\n    })\n    SpahQL.log(\"Path modified on data store, formulated the following dispatch strategy: [\"+dispatchQueue.join(\" -> \")+\"]. Data store: \", data);\n    </prepareDispatchQueue>\n\n    <triggerCallbacks>\n    for(var i=0; i<dispatchQueue.length; i++) {\n      var dispatchPath = dispatchQueue[i];\n      var pathCallbacks = this.callbacks[dispatchPath];\n      SpahQL.log(\"Triggering registered path callbacks for \"+dispatchPath+\": \"+((!pathCallbacks)? \"No callbacks to trigger\" : pathCallbacks.length+\" callbacks to trigger\"));\n      if(pathCallbacks) {\n        for(var j=0; j<pathCallbacks.length; j++) {\n          if(pathCallbacks[j][0] == data) {\n            var modifiedSubPaths = [];\n            for(var k=0; k<dispatchQueue.length; k++) {\n              if(dispatchQueue[k] != dispatchPath && (dispatchQueue[k]).indexOf(dispatchPath) == 0) {\n                modifiedSubPaths.push(\n                  dispatchQueue[k].substring(dispatchPath.length)\n                );\n              }\n            }\n            (pathCallbacks[j][1])(SpahQL.select(dispatchPath, data), dispatchPath, modifiedSubPaths);\n          }\n        }\n      }\n    }\n    </triggerCallbacks>\n}\n"], ["canFix", "\nfunction canFix(node) {\n  const leadingComments = sourceCode.getCommentsBefore(node);\n  const lastLeadingComment = leadingComments[leadingComments.length - 1];\n  const tokenBefore = sourceCode.getTokenBefore(node);\n\n  if (leadingComments.length === 0) {\n      return true;\n  }\n\n  if (lastLeadingComment.loc.end.line === tokenBefore.loc.end.line &&\n      lastLeadingComment.loc.end.line !== node.loc.start.line) {\n      return true;\n  }\n\n  return false;\n}\n"], ["setHandle", "\nfunction setHandle (handleNumber, to, lookBackward, lookForward) {\n  <validateAndUpdateHandle>\n  to = checkHandlePosition(scope_Locations, handleNumber, to, lookBackward, lookForward);\n  if (to === false) {\n      return false;\n  }\n  updateHandlePosition(handleNumber, to);\n  </validateAndUpdateHandle>\n\n  return true;\n}\n"], ["setupNodeObserver", "\nfunction(node, callback) {\n  <patchAndInitializeObserver>\n  common.patchNode(node);\n  if (!node.__dom.observer) {\n    node.__dom.observer = new AsyncObserver();\n  }\n  node.__dom.observer.callbacks.add(callback);\n  </patchAndInitializeObserver>\n\n  var observer = node.__dom.observer;\n\n  <returnObserverHandle>\n  return {\n    _callback: callback,\n    _observer: observer,\n    _node: node,\n    takeRecords: function takeRecords() {\n      return observer.takeRecords()\n    }\n  };\n  </returnObserverHandle>\n}\n"], ["MarkovChainStateEngine", "\nfunction MarkovChainStateEngine(converter, entities) {\n  MarkovChainStateEngine.super_.call(this, converter);\n  this.converter = converter;\n  this.initializedForTransition = false;\n  this.transitionCountTotals = {};\n  this.transitions = {};\n  this.transitionDefinitions = {};\n\n  <addDefiningEntities>\n  var self = this;\n  if (entities) {\n    entities.forEach(function(element) {\n      self.addDefiningEntity(element);\n    });\n  }\n  </addDefiningEntities>\n}\n"], ["_union", "\nfunction _union() {\n  <prepareUnionSQL>\n  var onlyUnions = this.onlyUnions();\n  var unions = this.grouped.union;\n  if (!unions) {\n    return '';\n  }\n  var sql = '';\n  for (var i = 0, l = unions.length; i < l; i++) {\n    var union = unions[i];\n    if (i > 0) {\n      sql += ' ';\n    }\n    if (i > 0 || !onlyUnions) {\n      sql += union.clause + ' ';\n    }\n    var statement = this.formatter.rawOrFn(union.value);\n    if (statement) {\n      if (union.wrap) {\n        sql += '(';\n      }\n      sql += statement;\n      if (union.wrap) {\n        sql += ')';\n      }\n    }\n  }\n  </prepareUnionSQL>\n  return sql;\n}\n"], ["parse_PtgArea", "\nfunction parse_PtgArea(blob, length, opts) {\n  var type = (blob[blob.l++] & 0x60) >> 5;\n  var area = parse_RgceArea(blob, opts.biff >= 2 && opts.biff <= 5 ? 6 : 8, opts);\n  return [type, area];\n}\n"], ["fromEventCapture", "\nfunction fromEventCapture(element, name) {\n  <createObservableFromEvent>\n  return Observable.create((subj) => {\n    const handler = function (...args) {\n      if (args.length > 1) {\n        subj.next(args);\n      } else {\n        subj.next(args[0] || true);\n      }\n    };\n\n    element.addEventListener(name, handler, true);\n    return new Subscription(() => element.removeEventListener(name, handler, true));\n  });\n  </createObservableFromEvent>\n}\n"], ["peerConnectionStateChangeHandler", "\nfunction() {\n  var newState = _peerConnection.signalingState;\n\n  if (newState && newState !== _state) {\n    _state = newState;\n    OT.debug('PeerConnection.stateChange: ' + _state);\n\n    <handleClosedState>\n    switch(_state) {\n      case 'closed':\n        tearDownPeerConnection();\n        break;\n    }\n    </handleClosedState>\n  }\n}\n"], "```\n\nEach function has been annotated with their respective single responsibility or, in certain cases, identified responsibilities within the functions that are not compliant with the SRP."]