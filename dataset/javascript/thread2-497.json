[["replacePathPredicates", "\nfunction (mMap, sTransientPredicate, sPredicate) {\n  var sPath;\n  for (sPath in mMap) {\n    if (sPath.includes(sTransientPredicate)) {\n      mMap[sPath.replace(sTransientPredicate, sPredicate)] = mMap[sPath];\n      delete mMap[sPath];\n    }\n  }\n}\n"], ["parseInlineAnnotation", "\nfunction tryParseInline (s) {\n  if (/INLINE/.test(s)) {\n    const [ match, inlinedFn ] = /INLINE \\((.*?)\\) id\\{/.exec(s) || [ false ];\n    if (match === false) return -1;\n    if (lastOptimizedFrame === null) return -1;\n    const { fn, file } = lastOptimizedFrame;\n    if (fn !== inlinedFn) return -1;\n    const key = `${fn} ${file}`;\n    inlined[key] = inlined[key] || [];\n    inlined[key].push(lastOptimizedFrame);\n    return match.length;\n  }\n  return 0;\n}\n"], ["defineFieldChecks", "\nfunction (fieldDefinition, fieldName) {\n  const fieldType = propertyHelper.getFieldType(fieldDefinition);\n  let checks;\n  if (fieldType === 'number' || fieldType === 'integer' || fieldType === 'float') {\n    checks = createChecks(fieldDefinition, fieldName, fieldType);\n  }\n  return checks;\n}\n"], ["manageHostConnections", "\nfunction(hostName, callback) {\n  var t = this,\n      errStr = '';\n      // Initial setup and callback registration\n  <registerCallback>\n  if (!t.addHostCallbacks[hostName]) {\n    t.addHostCallbacks[hostName] = [];\n  }\n  if (t.addHostCallbacks[hostName].push(callback) > 1) {\n    return;\n  }\n  </registerCallback>\n  \n  // Finalizing the process and calling callbacks\n  <finalizeAddHost>\n  var doneAdding = function(error) {\n    t.addHostCallbacks[hostName].forEach(function(cb) {\n      cb(error);\n    });\n    delete t.addHostCallbacks[hostName];\n  };\n  </finalizeAddHost>\n  \n  // Checking the range of ports already connected\n  <checkConnectedPorts>\n  var portStart = Config.Monitor.serviceBasePort,\n      portEnd = Config.Monitor.serviceBasePort + Config.Monitor.portsToScan - 1,\n      connectedPorts = [];\n  t.connections.each(function(connection){\n    var host = connection.get('hostName').toLowerCase();\n    var port = connection.get('hostPort');\n    if (host === hostName && port >= portStart && port <= portEnd) {\n      connectedPorts.push(port);\n    }\n  });\n  </checkConnectedPorts>\n  \n  // Scanning for ports and setting up connections\n  <scanAndSetupConnections>\n  var portsToScan = Config.Monitor.portsToScan - connectedPorts.length;\n  if (portsToScan === 0) {\n    errStr = 'All monitor ports in use.  Increase the Config.Monitor.portsToScan configuration';\n    log.error('addHostConnections', errStr);\n    return doneAdding(errStr);\n  }\n  var doneScanning = function() {\n    var conn = this; \n    conn.off('connect disconnect error', doneScanning);\n    if (--portsToScan === 0) {\n      return doneAdding();\n    }\n  };\n  for (var i = portStart; i <= portEnd; i++) {\n    if (connectedPorts.indexOf(i) < 0) {\n      var connection = t.addConnection({hostName:hostName, hostPort:i});\n      connection.on('connect disconnect error', doneScanning, connection);\n    }\n  }\n  </scanAndSetupConnections>\n}\n"], ["ensurePrototypeInheritance", "\nfunction ensurePrototypeTraversal(prototype) {\n  if (!Object.__proto__) {\n    var ancestor = Object.getPrototypeOf(prototype);\n    prototype.__proto__ = ancestor;\n    if (isBase(ancestor)) {\n      ancestor.__proto__ = Object.getPrototypeOf(ancestor);\n    }\n  }\n}\n"], ["checkAncestry", "\nfunction isAncestor(instA, instB) {\n  while (instB) {\n    if (instA === instB || instA === instB.alternate) {\n      return true;\n    }\n    instB = getParent(instB);\n  }\n  return false;\n}\n"], ["deleteClient", "\nfunction deleteClient (id, options) {\n  options = options || {};\n  options.url = '/v1/clients/' + id;\n  options.method = 'DELETE';\n  delete options.json;\n  return request.bind(this)(options);\n}\n"], ["addInversePathMapping", "\nfunction addPath(path, name) {\n  var fullPath = (pathModule.normalize(pathModule.join(baseFullUrl, path)) + \".js\").replace(/\\\\/g,\"/\");\n  inversePaths[path] = name;\n  inversePaths[fullPath] = name;\n}\n"], ["createUnitsDictionary", "\nfunction createUnits(conversions, withNames=false) {\n  const result = {};\n  <defineUnitConversion>\n  conversions.forEach(c => c.names.forEach(name =>\n      result[unitToLower(normalizeUnitName(name))] = {\n          name: c.names[0],\n          prefix: c.prefix,\n          scale: c.scale,\n          toBase: c.toBase,\n          fromBase: c.fromBase,\n          names: withNames ? c.names : null\n      }\n  ));\n  </defineUnitConversion>\n  return result;\n}\n"], ["retrieveModifierValue", "\nfunction getModifierValue(dialect, node) {\n  return node.count.type ? dialect.visit(node.count) : node.count;\n}\n"], "```\nThis function complies with SRP by retrieving a modifier value based on the presence of a type within a node."]