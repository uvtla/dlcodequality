[["formatFileSize", "\nfunction( size, pointLength, units ) {\n    var unit;\n\n    units = units || [ 'B', 'K', 'M', 'G', 'TB' ];\n\n    while ( (unit = units.shift()) && size > 1024 ) {\n        size = size / 1024;\n    }\n\n    return (unit === 'B' ? size : size.toFixed( pointLength || 2 )) +\n            unit;\n}\n"], ["cacheTile", "\nfunction (tile) {\n    if (!this.cache[tile.id]) {\n        this.cache[tile.id] = tile;\n        this.cacheCount++;\n        try {\n            this.addToImage(tile);\n        } catch (e) {\n            \n        } \n    }\n}\n"], ["generateBucketHref", "\nfunction (req, bucket) {\n    var location = getLocation(req),\n        href = location.origin;\n\n    \n    if (href.substr(-1) !== '/') {\n        href += '/';\n    }\n    \n    \n    href += bucket + location.search;\n\n    return href;\n}\n"], ["parseString", "\nfunction (str) {\n    return str.split(';').map(function (e, i) {\n        return plugs[i].parse(e)\n    })\n}\n"], ["collectSelectedNodes", "\nfunction(stopOnParents) {\n    var nodeList = [];\n    this.rootNode.visit(function(node){\n        if( node.selected ) {\n            nodeList.push(node);\n            if( stopOnParents === true ){\n                return \"skip\"; \n            }\n        }\n    });\n    return nodeList;\n}\n"], ["hasOwnPropertyCheck", "\nfunction _hasOwnProperty(obj) {\n    var key;\n    for (key in obj) {\n        if (obj.hasOwnProperty(key)) {\n            return true;\n        }\n    }\n\n    return false;\n}\n"], ["setupTabEventHandlersAndMenuItems", "\nfunction () {\n    topic.subscribe(\"/focus\", lang.hitch(this, \"onPageFocus\"));\n    topic.subscribe(\"/new\", lang.hitch(this, \"onNew\"));\n    topic.subscribe(\"/deleted\", lang.hitch(this, \"onDeleted\"));\n\n    <addCloseChildAspect>\n    aspect.before(this.tabContainer, \"closeChild\", function (child) {\n        this.closing = true;\n\n        setTimeout(function () {\n\n        }.bind(this), 0);\n    }.bind(this));\n    </addCloseChildAspect>\n    <addOnCloseAspect>\n    aspect.after(this.tabContainer, \"closeChild\", function (value, args) {\n        this.closing = false;\n        this.onClose(args[0]);\n    }.bind(this));\n    </addOnCloseAspect>\n    <addSelectChildAspect>\n    aspect.after(this.tabContainer, \"selectChild\", function (promise, args) {\n        if (!this.closing) {\n            this.tabSelected(args[0]);\n        }\n    }.bind(this));\n    </addSelectChildAspect>\n\n\n    var menu = registry.byId(this.tabContainer.id + \"_tablist_Menu\");\n\n    <createCloseAllMenuItem>\n    var me = this;\n    menu.addChild(\n        new MenuItem({\n            label: messages[\"tabopener.closeall\"],\n            ownerDocument: this.tabContainer.ownerDocument,\n            dir: this.tabContainer.dir,\n            lang: this.tabContainer.lang,\n            textDir: this.tabContainer.textDir,\n            onClick: function (evt) {\n                me.closeTabs();\n            }\n        })\n    );\n    </createCloseAllMenuItem>\n    \n    <createCloseOthersMenuItem>\n    menu.addChild(\n        new MenuItem({\n            label: messages[\"tabopener.closeothers\"],\n            ownerDocument: this.tabContainer.ownerDocument,\n            dir: this.tabContainer.dir,\n            lang: this.tabContainer.lang,\n            textDir: this.tabContainer.textDir,\n            onClick: function (evt) {\n                var tabElement = this.getParent().currentTarget;\n                var tab = registry.byNode(tabElement);\n                me.closeTabs(tab.page);\n            }\n        })\n    );\n    </createCloseOthersMenuItem>\n}\n"], ["createWebSocketInstance", "\nfunction ws(uri, protocols, opts) {\n    var instance;\n    if (protocols) {\n        instance = new WebSocket(uri, protocols);\n    } else {\n        instance = new WebSocket(uri);\n    }\n    return instance;\n}\n"], ["setCSSRules", "\nfunction set (sel, props) {\n    if (props) {\n        if (props && typeof props.rulesets === 'function') props = props.rulesets()\n        Object.keys(props).forEach(function (prop) {\n            var val = props[prop]\n            if (typeof val === 'object') {\n                set(expand(sel, prop), val)\n            } else {\n                if (!(sel in rules)) {\n                    rules[sel] = {}\n                }\n                rules[sel][prop] = val\n            }\n        })\n    } else {\n        if (sel && typeof sel.rulesets === 'function') sel = sel.rulesets()\n        Object.keys(sel).forEach(function (selector) {\n            set(selector, sel[selector])\n        })\n    }\n\n    return api\n}\n"], ["flattenCSSRules", "\nfunction flattenRules(rules) {\n    var out = {};\n\n    rules.forEach(function(rule) {\n        if (rule.type !== 'rule') return;\n        rule.selectors.forEach(function(sel) {\n            if (!out[sel]) out[sel] = {};\n\n            rule.declarations.forEach(function(decl) {\n                out[sel][decl.property] = decl.value;\n            });\n        });\n    });\n\n    return out;\n}\n"], "```\n\nFunction 7 contains the most complex setup with different responsibilities, so it's annotated at multiple levels, indicating potential SRP violations. The rest of the functions each manage a single responsibility and are annotated as compliant with SRP."]