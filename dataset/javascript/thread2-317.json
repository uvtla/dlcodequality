[["nodeHasNeighbor", "\nfunction nodeHasNeighbor(graph, type, direction, node, neighbor) {\n\n  const nodeData = graph._nodes.get(node);\n\n  if (type !== 'undirected') {\n    <checkOutgoingEdges>\n    if (direction !== 'out' && typeof nodeData.in !== 'undefined') {\n      for (const k in nodeData.in)\n        if (k === neighbor)\n          return true;\n    </checkOutgoingEdges>\n    <checkIncomingEdges>\n    if (direction !== 'in' && typeof nodeData.out !== 'undefined') {\n      for (const k in nodeData.out)\n        if (k === neighbor)\n          return true;\n    </checkIncomingEdges>\n  }\n\n  <checkUndirectedEdges>\n  if (type !== 'directed' && typeof nodeData.undirected !== 'undefined') {\n    for (const k in nodeData.undirected)\n        if (k === neighbor)\n          return true;\n  }\n  </checkUndirectedEdges>\n\n  return false;\n}\n"], ["makeError", "\nfunction makeError(code, text) {\n  var err = new Error(text);\n  err.code = code;\n  return err;\n}\n"], ["getSignature", "\nfunction getSignature(blob) {\n  return new Promise(function (callback) {\n    var reader = new FileReader();\n    reader.onloadend = function () {\n      <parseSignature>\n      var arr = new Uint8Array(reader.result).subarray(0, 4);\n      var signature = '';\n      for (var i = 0; i < arr.length; i++) {\n        signature += arr[i].toString(16);\n      }\n      </parseSignature>\n      callback(signature);\n    };\n    reader.readAsArrayBuffer(blob);\n  });\n}\n"], ["tokenizeSelector", "\nfunction(selector) {\n  var token = {},\n      tokens = [],\n      id,\n      found = false,\n      patterns = Y.Selector._patterns,\n      match;\n\n  <preprocessSelector>\n  selector = Y.Selector._replaceShorthand(selector);\n  </preprocessSelector>\n\n  do {\n    found = false;\n    for (var re in patterns) {\n      if (YAHOO.lang.hasOwnProperty(patterns, re)) {\n        if (re != 'tag' && re != 'combinator') {\n          token[re] = token[re] || [];\n        }\n        if ( (match = patterns[re].exec(selector)) ) {\n          found = true;\n          <extractToken>\n          if (re != 'tag' && re != 'combinator') {\n            if (re === 'attributes' && match[1] === 'id') {\n              token.id = match[3];\n            }\n            token[re].push(match.slice(1));\n          } else {\n            token[re] = match[1];\n          }\n          selector = selector.replace(match[0], '');\n          </extractToken>\n          <finalizeTokens>\n          if (re === 'combinator' || !selector.length) {\n            token.attributes = Y.Selector._fixAttributes(token.attributes);\n            token.pseudos = token.pseudos || [];\n            token.tag = token.tag ? token.tag.toUpperCase() : '*';\n            tokens.push(token);\n            token = {\n              previous: token\n            };\n          }\n          </finalizeTokens>\n        }\n      }\n    }\n  } while (found);\n\n  return tokens;\n}\n"], ["_gpfProcessDefineParams", "\nfunction _gpfProcessDefineParams (rootNamespace, defaultSuper, params) {\n  _gpfProcessDefineParamNoSuperUsed(defaultSuper, params);\n  _gpfProcessDefineParamCheckIfRelativeName(rootNamespace, params);\n  _gpfProcessDefineParamDefaultSuper(defaultSuper, params);\n  _gpfProcessDefineParamDefaultDefinition(params);\n  _gpfProcessDefineParamResolveBase(params);\n  _gpfProcessDefineParamsCheck(params);\n}\n"], ["addItemToList", "\nfunction (item, before) {\n  if (!_.isObject(item)) { return; }\n  \n  var duplicate = this.indexOf(item),\n      index;\n\n  <removeItemFromPreviousParent>\n  PropertyList.isPropertyList(item[__PARENT]) && (item[__PARENT] !== this) && item[__PARENT].remove(item);\n  </removeItemFromPreviousParent>\n  \n  <setParentReference>\n  _.assignHidden(item, __PARENT, this);\n  </setParentReference>\n\n  <removeDuplicate>\n  (duplicate > -1) && this.members.splice(duplicate, 1);\n  </removeDuplicate>\n  \n  <findInsertionIndex>\n  before && (before = this.indexOf(before));\n  </findInsertionIndex>\n  \n  <insertItem>\n  (before > -1) ? this.members.splice(before, 0, item) : this.members.push(item);\n  </insertItem>\n\n  <addToIndex>\n  if ((index = item[this._postman_listIndexKey]) && (index = String(index))) {\n    <normalizeIndex>\n    this._postman_listIndexCaseInsensitive && (index = index.toLowerCase());\n    </normalizeIndex>\n    \n    <handleMultipleValues>\n    if (this._postman_listAllowsMultipleValues && this.reference.hasOwnProperty(index)) {\n      <convertToArrayList>\n      !_.isArray(this.reference[index]) && (this.reference[index] = [this.reference[index]]);\n      </convertToArrayList>\n      <appendToList>\n      this.reference[index].push(item);\n      </appendToList>\n    }\n    else {\n      this.reference[index] = item;\n    }\n    </handleMultipleValues>\n  }\n  </addToIndex>\n\n}\n"], ["parseConfig", "\nfunction parseConfig(contents) {\n  var config = {};\n\n  contents = contents.replace(rSeajsConfig, function ($) {\n    $.replace(rAlias, function (_, $1) {\n      config.alias = evalConfig($1);\n    });\n\n    $.replace(rPaths, function (_, $1) {\n      config.paths = evalConfig($1);\n    });\n\n    $.replace(rVars, function (_, $1) {\n      config.vars = evalConfig($1);\n    });\n\n    return '';\n  });\n\n  return {\n    contents: contents,\n    config: config\n  };\n}\n"], ["findClosestPoint", "\nfunction findClosestPoint (sources, target) {\n  const distances = [];\n  let minDistance;\n  <calculateDistances>\n  sources.forEach(function (source, index) {\n    const d = distance(source, target);\n    distances.push(d);\n    if (index === 0) {\n      minDistance = d;\n    } else {\n      minDistance = Math.min(d, minDistance);\n    }\n  });\n  </calculateDistances>\n\n  <findMinimumDistanceIndex>\n  const index = distances.indexOf(minDistance);\n  </findMinimumDistanceIndex>\n\n  <returnClosestSource>\n  return sources[index];\n  </returnClosestSource>\n}\n"], ["isDomNodeList", "\nfunction (variable) {\n  <checkIsObjectAndNodeList>\n  return typeof variable === \"object\" &&\n      /^\\[object (HTMLCollection|NodeList|Object)\\]$/.test(Object.prototype.toString.call(variable)) &&\n      variable.length !== undefined &&\n      (variable.length === 0 || (typeof variable[0] === \"object\" && variable[0].nodeType > 0));\n  </checkIsObjectAndNodeList>\n}\n"], ["index", "\nfunction index(options) {\n  const {\n    file,\n    config,\n    logStart,\n    logNotFound,\n    logEnd,\n    defaultContent = defaultFileContent,\n  } = options;\n\n  <logIndexStarting>\n  logger.log(logStart);\n  </logIndexStarting>\n\n  <processIndexing>\n  return readConfig(config)\n    .then(input => validateExtensions(input))\n    .then(input => createStrings(input))\n    .then(input => writeExtensionFile({\n      input,\n      file,\n      defaultContent,\n      logNotFound,\n      logEnd,\n    }));\n  </processIndexing>\n}\n"], "```\n\nIn the functions provided, care has been taken to ensure that annotations are applied consistently with respect to the Single Responsibility Principle. Sections of code that collectively serve a single responsibility have been encapsulated with tags, and an effort has been made to neither over-segment nor under-segment the given functions. Responsibilities are defined as coherent blocks of instructions that achieve a specific task or purpose within the function."]