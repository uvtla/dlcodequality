[["_requireDirAll", "\nfunction _requireDirAll(originalModule, absDir, options) {\n  var modules = {};\n  var files = [];\n\n  try {\n    files = fs.readdirSync(absDir);\n  } catch (e) {\n    if (options.throwNoDir) {\n      throw e;\n    }\n  }\n\n  for (var length=files.length, i=0; i<length; ++i) {\n    var reqModule = {};\n    reqModule.filename = files[i];\n    reqModule.ext      = path.extname(reqModule.filename);\n    reqModule.base     = path.basename(reqModule.filename, reqModule.ext);\n    reqModule.filepath = path.join(absDir, reqModule.filename);\n\n    if (fs.statSync(reqModule.filepath).isDirectory() &&\n      options.recursive &&\n      ! isExcludedDir(reqModule, options.excludeDirs) ) {\n      reqModule.name = reqModule.filename;\n      \n      modules[reqModule.name] = _requireDirAll(originalModule, reqModule.filepath, options);\n\n    } else if ( ! isExcludedFileRe(reqModule, options.includeFiles) && !isExcludedFileParent(reqModule, originalModule)) {\n      reqModule.name    = reqModule.base;\n      reqModule.exports = require(reqModule.filepath);\n      if (options.map) {\n        options.map(reqModule);\n      }\n\n      var source = reqModule.exports;\n      var target = (reqModule.name === 'index' && options.indexAsParent) ? modules : modules &&  modules[ reqModule.name ];\n\n      var sourceIsObject = (typeof source === 'object');\n      var targetIsObject = (typeof target === 'object');\n\n      if (sourceIsObject && targetIsObject) {\n        deepAssign(target, source);\n      } else {\n        target = source;\n      }\n\n      if (reqModule.name === 'index' && options.indexAsParent) {\n        modules = target;\n      } else {\n        modules[ reqModule.name ] = target;\n      }\n    }\n  }\n\n  return modules;\n}\n"], ["forceTestFailure", "\nfunction (optMsg) {\n  var msg = \"Forced Failure\";\n  if (optMsg) {\n    msg += \" (\" + optMsg + \")\";\n  }\n\n  this.raiseFailure(msg);\n\n  throw {\n    name : this.ASSERT_FAILURE,\n    message : msg\n  };\n}\n"], ["writeFileSync", "\nfunction writeFileSync(cvs, data) {\n  if (typeof data.path !== 'string') {\n    throw new TypeError('Invalid path type: ' + typeof data.path);\n  }\n\n  var buff = cvs.toBuffer();\n  var fd = fs.openSync(data.path, 'w', WRITE_MODE);\n\n  try {\n    fs.writeSync(fd, buff, 0, buff.length, 0);\n  } catch (error) {\n    fs.closeSync(fd);\n  }\n}\n"], ["moduleLoader", "\nfunction (options, callback) {\n  options = extend({}, MODULE_LOADER_DEFAULTS, options)\n  var modulesFolder = options.uri\n\n  iterateFiles(modulesFolder, loadModule, callback, isJsFile)\n\n  function loadModule(fileName) {\n    if (options.skip && options.skip.test(fileName)) {\n      return\n    }\n    var module = require(fileName)\n    var name = path.relative(options.uri, fileName)\n    options.core.add(name, module)\n  }\n}\n"], ["goBack", "\nfunction goBack() {\n  if (History.length > 1 || location === RefreshLocation) {\n    location.pop();\n    return true;\n  }\n\n  warning(false, 'goBack() was ignored because there is no router history');\n\n  return false;\n}\n"], ["isObjectLiteralType", "\nfunction isObjectLiteralType(type) {\n  return type.symbol && (type.symbol.flags & (4096  | 2048 )) !== 0 &&\n      getSignaturesOfType(type, 0 ).length === 0 &&\n      getSignaturesOfType(type, 1 ).length === 0;\n}\n"], ["getStateParams", "\nfunction getStateParams(state) {\n  if (!state.params) {\n    return state.url ? state.url.params : state.parent.params;\n  }\n  return state.params;\n}\n"], ["computeSpecifierMap", "\nfunction computeSpecifierMap(specifiers) {\n  const specifierCount = specifiers.length;\n  const specifierMap = Object.create(null);\n\n  for (let i = 0; i < specifierCount; ++i) {\n    const s = specifiers[i];\n\n    const local =\n      s.type === \"ExportDefaultSpecifier\" ? \"default\" :\n      s.type === \"ExportNamespaceSpecifier\" ? \"*\" :\n      s.local.name;\n\n    const __ported =\n      s.type === \"ImportSpecifier\" ? s.imported.name :\n      s.type === \"ImportDefaultSpecifier\" ? \"default\" :\n      s.type === \"ImportNamespaceSpecifier\" ? \"*\" :\n      (s.type === \"ExportSpecifier\" ||\n       s.type === \"ExportDefaultSpecifier\" ||\n       s.type === \"ExportNamespaceSpecifier\") ? s.exported.name :\n      null;\n\n    if (typeof local === \"string\" && typeof __ported === \"string\") {\n      addToSpecifierMap(specifierMap, __ported, local);\n    }\n  }\n\n  return specifierMap;\n}\n"], ["SphereGeneration", "\nfunction Sphere(r, nsides, nsegments) {\n  r = r || 0.5;\n  nsides = nsides || 36;\n  nsegments = nsegments || 18;\n\n  Geometry.call(this, { vertices: true, normals: true, texCoords: true, faces: true });\n\n  var vertices = this.vertices;\n  var texCoords = this.texCoords;\n  var normals = this.normals;\n  var faces = this.faces;\n\n  var degToRad = 1/180.0 * Math.PI;\n\n  var dphi   = 360.0/nsides;\n  var dtheta = 180.0/nsegments;\n\n  for (var segment=0; segment<=nsegments; ++segment) {\n    var theta = segment * dtheta;\n    for (var side=0; side<=nsides; ++side) {\n      var phi = side * dphi;\n      var pos = evalPos(theta, phi);\n      var normal = pos.dup().normalize();\n      var texCoord = new Vec2(phi/360.0, theta/180.0);\n\n      vertices.push(pos);\n      normals.push(normal);\n      texCoords.push(texCoord);\n\n      if (segment == nsegments) continue;\n      if (side == nsides) continue;\n\n      faces.push([ /* ... face indices ... */ ]);\n    }\n  }\n\n  this.computeEdges();\n}\n"], ["calculatePerspectiveNearDistance", "\nfunction calculatePerspectiveNearDistance(viewportWidth, viewportHeight, distanceToSurface) {\n  if (viewportWidth <= 0) {\n    throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, \"WWMath\", \"calculatePerspectiveNearDistance\",\n      \"invalidWidth\"));\n  }\n\n  if (viewportHeight <= 0) {\n    throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, \"WWMath\", \"calculatePerspectiveNearDistance\",\n      \"invalidHeight\"));\n  }\n\n  if (distanceToSurface < 0) {\n    throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, \"WWMath\", \"calculatePerspectiveNearDistance\",\n      \"The specified distance is negative.\"));\n  }\n\n  var aspectRatio = viewportHeight / viewportWidth;\n\n  return 2 * distanceToSurface / Math.sqrt(aspectRatio * aspectRatio + 5);\n}\n"], "```\n\nIn most cases, the functions are performing a specific task or a set of closely related tasks that fit within a single responsibility. However, I have enclosed the entire function in tags to ensure clarity, as splitting these functions into finer-grained responsibilities would require extensive knowledge of the surrounding application context and might not necessarily lead to a meaningful segregation of responsibilities."]