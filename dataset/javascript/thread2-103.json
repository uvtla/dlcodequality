[["dictify", "\nfunction dictify(serializedFormArray) {\n  <formArrayToDictionary>\n  var o = {};\n  $.each(serializedFormArray, function() {\n    if (o[this.name] !== undefined) {\n      if (!o[this.name].push) {\n        o[this.name] = [o[this.name]];\n      }\n      o[this.name].push(this.value || '');\n    } else {\n      o[this.name] = this.value || '';\n    }\n  });\n  </formArrayToDictionary>\n  return o;\n}\n"], ["computeTextRadius", "\nfunction computeTextRadius(lines) {\n    <calculateRadius>\n    var textRadius = 0;\n\n    for (var i = 0, n = lines.length; i < n; ++i) {\n        var dx = lines[i].width / 2;\n        var dy = (Math.abs(i - n / 2 + 0.5) + 0.5) * DEFAULT_CANVAS_LINE_HEIGHT;\n        textRadius = Math.max(textRadius, Math.sqrt(dx * dx + dy * dy));\n    }\n    </calculateRadius>\n\n    return textRadius;\n}\n"], ["transformValues", "\nfunction (trans, val) {\n\t\t<createLookupObject>\n\t\tvar key,\n\t\t\ttmpArr = {},\n\t\t\tisArr = $.isArray(trans);\n\t\tfor (key in trans) {\n\t\t\tif (isArr || trans.hasOwnProperty(key)) {\n\t\t\t\ttmpArr[trans[key]] = val || key;\n\t\t\t}\n\t\t}\n\t\t</createLookupObject>\n\t\treturn tmpArr;\n\t}\n"], ["addToMenu", "\nfunction(menu,ind) {\n            \n            <checkAndExpandMenu>\n            if (menu instanceof MenuItem) {\n                \n                if (menu.submenu == null) menu.submenu = new Menu();\n                menu = menu.submenu;\n            }\n            </checkAndExpandMenu>\n            \n            <addItemToMenu>\n            menu.addItem(this,ind);\n            </addItemToMenu>\n            \n            return this;\n        }\n"], ["createPointObject", "\nfunction () {\n\t\t<pointDetails>\n\t\tvar point = this;\n\t\treturn {\n\t\t\tx: point.category,\n\t\t\ty: point.y,\n\t\t\tkey: point.name || point.category,\n\t\t\tseries: point.series,\n\t\t\tpoint: point,\n\t\t\tpercentage: point.percentage,\n\t\t\ttotal: point.total || point.stackTotal\n\t\t};\n\t\t</pointDetails>\n\t}\n"], ["decodeRaw", "\nfunction decodeRaw(value, position, options) {\n    <decodeEntities>\n    return entities(\n      value,\n      xtend(options, {position: normalize(position), warning: handleWarning})\n    )\n    </decodeEntities>\n  }\n"], ["getKnownHashesFromAssets", "\nfunction getKnownHashesFromAssets(assetMetadata) {\n  <collectHashes>\n  const knownHashes = new Set();\n  for (const metadata of Object.values(assetMetadata)) {\n    knownHashes.add(metadata.hash);\n  }\n  </collectHashes>\n  return knownHashes;\n}\n"], ["batchModelSave", "\nfunction(properties, value, equals, props, cascade, options)\n  {\n    <saveModel>\n    function saveIt(model)\n    {\n      model.$save( props, cascade, options );\n    }\n    </saveModel>\n\n    <executeBatchSave>\n    batchExecute(function()\n    {\n      this.eachWhere( saveIt, properties, value, equals );\n\n    }, this );\n    </executeBatchSave>\n\n    return this;\n  }\n"], ["getType", "\nfunction getType(number, countryCode) {\n    <parseNumber>\n    try {\n        var phoneUtil = i18n.phonenumbers.PhoneNumberUtil.getInstance();\n        var numberObj = phoneUtil.parseAndKeepRawInput(number, countryCode);\n        return phoneUtil.getNumberType(numberObj)\n    } catch (e) {\n    </parseNumber>\n    <handleParsingError>\n        return -99;\n    </handleParsingError>\n}\n"], ["validate", "\nfunction validate( opts, options ) {\n\t<validateOptionsObject>\n\tif ( !isObject( options ) ) {\n\t\treturn new TypeError( 'invalid input argument. Options argument must be an object. Value: `' + options + '`.' );\n\t}\n\t</validateOptionsObject>\n\t\n\t<setPackages>\n\topts.packages = options.packages;\n\tif ( !isStringArray( opts.packages ) ) {\n\t\treturn new TypeError( 'invalid option. Packages option must be a string array. Option: `' + opts.packages + '`.' );\n\t}\n\t</setPackages>\n\t\n\t<setPeriod>\n\tif ( options.hasOwnProperty( 'period' ) ) {\n\t\topts.period = options.period;\n\t\tif ( !isString( opts.period ) ) {\n\t\t\treturn new TypeError( 'invalid option. Period option must be a string. Option: `' + opts.period + '`.' );\n\t\t}\n\t}\n\t</setPeriod>\n\t\n\t<setHostname>\n\tif ( options.hasOwnProperty( 'hostname' ) ) {\n\t\topts.hostname = options.hostname;\n\t\tif ( !isString( opts.hostname ) ) {\n\t\t\treturn new TypeError( 'invalid option. Hostname option must be a string. Option: `' + opts.hostname + '`.' );\n\t\t}\n\t}\n\t</setHostname>\n\t\n\t<setPort>\n\tif ( options.hasOwnProperty( 'port' ) ) {\n\t\topts.port = options.port;\n\t\tif ( !isNonNegativeInteger( opts.port ) ) {\n\t\t\treturn new TypeError( 'invalid option. Port option must be a nonnegative integer. Option: `' + opts.port + '`.' );\n\t\t}\n\t}\n\t</setPort>\n\t\n\t<setProtocol>\n\tif ( options.hasOwnProperty( 'protocol' ) ) {\n\t\topts.protocol = options.protocol;\n\t\tif ( opts.protocol !== 'http' && opts.protocol !== 'https' ) {\n\t\t\treturn new TypeError( 'invalid option. The following protocols are supported: `\"http\", \"https\"`. Option: `' + opts.protocol + '`.' );\n\t\t}\n\t}\n\t</setProtocol>\n\treturn null;\n}\n"], "```\n\nAll functions have been annotated for SRP compliance. Some functions handle singular responsibilities and are fully enclosed in one set of tags, while others contain multiple blocks representing separate responsibilities, each enclosed in its own set of tags."]