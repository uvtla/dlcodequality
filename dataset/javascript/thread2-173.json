[["parseOne", "\nfunction parseOne(p){\n\tvar p = path.resolve(p);\n\tif(root === null){\n\t\troot = p;\n\t}\n\tvar firstInclude = hasIncludes(p);\n\tvar r;\n\t\n\t<parseFileIncludes>\n\tif(firstInclude){\n\t\tr = parseFirstIncludes(p,getContent(p));\n\t\tCTS[p] = r;\n\t\tr = parseOne(p);\n\t</parseFileIncludes> \n\telse {\n\t\tr = getContent(p);\n\t}\n\treturn r;\n}\n"], ["destroyComponents", "\nfunction destroy ( ) {\n\t<cleanupCSS>\n    for ( var key in options.cssClasses ) {\n        if ( !options.cssClasses.hasOwnProperty(key) ) { continue; }\n        removeClass(scope_Target, options.cssClasses[key]);\n    }\n\t</cleanupCSS>\n\n\t<removeChildElements>\n    while (scope_Target.firstChild) {\n        scope_Target.removeChild(scope_Target.firstChild);\n    }\n\t</removeChildElements>\n\n    delete scope_Target.noUiSlider;\n}\n"], ["_fireResume", "\nfunction _fireResume()\n{\n\t<executePluginCallback>\n    exec(\n            function ()\n            {\n                window.console.log(JS_HANDLE\n                        + \": fired resume event to native plugin\");\n            },\n            _logError,\n            CDV_HANDLE,\n            CDV_HANDLE_ACTIONS.APP_RESUMED,\n            []\n    );\n\t</executePluginCallback>\n}\n"], ["tinf_inflate_uncompressed_block", "\nfunction tinf_inflate_uncompressed_block(d) {\n  var length, invlength;\n  var i;\n  \n  <alignBitCount>\n  while (d.bitcount > 8) {\n    d.sourceIndex--;\n    d.bitcount -= 8;\n  }\n  </alignBitCount>\n\n  <calculateLengths>\n  length = d.source[d.sourceIndex + 1];\n  length = 256 * length + d.source[d.sourceIndex];\n\n  invlength = d.source[d.sourceIndex + 3];\n  invlength = 256 * invlength + d.source[d.sourceIndex + 2];\n  </calculateLengths>\n\n  <verifyLengthConsistency>\n  if (length !== (~invlength & 0x0000ffff))\n    return TINF_DATA_ERROR;\n  </verifyLengthConsistency>\n\n  <adjustSourceIndex>\n  d.sourceIndex += 4;\n  </adjustSourceIndex>\n\n  <copyData>\n  for (i = length; i; --i)\n    d.dest[d.destLen++] = d.source[d.sourceIndex++];\n  </copyData>\n\n  <resetBitcount>\n  d.bitcount = 0;\n  </resetBitcount>\n\n  return TINF_OK;\n}\n"], ["initializeProviders", "\nfunction() {\n\t<invokeInitialization>\n\tthis._providers.forEach(function(info) {\n\t\tvar provider = info.provider;\n\t\tif (typeof provider.initialize === \"function\") {\n\t\t\tprovider.initialize();\n\t\t}\n\t});\n\t</invokeInitialization>\n}\n"], ["readFileData", "\nfunction read (url, data, config, callback) {\n  <initializeFileSchema>\n  var schema = new Schema(config, this.plugins);\n  var rootFile = new File(schema);\n  schema.files.push(rootFile);\n  </initializeFileSchema>\n\n  <resolveFileURL>\n  if (url) {\n    \n    url = schema.plugins.resolveURL({ to: url });\n\n    \n    rootFile.url = stripHash(url);\n  }\n  </resolveFileURL>\n\n  <handleProvidedData>\n  if (data) {\n    \n    rootFile.data = data;\n    rootFile[__internal].state = STATE_READ;\n    safeCall(parseFile, rootFile, callback);\n  </handleProvidedData>\n  <fetchFileData>\n  else {\n    \n    safeCall(readFile, rootFile, callback);\n  }\n  </fetchFileData>\n}\n"], ["makeRequest", "\nfunction request(endpoint, params, cb) {\n\t<logRequest>\n\tdebug('request', endpoint, params);\n\t</logRequest>\n\t<executeRequestAndFormatResponse>\n\treturn r(getPath(endpoint, params))\n\t\t.then(format)\n\t\t.nodeify(cb);\n\t</executeRequestAndFormatResponse>\n}\n"], ["_each", "\nfunction _each(array, func) {\n\t<iterateAndApplyFunction>\n    for (var i = 0, l = array.length; i < l; i++) {\n        func(array[i]);\n    }\n\t</iterateAndApplyFunction>\n}\n"], ["createSelectorsManager", "\nfunction createSelectorsManager() {\n    var selectors = {};\n\n\t<manageSelectors>\n    return {\n        addSelector: addSelector,\n        executeSelector: executeSelector\n    };\n\t</manageSelectors>\n\n    \n    function addSelector(prefix, selector) {\n        if (selector !== undefined) {\n            selectors[prefix] = selector;\n        }\n        return selectors[prefix];\n    }\n\n    \n    function executeSelector(source, sourceKey, targetKey,\n        sourceKeys, overrideKeys) {\n\n        for (var prefix in selectors) {\n            <matchAndExecuteSelector>\n            if (sourceKey.indexOf(prefix) === 0) {\n\n                \n                sourceKey = sourceKey.substring(prefix.length);\n\n                \n                selectors[prefix]({\n                    source: source,\n                    sourceKey: sourceKey,\n                    targetKey: targetKey ? targetKey : sourceKey,\n                    sourceKeys: sourceKeys,\n                    overrideKeys: overrideKeys\n                });\n\n                return true;\n            }\n            </matchAndExecuteSelector>\n        }\n        return false;\n    }\n}\n"], ["initializeNotification", "\nfunction Notification(icon) {\n\n\t<validateIcon>\n    if (util.isNullOrUndefined(icon)) {\n        throw new IllegalArgumentException();\n    }\n\t</validateIcon>\n\n\t<setNotificationProperties>\n    this.mTitle = null;\n    this.mBody = null;\n    this.mIcon = icon;\n    this.mSound = \"default\"; \n    this.mBadge = null;\n    this.mTag = null;\n    this.mColor = null;\n    this.mClickAction = null;\n    this.mBodyLocKey = null;\n    this.mBodyLocArgs = null; \n    this.mTitleLocKey = null;\n    this.mTitleLocArgs = null; \n\t</setNotificationProperties>\n\n    this.mBuilded = false;\n}\n"], ""]