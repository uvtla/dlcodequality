[["FakeXMLHttpRequest", "`\n```javascript\nfunction FakeXMLHttpRequest() {\n    this.readyState = FakeXMLHttpRequest.UNSENT;\n    this.requestHeaders = {};\n    this.requestBody = null;\n    this.status = 0;\n    this.statusText = \"\";\n\n    var xhr = this;\n    var events = [\"loadstart\", \"load\", \"abort\", \"loadend\"];\n\n    function addEventListener(eventName) {\n        xhr.addEventListener(eventName, function (event) {\n            var listener = xhr[\"on\" + eventName];\n\n            if (listener && typeof listener == \"function\") {\n                listener(event);\n            }\n        });\n    }\n\n    for (var i = events.length - 1; i >= 0; i--) {\n        addEventListener(events[i]);\n    }\n\n    if (typeof FakeXMLHttpRequest.onCreate == \"function\") {\n        FakeXMLHttpRequest.onCreate(this);\n    }\n}\n```\n"], ["HSLA_TO_HSVA", "`\n```javascript\nfunction HSLA_TO_HSVA() {\n    var h = this.h();\n    var s = this.s();\n    var l = this.l();\n    var a = this.a();\n\n    l *= 2;\n    s *= (l <= 1) ? l : 2 - l;\n    var v = (l + s) / 2;\n    var sv = (2 * s) / (l + s);\n    return kolor.hsva(h, sv, v, a);\n}\n```\n"], ["jsonDescription", "`\n```javascript\nfunction jsonDescription(format, description) {\n  switch (format) {\n    case 'application/openapi+json':\n      if (typeof description == object) {\n        return description;\n      } else {\n        throw new Error(`application/openapi+json description ${description} is not an object`);\n      }\n    case 'application/openapi+yaml':\n      return yaml.safeLoad(description);\n    default:\n      throw new Error(`Unknown format: ${format} for ${description}`);\n  }\n}\n```\n"], ["function", "`\n```javascript\nfunction() {\n    var t = this,\n        components = t.model.get('components');\n    components.remove(components.models);\n    t.showSettings();\n}\n```\n"], ["function", "`\n```javascript\nfunction () {\n'use strict';\nvar options = {\n  config: {\n    starttag: `\n    endtag: `\n    addRootSlash: false,\n    relative: true,\n    transform: function (filepath) {\n      return '@import \\'' + filepath + '\\';';\n    }\n  },\n  src: './styles/style.scss',\n  files: [\n    '!./node_modules*',\n    '!./styles/style.scss',\n    '.*.scss'\n  ],\n  dest: './styles',\n  taskName: 'scss-glob-inject', \n  dependencies: []\n};\n\nreturn options;\n}\n```\n"], ["inventory_Ref", "`\n```javascript\nfunction inventory$Ref ($refParent, $refKey, path, pathFromRoot, indirections, inventory, $refs, options) {\n  var $ref = $refKey === null ? $refParent : $refParent[$refKey];\n  var $refPath = url.resolve(path, $ref.$ref);\n  var pointer = $refs._resolve($refPath, options);\n  var depth = Pointer.parse(pathFromRoot).length;\n  var file = url.stripHash(pointer.path);\n  var hash = url.getHash(pointer.path);\n  var external = file !== $refs._root$Ref.path;\n  var extended = $Ref.isExtended$Ref($ref);\n  indirections += pointer.indirections;\n\n  var existingEntry = findInInventory(inventory, $refParent, $refKey);\n  if (existingEntry) {\n    \n    if (depth < existingEntry.depth || indirections < existingEntry.indirections) {\n      removeFromInventory(inventory, existingEntry);\n    }\n    else {\n      return;\n    }\n  }\n\n  inventory.push({\n    $ref: $ref,                   \n    parent: $refParent,           \n    key: $refKey,                 \n    pathFromRoot: pathFromRoot,   \n    depth: depth,                 \n    file: file,                   \n    hash: hash,                   \n    value: pointer.value,         \n    circular: pointer.circular,   \n    extended: extended,           \n    external: external,           \n    indirections: indirections,   \n  });\n\n  \n  crawl(pointer.value, null, pointer.path, pathFromRoot, indirections + 1, inventory, $refs, options);\n}\n```\n"], ["_applyAllCallbacks", "`\n```javascript\nfunction _applyAllCallbacks(callbacks, args) {\n    if (callbacks.length > 0) {\n        var callback = callbacks.pop();\n        try {\n            callback.apply(undefined, args);\n        } finally {\n            _applyAllCallbacks(callbacks, args);\n        }\n    }\n}\n```\n"], ["workerBoilerScript", "`\n```javascript\nfunction workerBoilerScript() {\n\n    var postMessage = self.postMessage;\n    var structuredCloningSupport = null;\n    var toString = {}.toString;\n\n    self.console = {};\n    self.isWorker = true;\n\n    \n    ['log', 'debug', 'error', 'info', 'warn', 'time', 'timeEnd'].forEach(function(meth) {\n        self.console[meth] = function() {\n            postMessage({\n                cmd: 'console',\n                method: meth,\n                args: [].slice.call(arguments)\n            });\n        };\n    });\n\n    self.addEventListener('message', function(e) {\n\n        var data = e.data;\n\n        if (typeof data == 'string' && data.indexOf('EVAL|') === 0) {\n            eval(data.substring(5));\n            return;\n        }\n\n        if (structuredCloningSupport == null) {\n            \n            \n            structuredCloningSupport = e.data[0] === 'PING';\n\n            \n            self.postMessage(\n                structuredCloningSupport ?\n                    'pingback:structuredCloningSupport=YES' :\n                    'pingback:structuredCloningSupport=NO'\n            );\n\n            if (!structuredCloningSupport) {\n                postMessage = function(msg) {\n                    \n                    return self.postMessage(JSON.stringify(msg));\n                };\n            }\n\n            return;\n        }\n\n        if (!structuredCloningSupport) {\n            \n            data = JSON.parse(data);\n        }\n\n        var defs = data.definitions;\n        var isDeferred = false;\n        var args = data.args;\n\n        if (defs) {\n            \n            for (var i in defs) {\n                self[i] = defs[i];\n            }\n            return;\n        }\n\n        function callback() {\n            \n            returnResult({\n                args: [].slice.call(arguments)\n            });\n        }\n\n        callback.transfer = function() {\n            var args = [].slice.call(arguments);\n            var transfers = extractTransfers(args);\n            \n            returnResult({\n                args: args\n            }, transfers);\n        };\n\n        args.push(callback);\n\n        self.deferred = function() {\n            isDeferred = true;\n            var def = {};\n            function resolve(r, transfers) {\n                returnResult({\n                    isDeferred: true,\n                    action: 'resolve',\n                    args: [r]\n                }, transfers);\n                return def;\n            }\n            function reject(r, transfers) {\n                if (r instanceof Error) {\n                    \n                    var cloneableError = {\n                        message: r.message,\n                        stack: r.stack,\n                        name: r.name,\n                        code: r.code\n                    };\n                    for (var i in r) {\n                        if (r.hasOwnProperty(i)) {\n                            cloneableError[i] = r[i];\n                        }\n                    }\n                    postMessage({\n                        cmd: 'deferred_reject_error',\n                        token: data.token,\n                        error: cloneableError\n                    });\n                    return;\n                }\n                returnResult({\n                    isDeferred: true,\n                    action: 'reject',\n                    args: [r]\n                }, transfers);\n            }\n            \n            def.fulfil = def.fulfill = def.resolve = function(value) {\n                return resolve(value);\n            };\n            def.reject = function(value) {\n                return reject(value);\n            };\n            def.transferResolve = function(value) {\n                var transfers = extractTransfers(arguments);\n                return resolve(value, transfers);\n            };\n            def.transferReject = function(value) {\n                var transfers = extractTransfers(arguments);\n                return reject(value, transfers);\n            };\n            return def;\n        };\n\n        \n        var result = self[data.method].apply(self, args);\n\n        if (!isDeferred && result !== void 0) {\n            \n            returnResult({\n                args: [result]\n            });\n        }\n\n        self.deferred = function() {\n            throw new Error('Operative: deferred() called at odd time');\n        };\n\n        function returnResult(res, transfers) {\n            postMessage({\n                cmd: 'result',\n                token: data.token,\n                result: res\n            }, self.hasTransferSupport && transfers || []);\n        }\n\n        function extractTransfers(args) {\n            var transfers = args[args.length - 1];\n\n            if (toString.call(transfers) !== '[object Array]') {\n                throw new Error('Operative: callback.transfer() must be passed an Array of transfers as its last arguments');\n            }\n\n            return transfers;\n        }\n    });\n}\n```\n"], ["function", "`\n```javascript\nfunction() {\n    if (node.debug) {\n      node.log('STARTING event listener');\n    }\n\n    var net = require('net');\n    var dgram = require('dgram');\n    node.inputSocket = dgram.createSocket({type:'udp4', reuseAddr: true});\n\n    node.inputSocket.on('notify', function (event) {\n      if (node.debug) {\n        node.log('Got a notification.', event)\n      }\n    });\n\n    node.inputSocket.on('message', function (msg, rinfo) {\n      \n\n      if (rinfo.address == node.address) {\n        if (node.debug) {\n          node.log(\"UPnP Event from [\" + rinfo.address + \"] --> \" );\n        }\n\n        \n        msg = msg.toString().split('\\r\\n\\r\\n');\n        var header = msg[0];\n        var body = msg[1];\n\n        \n        var method = header.split('\\r\\n').shift().split(' ').shift().trim();\n        if (method == 'M-SEARCH'){\n          return;\n        }\n\n        \n        var arr = header.match(/[^\\r\\n]+/g);\n        var headerInfo = {};\n        for (var i = 1; i < arr.length; ++i){\n          var tem = arr[i].split(/:(.+)?/);\n          if (typeof(tem[1]) == 'string'){ tem[1] = tem[1].trim(); }\n          headerInfo[tem[0].toLowerCase()] = tem[1];\n        };\n        \n        \n        \n        \n\n        \n        if (method == 'NOTIFY' && headerInfo['nts'] == 'yamaha:propchange') {\n\n          var parseString = require('xml2js').parseString;\n          parseString(body, function (err, result) {\n            if (err) {\n              node.error('Failed to parse the event with error: ' + err);\n              return;\n            }\n\n            \n            var zoneName = undefined;\n            if (result.hasOwnProperty('YAMAHA_AV')) {\n              if (result.YAMAHA_AV.hasOwnProperty('Main_Zone')) {\n                zoneName = 'Main_Zone';\n              } else if (result.YAMAHA_AV.hasOwnProperty('Zone_2')) {\n                zoneName = 'Zone_2';\n              } else if (result.YAMAHA_AV.hasOwnProperty('Zone_3')) {\n                zoneName = 'Zone_3';\n              } else if (result.YAMAHA_AV.hasOwnProperty('Zone_4')) {\n                zoneName = 'Zone_4';\n              }\n            }\n            if (zoneName === undefined\n              || result.YAMAHA_AV[zoneName] === undefined\n              || result.YAMAHA_AV[zoneName][0] === undefined) {\n              if (node.debug) {\n                node.warn('Unknown event message format: ' + JSON.stringify(result));\n              }\n              return;\n            }\n\n            for (var i in result.YAMAHA_AV[zoneName][0].Property) {\n              var prop = result.YAMAHA_AV[zoneName][0].Property[i];\n              if (node.debug) {\n                node.log('Property-Change: ' + prop);\n              }\n\n              \n              \n              if (prop == 'Power') {\n\n                \n                node.sendGetCommand(zoneName + '.Power_Control.Power').then(function(value) {\n                  for (var s in node.subscriptions) {\n                    node.subscriptions[s].handler(zoneName + '.Power_Control.Power', value);\n                  }\n                }).catch(function(error) {\n                  node.error('Failed to request data from AVR with error: ' + error);\n                });\n\n              } else if (prop == 'Input') {\n\n                \n                node.sendGetCommand(zoneName + '.Input.Input_Sel').then(function(value) {\n                  for (var s in node.subscriptions) {\n                    node.subscriptions[s].handler(zoneName + '.Input.Input_Sel', value);\n                  }\n                }).catch(function(error) {\n                  node.error('Failed to request data from AVR with error: ' + error);\n                });\n\n              } else if (prop == 'Volume') {\n\n                \n                \n                node.sendGetCommand(zoneName + '.Volume.Lvl').then(function(value) {\n                  for (var s in node.subscriptions) {\n                    node.subscriptions[s].handler(zoneName + '.Volume.Lvl', value);\n                  }\n                }).catch(function(error) {\n                  node.error('Failed to request data from AVR with error: ' + error);\n                });\n                node.sendGetCommand(zoneName + '.Volume.Mute').then(function(value) {\n                  for (var s in node.subscriptions) {\n                    node.subscriptions[s].handler(zoneName + '.Volume.Mute', value);\n                  }\n                }).catch(function(error) {\n                  node.error('Failed to request data from AVR with error: ' + error);\n                });\n\n              } else if (prop == 'Play_Info') {\n\n                \n                \n                node.sendGetCommand(zoneName + '.Input.Input_Sel').then(function(value) {\n\n                  var validInputs = {\n                    'TUNER': 'Tuner', 'Napster': 'Napster', 'Spotify': 'Spotify', 'JUKE': 'JUKE', 'SERVER': 'SERVER',\n                    'NET RADIO': 'NET_RADIO', 'USB': 'USB', 'iPod_USB': 'iPod_USB', 'AirPlay': 'AirPlay'\n                  };\n\n                  if (validInputs.hasOwnProperty(value)) {\n                    node.sendGetCommand(validInputs[value] + '.Play_Info').then(function(value2) {\n                      for (var s in node.subscriptions) {\n                        node.subscriptions[s].handler(value + '.Play_Info', value2);\n                      }\n                    }).catch(function(error) {\n                      node.error('Received event Play_Info but failed to read play info of current input selection: ' + error);\n                    });\n                  } else {\n                    if (node.debug) {\n                      node.log('Received event Play_Info but do not know or support current input selection ' + value);\n                    }\n                  }\n                }).catch(function(error) {\n                  node.error('Received event Play_Info but failed to read current input selection: ' + error);\n                });\n\n              } else if (prop == 'List_Info') {\n\n                \n                \n                node.sendGetCommand(zoneName + '.Input.Input_Sel').then(function(value) {\n\n                  var validInputs = {\n                    'Napster': 'Napster', 'JUKE': 'JUKE', 'SERVER': 'SERVER',\n                    'NET RADIO': 'NET_RADIO', 'USB': 'USB', 'iPod_USB': 'iPod_USB'\n                  };\n\n                  if (validInputs.hasOwnProperty(value)) {\n                    node.sendGetCommand(validInputs[value] + '.List_Info').then(function(value2) {\n                      for (var s in node.subscriptions) {\n                        node.subscriptions[s].handler(value + '.List_Info', value2);\n                      }\n                    }).catch(function(error) {\n                      node.error('Received event List_Info but failed to read play info of current input selection: ' + error);\n                    });\n                  } else {\n                    if (node.debug) {\n                      node.log('Received event List_Info but do not know or support current input selection ' + value);\n                    }\n                  }\n                }).catch(function(error) {\n                  node.error('Received event List_Info but failed to read current input selection: ' + error);\n                });\n\n              } else {\n\n                \n                if (node.debug) {\n                  node.log('Received unsupported Property-Change via multicast: ' + prop);\n                }\n                return;\n\n              }\n            }\n          });\n        }\n      });\n\n      node.inputSocket.on('listening', function () {\n        try {\n          var address = node.inputSocket.address();\n          node.log('UDP client listening on ' + address.address + \":\" + address.port);\n          node.inputSocket.setBroadcast(true)\n          node.inputSocket.setMulticastTTL(5);\n          node.inputSocket.addMembership('239.255.255.250');\n          \n          \n\n          \n\n            \n          } catch (err) {\n            node.warn('Cannot bind address for UPNP event listener. Port probably already in use. Error: ' + err);\n          }\n        });\n\n      try {\n        node.inputSocket.bind(1900);\n      }\n      catch (err) {\n        node.warn('Cannot bind address for UPNP event listener. Port probably already in use. Error: ' + err);\n      }\n    }\n```\n"], ["compareCentroids", "`\n```javascript\nfunction compareCentroids(a, b) {\n  for (let i = 0, l = a.length; i < l; i++) {\n    for (let j = 0, m = a[i].length; j < m; j++) {\n      if (a[i][j] !== b[i][j])\n        return false;\n    }\n  }\n\n  return true;\n}\n```\n"], ""]