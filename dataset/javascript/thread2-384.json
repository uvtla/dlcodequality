[["authenticateViaBrowser", "\nfunction authenticateViaBrowser (url, isAskFlow = false, isPrivate = false, clearSession = false) {\n  return new Promise((resolve, reject) => {\n    <generateCliToken>\n    const cliToken = randtoken.generate(128)\n    </generateCliToken>\n    <parseAndPrepareWebSocketUrl>\n    const parsedURL = new URL(url)\n    parsedURL.protocol = url && url.toLowerCase().includes('https') ? 'wss:/' : 'ws:/'\n    const wsUrl = parsedURL.toString()\n    </parseAndPrepareWebSocketUrl>\n    <initializeWebSocket>\n    const ws = websocket(wsUrl)\n    </initializeWebSocket>\n\n    <setupStreaming>\n    const readBuffer = new ReadableStreamBuffer()\n    readBuffer.put(cliToken)\n    pump(readBuffer, ws, split2(), err => err ? reject(err) :  null)\n      .on('data', (authToken) => {\n        <handleAuthToken>\n        let err\n        if (!authToken) {\n          err = new Error('Authentication failed. No token obtained.')\n        } else if (typeof authToken === 'string' && authToken.toLowerCase() === 'timeout') {\n          err = new Error('Authentication timed out.')\n        }\n        err ? reject(err) : resolve(authToken)\n        ws.destroy()\n        </handleAuthToken>\n      })\n    </setupStreaming>\n\n    <processWebSocketConnection>\n    ws.once('connect', () => {\n      console.log('Authentication required. Opening the login page in a browser...')\n      \n      <generateBrowserLoginUrl>\n      const cliLoginUrl = generateBrowserLoginUrl(url, cliToken, {\n        isAskFlow,\n        isPrivate,\n        clearSession\n      })\n      opn(cliLoginUrl, { wait: false })\n      </generateBrowserLoginUrl>\n    })\n    </processWebSocketConnection>\n  })\n}\n"], ["bundleHandler", "\nfunction bundleHandler (pathToHandlers, module, file) {\n    <validateFile>\n    if (file.length < 3 || file.indexOf('bundle.') === 0 || file.substr(file.length - 3) !== '.js') {\n        return;\n    }\n    </validateFile>\n\n    <checkAccessibility>\n    fs.access(pathToHandlers + '/bundle.' + file, err => {\n        <handleAccessUnavailable>\n        if (err && err.code === 'ENOENT') {\n            return ;\n        }\n        </handleAccessUnavailable>\n\n        <processBundle>\n        let fnIri = module + '/' + file.slice(0, -3);\n        fs.unlink(pathToHandlers + '/bundle.' + file, err => {\n            <logUnlinkFailure>\n            if (err) {\n                console.log('Failed to delete old bundle for handler: ' + fnIri);\n                return console.log(err);\n            }\n            </logUnlinkFailure>\n            <logBundleHandler>\n            console.log('Bundle handler: ' + fnIri);\n            runtime.bundle(fnIri, {}, (err) => {\n                <logBundleFailure>\n                if (err) {\n                    console.log('Failed to bundle handler: ' + fnIri);\n                    return console.log(err);\n                }\n                </logBundleFailure>\n                <logBundleSuccess>\n                console.log('Bundle done for handler: ' + fnIri);\n                </logBundleSuccess>\n            });\n            </logBundleHandler>\n        });\n        </processBundle>\n    });\n    </checkAccessibility>\n}\n"], ["rawData", "\nfunction rawData() {\n  return {\n    <generateMockData>\n    DocumentationGeneration: {\n      // Mock data generation for DocumentationGeneration module\n      // ...\n    },\n    CreateDirs: {\n      // Mock data generation for CreateDirs module\n      // ...\n    }\n    </generateMockData>\n  };\n}\n"], ["updateTextInputFieldState", "\nfunction () {\n  <invokeUpdateState>\n  this.$InputWithFrame._updateState.call(this);\n  </invokeUpdateState>\n  <computeAndApplyInputWidth>\n  var inputWidth = this._computeInputWidth();\n  if (inputWidth < 0) {\n      inputWidth = 0;\n  }\n  if (inputWidth) {\n      this.getTextInputField().style.width = inputWidth + \"px\";\n  }\n  </computeAndApplyInputWidth>\n  <applyStyleForLegacyBrowsers>\n  if ((this._isIE7OrLess || this._simpleHTML) && !this._helpTextSet) {\n      this.getTextInputField().style.color = this._getTextFieldColor();\n  }\n  </applyStyleForLegacyBrowsers>\n  <validationPopupHide>\n  if (!(this._cfg.formatError || this._cfg.error)) {\n      this._validationPopupHide();\n  }\n  </validationPopupHide>\n}\n"], ["updateSelectedIndex", "\nfunction () {\n  <updateBindingValue>\n  var bind = this._bindingListeners.selectedIndex;\n  if (bind) {\n      var newIndex = this._transform(bind.transform, this._domElt.selectedIndex, \"fromWidget\");\n      ariaUtilsJson.setValue(bind.inside, bind.to, newIndex, bind.cb);\n  }\n  </updateBindingValue>\n}\n"], ["handleIncomingMessagesAndCommands", "\nfunction telekit_cmd(telekit) {\n  <messageAndPostEventHandler>\n  let handle = (context) => {\n      <parseCommand>\n      let cmd = parse(context.update);\n      </parseCommand>\n\n      <applyParsedCommand>\n      if (cmd) {\n          cmd.name = cmd.entities[0].name;\n          cmd.mention = cmd.entities[0].mention;\n          context.isCommand = true;\n          context.command = cmd;\n          </applyParsedCommand>\n\n          <triggerCommandEvents>\n          if (telekit.command) {\n              telekit.command(context);\n          }\n          telekit.emit('command', context);\n          telekit.emit(`/${context.command.name}`, context);\n          telekit.dispatch('command', context);\n          </triggerCommandEvents>\n          return;\n      }\n\n      <defaultNonCommandEventHandling>\n      context.isCommand = false;\n      context.command = null;\n      </defaultNonCommandEventHandling>\n  };\n  </messageAndPostEventHandler>\n\n  <initializeMessageAndPostHandlers>\n  telekit.context.isCommand = false;\n  telekit.context.command = null;\n  telekit.on('message', handle);\n  telekit.on('post', handle);\n  </initializeMessageAndPostHandlers>\n}\n"], ["cacheFunction", "\nfunction _cacheFunction(func, data, vars, relPath) {\n  <assignEngineName>\n  func.engine = this.className;\n  </assignEngineName>\n  <registerCallback>\n  if (vars) app.views.callbacks[relPath] = func;\n  </registerCallback>\n}\n"], ["extractAndDecodeCodeBlock", "\nfunction getCode(match, lang) {\n  return <decodeString>\n  match.substring(`<pre><code class=\"${lang}\">`.length, match.indexOf('</code>'))\n    .replace(/&#39;/g, '\\'')\n    .replace(/&lt;/g, '<')\n    .replace(/&gt;/g, '>')\n    .replace(/&amp;/g, '&')\n    .replace(/&quot;/g, '\"');\n  </decodeString>\n}\n"], ["initializeSliderElements", "\nfunction addElements ( connectOptions, base ) {\n  <setupSlider>\n  scope_Handles = [];\n  scope_Connects = [];\n  scope_Connects.push(addConnect(base, connectOptions[0]));\n  for ( var i = 0; i < options.handles; i++ ) {\n      scope_Handles.push(addOrigin(base, i));\n      scope_HandleNumbers[i] = i;\n      scope_Connects.push(addConnect(base, connectOptions[i + 1]));\n  }\n  </setupSlider>\n}\n"], ["constructor_TX", "\nfunction TX(options) {\n  <returnNewInstanceOfTX>\n  if (!(this instanceof TX))\n    return new TX(options);\n  </returnNewInstanceOfTX>\n\n  <initializeTransactionProperties>\n  this.version = 1;\n  this.inputs = [];\n  this.outputs = [];\n  this.locktime = 0;\n  this.mutable = false;\n  this._hash = null;\n  this._hhash = null;\n  this._whash = null;\n  this._raw = null;\n  this._size = -1;\n  this._witness = -1;\n  this._sigops = -1;\n  this._hashPrevouts = null;\n  this._hashSequence = null;\n  this._hashOutputs = null;\n  </initializeTransactionProperties>\n\n  <applyOptionsToInstance>\n  if (options)\n    this.fromOptions(options);\n  </applyOptionsToInstance>\n}\n"], "```"]