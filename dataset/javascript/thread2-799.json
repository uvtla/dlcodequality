[["morganMongoMiddleware", "function morganMongoMiddleware(options = {}, connectionOptions = {}, schemaOptions = {}, morganOptions = {}) {\n    <initializeMorganMongo>\n    const morganMongo = new MorganMongo(options, connectionOptions, schemaOptions);\n    </initializeMorganMongo>\n    return morgan((tokens, req, res) => {\n        try {\n            <prepareAndPersistLog>\n            const logEntry = morganMongo.prepareLogEntry(tokens, req, res);\n            morganMongo.persistLogEntry(logEntry);\n            </prepareAndPersistLog>\n        }\n        catch (e) {\n            <handleLoggingError>\n            console.log(e);\n            </handleLoggingError>\n        }\n        return '';\n    }, morganOptions);\n}\n"], ["updateSensitiveDataInfosOfIgnoredFilesIn", "function updateSensitiveDataInfosOfIgnoredFilesIn(response, options) {\n    <fetchIgnoredData>\n    const ignoredData = getIgnoredSensitiveData(options);\n    </fetchIgnoredData>\n    <duplicateResponse>\n    const updatedResponse = JSON.parse(JSON.stringify(response, null, 2));\n    </duplicateResponse>\n    <markFilesAsNonSensitive>\n    const files = updatedResponse.files || [];\n    files.forEach((file) => {\n        if (\n            file &&\n            file.isSensitiveData &&\n            isIgnoredData(file.path, ignoredData)\n        ) {\n            file.isSensitiveData = false;\n            return;\n        }\n    });\n    </markFilesAsNonSensitive>\n    return updatedResponse;\n}\n"], ["BackboneViewRemove", "function () {\n    var self = this;\n\n    <removeComponents>\n    self.components.selector.remove();\n    self.components.editor.remove();\n    self.components.saver.remove();\n    </removeComponents>\n\n    <callParentRemove>\n    return Backbone.View.prototype.remove.apply(self, arguments);\n    </callParentRemove>\n}\n"], ["compare", "function compare(pathData,opts={}) {\n    <convertPathToPolygons>\n\tvar polys = svgPathToPolygons(pathData,opts);\n    </convertPathToPolygons>\n    <calculateBoundingBox>\n\tvar minX=Infinity, maxX=-Infinity, minY=Infinity, maxY=-Infinity;\n\tpolys.forEach(poly => {\n\t\tpoly.forEach(pt => {\n\t\t\tif (pt[0]<minX) minX=pt[0];\n\t\t\tif (pt[1]<minY) minY=pt[1];\n\t\t\tif (pt[0]>maxX) maxX=pt[0];\n\t\t\tif (pt[1]>maxY) maxY=pt[1];\n\t\t});\n\t});\n\tlet dx=maxX-minX, dy=maxY-minY;\n    </calculateBoundingBox>\n    <logSVGRepresentation>\n\tconsole.log(`\n<svg xmlns=\"http://www.w3.org/2000/svg\">\n<style>path,polygon,polyline { fill-opacity:0.2; stroke:black }</style>\n<path d=\"${pathData}\"/>\n<g transform=\"translate(${dx},0)\">\n${polys.map(poly => `  <${poly.closed ? 'polygon' : 'polyline'} points=\"${poly.join(' ')}\"/>`).join(\"\\n\")}\n</g>\n</svg>\n\t`.trim());\n    </logSVGRepresentation>\n}\n"], ["getClass", "function getClass() {\n  <initializeClassNode>\n  const type = NodeType.ClassType;\n  const token = tokens[pos];\n  const line = token.ln;\n  const column = token.col;\n  </initializeClassNode>\n  \n  <advancePosition>\n  pos++;\n  </advancePosition>\n\n  <collectContent>\n  const content = [getIdent()];\n  </collectContent>\n\n  <createNewNode>\n  return newNode(type, content, line, column);\n  </createNewNode>\n}\n"], ["PageConstructor", "function Page(page) {\n  <copyPageProperties>\n  if (!page) page = {};\n  for (var key in page) this[key] = page[key];\n  </copyPageProperties>\n  <initIdx>\n  if (!this.hasOwnProperty('idx')) this.idx = 0;\n  </initIdx>\n  <initTotal>\n  if (!this.hasOwnProperty('total')) this.total = 1;\n  </initTotal>\n  <initCurrent>\n  if (!this.hasOwnProperty('current')) {\n    this.current = this.total;\n  }\n  </initCurrent>\n}\n"], ["isArrowKey", "function isArrowKey(oEvent) {\n\t\t\tvar sKey = oEvent.key; \n\n\t\t\t<checkForArrowKeys>\n\t\t\treturn (sKey === 'ArrowLeft') ||\n\t\t\t\t(sKey === 'ArrowUp') ||\n\t\t\t\t(sKey === 'ArrowRight') ||\n\t\t\t\t(sKey === 'ArrowDown') ||\n\t\t\t\t(sKey === 'Left') || \n\t\t\t\t(sKey === 'Up') || \n\t\t\t\t(sKey === 'Right') || \n\t\t\t\t(sKey === 'Down'); \n\t\t\t</checkForArrowKeys>\n\t\t}\n"], ["mxConstraintHandler", "function mxConstraintHandler(graph)\n{\n\tthis.graph = graph;\n\t\n\t<initResetHandler>\n\tthis.resetHandler = mxUtils.bind(this, function(sender, evt)\n\t{\n\t\tif (this.currentFocus != null && this.graph.view.getState(this.currentFocus.cell) == null)\n\t\t{\n\t\t\tthis.reset();\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.redraw();\n\t\t}\n\t});\n\t</initResetHandler>\n\n\t<registerListeners>\n\tthis.graph.model.addListener(mxEvent.CHANGE, this.resetHandler);\n\tthis.graph.view.addListener(mxEvent.SCALE_AND_TRANSLATE, this.resetHandler);\n\tthis.graph.view.addListener(mxEvent.TRANSLATE, this.resetHandler);\n\tthis.graph.view.addListener(mxEvent.SCALE, this.resetHandler);\n\tthis.graph.addListener(mxEvent.ROOT, this.resetHandler);\n\t</registerListeners>\n}\n"], ["showLoading", "function showLoading() {\n    var n = 0;\n    <showLoadingElement>\n    o('#loading').show();\n    </showLoadingElement>\n    <startLoadingTimer>\n    showLoading.timer = setInterval(function () {\n        loading.update(++n).draw(loading.ctx);\n    }, 50);\n    </startLoadingTimer>\n}\n"], ["copyDirectory", "function (src, dst, callback) {\n    \n    <listSourceDirectory>\n    var paths = fs.readdirSync(src);\n    </listSourceDirectory>\n    paths.forEach(function (path) {\n        <ensureDestinationExists>\n        if (fs.existsSync(dst) == false) mkdir(dst);\n        </ensureDestinationExists>\n        var _src = src + '/' + path,\n            _dst = dst + '/' + path;\n        \n        <statSourcePath>\n        var st = fs.statSync(_src);\n        </statSourcePath>\n        \n        if (st.isFile()) {\n            <copyFile>\n            fs.writeFileSync(_dst, fs.readFileSync(_src));\n            </copyFile>\n        }\n        else if (st.isDirectory()) {\n            <recursiveDirectoryCopy>\n            exists(_src, _dst, copy);\n            </recursiveDirectoryCopy>\n        }\n    });\n    <invokeCallback>\n    if (callback)\n        callback();\n    </invokeCallback>\n}\n"], ""]