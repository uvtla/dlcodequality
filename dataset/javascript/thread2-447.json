[["updateScrollPosition", "\nfunction(render) {\n    var self = this;\n\n    \n    \n\n    \n    var scrollLeft = self.__scrollLeft + self.__decelerationVelocityX;\n    var scrollTop = self.__scrollTop + self.__decelerationVelocityY;\n\n\n    \n    \n\n    if (!self.options.bouncing) {\n      \n      <constrainScrollPosition>\n      var scrollLeftFixed = Math.max(Math.min(self.__maxDecelerationScrollLeft, scrollLeft), self.__minDecelerationScrollLeft);\n      if (scrollLeftFixed !== scrollLeft) {\n        scrollLeft = scrollLeftFixed;\n        self.__decelerationVelocityX = 0;\n      }\n\n      var scrollTopFixed = Math.max(Math.min(self.__maxDecelerationScrollTop, scrollTop), self.__minDecelerationScrollTop);\n      if (scrollTopFixed !== scrollTop) {\n        scrollTop = scrollTopFixed;\n        self.__decelerationVelocityY = 0;\n      }\n      </constrainScrollPosition>\n      \n    }\n\n\n    \n    \n\n    if (render) {\n\n      <publishUpdates>\n      self.__publish(scrollLeft, scrollTop, self.__zoomLevel);\n      </publishUpdates>\n\n    } else {\n\n      <setScrollPosition>\n      self.__scrollLeft = scrollLeft;\n      self.__scrollTop = scrollTop;\n      </setScrollPosition>\n\n    }\n\n\n    \n    \n    \n\n    \n    if (!self.options.paging) {\n\n      <applyFriction>\n      \n      var frictionFactor = self.options.deceleration;\n\n      self.__decelerationVelocityX *= frictionFactor;\n      self.__decelerationVelocityY *= frictionFactor;\n      </applyFriction>\n      \n    }\n\n\n    \n    \n    \n\n    if (self.options.bouncing) {\n\n      <handleBounceEffect>\n      var scrollOutsideX = 0;\n      var scrollOutsideY = 0;\n\n      \n      var penetrationDeceleration = self.options.penetrationDeceleration;\n      var penetrationAcceleration = self.options.penetrationAcceleration;\n\n      \n      if (scrollLeft < self.__minDecelerationScrollLeft) {\n        scrollOutsideX = self.__minDecelerationScrollLeft - scrollLeft;\n      } else if (scrollLeft > self.__maxDecelerationScrollLeft) {\n        scrollOutsideX = self.__maxDecelerationScrollLeft - scrollLeft;\n      }\n\n      if (scrollTop < self.__minDecelerationScrollTop) {\n        scrollOutsideY = self.__minDecelerationScrollTop - scrollTop;\n      } else if (scrollTop > self.__maxDecelerationScrollTop) {\n        scrollOutsideY = self.__maxDecelerationScrollTop - scrollTop;\n      }\n\n      \n      if (scrollOutsideX !== 0) {\n        var isHeadingOutwardsX = scrollOutsideX * self.__decelerationVelocityX <= self.__minDecelerationScrollLeft;\n        if (isHeadingOutwardsX) {\n          self.__decelerationVelocityX += scrollOutsideX * penetrationDeceleration;\n        }\n        var isStoppedX = Math.abs(self.__decelerationVelocityX) <= self.__minVelocityToKeepDecelerating;\n        \n        if (!isHeadingOutwardsX || isStoppedX) {\n          self.__decelerationVelocityX = scrollOutsideX * penetrationAcceleration;\n        }\n      }\n\n      if (scrollOutsideY !== 0) {\n        var isHeadingOutwardsY = scrollOutsideY * self.__decelerationVelocityY <= self.__minDecelerationScrollTop;\n        if (isHeadingOutwardsY) {\n          self.__decelerationVelocityY += scrollOutsideY * penetrationDeceleration;\n        }\n        var isStoppedY = Math.abs(self.__decelerationVelocityY) <= self.__minVelocityToKeepDecelerating;\n        \n        if (!isHeadingOutwardsY || isStoppedY) {\n          self.__decelerationVelocityY = scrollOutsideY * penetrationAcceleration;\n        }\n      }\n      </handleBounceEffect>\n    }\n  }\n"], ["validatePredictionInput", "\nfunction (failed) {\n  if (failed) {\n    return false;\n  }\n  var count = that._count;\n  <checkIfNumber>\n  if (+count !== count) {\n    return true;\n  }\n  </checkIfNumber>\n  <checkIfGreaterThanZero>\n  if (count > 0) {\n    return true;\n  }\n  </checkIfGreaterThanZero>\n}\n"], ["isObjectOrClassMethod", "\nfunction isObjectOrClassMethod(node) {\n  const parent = node.parent;\n\n  return (\n    parent.type === \"MethodDefinition\" || (\n      parent.type === \"Property\" && (\n        parent.method ||\n        parent.kind === \"get\" ||\n        parent.kind === \"set\"\n      )\n    )\n  );\n}\n"], ["requireMaybe", "\nfunction requireMaybe(moduleName) {\n  <loadModule>\n  try {\n    var modulePath = require.resolve(moduleName);\n  } catch (e) {\n    return null;\n  }\n  </loadModule>\n  \n  <requireModule>\n  return require(moduleName);\n  </requireModule>\n}\n"], ["ObjectTypeProperty", "\nfunction ObjectTypeProperty(node, print) {\n  <handleStaticModifier>\n  if (node[\"static\"]) this.push(\"static \");\n  </handleStaticModifier>\n  <printKey>\n  print.plain(node.key);\n  </printKey>\n  <handleOptionalProperty>\n  if (node.optional) this.push(\"?\");\n  </handleOptionalProperty>\n  <handleTypeAnnotation>\n  if (!t.isFunctionTypeAnnotation(node.value)) {\n    this.push(\":\");\n    this.space();\n  }\n  </handleTypeAnnotation>\n  <printValue>\n  print.plain(node.value);\n  </printValue>\n}\n"], ["alterTableColumn", "\nfunction(name, newname) {\n  <createTransaction>\n  var act = new NobleMachine(function() {\n    act.toNext(db.query(\"SHOW COLUMNS FROM `\" + tablename + \"`;\"));\n  });\n  </createTransaction>\n\n  <generateAndExecuteSQL>\n  act.next(function(result) {\n    var sql = \"ALTER TABLE `\" + tablename + \"` CHANGE `\" + name + \"` `\" + newname + \"`\";\n\n    result.forEach(function(coldatum) {\n      if (coldatum['Field'] == name) {\n        sql += \" \" + coldatum['Type'];\n        \n        if (coldatum['Null'] == 'NO') {\n          sql += \" NOT NULL\";\n        }\n\n        if (coldatum['Key'] == 'PRI') {\n          sql += \" PRIMARY KEY\";\n        }\n\n        sql += coldatum['Extra'];\n\n        if (coldatum['Default'] != 'NULL') {\n          sql += \" DEFAULT \" + coldatum['Default'];\n        }\n      }\n    });\n    sql += \";\";\n\n    act.toNext(db.query(sql));\n  });\n  </generateAndExecuteSQL>\n\n  <nextAction>\n  me.act.next(act);\n  </nextAction>\n}\n"], ["enableDebugger", "\nfunction enableDebugger() {\n  <attemptEnableDebugger>\n  try {\n    _nodeConnection.domains.base.enableDebugger();\n  } catch (e) {\n    <handleDebuggerEnablementFailure>\n    window.alert(\"Failed trying to enable Node debugger: \" + e.message);\n    </handleDebuggerEnablementFailure>\n  }\n  </attemptEnableDebugger>\n}\n"], ["compileTemplate", "\nfunction compileTemplate (templatePath, outputFilename, mainCompilation) {\n  <getChildCompiler>\n  const childCompiler = getChildCompiler(mainCompilation.compiler);\n  </getChildCompiler>\n  <compileAndMapTemplates>\n  return childCompiler.compileTemplates(mainCompilation).then((compiledTemplates) => {\n    if (!compiledTemplates[templatePath]) console.log(Object.keys(compiledTemplates), templatePath);\n    const compiledTemplate = compiledTemplates[templatePath];\n    \n    <generateOutputName>\n    const outputName = mainCompilation.mainTemplate.hooks.assetPath.call(outputFilename, {\n      hash: compiledTemplate.hash,\n      chunk: compiledTemplate.entry\n    });\n    </generateOutputName>\n    return {\n      \n      hash: compiledTemplate.hash,\n      \n      outputName: outputName,\n      \n      content: compiledTemplate.content\n    };\n  });\n  </compileAndMapTemplates>\n}\n"], ["encryptKey", "\nfunction encryptKey(kms, keyId, plaintext, logger) {\n  <prepareEncryptionParams>\n  const params = {KeyId: keyId, Plaintext: plaintext};\n  </prepareEncryptionParams>\n  <performEncryption>\n  return encrypt(kms, params, logger).then(result => \n    <processEncryptionResult>\n    result.CiphertextBlob && result.CiphertextBlob.toString('base64')\n    </processEncryptionResult>\n  );\n  </performEncryption>\n}\n"], ["prepareRequest", "\nasync function prepareRequest(ctx, next) {\n  <setRequestParams>\n  ctx.request.params = ctx.params;\n  </setRequestParams>\n  <callNextMiddleware>\n  await next();\n  </callNextMiddleware>\n}\n"], "```"]