[["requestUnfinishedPastUnitsOfPrivateChains", "\nfunction requestUnfinishedPastUnitsOfPrivateChains(arrChains, onDone){\n\t<lockMutex>\n\tmutex.lock([\"private_chains\"], function(unlock){\n\t</lockMutex>\n\t\t<finishSubroutine>\n\t\tfunction finish(){\n\t\t\tunlock();\n\t\t\tif (onDone)\n\t\t\t\tonDone();\n\t\t}\n\t\t</finishSubroutine>\n\t\t<findUnfinishedPastUnits>\n\t\tprivatePayment.findUnfinishedPastUnitsOfPrivateChains(arrChains, true, function(arrUnits){\n\t\t\tif (arrUnits.length === 0)\n\t\t\t\treturn finish();\n\t\t\t</findUnfinishedPastUnits>\n\t\t\t<logActivity>\n\t\t\tbreadcrumbs.add(arrUnits.length+\" unfinished past units of private chains\");\n\t\t\t</logActivity>\n\t\t\t<requestHistory>\n\t\t\trequestHistoryFor(arrUnits, [], finish);\n\t\t\t</requestHistory>\n\t\t});\n\t});\n}\n"], ["initialLocalTemplatePromise", "\nfunction initialLocalTemplatePromise() {\n  <setup>\n  const self = this;\n  </setup>\n\n  <newPromise>\n  return new Promise((resolve, reject) => {\n    console.time(\"\u521d\u59cb\u5316\u672c\u5730\u6a21\u677f\u7528\u65f6:\");\n\n    <defineAjaxTasks>\n    let ajaxPreloadPromiseTasks = [];\n\n    $(this.bodyDOM).find(\"div[ct-data-role='page']\").each(function () {\n      self.templateDB[this.getAttribute(\"id\")] = this.outerHTML;\n      \n      ajaxPreloadPromiseTasks.push(AjaxPreloadPromise.call(self, this));\n      this.parentNode.removeChild(this);\n    });\n    </defineAjaxTasks>\n\n    <resolveAllPromises>\n    Promise.all(ajaxPreloadPromiseTasks).then(() => {\n      console.timeEnd(\"\u521d\u59cb\u5316\u672c\u5730\u6a21\u677f\u7528\u65f6:\");\n      resolve();\n    }).catch((error) => {\n      reject(error);\n    });\n    </resolveAllPromises>\n  });\n  </newPromise>\n}\n"], ["validateCoercionName", "\nfunction(cName){\n\t<validationCheck>\n        if(validate.isEmpty(cName)){\n            validateParams._warn('ignoring invalid coercion name: ' + cName);\n        }\n        </validationCheck>\n        <getCoercionFunction>\n        if(validate.isFunction(validateParams.coercions[cName])){\n            return validateParams.coercions[cName];\n        }else{\n            validateParams._warn(\"no coercion named '\" + cName + \"' defined - ignoring\");\n        }\n        return undefined;\n        </getCoercionFunction>\n}\n"], ["_links", "\nfunction _links (term) {\n\t<checkAndBuildLinks>\n    return term.links ? `\n    <ul class='links'>\n      ${Object.keys(term.links).reduce((acc, val) => { return `${acc}<li>${term.links[val].toLink(val)}</li>` }, '')}\n    </ul>` : ''\n    </checkAndBuildLinks>\n}\n"], ["broadcast", "\nfunction broadcast(connections, packet) {\n\t<broadcastPacket>\n    var i = connections.length;\n    while (i--) {\n        connections[i].write(packet);\n        flush(connections[i]);\n    }\n    </broadcastPacket>\n}\n"], ["stringify", "\nfunction stringify(jCal) {\n\t<preprocessData>\n    if (typeof jCal[0] == \"string\") {\n      \n      jCal = [jCal];\n    }\n    </preprocessData>\n\n    <stringifyComponents>\n    var i = 0;\n    var len = jCal.length;\n    var result = '';\n\n    for (; i < len; i++) {\n      result += stringify.component(jCal[i]) + LINE_ENDING;\n    }\n    </stringifyComponents>\n\n    <returnResult>\n    return result;\n    </returnResult>\n}\n"], ["generateTimeseries", "\nasync function* generateTimeseries(\n    lineDescriptors, revisions, levelOfDetail) {\n  <setupReaders>\n  const readers = [];\n  const timeseriesesByLine = [];\n  </setupReaders>\n\n  <createTimeseriesDescriptors>\n  for (const lineDescriptor of lineDescriptors) {\n    const fetchDescriptors = ChartTimeseries.createFetchDescriptors(\n        lineDescriptor, levelOfDetail);\n    const timeserieses = new Array(fetchDescriptors.length);\n    timeseriesesByLine.push({lineDescriptor, timeserieses});\n\n    for (let fetchIndex = 0; fetchIndex < fetchDescriptors.length;\n      ++fetchIndex) {\n      readers.push((async function* () {\n        const request = new TimeseriesRequest({\n          ...fetchDescriptors[fetchIndex],\n          ...revisions,\n        });\n\n        for await (const timeseries of request.reader()) {\n          \n          \n          timeserieses[fetchIndex] = timeseries;\n          yield {};\n        }\n      })());\n    }\n  }\n  </createTimeseriesDescriptors>\n\n  <yieldFilteredResults>\n  for await (const {results, errors} of new BatchIterator(readers)) {\n    const filtered = filterTimeseriesesByLine(timeseriesesByLine);\n    yield {timeseriesesByLine: filtered, errors};\n  }\n  </yieldFilteredResults>\n}\n"], ["transferAsset", "\nfunction transferAsset (commandOptions, { srcAccountId, destAccountId, assetId, description, amount }) {\n  <executeTransferCommand>\n  return command(\n    commandOptions,\n    txHelper.addCommand(\n      txHelper.emptyTransaction(),\n      'transferAsset',\n      {\n        srcAccountId,\n        destAccountId,\n        assetId,\n        description,\n        amount\n      }\n    )\n  )\n  </executeTransferCommand>\n}\n"], ["LatheBufferGeometry", "\nfunction LatheBufferGeometry( points, segments, phiStart, phiLength ) {\n\n\t<superCall>\n\tBufferGeometry.call( this );\n\n\tthis.type = 'LatheBufferGeometry';\n\n\tthis.parameters = {\n\t\tpoints: points,\n\t\tsegments: segments,\n\t\tphiStart: phiStart,\n\t\tphiLength: phiLength\n\t};\n\t</superCall>\n\n\t<setupInitialConfig>\n\tsegments = Math.floor( segments ) || 12;\n\tphiStart = phiStart || 0;\n\tphiLength = phiLength || Math.PI * 2;\n\n\t\n\tphiLength = _Math.clamp( phiLength, 0, Math.PI * 2 );\n\t</setupInitialConfig>\n\n\n\t<initializeBuffers>\n\tvar indices = [];\n\tvar vertices = [];\n\tvar uvs = [];\n\t</initializeBuffers>\n\n\t<generateVerticesAndUVs>\n\tvar base;\n\tvar inverseSegments = 1.0 / segments;\n\tvar vertex = new Vector3();\n\tvar uv = new Vector2();\n\tvar i, j;\n\n\t\n\tfor ( i = 0; i <= segments; i ++ ) {\n\n\t\tvar phi = phiStart + i * inverseSegments * phiLength;\n\n\t\tvar sin = Math.sin( phi );\n\t\tvar cos = Math.cos( phi );\n\n\t\tfor ( j = 0; j <= ( points.length - 1 ); j ++ ) {\n\n\t\t\t\n\t\t\tvertex.x = points[ j ].x * sin;\n\t\t\tvertex.y = points[ j ].y;\n\t\t\tvertex.z = points[ j ].x * cos;\n\n\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t\n\t\t\tuv.x = i / segments;\n\t\t\tuv.y = j / ( points.length - 1 );\n\n\t\t\tuvs.push( uv.x, uv.y );\n\n\n\t\t}\n\n\t}\n\t</generateVerticesAndUVs>\n\n\t<generateIndices>\n\tfor ( i = 0; i < segments; i ++ ) {\n\n\t\tfor ( j = 0; j < ( points.length - 1 ); j ++ ) {\n\n\t\t\tbase = j + i * points.length;\n\n\t\t\tvar a = base;\n\t\t\tvar b = base + points.length;\n\t\t\tvar c = base + points.length + 1;\n\t\t\tvar d = base + 1;\n\n\t\t\t\n\t\t\tindices.push( a, b, d );\n\t\t\tindices.push( b, c, d );\n\n\t\t}\n\n\t}\n\t</generateIndices>\n\n\t<setGeometryAttributes>\n\tthis.setIndex( indices );\n\tthis.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\tthis.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\t</setGeometryAttributes>\n\n\t<computeNormals>\n\tthis.computeVertexNormals();\n\t</computeNormals>\n\n\t<adjustWrappedNormals>\n\tif ( phiLength === Math.PI * 2 ) {\n\n\t\tvar normals = this.attributes.normal.array;\n\t\tvar n1 = new Vector3();\n\t\tvar n2 = new Vector3();\n\t\tvar n = new Vector3();\n\n\t\t\n\t\tbase = segments * points.length * 3;\n\n\t\tfor ( i = 0, j = 0; i < points.length; i ++, j += 3 ) {\n\n\t\t\t\n\t\t\tn1.x = normals[ j + 0 ];\n\t\t\tn1.y = normals[ j + 1 ];\n\t\t\tn1.z = normals[ j + 2 ];\n\n\t\t\t\n\t\t\tn2.x = normals[ base + j + 0 ];\n\t\t\tn2.y = normals[ base + j + 1 ];\n\t\t\tn2.z = normals[ base + j + 2 ];\n\n\t\t\t\n\t\t\tn.addVectors( n1, n2 ).normalize();\n\n\t\t\t\n\t\t\tnormals[ j + 0 ] = normals[ base + j + 0 ] = n.x;\n\t\t\tnormals[ j + 1 ] = normals[ base + j + 1 ] = n.y;\n\t\t\tnormals[ j + 2 ] = normals[ base + j + 2 ] = n.z;\n\n\t\t}\n\n\t}\n\t</adjustWrappedNormals>\n}\n"], ["mobileNavigationBackOnClickComponent", "\nfunction mobileNavigationBackOnClickComponent() {\n  <defineComponent>\n  return {\n    require: '^^gmfMobileNav',\n    restrict: 'A',\n    scope: false,\n    \n    <componentLinkFunction>\n    link: (scope, element, attrs, navCtrl) => {\n      element.on('click', () => {\n        if (!navCtrl) {\n          throw new Error('Missing navCtrl');\n        }\n        navCtrl.backIfActive(element[0]);\n      });\n    }\n    </componentLinkFunction>\n  };\n  </defineComponent>\n}\n"], ""]