[["compareSetter", "function(yOrdering) {\n    this.compare = yOrdering ?\n        OpenLayers.ElementsIndexer.IndexingMethods.Z_ORDER_Y_ORDER :\n        OpenLayers.ElementsIndexer.IndexingMethods.Z_ORDER_DRAWING_ORDER;\n    this.clear();\n}\n"], ["generateBootstrapContent", "function generateBootstrapContent(partialsArray, lineDelimiter) {\n    var _bootstrapContent = '',\n        _folderGroup = '';\n    partialsArray.forEach(function (partialName) {\n        var _sassPath = mainPartialList[partialName].removedRoot,\n            _currentRoot = _sassPath.parseRootFolder();\n        if (options.useRelativePaths) {\n            _sassPath = Path.relative(Path.dirname(options.bootstrapFile),\n                                      mainPartialList[partialName].fileName.toSassFormat());\n            _sassPath = _sassPath.replace(Path.extname(_sassPath), '');\n            _sassPath = _sassPath.replace(/\\\\/g, \"/\");\n        } else {\n            _sassPath = _sassPath.toSassFormat();\n        }\n        if (_folderGroup != _currentRoot) {\n            _bootstrapContent += NEW_LINE + '\n            _folderGroup = _currentRoot;\n        }\n        _bootstrapContent += options.importKeyword + ' \"' + _sassPath + '\"' + lineDelimiter + NEW_LINE;\n    });\n    return _bootstrapContent;\n}\n"], ["performAjaxDELETE", "function(id, callback) {\n    var attrAjax = {\n        'type': 'DELETE',\n        'dataType': 'text',\n        'url': Utils.getUrl(config.urls.subscriptions, id)\n    };\n    this.service.ajax(attrAjax, function(err, res){\n        if (err) {\n            callback(err, null);\n        } else {\n            callback(null, true);\n        }\n    });\n}\n"], ["isMatchRule", "function isMatchRule(req, pathname, rule) {\n    if (typeof rule === 'string') {\n        return pathname.indexOf(rule) > -1;\n    } else if (rule instanceof RegExp) {\n        return rule.test(pathname);\n    } else if (typeof rule === 'function') {\n        return rule(pathname, req);\n    }\n}\n"], ["performDatabaseQuery", "function doQuery(options) {\n    return models.Subscriber.findPage(options)\n        .then(({data, meta}) => {\n            return {\n                subscribers: data.map(model => model.toJSON(options)),\n                meta: meta\n            };\n        });\n}\n"], ["parseTemplate", "function maxstache (str, ctx) {\n    ctx = ctx || {}\n    assert.equal(typeof str, 'string')\n    assert.equal(typeof ctx, 'object')\n    const tokens = str.split(/\\{\\{|\\}\\}/)\n    const res = tokens.map(parse(ctx))\n    return res.join('')\n}\n"], ["createSVGGradient", "function buildGradient() {\n    if (!chartGradientEl) {\n        chartGradientEl = svg.select('.metadata-group')\n            .append('linearGradient')\n                .attr('id', gradientId)\n                .attr('gradientUnits', 'userSpaceOnUse')\n                .attr('x1', 0)\n                .attr('x2', xScale(data[data.length - 1].date))\n                .attr('y1', 0)\n                .attr('y2', 0)\n            .selectAll('stop')\n                .data([\n                    {offset: '0%', color: gradient[0]},\n                    {offset: '100%', color: gradient[1]}\n                ])\n            .enter().append('stop')\n                .attr('offset', ({offset}) => offset)\n                .attr('stop-color', ({color}) => color);\n    }\n}\n"], ["mergeBatchResults", "function mergeBatchResults(batches) {\n    let files = [];\n    let unformattedFiles = [];\n    let formattedFiles = [];\n    let errors = [];\n    batches.forEach(batch => {\n        files.push(...batch.files);\n        unformattedFiles.push(...batch.unformattedFiles);\n        formattedFiles.push(...batch.formattedFiles);\n        errors.push(...batch.errors);\n    });\n    return { files, formattedFiles, unformattedFiles, errors };\n}\n"], ["initializeConverter", "function _constructor () {\n    converterOptions = converterOptions || {};\n    for (var gOpt in globalOptions) {\n        if (globalOptions.hasOwnProperty(gOpt)) {\n            options[gOpt] = globalOptions[gOpt];\n        }\n    }\n    if (typeof converterOptions === 'object') {\n        for (var opt in converterOptions) {\n            if (converterOptions.hasOwnProperty(opt)) {\n                options[opt] = converterOptions[opt];\n            }\n        }\n    } else {\n        throw Error('Converter expects the passed parameter to be an object, but ' + typeof converterOptions +\n        ' was passed instead.');\n    }\n    if (options.extensions) {\n        showdown.helper.forEach(options.extensions, _parseExtension);\n    }\n}\n"], ["validateSpec", "function validateSpec (spec) {\n    if (spec === undefined) {\n        return new Error('spec cannot be undefined')\n    }\n    const isSimpleSpec = isString(spec) || isString(spec.files)\n    const isArraySpec = (Array.isArray(spec.files) && spec.files.every(isString))\n    if (isArraySpec) {\n        if (spec.base === undefined) {\n            return new Error('spec.base cannot be undefined if spec.files is an array')\n        }\n    } else {\n        if (!isSimpleSpec) {\n            return new Error('spec.files cannot be undefined property')\n        }\n    }\n    return undefined\n}\n"], "```"]