[["step1a$1", "\nfunction step1a$1(token) {\n    <getR1Responsibility>\n    var r1 = getR1(token);\n\n    if (!r1) {\n        return token;\n    }\n    </getR1Responsibility>\n\n    <matchRegExpResponsibility>\n    var r1Match = r1.match(/(a|e|ede|ande|ende|ane|ene|hetene|en|heten|ar|er|heter|as|es|edes|endes|enes|hetenes|ens|hetens|ers|ets|et|het|ast)$/);\n\n    if (r1Match) {\n        return token.replace(new RegExp(r1Match[1] + '$'), '');\n    }\n    </matchRegExpResponsibility>\n\n    return token;\n}\n"], ["rdfToJs", "\nfunction rdfToJs (node) {\n    <initializeValue>\n    let value;\n    const rdfVal = node.value;\n    const datatype = node.datatype;\n    </initializeValue>\n  \n    <throwErrorFunction>\n    const throwError = () => {\n        throw new Error(\n            `Cannot parse rdf type/value to JS value.  Given value [${rdfVal}] of type [${datatype}].`\n        );\n    };\n    </throwErrorFunction>\n  \n    <parseDatatype>\n    if (datatype) {\n        const XMLSchema = 'http://www.w3.org/2001/XMLSchema#';\n        switch (datatype.value) {\n            case `${XMLSchema}boolean`:\n                if (rdfVal === '1') {\n                    value = true;\n                } else if (rdfVal === '0') {\n                    value = false;\n                } else {\n                    throwError();\n                }\n                break;\n            case `${XMLSchema}dateTime`:\n                value = new Date(rdfVal);\n                break;\n            case `${XMLSchema}decimal`:\n            case `${XMLSchema}double`:\n                value = Number.parseFloat(rdfVal);\n                break;\n            case `${XMLSchema}integer`:\n                value = Number.parseInt(rdfVal);\n                break;\n            case 'http://www.w3.org/1999/02/22-rdf-syntax-ns#langString':\n            case `${XMLSchema}string`:\n            default:\n                value = rdfVal;\n                break;\n        }\n    } else {\n        value = rdfVal;\n    }\n    </parseDatatype>\n  \n    return value;\n}\n"], ["automat", "\nfunction automat(template, replacements) {\n    <checkArguments>\n    var hasReplacements = arguments.length > 1;\n    </checkArguments>\n\n    <handleTemplateFunction>\n    if (typeof template === 'function') {\n        template = template.call(this); \n    }\n    </handleTemplateFunction>\n\n    <performReplacements>\n    if (hasReplacements) {\n        var args = arguments;\n        template = template.replace(automat.replacersRegex, function(match, key) {\n            key -= -1; \n            return args.length > key ? args[key] : '';\n        });\n\n        template = template.replace(automat.encodersRegex, function(match, key) {\n            key -= -1; \n            if (args.length > key) {\n                var htmlEncoderNode = document.createElement('DIV');\n                htmlEncoderNode.textContent = args[key];\n                return htmlEncoderNode.innerHTML;\n            } else {\n                return '';\n            }\n        });\n    }\n    </performReplacements>\n\n    return template;\n}\n"], ["dispatch", "\nfunction dispatch(methodName, inDocument, xpath, contextNode, namespaceResolver) {\n    <preprocessXpath>\n    xpath = preprocess(xpath);\n    </preprocessXpath>\n\n    <setDefaultContext>\n    if (!contextNode) {\n        contextNode = inDocument;\n    }\n    </setDefaultContext>\n\n    <executeXpathQuery>\n    var result = getEngineFor(inDocument)\n        .setIgnoreAttributesWithoutValue(ignoreAttributesWithoutValue)\n        [methodName](xpath, contextNode, namespaceResolver);\n    </executeXpathQuery>\n\n    return result;\n}\n"], ["generateNames", "\nfunction generateNames(model, prefix, name) {\n    <initializeProperties>\n    if (name === void 0) { name = \"\"; }\n    model.fullPackageName = prefix + (name != \".\" ? name : \"\");\n    model.properties = argv.properties;\n    model.explicitRequired = argv.explicitRequired;\n    model.camelCaseProperties = argv.camelCaseProperties;\n    model.camelCaseGetSet = argv.camelCaseGetSet;\n    model.underscoreGetSet = argv.underscoreGetSet;\n    model.generateBuilders = argv.generateBuilders;\n    </initializeProperties>\n\n    <processDefinitionsAndNames>\n    var newDefinitions = {};\n\n    var key;\n    for (key in model.messages) {\n        var message = model.messages[key];\n        newDefinitions[message.name] = \"Builder\";\n        generateNames(message, model.fullPackageName, \".\" + (model.name ? model.name : \"\"));\n    }\n\n    for (key in model.enums) {\n        var currentEnum = model.enums[key];\n        newDefinitions[currentEnum.name] = \"\";\n        currentEnum.fullPackageName = model.fullPackageName + (model.name ? \".\" + model.name : \"\");\n    }\n\n    for (key in model.fields) {\n        var field = model.fields[key];\n        if (typeof newDefinitions[field.type] !== \"undefined\") {\n            field.type = model.name + \".\" + field.type;\n        }\n    }\n    model.oneofsArray = [];\n    for (key in model.oneofs) {\n        var oneof = model.oneofs[key];\n        model.oneofsArray.push({ name: key, value: oneof });\n    }\n\n    var definitions = [];\n    for (key in newDefinitions) {\n        definitions.push({ name: key, type: ((model.name ? (model.name + \".\") : \"\") + key) + newDefinitions[key] });\n    }\n    model.definitions = definitions;\n    </processDefinitionsAndNames>\n}\n"], ["getSupportedDataTypes", "\nfunction getSupportedDataTypes () {\n    <initializeTypesArray>\n    var types = [];\n    </initializeTypesArray>\n\n    <checkAndPushTypes>\n    if (typeof Uint8Array === 'function') {\n        types.push(Uint8Array);\n    }\n    if (typeof Uint16Array === 'function') {\n        types.push(Uint16Array);\n    }\n    if (typeof ArrayBuffer === 'function') {\n        types.push(ArrayBuffer);\n    }\n    if (typeof Uint32Array === 'function') {\n        types.push(Uint32Array);\n    }\n    if (typeof Int8Array === 'function') {\n        types.push(Int8Array);\n    }\n    if (typeof Int16Array === 'function') {\n        types.push(Int16Array);\n    }\n    if (typeof Int32Array === 'function') {\n        types.push(Int32Array);\n    }\n    if (typeof Uint8ClampedArray === 'function') {\n        types.push(Uint8ClampedArray);\n    }\n    if (typeof Float32Array === 'function') {\n        types.push(Float32Array);\n    }\n    if (typeof Float64Array === 'function') {\n        types.push(Float64Array);\n    }\n    if (typeof DataView === 'function') {\n        types.push(DataView);\n    }\n    </checkAndPushTypes>\n\n    return types;\n}\n"], ["TokenBucket", "\nfunction TokenBucket(timespan, limit, { distFactor = 1, factor = 20, spread = 500 / timespan, now = Date.now } = {}) {\n    <initializeProperties>\n    this.now = now;\n    this.timespan = timespan;\n    this.givenLimit = limit;\n    this.factor = factor;\n    this.spread = spread;\n    this.timespanIndex = Math.ceil(timespan / factor);\n    this.total = 0;\n    this.time = -1;\n    this.buffer = new Array(this.factor + 1).fill(0);\n    </initializeProperties>\n  \n    <setDistFactorMethod>\n    this.setDistFactor(distFactor);\n    </setDistFactorMethod>\n}\n"], ["parseCLIArguments", "\nfunction (args, cb) {\n    <initializeCLIParameters>\n    var flags = {},\n        commands = {};\n    </initializeCLIParameters>\n\n    <checkArgumentsAvailability>\n    if (!args || !args.length) {\n        printUsage();\n    }\n    </checkArgumentsAvailability>\n\n    <parseArguments>\n    for (var i = 0, len = args.length; i < len; i++) {\n        var arg = args[i],\n            rFlag = /^--/,\n            split;\n\n        if (rFlag.test(arg)) {\n            split = arg.split(\"=\");\n            flags[split[0].replace(rFlag, \"\")] = (split[1] || true);\n        } else {\n            commands[arg] = true;\n        }\n    }\n    </parseArguments>\n\n    <handleFlagsAndCommands>\n    if (flags.quiet) {\n        nsl.log(\"server\", \"Squarespace server running in silent mode\");\n        nsl.silence();\n    }\n\n    if (flags.open) {\n        serverConfig.open = true;\n    }\n\n    if (flags.auth) {\n        serverConfig.auth = true;\n    }\n\n    if (flags.version) {\n        printVersion();\n    } else if (commands.buster) {\n        sqsCache.clear();\n        process.exit();\n    } else if (commands.server) {\n        if (flags.port) {\n            flags.port = Number(flags.port);\n            serverConfig.port = flags.port;\n        }\n        cb();\n    }\n    </handleFlagsAndCommands>\n}\n"], ["getMatchedWord", "\nfunction getMatchedWord(sWords, sTokenToMatch) {\n    <checkInputWords>\n    if (sWords) {\n    </checkInputWords>\n\n        <defineStartsWithTokenFunction>\n        var fnStartsWithToken = function (sString) {\n            return sString.toLowerCase().indexOf(sTokenToMatch.toLowerCase()) === 0;\n        };\n        </defineStartsWithTokenFunction>\n\n        <splitAndFilterWords>\n        var aMetadataTokens = sWords.split(\" \");\n        var sMatchedMetadataToken = aMetadataTokens.filter(fnStartsWithToken);\n        </splitAndFilterWords>\n\n        <returnMatchedWord>\n        if (sMatchedMetadataToken.length) {\n            return sMatchedMetadataToken[0];\n        }\n        </returnMatchedWord>\n    }\n    return null;\n}\n"], ["calculateClosestPointOnLineSegment", "\nfunction (p, p1, p2, sqDist) {\n    <initializeVariables>\n    var x = p1.x,\n        y = p1.y,\n        dx = p2.x - x,\n        dy = p2.y - y,\n        dot = dx * dx + dy * dy,\n        t;\n    </initializeVariables>\n\n    <calculateProjection>\n    if (dot > 0) {\n        t = ((p.x - x) * dx + (p.y - y) * dy) / dot;\n\n        if (t > 1) {\n            x = p2.x;\n            y = p2.y;\n        } else if (t > 0) {\n            x += dx * t;\n            y += dy * t;\n        }\n    }\n    </calculateProjection>\n\n    <computeDistanceOrPoint>\n    dx = p.x - x;\n    dy = p.y - y;\n\n    return sqDist ? dx * dx + dy * dy : new L.Point(x, y);\n    </computeDistanceOrPoint>\n}\n"], ""]