[["collections", "\nfunction collections(options) {\n  options = options || {};\n\n  return function plugin(app, base) {\n    if (!isValidInstance(app)) return;\n\n    <configureOptions>\n    app.option(base.options);\n    app.option(options);\n    </configureOptions>\n\n    <createCollections>\n    app.create('badges', { viewType: 'partial' });\n    app.create('docs', { viewType: 'partial' });\n    </createCollections>\n\n    <usePlugin>\n    app.use(require('generate-collections'));\n    </usePlugin>\n\n    return plugin;\n  };\n}\n"], ["invokeCommand", "\nfunction invokeCommand(command, argv, isInternalCommand) {\n  <resolveGlobs>\n  const globs = getGlobs();\n  </resolveGlobs>\n\n  if (globs.length === 0) {\n    <handleEmptyGlobs>\n    return invokeCommandError(command, isInternalCommand);\n    </handleEmptyGlobs>\n  }\n\n  <getModules>\n  const modulesAnswered = getModulesAnswered(command, argv, globs);\n  const modulesAnsweredLength = modulesAnswered.length;\n  </getModules>\n\n  if (modulesAnsweredLength === 0) {\n    <handleNoModules>\n    return invokeCommandError(command, isInternalCommand);\n    </handleNoModules>\n  }\n\n  <logSuccess>\n  const modulesAnsweredPlural = modulesAnsweredLength === 1 ? 'module' : 'modules';\n  logger.verbose(\n    `Successfully passed ${command} to ${modulesAnsweredLength} ${modulesAnsweredPlural}:`\n  );\n  logger.verbose(modulesAnswered.join(', '));\n  </logSuccess>\n}\n"], ["targetsElementPseudo", "\nfunction targetsElementPseudo (element, selector) {\n  <processSelector>\n  const selectors = simpleSelectorParser.process(selector).res\n  </processSelector>\n\n  return selectors.filter((selector) => {\n    let selectorNodes = selector.nodes.concat([]).reverse() \n\n    <analyzeSelectorNodes>\n    for (const node of selectorNodes) {\n      if (node.type === 'cominator') { break }\n\n      if (node.type === 'pseudo' && node.value.replace(/::?/, '') in element.pseudos) {\n        return true\n      }\n\n      if (node.type === 'tag' && node.value === element.tag) { break }\n    }\n    </analyzeSelectorNodes>\n\n    return false\n  }).length > 0\n}\n"], ["makeApp", "\nfunction makeApp(rootContainer, combinedStore) {\n  <renderApp>\n  return React.createElement(react_redux_1.Provider, { store: combineStores(combinedStore) }, rootContainer);\n  </renderApp>\n}\n"], ["anonymousFunction", "\nfunction(oArgs) {\n    \n  <handleEvent>\n  if(!Dom.isAncestor(oArgs.target,Ev.getRelatedTarget(oArgs.event))) {\n      this.unhighlightColumn(oArgs.target);\n  }\n  </handleEvent>\n}\n"], ["sh_highlightElement", "\nfunction sh_highlightElement(element, language) {\n  <addClass>\n  sh_addClass(element, 'sh_sourceCode');\n  </addClass>\n  <extractAndHighlight>\n  var originalTags = [];\n  var inputString = sh_extractTags(element, originalTags);\n  var highlightTags = sh_highlightString(inputString, language);\n  </extractAndHighlight>\n  <mergeTags>\n  var tags = sh_mergeTags(originalTags, highlightTags);\n  </mergeTags>\n  <insertHighlightedContent>\n  var documentFragment = sh_insertTags(tags, inputString);\n  while (element.hasChildNodes()) {\n    element.removeChild(element.firstChild);\n  }\n  element.appendChild(documentFragment);\n  </insertHighlightedContent>\n}\n"], ["doDelete", "\nfunction doDelete(filter) {\n  <logDeletionAttempt>\n  console.log('folder delete called', filter);\n  </logDeletionAttempt>\n  return new Promise(function(resolve, reject) {\n    var keysPromise;\n    var deletes = [], deletedKeys = [];\n\n    <processFilter>\n    if (common.keyTypes.indexOf(typeof filter) !== -1) {\n      filter = [filter];\n    } else if (filter instanceof Array) {\n    } else if (filter === true || typeof filter === 'object') {\n      <handleObjectOrTrueFilter>\n      console.log('object/true delete handler');\n      readKeys().then(/*...*/);\n      </handleObjectOrTrueFilter>\n      return;\n    } else {\n      <handleInvalidFilter>\n      reject({\n        message: 'filter needs to be an object containing a filter'\n      });\n      </handleInvalidFilter>\n      return;\n    }\n    </processFilter>\n\n    <resolveKeysAndDelete>\n    if (options.cacheKeys) {/*...*/}\n    keysPromise.then(/*...*/);\n    </resolveKeysAndDelete>\n  });\n}\n"], ["couldBeError", "\nfunction couldBeError (node) {\n  <determineErrorPotential>\n  switch (node.type) {\n    /*...several cases...*/\n    default:\n      return node.value === null\n  }\n  </determineErrorPotential>\n}\n"], ["svdJs", "\nfunction svdJs() {\n  <setup>\n  var A = this;\n  var V = Matrix$b.I(A.rows());\n  var S = A.transpose();\n  var U = Matrix$b.I(A.cols());\n  var err = Number.MAX_VALUE;\n  var i = 0;\n  var maxLoop = 100;\n  </setup>\n\n  <iterativeProcess>\n  while(/*...*/) {\n    var qr = S.transpose().qrJs();\n    /* ... update U, V, S, err, i ... */\n  }\n  </iterativeProcess>\n\n  <processResults>\n  var ss = S.diagonal();\n  var s = [];\n  for(/*...*/) {\n    /*... more processing ...*/\n  }\n  </processResults>\n\n  <returnResult>\n  return {U: U, S: $V(s).toDiagonalMatrix(), V: V};\n  </returnResult>\n}\n"], ["anonymousFunction2", "\nfunction () {\n  var series = this,\n    chart = series.chart,\n    wasDirtyData = series.isDirtyData, \n    group = series.group,\n    xAxis = series.xAxis,\n    yAxis = series.yAxis;\n\n  <updateGroup>\n  if (group) {/*...*/}\n  </updateGroup>\n\n  <seriesPreparation>\n  series.translate();\n  if (series.setTooltipPoints) {\n    series.setTooltipPoints(true);\n  }\n  series.render();\n  </seriesPreparation>\n\n  <fireEventIfDirty>\n  if (wasDirtyData) {\n    fireEvent(series, 'updatedData');\n  }\n  </fireEventIfDirty>\n}\n"], "```"]