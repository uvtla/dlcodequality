[["function(app)", "\nfunction(app) {\n  <initializeFilePath>\n  var filePath = path.join(app.getBase(), Constants.FILEPATH.SERVER_DIR, app.serverType, Constants.FILEPATH.LIFECYCLE);\n  if(!fs.existsSync(filePath)) {\n    return;\n  }\n  </initializeFilePath>\n\n  <loadLifecycle>\n  var lifecycle = require(filePath);\n  for(var key in lifecycle) {\n    if(typeof lifecycle[key] === 'function') {\n      app.lifecycleCbs[key] = lifecycle[key];\n    } else {\n      logger.warn('lifecycle.js in %s is error format.', filePath);\n    }\n  }\n  </loadLifecycle>\n}\n"], ["anonymous", "\nfunction (revertOriginal, keepEditor) {\n  <destructionLogic>\n  if (!keepEditor) {\n    editproxy.destroy(revertOriginal);\n  }\n  </destructionLogic>\n\n  <selectionLogic>\n  if (!selection.isSelected()) {\n    return;\n  }\n  selection.refreshBorderDimensions();\n  </selectionLogic>\n\n  <prepareEditproxy>\n  if (!keepEditor) {\n    editproxy.prepare();\n  }\n  </prepareEditproxy>\n}\n"], ["anonymous", "\nfunction(data) {\n  <formatAndTargetData>\n  var leftData = this.formatInput(data),\n      rightData = this.getTargets(leftData),\n      me = this;\n  </formatAndTargetData>\n\n  <populateLeftList>\n  $.each(leftData, function(index, value) {\n      me.$leftListBody.append([\n          '<li class=\"biz-transfer-list-content-item\">',\n          '<input type=\"checkbox\" data-id=\"' + value.id + '\" title=\"' + value.title + '\" ' + (value.chosen ? 'disabled' : '') + '/></li>'\n      ].join(''));\n  });\n  </populateLeftList>\n\n  <populateRightList>\n  $.each(rightData, function(index, value) {\n      me.$rightListBody.append(['<li class=\"biz-transfer-list-content-item\">',\n          '<input type=\"checkbox\" data-id=\"' + value.id + '\" title=\"' + value.title + '\" /></li>'\n      ].join(''));\n  });\n  </populateRightList>\n\n  <initializeCheckboxes>\n  this.$main.find(':checkbox').bizCheckbox({\n      theme: this.options.theme\n  });\n  </initializeCheckboxes>\n}\n"], ["cleanLinks", "\nfunction cleanLinks( el ) {\n  <cleanHtmlContent>\n  var i;\n  for ( i = 0; i < el.length; i++ ) {\n    el[ i ].innerHTML = cleanPath( el[ i ].innerHTML );\n  }\n  </cleanHtmlContent>\n}\n"], ["jxh", "\nfunction jxh(obj, indentStr = '  ', indentLevel = 0) {\n  <generateHtmlFromObject>\n  let html = '';\n  switch (getType(obj)) {\n      case 'array':\n          for (let item of obj) {\n              html += jxh(item, indentStr, indentLevel);\n          }\n          break;\n      case 'object':\n          for (let tag in obj) {\n              let content = obj[tag];\n              html += routeTags(tag, content, indentStr, indentLevel);\n          }\n          break;\n      default:\n          objTypeError(obj);\n          break;\n  }\n  return html;\n  </generateHtmlFromObject>\n}\n"], ["mapScaling", "\nfunction(scale, centerX, centerY){\n  <calculateBoundingBox>\n  var bbox,\n      itemBbox,\n      newBbox,\n      codes,\n      i;\n\n  if (jvm.$.isArray(scale) || this.regions[scale]) {\n    if (jvm.$.isArray(scale)) {\n      codes = scale;\n    } else {\n      codes = [scale]\n    }\n    for (i = 0; i < codes.length; i++) {\n      if (this.regions[codes[i]]) {\n        itemBbox = this.regions[codes[i]].element.getBBox();\n        if (itemBbox) {\n          if (typeof bbox == 'undefined') {\n            bbox = itemBbox;\n          } else {\n            newBbox = {\n              x: Math.min(bbox.x, itemBbox.x),\n              y: Math.min(bbox.y, itemBbox.y),\n              width: Math.max(bbox.x + bbox.width, itemBbox.x + itemBbox.width) - Math.min(bbox.x, itemBbox.x),\n              height: Math.max(bbox.y + bbox.height, itemBbox.y + itemBbox.height) - Math.min(bbox.y, itemBbox.y)\n            }\n            bbox = newBbox;\n          }\n        }\n      }\n    }\n    </calculateBoundingBox>\n\n    <setMapScale>\n    this.setScale(\n      Math.min(this.width / bbox.width, this.height / bbox.height),\n      - (bbox.x + bbox.width / 2),\n      - (bbox.y + bbox.height / 2),\n      true\n    );\n    </setMapScale>\n  } else {\n    <setScaleDirectly>\n    scale = scale * this.baseScale;\n    this.setScale(scale, - centerX * this.defaultWidth, - centerY * this.defaultHeight, true);\n    </setScaleDirectly>\n  }\n}\n"], ["measureCleanup", "\nfunction() {\n  <prepareModel>\n  const model = L.extend({}, this._resultsModel, { points: this._latlngs });\n  </prepareModel>\n\n  <unlockAndDetachEvents>\n  this._locked = false;\n  L.DomEvent.off(this._container, 'mouseover', this._handleMapMouseOut, this);\n  </unlockAndDetachEvents>\n\n  <clearMeasureAndEventHandlers>\n  this._clearMeasure();\n\n  this._captureMarker\n    .off('mouseout', this._handleMapMouseOut, this)\n    .off('dblclick', this._handleMeasureDoubleClick, this)\n    .off('click', this._handleMeasureClick, this);\n\n  this._map\n    .off('mousemove', this._handleMeasureMove, this)\n    .off('mouseout', this._handleMapMouseOut, this)\n    .off('move', this._centerCaptureMarker, this)\n    .off('resize', this._setCaptureMarkerIcon, this);\n  </clearMeasureAndEventHandlers>\n\n  <removeLayersAndResetState>\n  this._layer.removeLayer(this._measureVertexes).removeLayer(this._captureMarker);\n  this._measureVertexes = null;\n\n  this._updateMeasureNotStarted();\n  this._collapse();\n  </removeLayersAndResetState>\n\n  <fireMeasureFinish>\n  this._map.fire('measurefinish', model, false);\n  </fireMeasureFinish>\n}\n"], ["versionGreaterThan", "\nfunction versionGreaterThan (version1, version2) {\n  <handleEqualOrSpecialCases>\n  if (version1 === version2) return false;\n  if (version1 === -1) return version2;\n  if (version2 === -1) return version1;\n  </handleEqualOrSpecialCases>\n\n  <checkSimpleCase>\n  if (version1.indexOf('.') === -1 && version2.indexOf('.') === -1) {\n    return version1 > version2;\n  }\n  </checkSimpleCase>\n\n  <versionComparisonLogic>\n  var v1 = version1.split('.'),\n      v2 = version2.split('.'),\n      versionLength = (v1.length > v2.length ? v2 : v1).length;\n\n  for (var i = 0; i < versionLength; ++i) {\n    if (parseInt(v1[i], 10) > parseInt(v2[i], 10)) {\n      return true;\n    }\n  }\n  </versionComparisonLogic>\n\n  <handleTrailingVersions>\n  if (i < v1.length) {\n    return true;\n  }\n  </handleTrailingVersions>\n\n  return false;\n}\n"], ["unindent", "\nfunction unindent(string, skipFirstLine) {\n  <setupLineSplitting>\n  var lines     = string.split('\\n'),\n      skipFirst = typeof skipFirstLine !== 'undefined' ? skipFirstLine : true,\n      start     = skipFirst ? 1 : 0;\n  </setupLineSplitting>\n\n  <findSmallestIndentation>\n  var indentation, smallestIndentation = Infinity;\n  for (var i = start, len = lines.length; i < len; ++i) {\n    if (isBlank(lines[i])) {\n      continue;\n    }\n    indentation = getIndentation(lines[i]);\n    if (indentation < smallestIndentation) {\n      smallestIndentation = indentation;\n    }\n  }\n  </findSmallestIndentation>\n\n  <reduceIndentation>\n  var result = [lines[0]]\n    .concat(\n      lines\n        .slice(1)\n        .map(function(line) { return decreaseIndent(line, smallestIndentation); })\n    )\n    .join('\\n');\n  </reduceIndentation>\n\n  return result;\n}\n"], ["customLog", "\nfunction customLog(message) {\n  <prepareMessage>\n  const trimmed = message.trim()\n  const limit = trimmed.indexOf('\\n')\n  </prepareMessage>\n\n  <logOutput>\n  if (limit === -1) {\n    fancyLog(trimmed)\n  } else {\n    const title = trimmed.slice(0, limit).trim()\n    const details = trimmed.slice(limit).trim()\n    fancyLog(`${title}${('\\n' + details).replace(/\\n/g, '\\n  ')}`)\n  }\n  </logOutput>\n}\n"], "```"]