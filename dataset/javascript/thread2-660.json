[["createEventWrapper", "\nfunction (event, delegateId, wrapTarget, container) {\n<checkAncestor>\n    if (aria.utils.Dom.isAncestor(event.relatedTarget, container) === false) </checkAncestor> {\n<wrapAndDirectCall>\n        var eventWrapper = this.__wrapEvent(event, wrapTarget);\n        eventWrapper.type = event.type == \"mouseover\" ? \"mouseenter\" : \"mouseleave\";\n        eventWrapper.setTarget(container);\n        return this.directCall(eventWrapper, delegateId, wrapTarget, container); </wrapAndDirectCall>\n    }\n}\n"], ["parseUrlAndBuildState", "\nfunction (url) {\n<matchState>\n    var result;\n    LIST.some(function (state) {\n        var params = state.pattern.match(url);\n        if (params) {\n            result       = state;\n            state.params = params;\n            return true;\n        }\n    });\n</matchState>\n\n<buildParentHierarchy>\n    if (result) {\n        var state        = result,\n            parent_index = state.name.lastIndexOf('.'), parent_name;\n        while (parent_index !== -1) {\n            parent_name  = state.name.substring(0, parent_index);\n            state.parent = STATES[parent_name];\n            state        = state.parent;\n            parent_index = state.name.lastIndexOf('.');\n        }\n        return result;\n    }\n</buildParentHierarchy>\n}\n"], ["initializeFeatureHashing", "\nfunction FeatureHashing(k) {\n<validateInput>\n    if (k > MAX_SAFE_INTEGER_HEX_LENGTH*4 || k < 1 || k !== (k|0)) { throw new Error(\"Feature vector bit length must be an integer between 1 and \" + (MAX_SAFE_INTEGER_HEX_LENGTH*4) + \"inclusive.\"); }\n</validateInput>\n    length = Math.pow(2, k||18); \n    valueCount = 0;\n\n<addFeatureValue>\n    this.add = add;\n    function add(value) {\n        var hashHex, hashInt, featureNumber;\n        hashHex = crypto.createHash('md5').update(value).digest('hex');\n        hashInt = parseInt(hashHex.slice(hashHex.length - MAX_SAFE_INTEGER_HEX_LENGTH), 16); \n        featureNumber = hashInt % length;\n        if (featureVector[featureNumber] === undefined) { featureVector[featureNumber] = 1; }\n        else { featureVector[featureNumber] += 1; }\n        valueCount += 1;\n    }\n</addFeatureValue>\n\n<featureVectorOperations>\n    this.sparseFeatureVector = function() { return featureVector; }\n    this.sparseLength = function() { return Object.keys(featureVector).length; }\n    this.length = function() { return length; }\n    this.fillRatio = function() { return (length / Object.keys(featureVector).length) || 0; }\n    this.collisions = function() { return valueCount - Object.keys(featureVector).length; }\n    this.collisionRatio = function() { return (valueCount / Object.keys(featureVector).length - 1) || 0; }\n    this.valueCount = function() { return valueCount; }\n</featureVectorOperations>\n}\n"], ["recursiveFlattenArray", "\nfunction flattenArray(array, filter, map, result) {\n<processArrayElements>\n  let index = -1;\n  while (++index < array.length) {\n    const value = array[index];\n    if (Array.isArray(value)) {\n      flattenArray(value, filter, map, result);\n    } else if (filter(value)) {\n      result.push(map(value));\n    }\n  }\n</processArrayElements>\n  return result;\n}\n"], ["stripElementTabIndex", "\nfunction stripElement(element) {\n<updateTabIndex>\n  const tabIndexElementPosition = elementsWithMissingTabIndex.indexOf(element);\n  if (tabIndexElementPosition !== -1) {\n    element.tabIndex = -1;\n    elementsWithMissingTabIndex.splice(tabIndexElementPosition, 1);\n  }\n</updateTabIndex>\n}\n"], ["setupRoutePrefix", "\nfunction(routePrefix)\n{\n<normalizeRoutePrefix>\n\tif(routePrefix==='/')routePrefix='';\n    this.appUrl = routePrefix;\n</normalizeRoutePrefix>\n<bindRouteHandlers>\n\tvar pattern = /^(.*?)\\s(.*?)$/\n\tfor(var routePath in this.routes)\n\t{\n\t\tvar routePathArray = routePath.match(pattern);\n\t\tthis.openbiz.context[routePathArray[1]](routePrefix+routePathArray[2],this.routes[routePath]);\n\t}\n</bindRouteHandlers>\n    return this;\n}\n"], ["verifyConnectionState", "\nfunction checkConnectionState(key, value)\n{\n<throwTypeError>\n  if(typeof value != 'string') {\n    throw SyntaxError(key+' param should be a String, not '+typeof value);\n  }\n</throwTypeError>\n<throwValueError>\n  if(!value.match('DISCONNECTED|CONNECTED')) {\n    throw SyntaxError(key+' param is not one of [DISCONNECTED|CONNECTED] ('+value+')');\n  }\n</throwValueError>\n}\n"], ["setupObservationProxy", "\nfunction(array, options) {\n<defaultOption>\n\t\tif(options.shouldRecordObservation === undefined) {\n\t\t\toptions.shouldRecordObservation = makeObject.shouldRecordObservationOnOwnAndMissingKeys;\n\t\t}\n</defaultOption>\n<initializeMeta>\n\t\tvar meta = {\n\t\t\ttarget: array,\n\t\t\tproxyKeys: options.proxyKeys !== undefined ? options.proxyKeys : Object.create(makeArray.proxyKeys()),\n\t\t\tcomputedKeys: Object.create(null),\n\t\t\toptions: options,\n\t\t\tpreventSideEffects: 0\n\t\t};\n\t\tmeta.proxyKeys[symbols.metaSymbol] = meta;\n</initializeMeta>\n<createProxy>\n\t\tmeta.proxy = new Proxy(array, {\n\t\t\tget: makeObject.get.bind(meta),\n\t\t\tset: makeArray.set.bind(meta),\n\t\t\townKeys: makeObject.ownKeys.bind(meta),\n\t\t\tdeleteProperty: makeObject.deleteProperty.bind(meta),\n\t\t\tmeta: meta\n\t\t});\n</createProxy>\n<bindProxyHandlers>\n\t\tmapBindings.addHandlers(meta.proxy, meta);\n</bindProxyHandlers>\n\t\treturn meta.proxy;\n}\n"], ["registerPlugins", "\nfunction(plugins, pluginBase){\n<handlePluginBase>\n        var _this = this;\n        if (typeof pluginBase === 'string') {\n            _pluginBase = pluginBase;\n        }\n</handlePluginBase>\n<registerEachPlugin>\n        plugins.forEach(function(plugin, index){\n            var name;\n            var path;\n            if (typeof plugin === 'string'){\n                name = plugin;\n            } else {\n                name = plugin.name;\n                path = plugin.path;\n            }\n            _this.register(name, plugin);\n        });\n</registerEachPlugin>\n}\n"], ["generateFrameIconMarkup", "\nfunction (cfg, cssPrefix, position) {\n<checkFrameIconPosition>\n    var stateObject = cfg.stateObject;\n    var frameIconVPos = stateObject.frameIconVPos;\n    if (stateObject.frameIcon && frameIconVPos == position) </checkFrameIconPosition> {\n        return '<span class=\"' + cssPrefix + 'frameIcon\"></span>';\n    }\n    return \"\";\n}\n"], "```"]