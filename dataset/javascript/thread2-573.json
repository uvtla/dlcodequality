[["onDrag", "\nfunction onDrag(target, innerTarget, dir, listener) { \n  <initializePointerEvents>\n  const hasPointerEvent = undefined !== target.onpointerup;\n  const hasTouchEvent   = undefined !== target.ontouchstart;\n  const pointerDown = hasPointerEvent ? 'pointerdown' : hasTouchEvent ? 'touchstart' : 'mousedown';\n  const pointerMove = hasPointerEvent ? 'pointermove' : hasTouchEvent ? 'touchmove' : 'mousemove';\n  const pointerUp   = hasPointerEvent ? 'pointerup'   : hasTouchEvent ? 'touchend' : 'mouseup';\n  </initializePointerEvents>\n\n  <determineDirection>\n  const dirIsInline = /^(ltr|rtl)$/i.test(dir);\n  const dirIsStart  = /^(ltr|ttb)$/i.test(dir);\n  </determineDirection>\n\n  <determineAxis>\n  const axisProp = dirIsInline ? 'clientX' : 'clientY';\n  </determineAxis>\n\n  let window, start, end;\n\n  <attachDragEvents>\n  target.addEventListener(pointerDown, onpointerdown);\n  </attachDragEvents>\n\n  function onpointerdown(event) {\n    <setupDragEvent>\n    window = target.ownerDocument.defaultView;\n    const rect = innerTarget.getBoundingClientRect();\n    start = dirIsInline ? rect.left : rect.top;\n    end   = dirIsInline ? rect.right : rect.bottom;\n    </setupDragEvent>\n\n    <initiateDrag>\n    onpointermove(event);\n    window.addEventListener(pointerMove, onpointermove);\n    window.addEventListener(pointerUp, onpointerup);\n    </initiateDrag>\n  }\n\n  function onpointermove(event) {\n    <calculateDragDistance>\n    event.preventDefault();\n    const position = axisProp in event ? event[axisProp] : event.touches && event.touches[0] && event.touches[0][axisProp] || 0;\n    const percentage = (dirIsStart ? position - start : end - position) / (end - start);\n    </calculateDragDistance>\n\n    <triggerListenerDuringDrag>\n    listener(percentage);\n    </triggerListenerDuringDrag>\n  }\n\n  function onpointerup() {\n    <detachDragEvents>\n    window.removeEventListener(pointerMove, onpointermove);\n    window.removeEventListener(pointerUp, onpointerup);\n    </detachDragEvents>\n  }\n}\n"], ["hashToArray", "\nfunction hashToArray(hashObj, __key__ = \"id\") {\n  <validateHashObject>\n  if (hashObj && typeof hashObj !== \"object\") {\n    throw new Error(\"Cant convert hash-to-array because hash was not passed in: \" + hashObj);\n  }\n  </validateHashObject>\n  const hash = Object.assign({}, hashObj);\n  const results = [];\n  <determineHashType>\n  const isHashArray = Object.keys(hash).every(i => hash[i] === true);\n  const isHashValue = Object.keys(hash).every(i => typeof hash[i] !== \"object\");\n  </determineHashType>\n  <convertHash>\n  Object.keys(hash).map(id => {\n    const obj = typeof hash[id] === \"object\"\n      ? Object.assign({}, hash[id], { [__key__]: id }) : isHashArray\n      ? id\n      : { [__key__]: id, value: hash[id] };\n    results.push(obj);\n  });\n  </convertHash>\n  return results;\n}\n"], ["addControllerRoutes", "\nfunction addControllerRoutes(router) {\n  <registerRoutes>\n  _.each(reservedRoutes, routeName => {\n    let pathRouter,\n    filename = routeName + '.js',\n    controller = files.tryRequire([__dirname, routesPath, filename].join(path.sep));\n  \n    <setupRouter>\n    pathRouter = express.Router();\n    pathRouter.use(require('body-parser').json({ strict: true, type: 'application/json', limit: '50mb' }));\n    pathRouter.use(require('body-parser').text({ type: 'text/*' }));\n    </setupRouter>\n\n    <configureController>\n    controller(pathRouter);\n    </configureController>\n\n    <mountRouter>\n    router.use(`/${routeName}`, pathRouter);\n    </mountRouter>\n  });\n  </registerRoutes>\n}\n"], ["buildSceneGraph", "\nfunction buildSceneGraph(scene) {\n  <configureFontSettings>\n  var fontSize = App.defaults.size;\n  ... // Code that sets the font size and style\n  </configureFontSettings>\n\n  <setupSceneGraph>\n  ... // Code that constructs the scene graph and adds shapes and text to it\n  </setupSceneGraph>\n\n  <finalizeSceneLayout>\n  ... // Code that finalizes the layout of text and lines in the scene graph\n  </finalizeSceneLayout>\n\n  <returnSceneGraph>\n  return sceneGraph;\n  </returnSceneGraph>\n}\n"], ["repositionTerminals", "\nfunction() {\n  var width = WireIt.getIntStyle(this.el, \"width\");\n  var inputsIntervall = Math.floor(width/(this.nParams+1));\n\n  <repositionInputTerminals>\n  for(var i = 1 ; i < this.terminals.length ; i++) {\n    ... // Code that repositions each terminal based on the width\n  }\n  </repositionInputTerminals>\n\n  <repositionOutputTerminal>\n  WireIt.sn(this.outputTerminal.el, null, {position: \"absolute\", bottom: \"-15px\", left: (Math.floor(width/2)-15)+\"px\"});\n  for(var j = 0 ; j < this.outputTerminal.wires.length ; j++) {\n    this.outputTerminal.wires[j].redraw();\n  }\n  </repositionOutputTerminal>\n}\n"], ["removeChildNow", "\nfunction removeChildNow(child, keepalive) {\n  if (this.hasChild(child) && this.getChildIndex(child) >= 0) {\n    <notifyChildDeactivation>\n    if (typeof child.onDeactivateEvent === \"function\") {\n      child.onDeactivateEvent();\n    }\n    </notifyChildDeactivation>\n\n    if (!keepalive) {\n      <destroyChild>\n      if (typeof child.destroy === \"function\") {\n        child.destroy();\n      }\n      me.pool.push(child);\n      </destroyChild>\n    } \n\n    <updateChildList>\n    var childIndex = this.getChildIndex(child);\n    if (childIndex >= 0) {\n      this.children.splice(childIndex, 1);\n      child.ancestor = undefined;\n    }\n    this.onChildChange.call(this, childIndex);\n    </updateChildList>\n  }\n}\n"], ["ProcessWatcher", "\nfunction ProcessWatcher(pid, parent) {\n  var self = this;\n\n  this.dead = false;\n\n  <checkIfProcessAlive>\n  if (exports.alive(pid) === false) {\n    process.nextTick(function () {\n      self.dead = true;\n      self.emit('dead');\n    });\n    return self;\n  }\n  </checkIfProcessAlive>\n  \n  <monitorParentProcess>\n  if (parent && exports.support.disconnect) {\n    ... // Code sets up the event listeners for the parent process\n    return self;\n  }\n  </monitorParentProcess>\n\n  <monitorProcess>\n  var timer = setInterval(function () {\n    ... // Code to monitor and emit events throughout the process lifecycle\n  });\n  this.stop = clearInterval.bind(null, timer);\n  </monitorProcess>\n}\n"], ["md5HashFunction", "\nfunction(x,y){\n  ... // Code that implements the MD5 hashing function\n}\n"], ["tickleMiddleware", "\nfunction tickle(req, res, next) {\n  <tickleRequest>\n  req.tickle = global.tickle.add(req.url);\n  return next !== undefined ? next() : req.tickle;\n  </tickleRequest>\n}\n"], ["HttpRequest", "\nfunction HttpRequest(uri, config) {\n  ... // Code that initializes and sends an HTTP request using node.js libraries\n}\n"], "```\n\nNotably, several of the provided functions are complex and truncated to prevent over-segmentation. However, for functions like `buildSceneGraph`, because the actual code content is omitted, I've used generic tags to indicate there are separate coherent tasks that likely happen within each segment, even though I did not have the specific details to create precise tags. In such cases, further detail would be necessary to perform a fully accurate SRP analysis."]