[["functionEventOn", "\nfunction(name, callback, context) {\n  <eventApiCheck>\n  if (!eventsApi(this, 'on', name, [callback, context]) || !callback) return this;\n  </eventApiCheck>\n  <initializeEventsObject>\n  this._events || (this._events = {});\n  </initializeEventsObject>\n  <registerCallback>\n  var events = this._events[name] || (this._events[name] = []);\n  events.push({callback: callback, context: context, ctx: context || this});\n  </registerCallback>\n  return this;\n}\n"], ["functionInitModelRead", "\nfunction initModelRead (args) {\n  <basicConfiguration>\n  var controller = this;\n  var model = this.model;\n  if (!model.columnName('id')) {\n      return;\n  }\n  args = requireValidOptionalObject(args);\n  args.read = requireValidOptionalObject(args.read);\n  var queryArgs = requireValidOptionalObject(args.read.query);\n  </basicConfiguration>\n\n  <defaultQuerySetup>\n  if (!defined(queryArgs.with)) {\n      queryArgs.with = {};\n      _.each(model.relations, (relation, relationName) => {\n          queryArgs.with[relationName] = {\n              limit: 20,\n          }\n      });\n  }\n  if (queryArgs.with === false) {\n      delete queryArgs.with;\n  }\n  var role = args.defaultRole || 'all';\n  var forms = args.read && args.read.forms;\n  </defaultQuerySetup>\n\n  <inputSetup>\n  var input = {\n      current: 'query.current',\n      deleted: 'query.deleted',\n      id: 'params.id',\n  };\n  </inputSetup>\n\n  <linksSetup>\n  var links;\n  if (Array.isArray(args.read.links)) {\n      links = _.cloneDeep(args.read.links);\n  }\n  else if (Array.isArray(args.links)) {\n      links = _.cloneDeep(args.links);\n  }\n  else {\n      links = [];\n  }\n  </linksSetup>\n\n  <registerPath>\n  if (!this.paths['/:id']) {\n      this.paths['/:id'] = {};\n  }\n  this.paths['/:id'].get = [\n      {\n          before: function (args) {\n              return beforeRead(controller, args, forms, queryArgs);\n          },\n          input: input,\n          method: function (args) {\n              return read(controller, args, links);\n          },\n          methodName: 'read',\n          role: role,\n          template: 'instance',\n      },\n  ];\n  </registerPath>\n}\n"], ["functionLayoutRecalc", "\nfunction () {\n  <layoutComparisonSetup>\n  var self = this, rect = self._layoutRect, lastRect = self._lastRect;\n  if (!lastRect || lastRect.w != rect.w || lastRect.h != rect.h) {\n  </layoutComparisonSetup>\n    <performLayoutRecalc>\n    self._layout.recalc(self);\n    rect = self.layoutRect();\n    self._lastRect = { x: rect.x, y: rect.y, w: rect.w, h: rect.h };\n    </performLayoutRecalc>\n    return true;\n  }\n}\n"], ["functionFromShape", "\nfunction fromShape(obj, propType, options=null) {\n  <validateShape>\n  const declaration = propType[SHAPE];\n  if (!(declaration instanceof Declaration)) {\n    throw new Error('fromShape called with a non-shape property type');\n  }\n  const shape = declaration.shape;\n  </validateShape>\n\n  <createShapeInstance>\n  const instance = {};\n  const checker = {};\n  Object.keys(shape).forEach(key => {\n    <handleReshape>\n    const type = shape[key];\n    if (type[SHAPE] instanceof Reshape) {\n      addReshape(instance, key);\n      return;\n    }\n    </handleReshape>\n    <copyValues>\n    let value = obj[key];\n    if (value === undefined) {\n      return;\n    }\n    if (type[SHAPE] instanceof Declaration) {\n      instance[key] = fromShape(value, type);\n      return;\n    }\n    if (checker.toString.call(value) === '[object Function]') {\n      value = value.bind(obj);\n    }\n    instance[key] = value;\n    </copyValues>\n  });\n  </createShapeInstance>\n\n  <handleOptions>\n  options = options || {};\n  if (options.mutable) {\n    return instance;\n  }\n  return deepFreeze(instance);\n  </handleOptions>\n}\n"], ["functionDebounceParenHighlight", "\nfunction() {\n  <clearPreviousTimeout>\n  if (this.parenEvent) this.parent.clearTimeout(this.parenEvent);\n  </clearPreviousTimeout>\n  <setDebounce>\n  var self = this;\n  this.parenEvent = this.parent.setTimeout(function(){self.highlightParens();}, 300);\n  </setDebounce>\n}\n"], ["functionSortTextLoaded", "\nfunction () {\n  <prepareSortParameters>\n  var array = ariaUtilsObject.keys(this.__textLoaded);\n  var prefixes = this.__prefixes;\n  var prefixLength = this.__PREFIX.length;\n  </prepareSortParameters>\n\n  <comparatorDefinition>\n  var comparator = function (first, second) {\n      var firstIndex = prefixes[first]\n              ? parseInt(prefixes[first].substring(prefixLength), 10)\n              : Number.MAX_VALUE;\n      var secondIndex = prefixes[second]\n              ? parseInt(prefixes[second].substring(prefixLength), 10)\n              : Number.MAX_VALUE;\n      if (firstIndex === secondIndex) {\n          return 0;\n      }\n      return firstIndex > secondIndex ? 1 : -1;\n  };\n  </comparatorDefinition>\n\n  <performSort>\n  var sorted = array.sort(comparator);\n  </performSort>\n  \n  <cleanup>\n  prefixes = null;\n  prefixLength = null;\n  </cleanup>\n  \n  return sorted;\n}\n"], ["functionLoadSync", "\nfunction (path, encoding) {\n  <synchronousFetchRequest>\n  var xhr = new XMLHttpRequest();\n  xhr.open('GET', path, false);\n  xhr.send();\n  </synchronousFetchRequest>\n  return xhr.responseText;\n}\n"], ["functionAddressToKey", "\nfunction addressToKey(address) {\n  <keyFormation>\n  const protocol = \"http\";\n  const host = iputil.addrToHostname(iputil.normalize(address.address));\n  return `${protocol}://${host}`;\n  </keyFormation>\n}\n"], ["functionTestCharConversion", "\nfunction (successCallback, errorCallback, args) {\n  <logEntry>\n  winble.logger.logApiEntry(\"testCharConversion\");\n  </logEntry>\n  <arraySetup>\n  var array = new Uint8Array(1);\n  array[0] = args[0] ? args[0] : 0;\n  </arraySetup>\n  <invokeSuccessCallback>\n  successCallback(array);\n  </invokeSuccessCallback>\n  <logExit>\n  winble.logger.logApiExit(\"testCharConversion\");\n  </logExit>\n}\n"], ["functionGenerateClasses", "\nfunction GENERATE_CLASSES(classes, parent) {\n  return <aggregateClasses>\n  _.reduce(classes, function(memo, classSpec, className) {\n    return memo\n      + <generateClassSnippet>\n      GENERATE_CLASS(className, classSpec.description, parent, classSpec.parent)\n      </generateClassSnippet>\n      + <generateMethodsSnippet>\n      _.reduce(classSpec.methods, function(memo, methodSpec, methodName) {\n        return memo += GENERATE_METHOD(methodName, methodSpec, className);\n      }, '')\n      </generateMethodsSnippet>\n      + <generateVariablesSnippet>\n      _.reduce(classSpec.variables, function(memo, variableSpec, variableName) {\n        return memo += GENERATE_VAR(variableName, variableSpec, className);\n      }, '')\n      </generateVariablesSnippet>\n      + <generateEnumsSnippet>\n      _.reduce(classSpec.enums, function(memo, enumSpec, enumName) {\n        return memo += GENERATE_ENUM(enumName, enumSpec, className);\n      }, '');\n  }, '');\n  </aggregateClasses>;\n}\n"], "```"]