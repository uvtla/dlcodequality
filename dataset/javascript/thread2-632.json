[["setEnumerable", "\nfunction setEnumerable(ctx, props, state) {\n    if (state === void 0) { state = false; }\n    props = chek_1.split(props);\n    var obj = {};\n    props.forEach(function (p) {\n        obj[p] = {\n            writable: true,\n            enumerable: state\n        };\n    });\n    Object.defineProperties(ctx, obj);\n}\n"], ["writeEntities", "\nfunction writeEntities(subFolder) {\n  for (let i = 0, entityNames = Object.keys(configuration.entities); i < entityNames.length; i++) {\n    <createFilePath>\n    const filePath = path.join(subFolder, toFilePath(entityNames[i]));\n    </createFilePath>\n    <updateAndWriteEntity>\n    const entity = updateChangelogDate(filePath, configuration.entities[entityNames[i]]);\n    fs.writeFileSync(filePath, JSON.stringify(entity, null, 4));\n    </updateAndWriteEntity>\n  }\n}\n"], ["getRelationship", "\nfunction getRelationship(payload, resource, key) {\n  var relationships = resource.relationships && resource.relationships[key];\n  if (!relationships || !relationships.data) {\n    return;\n  }\n  return !Array.isArray(relationships.data)\n    ? <getSingleRelationship>getIncluded(payload, relationships.data.type, relationships.data.id)</getSingleRelationship>\n    : <getMultipleRelationships>relationships.data.map(function (relationship) {\n        return getIncluded(payload, relationship.type, relationship.id);\n      }).filter(function(entity) { return entity; })</getMultipleRelationships>\n}\n"], ["processData", "\nfunction (tree, data) {\n      \n      <processOutput>\n      var output = this.process(tree, data)\n      </processOutput>\n      <debuggingBlock>\n      if (this.debugging) {\n        this.plugins.debug.process([], {\n          includedTemplates: this.includedTemplates,\n          assignedVars: data\n        })\n      }\n      </debuggingBlock>\n      <clearData>\n      this.clear()\n      </clearData>\n\n      return {\n        output: output.tpl,\n        smarty: output.smarty\n      }\n}\n"], ["retrieveSource", "\nfunction (len) {\n            var result = '';\n            if (len) {\n                result = this.source.substr(this.position, len);\n            } else {\n                result = this.source.substr(this.position);\n            }\n            return result;\n}\n"], ["webSQLStorage", "\nfunction(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\texports.__esModule = true;\n\t(function () {\n\t    'use strict';\n\n\t    \n\t    var globalObject = this;\n\t    var openDatabase = this.openDatabase;\n\n\t    <initializeStorage>\n\t    \n\t    if (!openDatabase) {\n\t        return;\n\t    }\n\t    </initializeStorage>\n\n\t    \n\t    \n\t    <_initStorage>\n\t    function _initStorage(options) {\n\t        var self = this;\n\t        var dbInfo = {\n\t            db: null\n\t        };\n\n\t        \n\t        if (options) {\n\t            <copyOptions>\n\t            for (var i in options) {\n\t                dbInfo[i] = typeof options[i] !== 'string' ? options[i].toString() : options[i];\n\t            }\n\t            </copyOptions>\n\t        }\n\n\t        <createDBInfoPromise>\n\t        var dbInfoPromise = new Promise(function (resolve, reject) {\n\t            \n\t            \n\t            <openDatabaseConnection>\n\t            try {\n\t                dbInfo.db = openDatabase(dbInfo.name, String(dbInfo.version), dbInfo.description, dbInfo.size);\n\t            } catch (e) {\n\t                return self.setDriver(self.LOCALSTORAGE).then(function () {\n\t                    return self._initStorage(options);\n\t                }).then(resolve)['catch'](reject);\n\t            }\n\t            </openDatabaseConnection>\n\n\t            \n\t            <initializeStore>\n\t            dbInfo.db.transaction(function (t) {\n\t                t.executeSql('CREATE TABLE IF NOT EXISTS ' + dbInfo.storeName + ' (id INTEGER PRIMARY KEY, key unique, value)', [], function () {\n\t                    self._dbInfo = dbInfo;\n\t                    resolve();\n\t                }, function (t, error) {\n\t                    reject(error);\n\t                });\n\t            });\n\t            </initializeStore>\n\t        });\n\t        </createDBInfoPromise>\n\n\t        <loadSerializer>\n\t        return new Promise(function (resolve, reject) {\n\t            resolve(__webpack_require__(3));\n\t        }).then(function (lib) {\n\t            dbInfo.serializer = lib;\n\t            return dbInfoPromise;\n\t        });\n\t        </loadSerializer>\n\t    }\n\t    </_initStorage>\n\n\t    \n\t    <getItem_function>\n\t    function getItem(key, callback) {\n\t        \n\t    }\n\t    </getItem_function>\n\t    \n\t    <iterate_function>\n\t    function iterate(iterator, callback) {\n\t        \n\t    }\n\t    </iterate_function>\n\n\t    \n\t    <setItem_function>\n\t    function setItem(key, value, callback) {\n\t        \n\t    }\n\t    </setItem_function>\n\n\t    \n\t    <removeItem_function>\n\t    function removeItem(key, callback) {\n\t        \n\t    }\n\t    </removeItem_function>\n\n\t    \n\t    \n\t    <clear_function>\n\t    function clear(callback) {\n\t        \n\t    }\n\t    </clear_function>\n\n\t    \n\t    \n\t    <length_function>\n\t    function length(callback) {\n\t        \n\t    }\n\t    </length_function>\n\n\t    \n\t    \n\t    \n\t    \n\t    \n\t    \n\t    \n\t    <key_function>\n\t    function key(n, callback) {\n\t        \n\t    }\n\t    </key_function>\n\n\t    <keys_function>\n\t    function keys(callback) {\n\t        \n\t    }\n\t    </keys_function>\n\n\t    <executeCallback_function>\n\t    function executeCallback(promise, callback) {\n\t        \n\t    }\n\t    </executeCallback_function>\n\n\t    <webSQLStorage_definition>\n\t    var webSQLStorage = {\n\t        _driver: 'webSQLStorage',\n\t        _initStorage: _initStorage,\n\t        iterate: iterate,\n\t        getItem: getItem,\n\t        setItem: setItem,\n\t        removeItem: removeItem,\n\t        clear: clear,\n\t        length: length,\n\t        key: key,\n\t        keys: keys\n\t    };\n\t    </webSQLStorage_definition>\n\n\t    exports['default'] = webSQLStorage;\n\t}).call(typeof window !== 'undefined' ? window : self);\n\tmodule.exports = exports['default'];\n }\n"], ["parseBiop", "\nfunction() {\n    gobbleSpaces();\n    var biop, to_check = expr.substr(index, max_binop_len), tc_len = to_check.length;\n    while(tc_len > 0) {\n        \n        \n        \n        \n        if(binary_ops.hasOwnProperty(to_check) && (\n            !isIdentifierStart(exprICode(index)) ||\n            (index+to_check.length< expr.length && !isIdentifierPart(exprICode(index+to_check.length)))\n        )) {\n            index += tc_len;\n            return to_check;\n        }\n        to_check = to_check.substr(0, --tc_len);\n    }\n    return false;\n}\n"], ["validDateTime", "\nfunction validDateTime(data)\n{\n    \n    \n    \n    <getDom_function>\n    var getDom = function(month, year) {\n        var domTable = [ 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 ];\n\n        if(month == 2) {\n            if((year % 4 == 0) && ((year % 100 != 0) || (year % 400 == 0))) {\n                domTable[month-1] = 29;\n            }\n        }\n\n        return(domTable[month-1]);\n    };\n    </getDom_function>\n\n    <validateDateTime>\n    var matchDateRegEx = /^([0-9]{4})-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])T([01][0-9]|2[0-3]):([0-4][0-9]|5[0-9]):([0-5][0-9]|60)(\\.[0-9]+)?(Z|([+-][01][0-9]|2[0-3]):([0-4][0-9]|5[0-9]))$/;\n\n    try {\n        var m = matchDateRegEx.exec(data);\n        if(!m) { throw 'failed to match regex'; }\n        var year   = +m[1];     \n        var month  = +m[2];     \n        var day    = +m[3];     \n        if(day > getDom(month, year)) { throw 'invalid number of days for month'; }\n        var hour   = +m[4];     \n        var minute = +m[5];     \n        var second = +m[6];     \n        var msec   = +m[7];     \n        var tzHour = +m[8];     \n        var tzMin  = +m[9];     \n\n        return true;\n    }\n    catch(e) {\n        return false;\n    }\n    </validateDateTime>\n}\n"], ["initSASS", "\nfunction initSASS() {\n  <buildSassMap>\n  var sassMap = build.engine.sass.map;\n  </buildSassMap>\n  <sassOptions>\n  var opt = {\n    src: build.sourceDir,\n    \n    force: true,\n    \n    response: false,\n    \n    sourceMap: sassMap.enabled,\n    sourceMapEmbed: sassMap.inline\n  };\n  </sassOptions>\n  \n  <configureSassMiddleware>\n  var sassOpt = lodash.assign({ indentedSyntax: true }, opt);\n  app.use(sassMw(sassOpt));\n  </configureSassMiddleware>\n  \n  <configureScssMiddleware>\n  var scssOpt = lodash.assign({ indentedSyntax: false }, opt);\n  app.use(sassMw(scssOpt));\n  </configureScssMiddleware>\n}\n"], ["updatePermission", "\nasync function updatePermission (permissionModel, roleId, resourceType, resourceName, updateFn) {\n  <resourceTypeCheck>\n  stateMachinesOnlyForNow(resourceType)\n  </resourceTypeCheck>\n\n  <retrieveGrants>\n  const grants = await getGrantsFor(\n    permissionModel,\n    roleId,\n    resourceName\n  )\n  </retrieveGrants>\n\n  <reviseGrants>\n  const revisedGrants = updateFn(grants)\n  if (revisedGrants === false) return\n  </reviseGrants>\n\n  <setGrants>\n  await setGrantsFor(\n    permissionModel,\n    roleId,\n    resourceName,\n    revisedGrants\n  )\n  </setGrants>\n}\n"], "```"]