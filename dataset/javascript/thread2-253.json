[["unnamedFunction1", "\nfunction(x,y) {\n\n   if(typeof this.mouseInState === undefined) {\n      this.mouseInState = false;\n   }\n\n   <handleWireInteraction>\n   if( this.wireDrawnAt(x,y) ) {\n      if(!this.mouseInState) {\n         this.mouseInState=true;\n         this.onWireIn(x,y);\n      }\n      \n      this.onWireMove(x,y);\n   }\n   else {\n      if(this.mouseInState) {\n         this.mouseInState=false;\n         this.onWireOut(x,y);\n      }\n   }\n   </handleWireInteraction>\n   \n}\n"], ["unnamedFunction2", "\nfunction (evt, callback) {\n   <validateEvent>\n   if (!evt || !_.isObject(evt)) {\n      var err = new Error('Please pass a valid event!');\n      debug(err);\n      throw err;\n   }\n   </validateEvent>\n\n   var self = this;\n\n   <initializeRevisionGuard>\n   var workWithRevisionGuard = false;\n   if (\n      this.revisionGuard &&\n      !!this.definitions.event.revision && dotty.exists(evt, this.definitions.event.revision) &&\n      !!this.definitions.event.aggregateId && dotty.exists(evt, this.definitions.event.aggregateId)\n   ) {\n      workWithRevisionGuard = true;\n   }\n\n   if (dotty.get(evt, this.definitions.event.name) === this.options.commandRejectedEventName) {\n      workWithRevisionGuard = false;\n   }\n   </initializeRevisionGuard>\n\n   if (!workWithRevisionGuard) {\n      return this.dispatch(evt, callback);\n   }\n\n   <revisionGuardProcess>\n   this.revisionGuard.guard(evt, function (err, done) {\n      if (err) {\n         debug(err);\n         if (callback) {\n            callback([err]);\n         }\n         return;\n      }\n\n      self.dispatch(evt, function (errs, cmds, sagaModels) {\n         if (errs) {\n            debug(errs);\n            if (callback) {\n               callback(errs, cmds, sagaModels);\n            }\n            return;\n         }\n\n         done(function (err) {\n            if (err) {\n               if (!errs) {\n                  errs = [err];\n               } else if (_.isArray(errs)) {\n                  errs.unshift(err);\n               }\n               debug(err);\n            }\n\n            if (callback) {\n               callback(errs, cmds, sagaModels);\n            }\n         });\n      });\n\n   });\n   </revisionGuardProcess>\n}\n"], ["isCounterAfter", "\nfunction isCounterAfter(counter, currentStateCounter) {\n   <calculateDifference>\n   const diff = counter - currentStateCounter\n   </calculateDifference>\n\n   <determineWhetherCounterIsAfter>\n   return diff > 0 || (diff < 0 && Math.abs(diff) > MAX_SAFE_INTEGER / 2)\n   </determineWhetherCounterIsAfter>\n}\n"], ["classify", "\nfunction classify(str) {\n    <transformString>\n    return str\n        .split('.')\n        .map(part => capitalize(camelize(part)))\n        .join('.');\n    </transformString>\n}\n"], ["flipIfOrConditional", "\nfunction flipIfOrConditional(path) {\n   const { node } = path;\n   <flipNegationIfNotLogicalExpression>\n   if (!path.get(\"test\").isLogicalExpression()) {\n     flipNegation(node);\n     return;\n   }\n   </flipNegationIfNotLogicalExpression>\n\n   <flipLogicalTestAndSwapBranches>\n   if (flipExpressions.shouldFlip(node.test)) {\n     node.test = flipExpressions.flip(node.test);\n     [node.alternate, node.consequent] = [\n       node.consequent,\n       node.alternate\n     ];\n   }\n   </flipLogicalTestAndSwapBranches>\n}\n"], ["changeSkin", "\nfunction changeSkin(cls) {\n   <removeExistingSkins>\n   $.each(mySkins, function (i) {\n       $('body').removeClass(mySkins[i])\n   })\n   </removeExistingSkins>\n\n   <addNewSkinAndStorePreference>\n   $('body').addClass(cls)\n   store('skin', cls)\n   return false\n   </addNewSkinAndStorePreference>\n}\n"], ["resolveObject", "\nfunction resolveObject(arg) {\n  var resolvedObject = {};\n  <resolveObjectKeyValues>\n  return Object.keys(arg)\n      .reduce(function(soFar, key) {\n        return soFar\n            .then(resolveItem.bind(null, arg[key]))\n            .then(function(value) {\n              resolvedObject[key] = value;\n            });\n      }, Promise.resolve())\n      .then(function() {\n        return resolvedObject;\n      });\n  </resolveObjectKeyValues>\n}\n"], ["dotProduct", "\nfunction dotProduct(v) {\n   <calculateDotProduct>\n   return this._x * v.x + this._y * v.y + this._z * (v.z || 1);\n   </calculateDotProduct>\n}\n"], ["getDisplayName", "\nfunction getDisplayName(node) {\n   <findDisplayNameProperty>\n   const property = find(\n     node.arguments[0].properties,\n     _node => _node.key.name === 'displayName',\n   );\n   return property && property.value.value;\n   </findDisplayNameProperty>\n}\n"], ["unnamedFunction3", "\nfunction (msgctxt, msgid) {\n   <retrieveMessageOrFallback>\n   var message;\n   if (this.$i18n.getLocaleMessage(this.$i18n.activeLocale)[msgctxt]) {\n      message = this.$i18n.getLocaleMessage(this.$i18n.activeLocale)[msgctxt][msgid];\n   }\n\n   if (!message) {\n      return msgid\n   } else {\n      return message.msgstr[0] || message.msgid\n   }\n   </retrieveMessageOrFallback>\n}\n"], "```\n\nEach of the above functions has been annotated with tags representing their separate responsibilities. When the functions had more than one responsibility or had complex logic, those sections were tagged accordingly. Some simple mathematical operations or direct assignments were not considered separate responsibilities and thus not annotated with their own tags."]