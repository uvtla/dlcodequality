[["listNames", "\nfunction listNames(theContacts) {\n  var s = '';\n  for (var contact in theContacts) {\n    if (s != '') { s = s + \", \" };\n    s = s + contact;\n  }\n  return s;\n}\n"], ["parse_messages", "\nfunction parse_messages (parser_type, str) {\n  var parser = new HTTPParser(parser_type);\n  var buffer = new Buffer(str, 'utf-8');\n  <parse_messages_initialization>\n  var output = [];\n\n  parser.onMessageBegin = function() {\n    output.push({\n      versionMajor: undefined,\n      versionMinor: undefined,\n      method: undefined,\n      uri: undefined,\n      statusCode: undefined,\n      headers: {},\n      body: \"\",\n      complete: false\n    });\n    parser.field = null;\n    parser.value = null;\n  };\n  </parse_messages_initialization>\n\n  <parse_messages_callbacks>\n  \n  parser.onURL = function(b, start, len) { /* ... */ };\n  parser.onHeaderField = function(b, start, len) { /* ... */ };\n  parser.onHeaderValue = function(b, start, len) { /* ... */ };\n  parser.onHeadersComplete = function(info) { /* ... */ };\n  parser.onBody = function(b, start, len) { /* ... */ };\n  parser.onMessageComplete = function() { /* ... */ };\n  \n  </parse_messages_callbacks>\n\n  parser.execute(buffer, 0, buffer.length);\n  \n  <parse_messages_filtering>\n  var complete_output = output.filter(function (o) {\n    return o.complete;\n  });\n  </parse_messages_filtering>\n  \n  return complete_output;\n}\n"], ["buildCSVsForSingleMergedForm", "\nfunction buildCSVsForSingleMergedForm(formSubmissionModel, params, cb) {\n  <form_export_initialization>\n  var formId = params.formId; /* ... */\n  var fileName = date + \"-\" + formId + \"-\" + (formName.split(' ').join('_'));\n  cb = _.once(cb);\n  params.statusUpdaterFunction(/* ... */);\n  var exportProgressInterval = setInterval(function() { /* ... */ }, 1000);\n  var fullSubmissionCSVString = csvHeaders.generateCSVHeaders(/* ... */);\n  </form_export_initialization>\n\n  <form_export_data_processing>\n  var submissionQueryStream = formSubmissionModel.find(/* ... */).stream();\n  submissionQueryStream.on('data', function addSubmissionToCSV(submissionJSON) { /* ... */ })\n  .on('error', function(err) { /* ... */ })\n  .on('close', function() { /* ... */ });\n  </form_export_data_processing>\n}\n"], ["makeChainedCallback", "\nfunction makeChainedCallback(i, fns, results, cb) {\n  return function(err, result) {\n    if (err) {\n      return cb(err);\n    }\n    results[i] = result;\n    if (fns[i + 1]) {\n      return fns[i + 1](makeChainedCallback(i + 1, fns, results, cb));\n    } else {\n      return cb(null, results);\n    }\n  };\n}\n"], ["anonymous_function_with_confirm", "\nfunction(data) {\n  <fetch_with_confirmation>\n  var confirm = messages[\"OverrideContentRemoteTrackingBr\"] + \"\\n\\n\" + messages['Are you sure?'];\n  fetchCallback(data, true, confirm).then(function() {\n    dispatchModelEventOn({type: \"modelChanged\", action: \"fetch\", item: data.items});\n  });\n  </fetch_with_confirmation>\n}\n"], ["relatedObject_association", "\nfunction(instance, relatedObject, options) {\n  var opts = _.defaults({}, options, { follow: true, attrs: true });\n  var inverse = opts.follow && relatedObject && relatedObject[this.inverse + 'Relation'];\n  if (opts.attrs) {\n    \n    instance.setAttribute(this.foreignKeyAttr, relatedObject[this.primaryKey]);\n  }\n\n  this._setRelated(instance, relatedObject);\n\n  if (inverse) {\n    inverse.associate(relatedObject, instance, _.extend({}, options, { follow: false, }));\n  }\n}\n"], ["getHelpManData", "\nfunction getHelpManData(commandData, context) {\n  \n  commandData.command.params = commandData.command.params.filter(function(param) { /* ... */ });\n  addParamGroups(commandData.command);\n  commandData.subcommands.forEach(addParamGroups);\n\n  return {\n    l10n: l10n.propertyLookup, /* ... */,\n    getTypeDescription: function(param) { /* ... */ },\n    getSynopsis: function(param) { /* ... */ },\n    command: commandData.command,\n    subcommands: commandData.subcommands\n  };\n}\n"], ["formatStackInternal", "\nfunction formatStackInternal(error, message, stackFormat) {\n  <stack_formatting_initialization>\n  var format = stackFormat || DEFAULT_FORMAT;\n  var enhanced = enhanceError(error);\n  var stack = message;\n  </stack_formatting_initialization>\n\n  <stack_formatting_processing>\n  for (var i1 = 0; enhanced.stackLines && i1 < enhanced.stackLines.length; i1 += 1) { /* ... */ }\n  </stack_formatting_processing>\n  \n  enhanced.stack = stack;\n  return enhanced;\n}\n"], ["flushCacheTimed", "\nfunction flushCacheTimed(stream, onFlush) {\n  var nextWrite = lastWrite + settings.time;\n  var now = Date.now();\n  if (now >= nextWrite) {\n    flushCache(stream);\n    onFlush();\n    return;\n  }\n  \n  timeout = setTimeout(function () {\n    flushCache(stream);\n    onFlush();\n  }, nextWrite - now);\n}\n"], ["jsonInit_block_definition", "\nfunction() {\n  this.jsonInit({\n    \"id\": \"event_whenbroadcastreceived\", /* ... */\n    \"extensions\": [\"colours_event\", \"shape_hat\"]\n  });\n}\n"], "```"]