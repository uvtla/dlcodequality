[["Text", "\nfunction Text(annotations) {\n  this._parent = annotations;\n  this._root = undefined;\n  this._children = {};\n  this._config = {\n    'width': 200,\n    'height': 20,\n    'position': {\n      'left': 0,\n      'top': 0\n    },\n    'text': ''\n  };\n\n  if (annotations._config.hasOwnProperty('text')) {\n    annotations._config.text.push(this._config);\n  } else {\n    annotations._config.text = [this._config];\n  }\n  if (annotations._children.hasOwnProperty('text')) {\n    annotations._children.text.push(this);\n  } else {\n    annotations._children.text = [this];\n  }\n\n  return this;\n}\n"], ["readFiles", "\nfunction readFiles() {\n  var self = this;\n  \n  async.waterfall([\n    function(callback) {\n      storeFileContent.init(self.options.testSrc, callback);\n    },\n    function(data, callback) {\n      self.testFiles = data;\n      storeFileContent.init(self.options.viewSrc, callback);\n    },\n    function(data, callback) {\n      self.viewFiles = data;\n      callback(null, 'success');\n    }\n  ], function() {\n    findElementSelectors.call(self);\n  });\n}\n"], ["getTarget", "\nfunction getTarget(index, headersChain, getHeader) {\n  if (index === 0) {\n    return Promise.resolve({ bits: MAX_BITS, target: MAX_TARGET })\n  }\n\n  return Promise.try(function() {\n    var firstHeader = getHeader((index - 1) * 2016)\n    var lastHeader = _.find(headersChain, { height: index * 2016 - 1 })\n    if (lastHeader === undefined) {\n      lastHeader = getHeader(index * 2016 - 1)\n    }\n    return Promise.all([firstHeader, lastHeader])\n  })\n  .spread(function(firstHeader, lastHeader) {\n    var nTargetTimestamp = 14 * 24 * 60 * 60;\n    var nActualTimestamp = lastHeader.time - firstHeader.time;\n    // ...\n    // Further calculations to determine 'target'\n    // ...\n    return { bits: c + MM * i, target: target.toHex() }\n  })\n}\n"], ["function_EarliestTime", "\nfunction(earliestTime, callback) {\n  if (!callback && utils.isFunction(earliestTime)) {\n    callback = earliestTime;\n    earliestTime = undefined;\n  }\n\n  var query = \"| datamodel \\\"\" + this.dataModel.name + \"\\\" \" + this.name + \" search | tscollect\";\n  var args = earliestTime ? { earliest_time: earliestTime } : {};\n\n  this.dataModel.service.search(query, args, callback);\n}\n"], ["normalizeValidator", "\nfunction normalizeValidator(validator) {\n  if (validator.validate !== undefined) {\n    return function(c) { return validator.validate(c); };\n  }\n  else {\n    return validator;\n  }\n}\n"], ["makeLookAt", "\nfunction makeLookAt(ex, ey, ez, cx, cy, cz, ux, uy, uz) {\n  var eye = $V([ex, ey, ez]);\n  var center = $V([cx, cy, cz]);\n  var up = $V([ux, uy, uz]);\n  \n  var z = eye.subtract(center).toUnitVector();\n  var x = up.cross(z).toUnitVector();\n  var y = z.cross(x).toUnitVector();\n  \n  var m = $M([ [x.e(1), x.e(2), x.e(3), 0],\n               [y.e(1), y.e(2), y.e(3), 0],\n               [z.e(1), z.e(2), z.e(3), 0],\n               [0, 0, 0, 1] ]);\n  \n  var t = $M([ [1, 0, 0, -ex],\n               [0, 1, 0, -ey],\n               [0, 0, 1, -ez],\n               [0, 0, 0, 1] ]);\n  return m.x(t);\n}\n"], ["function_d", "\nfunction(d) {\n  \"use strict\";\n\n  if (typeof d === \"number\") {\n    d = new Date(d);\n  }\n  return new Date(d.getFullYear(), d.getMonth() + 1, 0);\n}\n"], ["fromBoot", "\nfunction fromBoot(options) {\n  var version;\n  var bootPath = Path.resolve(\n    options.directory,\n    'bundle',\n    'programs',\n    'server',\n    'boot.js');\n\n  try {\n    version = Fs.readFileSync(bootPath, 'utf8')\n      .split('\\n')\n      .find((line) => line.indexOf('MIN_NODE_VERSION') >= 0)\n      .split(' ')[3]\n      .replace(/[v;']/g, '');\n  } catch (err) {\n    return false;\n  }\n  return version;\n}\n"], ["svgToString", "\nfunction svgToString(filename) {\n  if (!/\\.svg$/i.test(filename)) {\n    return through();\n  }\n\n  return through(function(buf, enc, next) {\n    this.push('module.exports=' + JSON.stringify(buf.toString('utf8')));\n    next();\n  });\n}\n"], ["computeBuffer", "\nfunction computeBuffer() {\n  this._buffer = map.layerPointToLatLng(new L.Point(0, 0)).lat -\n                 map.layerPointToLatLng(new L.Point(this.options.snapDistance, 0)).lat;\n}\n"], "```"]