[["full", "\nfunction full(source) {\n        <generatePermutations>\n        for (var i = 0, item; i < source.length; i++) {\n          item = source.splice(i, 1)[0];\n          seen.push(item);\n\n          if (source.length === 0) permutations.push(seen.slice());\n          full(source);\n\n          source.splice(i, 0, item);\n          seen.pop();\n        }\n        </generatePermutations>\n\n        return permutations;\n      }\n"], ["renameClassName", "\nfunction renameClassName(ast, oldName, newName) {\n  <findClassDeclaration>\n  let defNode = null;\n\n  traverse(ast, {\n    ClassDeclaration(path) {\n      if (path.node.id && path.node.id.name === oldName) {\n        defNode = path.node.id;\n      }\n    }\n  });\n  </findClassDeclaration>\n\n  <renameIdentifier>\n  if (defNode) {\n    return identifier.renameIdentifier(ast, oldName, newName, defNode);\n  }\n  </renameIdentifier>\n  return [];\n}\n"], ["parse_PtgRefErr", "\nfunction parse_PtgRefErr(blob, length, opts) {\n\tvar type = (blob.read_shift(1) >>> 5) & 0x03;\n\tblob.l += 4;\n\tif(opts.biff == 12) blob.l += 2;\n\treturn [type];\n}\n"], ["getScrollParent", "\nfunction getScrollParent(parent, child) {\n  <calculateScrollOffset>\n  let element = child;\n  let scrollTop = 0;\n\n  while (element && element !== parent) {\n    element = element.parentNode;\n    scrollTop += element.scrollTop;\n  }\n  </calculateScrollOffset>\n  return scrollTop;\n}\n"], ["anonymousConfigureEngine", "\nfunction(opt) {\n        <logEngineConfiguration>\n        console.log(\"\\n\\n############ENGINE CONFIGURATION OPTIONS############\\n\");\n        console.dir(opt);\n        console.log(\"\\n####################################################\\n\");\n        </logEngineConfiguration>\n\n        <validateEngineOptions>\n        if (!opt.hasOwnProperty('engine')) throw (\"Please specify a scheduler engine\");\n        if (opt.engine === \"sge\")\n            engine = sgeLib;\n        else if (opt.engine === \"slurm\")\n            engine = slurmLib;\n        else if (opt.engine === \"emulator\") {\n            engine = emulatorLib;\n            emulator = true;\n        }\n        if (opt.engine != \"emulator\") {\n            if (!opt.hasOwnProperty('binaries')) throw \"You must specify scheduler engine binaries\";\n        }\n        </validateEngineOptions>\n\n        <configureEngine>\n        engine.configure(opt.binaries, jobsArray);\n        console.log(\"Engine configured is \" + engine.type());\n        </configureEngine>\n    }\n"], ["detectType", "\nfunction detectType(media, options, src) {\n\tvar mediaFiles = [];\n\tvar i;\n\tvar n;\n\tvar isCanPlay;\n\n\t<populateMediaFiles>\n\tif (options.type) {\n\t\tif (typeof options.type == 'string') {\n\t\t\tmediaFiles.push({\n\t\t\t\ttype: options.type,\n\t\t\t\turl: src\n\t\t\t});\n\t\t} else {\n\t\t\tfor (i = 0; i < options.type.length; i++) {\n\t\t\t\tmediaFiles.push({\n\t\t\t\t\ttype: options.type[i],\n\t\t\t\t\turl: src\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t} else if (src !== null) {\n\t\tmediaFiles.push({\n\t\t\ttype: getType(src, media.getAttribute('type')),\n\t\t\turl: src\n\t\t});\n\t} else {\n\t\tfor (i = 0; i < media.children.length; i++) {\n\t\t\tn = media.children[i];\n\t\t\tif (n.nodeType == 1 && n.tagName.toLowerCase() == 'source') {\n\t\t\t\tsrc = n.getAttribute('src');\n\t\t\t\tmediaFiles.push({\n\t\t\t\t\ttype: getType(src, n.getAttribute('type')),\n\t\t\t\t\turl: src\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}\n\t</populateMediaFiles>\n\n\t<adjustCanPlayTypeFunctionBasedOnEnvironment>\n\tif (zyMedia.features.isBustedAndroid) {\n\t\tmedia.canPlayType = function(type) {\n\t\t\treturn /video\\/(mp4|m4v)/i.test(type) ? 'maybe' : ''\n\t\t};\n\t}\n\tif (zyMedia.features.isChromium) {\n\t\tmedia.canPlayType = function(type) {\n\t\t\treturn /video\\/(webm|ogv|ogg)/i.test(type) ? 'maybe' : ''\n\t\t};\n\t}\n\t</adjustCanPlayTypeFunctionBasedOnEnvironment>\n\n\t<evaluateMediaFilePlayability>\n\tif (zyMedia.features.supportsCanPlayType) {\n\t\tfor (i = 0; i < mediaFiles.length; i++) {\n\t\t\tif (\n\t\t\t\tmediaFiles[i].type == \"video/m3u8\" ||\n\t\t\t\tmedia.canPlayType(mediaFiles[i].type).replace(/no/, '') !== '' ||\n\t\t\t\tmedia.canPlayType(mediaFiles[i].type.replace(/mp3/, 'mpeg')).replace(/no/, '') !== '' ||\n\t\t\t\tmedia.canPlayType(mediaFiles[i].type.replace(/m4a/, 'mp4')).replace(/no/, '') !== '') {\n\t\t\t\tisCanPlay = true;\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\t</evaluateMediaFilePlayability>\n\n\treturn isCanPlay\n}\n"], ["registerHelpers", "\nfunction registerHelpers(helpers) {\n    var s = this;\n\n    <registerEachHelper>\n    var names = Object.keys(helpers || {});\n    for (var i = 0, len = names.length; i < len; i++) {\n      var name = names[i];\n      s.registerHelper(name, helpers[name]);\n    }\n    </registerEachHelper>\n\n    return s;\n  }\n"], ["unnamedInsertScale", "\nfunction (index, scaleId) {\n    scales.splice(index, 0, scale.create(chord.root, scaleId));\n  }\n"], ["getRelative", "\nfunction getRelative(filename) {\n    <parseAndJoinFilePath>\n    var parsed = chek_1.isString(filename) ? getParsed(filename) : filename;\n    return path_1.relative(exports.cwd, path_1.join(parsed.dir, parsed.base || ''));\n    </parseAndJoinFilePath>\n}\n"], ["formatNumber", "\nfunction(nr, dec, decPoint, thousandSep){\n\t\tdecPoint||(decPoint = '.');\n\t\tthousandSep||(thousandSep = ',');\n\t\tdec = isNaN(dec = Math.abs(dec)) ? 2 : dec;\n\t\tvar sign = (nr < 0) ? '-' : '',\n\t\t<calculateFormattedNumber>\n\t\t\ti = parseInt(nr = Math.abs(+nr || 0).toFixed(dec), 10) + '',\n\t\t\tj = (j = i.length) > 3 ? j % 3 : 0;\n\t\treturn sign + (j ? i.substr(0, j) + thousandSep : '') + i.substr(j).replace(/(\\d{3})(?=\\d)/g, '$1' + thousandSep) + (dec ? decPoint + Math.abs(nr - i).toFixed(dec).slice(2) : '');\n\t\t</calculateFormattedNumber>\n\t}\n"], "```"]