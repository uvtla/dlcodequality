[["filterArrayBasedOnCallback", "\nfunction(array, callback, caller) {\n    <declareVariables>\n    var selected = []; \n    </declareVariables>\n    <checkNativeFilterSupport>\n    if (Array.prototype.filter) {\n        selected = array.filter(callback, caller);\n    } else {\n    </checkNativeFilterSupport>\n        <validateInputs>\n        var len = array.length;\n        if (typeof callback != \"function\") {\n            throw new TypeError();\n        }\n        </validateInputs>\n        <filterArrayManually>\n        for(var i=0; i<len; i++) {\n            if (i in array) {\n                var val = array[i];\n                if (callback.call(caller, val, i, array)) {\n                    selected.push(val);\n                }\n            }\n        }\n        </filterArrayManually>        \n    <returnSelected>\n    }\n    return selected;\n}\n</returnSelected>\n"], ["addSound", "\nfunction add(config) {\n    <createSoundObject>\n    const src = file.getSupportedFile(config.src || config.url || config.data || config);\n    const sound = new Sound(Object.assign({}, config || {}, {\n        src,\n        context,\n        destination: bus.gain\n    }));\n    </createSoundObject>\n    <configureSound>\n    sound.isTouchLocked = isTouchLocked;\n    if (config) {\n        sound.id = config.id || config.name || '';\n        sound.loop = !!config.loop;\n        sound.volume = config.volume;\n        sound.effects = config.effects || [];\n    }\n    </configureSound>\n    <addSoundToBus>\n    bus.add(sound);\n    </addSoundToBus>\n    <returnSound>\n    return sound;\n    </returnSound>\n}\n"], ["mkdirpSync", "\nfunction _mkdirpSync (directory, mode) {\n    <validateArguments>\n    if (\"undefined\" === typeof directory) {\n        throw new ReferenceError(\"missing \\\"directory\\\" argument\");\n    }\n    else if (\"string\" !== typeof directory) {\n        throw new TypeError(\"\\\"directory\\\" argument is not a string\");\n    }\n    else if (\"\" === directory.trim()) {\n        throw new Error(\"\\\"directory\\\" argument is empty\");\n    }\n    else if (\"undefined\" !== typeof mode && \"number\" !== typeof mode) {\n        throw new TypeError(\"\\\"mode\\\" argument is not a number\");\n    }\n    </validateArguments>\n    <createDirectoryIfNotExists>\n    else if (!isDirectorySync(directory)) {\n        const SUB_DIRECTORY = dirname(directory);\n        if (!isDirectorySync(SUB_DIRECTORY)) {\n            _mkdirpSync(SUB_DIRECTORY);\n        }\n        mkdirSync(directory, mode ? mode : DEFAULT_OPTION);\n    }\n    </createDirectoryIfNotExists>\n}\n"], ["appendChildToNode", "\nfunction (node) {\n    <createElement>\n    var element = this._createElement(node);\n    </createElement>\n    <setAttributesAndAppendChildren>\n    this._setAttributesTo(element);\n    this._appendChildrenTo(element);\n    </setAttributesAndAppendChildren>\n    <returnNodeWithNewChild>\n    return node.appendChild(element);\n    </returnNodeWithNewChild>\n}\n"], ["enableDatepicker", "\nfunction (target) {\n    <getInstanceAndCheck>\n    var inst = this._getInst(target);\n    if (!inst || !inst.isDisabled) {\n        return FALSE;\n    }\n    </getInstanceAndCheck>\n    <removeClassAndReset>\n    $(\"#sbHolder_\" + inst.uid).removeClass(inst.settings.classHolderDisabled);\n    inst.isDisabled = FALSE;\n    $.data(target, PROP_NAME, inst);\n    </removeClassAndReset>\n}\n"], ["initializeStemmer", "\nfunction() {\n    var stemmer = this;\n    <setStemMethod>\n    stemmer.stem = function(token) {\n        return token;\n    };\n    </setStemMethod>\n    <setTokenizeAndStemMethod>\n    stemmer.tokenizeAndStem = function(text, keepStops) {\n        var stemmedTokens = [];\n        new aggressive_tokenizer_fa().tokenize(text).forEach(function(token) {\n            if(keepStops || stopwords_fa.words.indexOf(token) == -1)\n                stemmedTokens.push(stemmer.stem(token));\n        });\n        return stemmedTokens;\n    };\n    </setTokenizeAndStemMethod>\n    <attachStringPrototypes>\n    stemmer.attach = function() {\n        String.prototype.stem = function() {\n            return stemmer.stem(this);\n        };\n        String.prototype.tokenizeAndStem = function(keepStops) {\n            return stemmer.tokenizeAndStem(this, keepStops);\n        };\n    };\n    </attachStringPrototypes>\n}\n"], ["mergeAssetsWithResolution", "\nfunction mergeAssets (\n  parentVal,\n  childVal,\n  vm,\n  key\n) {\n    <createResObject>\n    var res = Object.create(parentVal || null);\n    </createResObject>\n    <extendWithChildVal>\n    if (childVal) {\n        assertObjectType(key, childVal, vm);\n        return extend(res, childVal)\n    } else {\n        return res\n    }\n    </extendWithChildVal>\n}\n"], ["createParticles", "\nfunction _createParticles(node, count) {\n    <initializeParticlesArray>\n    this._particles = [];\n    </initializeParticlesArray>\n    <createParticleOptions>\n    var options = {\n        size: [this.options.particleSize, this.options.particleSize],\n        properties: {\n            backgroundColor: this.options.color,\n            borderRadius: '50%'\n        }\n    };\n    </createParticleOptions>\n    <addParticlesToNode>\n    for (var i = 0; i < count; i++) {\n        var particle = {\n            surface: new Surface(options),\n            mod: new Modifier({})\n        };\n        this._particles.push(particle);\n        node.add(particle.mod).add(particle.surface);\n    }\n    </addParticlesToNode>\n}\n"], ["initializePromise", "\nfunction Promise(cb, ctx) {\n    <setProperties>\n    this.context = ctx;\n    this.thenChain = [];\n    this.errCb = null;\n    this.noErrorCb = null;\n    </setProperties>\n    <setupCallbackExecution>\n    process.nextTick(function() {\n        cb();\n    });\n    </setupCallbackExecution>\n}\n"], ["getElementNameForTransformation", "\nfunction getElementNameForTransformation( rule, check ) {\n    <determineElementName>\n    if (rule.element)\n        return rule.element;\n    if (check)\n        return check.match(/^([a-z0-9]+)/i)[0];\n    return rule.left.getDefinition().element;\n    </determineElementName>\n}\n"], "```\n\nEach function was annotated within the designated tags for SRP compliance. Tags denote separate distinct responsibilities where they exist."]