[["runLint", "\nfunction runLint(files, config, reporter, bin) {\n  <setDefaultReporter>\n  reporter = reporter || DEFAULT_REPORTER;\n  </setDefaultReporter>\n\n  <configureEslint>\n  const eslintConfig = config ? { configFile: config } : {};\n  const CLIEngine = bin\n    ? require(bin).CLIEngine\n    : runtimeRequire('eslint', __filename).CLIEngine;\n  </configureEslint>\n\n  <runEslintAnalysis>\n  const eslintCLI = new CLIEngine(eslintConfig);\n  const report = eslintCLI.executeOnFiles(files);\n  </runEslintAnalysis>\n\n  <reportAnalysisResults>\n  if (report.errorCount > 0 || report.warningCount > 0) {\n    printLintReportResults(report, reporter);\n    return false;\n  }\n  </reportAnalysisResults>\n\n  return true;\n}\n"], ["polyfillSymbol", "\nfunction polyfillSymbol(name) {\n  <polyfillLogic>\n  if (!Symbol[name])\n    Object.defineProperty(Symbol, name, { value: Symbol(name) });\n  </polyfillLogic>\n}\n"], ["processRouteSampleData", "\nfunction processRouteSampleData(o) {\n  <processBasedOnPacketId>\n  if (parseInt(o.rawDataPacket[0]) === k.OBCIGanglionByteIdUncompressed) {\n    return processUncompressedData(o);\n  } else {\n    return processCompressedData(o);\n  }\n  </processBasedOnPacketId>\n}\n"], ["doaction", "\nfunction doaction(type, data) {\n  <conditionalAscendGlobal>\n  if (gui.hosted) {\n    gui.Action.ascendGlobal(document, type, data);\n  }\n  </conditionalAscendGlobal>\n}\n"], ["createOtpReducer", "\nfunction createOtpReducer(config, initialQuery) {\n  <createQueryWithDefaults>\n  const currentQuery = Object.assign(defaultQuery, initialQuery)\n  let queryModes = currentQuery.mode.split(',')\n  </createQueryWithDefaults>\n\n  <adjustQueryModes>\n  if (queryModes.includes('TRANSIT')) {\n    queryModes = queryModes.filter(m => !isTransit(m))\n    config.modeGroups.forEach(group => {\n      group.modes.forEach(m => {\n        const modeStr = m.mode || m\n        if (transitModes.includes(modeStr)) queryModes.push(modeStr)\n      })\n    })\n    currentQuery.mode = queryModes.join(',')\n  }\n  </adjustQueryModes>\n\n  <handleSingleAccessMode>\n  if (currentQuery.routingType === 'ITINERARY') {\n    queryModes = ensureSingleAccessMode(queryModes)\n  }\n  </handleSingleAccessMode>\n\n  <defineInitialState>\n  const initialState = {\n    config: Object.assign(defaultConfig, config),\n    currentQuery,\n    location: {\n      currentPosition: {\n        error: null,\n        coords: null,\n        fetching: false\n      },\n      sessionSearches: [],\n      nearbyStops: []\n    },\n    searches: {},\n    transitIndex: {\n      stops: {},\n      trips: {}\n    },\n    useRealtime: true,\n    activeSearchId: 0,\n    overlay: {\n      bikeRental: {\n        stations: []\n      },\n      transit: {\n        stops: []\n      }\n    },\n    ui: {\n      mobileScreen: MobileScreens.WELCOME_SCREEN\n    }\n  }\n  </defineInitialState>\n\n  return (state = initialState, action) => { ... }\n}\n"], ["transformFunction", "\nfunction transformFunction(node) {\n  <handleNodeProperties>\n  var nameNode = node.nodes[0];\n  var paramsNodes = node.nodes[1] ? node.nodes[1].nodes : [];\n  node.name = nameNode.value;\n  if (node.name) {\n    node.item('functions')[node.name] = node;\n  }\n  node.params = [];\n  node.paramIndex = {};\n  </handleNodeProperties>\n\n  <manageParamTags>\n  var paramTags = node.paramTags;\n  if (node.paramTags === undefined && node.parent &&\n      node.parent.type === 'assign' && node.parent.paramTags) {\n    paramTags = node.parent.paramTags;\n  }\n  node.item('paramTags', paramTags);\n  </manageParamTags>\n\n  <copyTags>\n  if (node.copyTags) {\n    var tagSource = node.item('functions')[node.copyTags];\n    if (tagSource) {\n      if (!node.description && tagSource.description) {\n        node.description = tagSource.description;\n      }\n      if (!paramTags && tagSource.item('paramTags')) {\n        paramTags = tagSource.item('paramTags');\n      }\n    }\n  }\n  </copyTags>\n\n  <processParams>\n  paramsNodes.forEach(function (paramNode, i) {\n    var param = {\n      name: paramNode.value\n    };\n    node.paramIndex[param.name] = i;\n    if (paramTags) {\n      if (paramTags[param.name]) {\n        var tagValue = paramTags[param.name];\n        Object.keys(tagValue).forEach(function (key, i) {\n          if (key !== 'name') {\n            param[key] = tagValue[key];\n          }\n        });\n      }\n    }\n    node.params.push(param);\n  });\n  </processParams>\n}\n"], ["extract", "\nfunction extract(pattern, part) {\n  <validateArguments>\n  if (!pattern) throw new Error('missing pattern');\n  if (!part) return STOP;\n  </validateArguments>\n\n  <handleTermMatching>\n  let term = matchTerm(pattern);\n  if (term) {\n    ... // Omitted for brevity\n  }\n  </handleTermMatching>\n\n  <processArrayPatterns>\n  if (Array.isArray(pattern)) {\n    ... // Omitted for brevity\n  }\n  </processArrayPatterns>\n\n  <mergeResults>\n  let allResult = {};\n  ... // Omitted for brevity\n  return allResult;\n  </mergeResults>\n}\n"], ["autoboot", "\nfunction autoboot(containerElement) {\n  <validateElement>\n  check(containerElement, 'containerElement').is.anInstanceOf(Element)();\n  </validateElement>\n\n  <bootIfAutoboot>\n  if (containerElement.classList.contains(Common.AUTOBOOT)) {\n    boot(containerElement);\n  }\n  </bootIfAutoboot>\n}\n"], ["functionUnnamed-1", "\nfunction(obj) {\n  <clearSingletons>\n  for (var a in this.__singletons) {\n    if (a in obj) {\n      Object.defineProperty(obj, a, {\n        configurable: true,\n        value: undefined\n      });\n    }\n  }\n  </clearSingletons>\n\n  return this;\n}\n"], ["functionUnnamed-2", "\nfunction(sId, sTitle, sDescription, aSelections) {\n  <createRulesToExport>\n  var oRulesToExport = {\n    id: sId,\n    title: sTitle,\n    description: sDescription,\n    dateExported: (new Date()).toISOString(),\n    version: \"1.0\",\n    selections: aSelections\n  };\n  </createRulesToExport>\n\n  <exportRules>\n  var oExportObject = JSON.stringify(oRulesToExport);\n  File.save(oExportObject, constants.RULE_SELECTION_EXPORT_FILE_NAME, 'json', 'text/plain');\n  </exportRules>\n}\n"], "```"]