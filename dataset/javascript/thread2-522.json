[["parsePath", "\nfunction parsePath(path) {\n        var lastSlash = path.lastIndexOf(\"/\"), folder, rest;\n        if (lastSlash === path.length - 1) {\n            lastSlash = path.slice(0, path.length - 1).lastIndexOf(\"/\");\n        }\n        if (lastSlash >= 0) {\n            rest = \" - \" + (lastSlash ? path.slice(0, lastSlash) : \"/\");\n            folder = path.slice(lastSlash + 1);\n        } else {\n            rest = \"/\";\n            folder = path;\n        }\n\n        return {path: path, folder: folder, rest: rest};\n    }\n"], ["parse_children", "\nfunction parse_children(lines, parent_node_names)\n{\n\t<filter_lines_for_parsing>\n\tlines = filter_lines_for_parsing(lines)\n\t</filter_lines_for_parsing>\n\n\t<check_lines_empty>\n\tif (lines.length === 0)\n\t{\n\t\treturn {}\n\t}\n\t</check_lines_empty>\n\n\t<process_lines>\n\treturn split_lines_by_child_nodes(lines).map(function(lines)\n\t{\n\t\t<get_declaration_line>\n\t\tconst declaration_line = lines.shift()\n\t\t</get_declaration_line>\n\n\t\t<check_declaration_indentation>\n\t\tif (declaration_line.tabs !== 0)\n\t\t{\n\t\t\tthrow new Error(`Excessive indentation (${declaration_line.tabs} more \"tabs\" than needed) at line ${declaration_line.index}: \"${declaration_line.original_line}\"`)\n\t\t}\n\t\t</check_declaration_indentation>\n\n\t\t<split_declaration>\n\t\tconst declaration = declaration_line.line\n\t\tconst names = declaration.split(',').map(name => name.trim())\n\t\t</split_declaration>\n\n\t\t<validate_names>\n\t\tvalidate_child_style_class_types(parent_node_names, names)\n\t\t</validate_names>\n\n\t\t<parse_style_class>\n\t\tconst style_json = parse_style_class(lines, names)\n\t\t</parse_style_class>\n\n\t\t<generate_nodes>\n\t\treturn names.map(function(node_declaration)\n\t\t{\n\t\t\tconst { name, is_a_modifier } = parse_node_name(node_declaration)\n\t\t\tconst json = extend({}, style_json)\n\n\t\t\tif (is_a_modifier)\n\t\t\t{\n\t\t\t\tjson._is_a_modifier = true\n\t\t\t}\n\n\t\t\treturn { name, json }\n\t\t})\n\t\t</generate_nodes>\n\t})\n\t<concat_child_arrays>\n\t.reduce(function(array, child_array)\n\t{\n\t\treturn array.concat(child_array);\n\t}, \n\t[])\n\t</concat_child_arrays>\n\t<build_nodes_object>\n\t.reduce(function(nodes, node)\n\t{\n\t\tif (nodes[node.name])\n\t\t{\n\t\t\textend(nodes[node.name], node.json)\n\t\t}\n\t\telse\n\t\t{\n\t\t\tnodes[node.name] = node.json\n\t\t}\n\t\t\n\t\treturn nodes\n\t}, \n\t{})\n\t</build_nodes_object>\n}\n"], ["attributes", "\nfunction attributes(attrs) {\n  attrs = attrs || {};\n  var ident = attrs.id || '';\n  var classes = attrs.classes || [];\n  var keyvals = [];\n  <parse_keys>\n  Object.keys(attrs).forEach(function (k) {\n    if (k !== 'classes' && k !== 'id') keyvals.push([k,attrs[k]]);\n  });\n  </parse_keys>\n  return [ident, classes, keyvals];\n}\n"], ["pathToRegexp", "\nfunction pathToRegexp(val, keys, options) {\n  return new RegExp(toRegexpSource(val, keys, options), flags(options));\n}\n"], ["anonymous_function_navigation", "\nfunction (sId, bPrevious) {\n  <iterate_buttons>\n\tthis.getButtons().some(function (oButton, iIndex, aArray) {\n\t\tif (sId === oButton.getId()) {\n\t\t\tif (bPrevious) {\n\t\t\t\tthis._setFocusOnPreviousButton(aArray, iIndex);\n\t\t\t} else {\n\t\t\t\tthis._setFocusOnNextButton(aArray, iIndex);\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t}.bind(this));\n  </iterate_buttons>\n}\n"], ["getNodeText", "\nfunction _getNodeText(node) {\n    return node.sourceFile.text.substr(node.start, node.end - node.start);\n}\n"], ["anonymous_function_template_initialization", "\nfunction (out) {\n    out.writeln(\"__$initTemplate: function() {\");\n    out.increaseIndent();\n    if (out.parentClassType == this._classType) {\n        \n        out.writeln(\"if (! this.$\", out.parentClassName, \".__$initTemplate.call(this)) { return false; }\");\n    }\n    <write_block_content>\n    out.write(out.getBlockContent(\"initTemplate\"));\n    </write_block_content>\n    var gv = out.getBlockContent(\"globalVars\");\n    if (gv.length > 0) {\n        out.writeln(\"try {\");\n        out.increaseIndent();\n        <use_global_vars>\n        out.writeln(\"with (this) {\");\n        out.increaseIndent();\n        out.write(gv);\n        </use_global_vars>\n        out.decreaseIndent();\n        out.writeln(\"}\"); \n        out.decreaseIndent();\n        out.writeln(\"} catch (_ex) {\");\n        out.increaseIndent();\n        <log_var_init_error>\n        out.writeln(\"this.$logError(this.EXCEPTION_IN_VARINIT,[this.$classpath],_ex);\");\n        out.writeln(\"return false;\");\n        </log_var_init_error>\n        out.decreaseIndent();\n        out.writeln(\"}\");\n    }\n    out.writeln(\"return true;\");\n    out.decreaseIndent();\n    out.writeln(\"}\");\n}\n"], ["tuple", "\nfunction tuple(name, ...types) {\n  if (name[TYPICAL_TYPE]) {\n    types.unshift(name);\n    name = `Some${types.length}Tuple`;\n  }\n\n  <validate_input_DEV>\n  if (__DEV__) {\n    assert(typeof name === 'string', `tuple()'s name must be a string`);\n    for (const type of types) {\n      assert(type[TYPICAL_TYPE], `tuple()'s type must be a typical type`);\n    }\n  }\n  </validate_input_DEV>\n\n  const api = this;\n\n  <Tuple_constructor>\n  function Tuple(value, context) {\n    if (Context.isRequired(context)) {\n      return Context.with(value, Tuple, context, api);\n    } else if (!context.isArray(value) || value.length !== types.length) {\n      return context.valueIsNotOfType(value, Tuple);\n    }\n\n    return forEachTypedProperty(\n      value,\n      value.keys(),\n      k => types[k],\n      context.validateAndCopy ? [] : void 0,\n      context\n    );\n  }\n  </Tuple_constructor>\n\n  <decorate_Tuple>\n  return decorate(Tuple, name, tuple, ...types);\n  </decorate_Tuple>\n}\n"], ["readJson", "\nfunction readJson(file) {\n  <read_and_parse_json>\n  return when(\n    readText(file),\n    function(result) {\n      try {\n        return JSON.parse(result);\n      } catch (e) {\n        if (e instanceof SyntaxError) {\n          return json5.parse(result);\n        } else {\n          throw e;\n        }\n      }\n    },\n    function(e) {\n      throw e;\n    }\n  );\n  </read_and_parse_json>\n}\n"], ["encodeEmailAddress", "\nfunction encodeEmailAddress(addr) {\n\n        <char2hex>\n        function char2hex(ch) {\n            var hexDigits = '0123456789ABCDEF';\n            var dec = ch.charCodeAt(0);\n            return(hexDigits.charAt(dec>>4) + hexDigits.charAt(dec&15));\n        }\n        </char2hex>\n\n        var encode = [\n            function(ch){return \"&#\"+ch.charCodeAt(0)+\";\";},\n            function(ch){return \"&#x\"+char2hex(ch)+\";\";},\n            function(ch){return ch;}\n        ];\n\n        <prefix_email>\n        addr = \"mailto:\" + addr;\n        </prefix_email>\n\n        <encode_characters>\n        addr = addr.replace(/./g, function(ch) {\n            if (ch == \"@\") {\n                ch = encode[Math.floor(Math.random()*2)](ch);\n            } else if (ch !=\":\") {\n                var r = Math.random();\n                ch =  (r > .9 ? encode[2](ch) : r > .45 ? encode[1](ch) : encode[0](ch));\n            }\n            return ch;\n        });\n        </encode_characters>\n\n        <create_mailto_link>\n        addr = \"<a href=\\\"\" + addr + \"\\\">\" + addr + \"</a>\";\n        addr = addr.replace(/\">.+:/g,\"\\\">\");\n        </create_mailto_link>\n\n        return addr;\n    }\n"], "```"]