[["optimizeFileContents", "\nfunction (fileName, fileContents, outFileName, config, pluginCollector) {\n  config = config || {};\n\n  <processPragma>\n  fileContents = pragma.process(fileName, fileContents, config, 'OnSave', pluginCollector);\n  </processPragma>\n\n  <determineOptimizer>\n  var optFunc, optConfig,\n      parts = (String(config.optimize)).split('.'),\n      optimizerName = parts[0],\n      keepLines = parts[1] === 'keepLines',\n      licenseContents = '';\n\n  if (optimizerName && optimizerName !== 'none') {\n      optFunc = envOptimize[optimizerName] || optimize.optimizers[optimizerName];\n      if (!optFunc) {\n          throw new Error('optimizer with name of \"' +\n                          optimizerName +\n                          '\" not found for this environment');\n      }\n  </determineOptimizer>\n\n  <optimizerConfiguration>\n  optConfig = config[optimizerName] || {};\n  if (config.generateSourceMaps) {\n      optConfig.generateSourceMaps = !!config.generateSourceMaps;\n      optConfig._buildSourceMap = config._buildSourceMap;\n  }\n  </optimizerConfiguration>\n\n  <applyOptimization>\n  try {\n      if (config.preserveLicenseComments) {\n          <extractLicenseComments>\n          try {\n              licenseContents = parse.getLicenseComments(fileName, fileContents);\n          } catch (e) {\n              throw new Error('Cannot parse file: ' + fileName + ' for comments. Skipping it. Error is:\\n' + e.toString());\n          }\n          </extractLicenseComments>\n      }\n      fileContents = licenseContents + optFunc(fileName, fileContents, outFileName, keepLines, optConfig);\n      if (optConfig._buildSourceMap && optConfig._buildSourceMap !== config._buildSourceMap) {\n          config._buildSourceMap = optConfig._buildSourceMap;\n      }\n  } catch (e) {\n      if (config.throwWhen && config.throwWhen.optimize) {\n          throw e;\n      } else {\n          logger.error(e);\n      }\n  }\n  </applyOptimization>\n  } else {\n      <resetSourceMap>\n      if (config._buildSourceMap) {\n          config._buildSourceMap = null;\n      }\n      </resetSourceMap>\n  }\n\n  return fileContents;\n}\n"], ["createNewDialog", "\nfunction createNewDialog() {\n  <collectUserInfo>\n  var usersIds = [];\n  var usersNames = [];\n\n  $('#users_list .users_form.active').each(function(index) {\n    usersIds[index] = $(this).attr('id');\n    usersNames[index] = $(this).text();\n  });\n  </collectUserInfo>\n\n  <prepareDialogCreation>\n  var dialogName;\n  var dialogOccupants;\n  var dialogType;\n\n  if (usersIds.length > 1) {\n    if (usersNames.indexOf(currentUser.login) > -1) {\n      dialogName = usersNames.join(', ');\n    }else{\n      dialogName = currentUser.login + ', ' + usersNames.join(', ');\n    }\n    dialogOccupants = usersIds;\n    dialogType = 2;\n  } else {\n    dialogOccupants = usersIds;\n    dialogType = 3;\n  }\n\n  var params = {\n    type: dialogType,\n    occupants_ids: dialogOccupants,\n    name: dialogName\n  };\n  </prepareDialogCreation>\n\n  <createDialogWithAPI>\n  QB.chat.dialog.create(params, function(err, createdDialog) {\n    if (err) {\n      console.log(err);\n    } else {\n      <onDialogCreated>\n      console.log(\"Dialog \" + createdDialog._id + \" created with users: \" + dialogOccupants);\n\n      var dialogId = createdDialog._id;\n      dialogs[dialogId] = createdDialog;\n\n      currentDialog = createdDialog;\n\n      joinToNewDialogAndShow(createdDialog);\n\n      notifyOccupants(createdDialog.occupants_ids, createdDialog._id, 1);\n\n      triggerDialog(createdDialog._id);\n\n      $('a.users_form').removeClass('active');\n      </onDialogCreated>\n    }\n  });\n  </createDialogWithAPI>\n}\n"], ["cacheMethod", "\nfunction doCacheForMethod (signature) {\n  <validateSignature>\n  signature = getValidSignature(signature)\n  if (!hasMethod(signature.signature)) {\n      return\n  }\n  </validateSignature>\n\n  <retrieveCacheConfig>\n  var method = getMethod(signature.signature)\n  var module = getModule(signature.moduleName)\n  if (!defined(immutable.caches[signature.moduleName])) {\n      return\n  }\n  if (!defined(immutable.caches[signature.moduleName][signature.methodName])) {\n      return\n  }\n  var cache = immutable.caches[signature.moduleName][signature.methodName]\n  </retrieveCacheConfig>\n\n  <applyCaching>\n  module.cache(signature.methodName, cache.cache)\n  cache.cached = true\n  </applyCaching>\n}\n"], ["compareHmac", "\nfunction compareHmac(hmac1, hmac2) {\n  <convertBuffersToStrings>\n  var left = hmac1;\n  if (Buffer.isBuffer(hmac1)) {\n      left = hmac1.toString('base64');\n  }\n  var right = hmac2;\n  if (Buffer.isBuffer(hmac2)) {\n      right = hmac2.toString('base64');\n  }\n  </convertBuffersToStrings>\n  return (left == right);\n}\n"], ["initializeMemcacheStore", "\nfunction MemcacheStore (options) {\n  <configureDefaults>\n  options = options || {};\n  this._host = options.host || '127.0.0.1';\n  this._port = options.port || 11211;\n  this._prefix = options.prefix || '';\n  this._user = options.user || '';\n  this._password = options.password || '';\n  this._pool = options.pool = (options.pool > 1 ? options.pool : 1);\n  this._connectionString = this._user + ':' + this._password + '@' + this._host + ':' + this._port;\n  </configureDefaults>\n\n  <createConnections>\n  this._clients = [];\n  this._clientIndex = -1;\n  for (var i = 0; i < options.pool; i++) {\n    this._clients.push(memjs.Client.create(this._connectionString));\n  }\n  </createConnections>\n\n  return this;\n}\n"], ["encodeString", "\nfunction encode(raw) {\n  if (type(raw) !== \"string\") {\n    return raw;\n  }\n  \n  return raw.replace(/[\"&'<>`]/g, function(match) {\n    return \"&#\" + match.charCodeAt(0) + \";\";\n  });\n}\n"], ["getUsStatesList", "\nfunction getUsStatesList(s) {\n  <handleRequests>\n  switch(s) {\n    <statesTerritoriesAbbreviations>\n    case 'usStatesTerrByAbbrLow':\n    case 'usStatesTerrByAbbr':\n    case 'usTerrByAbbrLow':\n    case 'usTerrByAbbr':\n    case 'usStatesByAbbrLow':\n    case 'usStatesByAbbr':\n      if (!this[s]) {\n        <generateList>\n        this[s] = computeList(s);\n        </generateList>\n      }\n      return this[s];\n    </statesTerritoriesAbbreviations>\n\n    <statesTerritoriesNames>\n    case 'usStatesTerrLow':\n    case 'usStatesTerr':\n    case 'usStatesLow':\n    case 'usStates':\n    case 'usTerrLow':\n    case 'usTerr':\n      if (!this[s]) {\n        <generateList>\n        this[s] = computeList(s);\n        </generateList>\n      }\n      return this[s];\n    </statesTerritoriesNames>\n\n    default:\n      throw new Error('getUsStatesList: unknown request: ' + s);\n  }\n  </handleRequests>\n}\n"], ["parseChord", "\nfunction (chord) {\n  var intervals = [];\n  \n  <defineBaseIntervals>\n  intervals[1] = 'P';\n  intervals[3] = 'M';\n  intervals[5] = 'P';\n  </defineBaseIntervals>\n\n  <modifyIntervalsForChordType>\n  if ((/^(m|dim|\u00f8)/).test(chord)) {\n    intervals[3] = 'm';  \n  }\n  \n  if ((/(dim|\u00f8|[-b]5)/).test(chord)) {\n    intervals[5] = 'dim';  \n  }\n  \n  if ((/^(aug|\\+)/).test(chord) || (/[+#]5/).test(chord)) {\n    intervals[5] = 'aug';  \n  }\n  \n  if ((/no5/).test(chord)) {\n    intervals[5] = '';\n  }\n  \n  else if ((/^[5n]/).test(chord) || (/no3/).test(chord)) {\n    intervals[3] = '';\n  }\n  \n  if ((/(\u00f8|7|9|11|13)/).test(chord)) {\n    intervals[7] = 'm';  \n  }\n  \n  if ((/(M7|M9|M11|M13)/).test(chord)) {\n    intervals[7] = 'M';\n  }\n  \n  if ((/(dim7|dim9|dim11|dim13)/).test(chord)) {\n    intervals[7] = 'dim';\n  }\n  \n  if ((/6/).test(chord)) {\n    intervals[6] = 'M';\n    intervals[7] = '';\n  }\n  \n  if ((/sus2/).test(chord)) {\n    intervals[2] = 'M';\n    intervals[3] = '';\n  }\n  \n  else if ((/sus/).test(chord)) {\n    intervals[4] = 'P';\n    intervals[3] = '';\n  }\n  \n  if ((/9/).test(chord)) {\n    intervals[9] = 'M';  \n  }\n  if ((/[+#]9/).test(chord)) {\n    intervals[9] = '';  \n    intervals[10] = 'm'; \n  }\n  if ((/[-b]9/).test(chord)) {\n    intervals[9] = 'm';  \n  }\n  if ((/add9/).test(chord)) {\n    if (!(/7/).test(chord)) intervals[7] = '';\n  }\n  \n  if ((/[+#]11/).test(chord)) {\n    intervals[11] = 'aug';  \n  }\n  else if ((/[-b]11/).test(chord)) {\n    intervals[11] = 'dim';  \n  }\n  else if ((/add11/).test(chord) || (/\\([^\\)]*11[^\\)]*\\)/).test(chord)) {\n    intervals[11] = 'P';\n    if ((/add11/).test(chord) && !(/7|9/).test(chord)) {\n      intervals[7] = '';\n    }\n  }\n  else if ((/11/).test(chord)) {\n    intervals[11] = 'P';\n    intervals[9] = intervals[9] || 'M';  \n  }\n  \n  if ((/[-b]13/).test(chord)) {\n    intervals[13] = 'm';  \n  }\n  else if ((/add13/).test(chord) || (/\\([^\\)]*13[^\\)]*\\)/).test(chord)) {\n    intervals[13] = 'M';\n    if ((/add13/).test(chord) && !(/7|9|11/).test(chord)) {\n      intervals[7] = '';\n    }\n  }\n  else if ((/13/).test(chord)) {\n    intervals[13] = 'M';\n    intervals[11] = intervals[11] || 'P';\n    intervals[9] = intervals[9] || 'M';\n  }\n  \n  if ((/no9/).test(chord)) {\n    intervals[9] = '';\n  }\n  \n  if ((/no11/).test(chord)) {\n    intervals[11] = '';\n  }\n  </modifyIntervalsForChordType>\n\n  return intervals;\n}\n"], ["applyHelpersToObject", "\nfunction(object, extra_helpers) {\n  object = object || {};\n  this._extra_helpers = extra_helpers;\n  <initializeHelpers>\n  var v = new EJS.Helpers(object, extra_helpers || {});\n  </initializeHelpers>\n  <processTemplate>\n  return this.template.process.call(object, object,v);\n  </processTemplate>\n}\n"], ["sendTransportData", "\nfunction (options) {\n  if (typeof options === 'object') {\n    <formatTransportOptions>\n    options.name = this.prefix + '.' + options.name;\n    </formatTransportOptions>\n    <executeSend>\n    return this.transport.send(options);\n    </executeSend>\n  }  else {\n    throw new Error('Transport options must be an object.');\n  }\n}\n"], "```"]