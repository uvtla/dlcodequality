[["encodeMuLawSamples", "\nfunction encode$2(samples) {\n  let muLawSamples = new Uint8Array(samples.length);\n  for (let i=0; i<samples.length; i++) {\n    muLawSamples[i] = encodeSample$1(samples[i]);\n  }\n  return muLawSamples;\n}\n"], ["GitConstructor", "\nfunction Git(repo, initialBranch) {\n  this._repo = repo\n  this._staged = []\n  this._localBranches = []\n  this._remoteBranches = []\n  this._currentBranch = initialBranch\n  this._commits = []\n}\n"], ["updateHeatmap", "\nfunction(x, y){\n  <validateArguments>\n  if(x < 0 || y < 0)\n    return;\n  </validateArguments>\n\n  var me = this,\n      heatmap = me.get(\"heatmap\"),\n      data = me.get(\"data\");\n\n  <initializeHeatmapData>\n  if(!data[x])\n    data[x] = [];\n\n  if(!data[x][y])\n    data[x][y] = 0;\n  </initializeHeatmapData>\n  \n  data[x][y]+=(arguments.length<3)?1:arguments[2];\n  \n  me.set(\"data\", data);\n  \n  <updateMaxValueAndRedraw>\n  if(me.max < data[x][y]){\n    heatmap.get(\"actx\").clearRect(0,0,heatmap.get(\"width\"),heatmap.get(\"height\"));\n    me.setDataSet({ max: data[x][y], data: data }, true);\n    return;\n  }\n  heatmap.drawAlpha(x, y, data[x][y], true);\n  </updateMaxValueAndRedraw>\n}\n"], ["promiseBasedUserValidation", "\nfunction main (params) {\n  return new Promise((resolve, reject) => {\n    <preValidationDebugging>\n    var debug = typeof params.debug === 'boolean' ? params.debug : false\n\n    if (typeof params !== 'object') {\n      if (debug) console.log('Format ze starej wersji.')\n      \n      reject(new Error('Nieprawid\u0142owy format danych.'))\n      return\n    }\n    </preValidationDebugging>\n\n    <validateParamsAndLogin>\n    if (\n      (typeof params.username === 'string' &&\n        (params.username !== '' && params.username !== ' ')\n      ) &&\n      (\n        (typeof params.password === 'string' &&\n          (params.password !== '' && params.password !== ' ')\n        ) ||\n        (typeof params.hash === 'string' &&\n          (params.hash !== '' && params.hash !== ' ')\n        )\n      )\n    ) {\n      if (debug) console.log('Loguj\u0119...')\n      login(params).then(o => {\n        resolve(new Client(params.username, o.agent, o.id, o.hash))\n      }).catch(e => {\n        reject(e)\n      })\n    } else {\n      reject(new Error('Nieprawid\u0142owy format danych.'))\n    }\n    </validateParamsAndLogin>\n  })\n}\n"], ["getRouteInfo", "\nfunction getRouteInfo(appName, urlRequest, query, lang, user, referrer) {\n\n  <prepareActiveUser>\n  var activeUser = user ? {\n    _id: user._id,\n    name: user.username,\n    role: user.role,\n    user: user\n  } : {};\n  </prepareActiveUser>\n\n  <cacheLookup>\n  var cacheKey = appName + '||' + lang + '||' + urlRequest;\n  var cachedRouteInfo = routeInfoCache[cacheKey];\n  if (!user && cachedRouteInfo) {\n    cachedRouteInfo.query = query;  \n    return cachedRouteInfo;\n  }\n  </cacheLookup>\n\n  <initializeVariablesDetermineAMP>\n  var isAmp = /\\.html$/.test(urlRequest);\n  if (isAmp) {\n    urlRequest = urlRequest.substring(0, urlRequest.length - 5);\n  }\n\n  var url = urlRequest.toLowerCase();\n  var i, route, routeInfo;\n  var routes = getRoutes(appName);\n  </initializeVariablesDetermineAMP>\n  \n  if (routes) {\n    <matchRouteAndConstructRouteInfo>\n    for (i = 0; i < routes.length; i++) {\n      route = routes[i];\n      if (route.urlRegex.test(url)) {\n        routeInfo = _.extend({\n          appName:    appName,\n          referrer:   referrer,\n          lang:       lang,\n          url:        urlRequest,\n          query:      query,\n          activeUser: activeUser,\n          isAmp:      isAmp,\n          tokens:     getTokenValuesFromUrl(route.urlPattern, urlRequest)\n        }, route);\n\n        if (isAmp) {\n          routeInfo.wrapper = 'amp';\n        }\n\n        if (!user) {\n          routeInfoCache[cacheKey] = routeInfo;\n        }\n\n        return routeInfo;\n      }\n    }\n    </matchRouteAndConstructRouteInfo>\n  }\n\n  <throwIfNoValidRoute>\n  throw new Error('404: ' + appName + ' ' + urlRequest + ' is not a valid request');\n  </throwIfNoValidRoute>\n}\n"], ["dynamicFunctionGenerator", "\nfunction (def) {\n  if (def) {\n    var self = this,\n      index,\n      count,\n      tmpDef,\n      defNewKey,\n      sigIndex,\n      signatures;\n\n    <prepareDefinition>\n    if (!(def instanceof Array)) {\n      tmpDef = {};\n      for (index in def) {\n        if (def.hasOwnProperty(index)) {\n          defNewKey = index.replace(/ /g, '');\n          if (defNewKey.indexOf('*') === -1) {\n            tmpDef[defNewKey] = def[index];\n          } else {\n            signatures = this.generateSignaturePermutations(defNewKey);\n            for (sigIndex = 0; sigIndex < signatures.length; sigIndex++) {\n              if (!tmpDef[signatures[sigIndex]]) {\n                tmpDef[signatures[sigIndex]] = def[index];\n              }\n            }\n          }\n        }\n      }\n      def = tmpDef;\n    }\n    </prepareDefinition>\n\n    <invokeFunction>\n    return function () {\n      var arr = [],\n        lookup,\n        type;\n      for (index = 0; index < arguments.length; index++) {\n        type = typeof arguments[index];\n        if (type === 'object' && arguments[index] instanceof Array) {\n          type = 'array';\n        }\n        if (arguments.length === 1 && type === 'undefined') {\n          break;\n        }\n        arr.push(type);\n      }\n\n      lookup = arr.join(',');\n      if (def[lookup]) {\n        return self.callExtend(this, '$main', def, def[lookup], arguments);\n      } else {\n        for (index = arr.length; index >= 0; index--) {\n          lookup = arr.slice(0, index).join(',');\n          if (def[lookup + ',...']) {\n            return self.callExtend(this, '$main', def, def[lookup + ',...'], arguments);\n          }\n        }\n      }\n      throw('Irrelon Overload: Overloaded method does not have a matching signature for the passed arguments: ' + JSON.stringify(arr));\n    };\n    </invokeFunction>\n  }\n\n  return function () {};\n}\n"], ["deserializeFormData", "\nfunction deserialize(formEl, data, options, nodeCallback) {\n  <setupDeserializeEnvironment>\n  var parent = makeElement(formEl),\n      opts = getOptions(options),\n      elements = getElements(parent, opts.skipDisabled, opts.skipReadOnly);\n  if (!isType(data, 'object')) {\n    if (!isType(data, 'string'))\n      return;\n    try { \n      data = JSON.parse(data);\n    } catch (e) {\n      error('Passed string is not a JSON string > ' + data);\n    }\n  }\n  </setupDeserializeEnvironment>\n  for (var i = 0, l = elements.length; i < l; i++) {\n    var el = elements[i], textKey;\n    if (!isInput(el)) {\n      <populateNonInputElements>\n      if (textKey = el.getAttribute(_defaults.attributeText))\n        el.textContent = getObjectValue(textKey, opts.delimiter, data);\n      continue;\n      </populateNonInputElements>\n    }\n    var key = el.name || opts.useIdOnEmptyName && el.id,\n        value = getObjectValue(key, opts.delimiter, data);\n    if (isType(value, 'undefined') || value === null) {\n      <clearUnmatchedInputs>\n      opts.deserializeClean && clearInput(el, opts.triggerChange);\n      continue;\n      </clearUnmatchedInputs>\n    }\n    var mutated = nodeCallback && nodeCallback(el, value);\n    if (!mutated)\n      <setValueToInputs>\n      setValueToInput(el, value, opts.triggerChange);\n      </setValueToInputs>\n  }\n}\n"], ["extractStylesFromXml", "\nfunction parseStyles(content, xml) {\n  if (!content) {\n    return {}\n  }\n  const doc = xml.createDocument(content)\n  \n  <parseNumberFormats>\n  const numFmts = xml.select(doc, null, '\n    .map(parseNumberFormatStyle)\n    .reduce((formats, format) => {\n      formats[format.id] = format\n      return formats\n    }, [])\n  </parseNumberFormats>\n\n  return xml.select(doc, null, '\n    if (xf.hasAttribute('xfId')) {\n      <extendBaseStylesWithCellStyles>\n      return {\n        ...baseStyles[xf.xfId],\n        ...parseCellStyle(xf, numFmts)\n      }\n      </extendBaseStylesWithCellStyles>\n    }\n    <parseCellStyle>\n    return parseCellStyle(xf, numFmts)\n    </parseCellStyle>\n  })\n}\n"], ["simplifyErrorRecoveryCode", "\nfunction removeErrorRecovery (fn) {\n  var parseFn = String(fn);\n  try {\n    var JSONSelect = require(\"JSONSelect\");\n    var Reflect = require(\"reflect\");\n    var ast = Reflect.parse(parseFn);\n\n    <updateASTForErrorHandling>\n    var labeled = JSONSelect.match(':has(:root > .label > .name:val(\"_handle_error\"))', ast);\n    labeled[0].body.consequent.body = [labeled[0].body.consequent.body[0], labeled[0].body.consequent.body[1]];\n    </updateASTForErrorHandling>\n\n    <stringifyAndCleanAST>\n    return Reflect.stringify(ast).replace(/_handle_error:\\s?/,\"\").replace(/\\\\\\\\n/g,\"\\\\n\");\n    </stringifyAndCleanAST>\n  } catch (e) {\n    return parseFn;\n  }\n}\n"], ["addGetterSetterToBindingHandlers", "\nfunction addGetterSetter(bindingHandlersObject) {\n  <defineSetProperty>\n  Object.defineProperties(bindingHandlersObject, {\n    'set': {\n      configurable: true,\n      value: function setBindingHandler(nameOrObject, value) {\n        if (typeof nameOrObject === 'string') {\n          bindingHandlersObject[nameOrObject] = value;\n        } else if (typeof nameOrObject === 'object') {\n          <handleSetForObject>\n          if (value !== undefined) {\n            options.onError(\n              new Error(\"Given extraneous `value` parameter (first param should be a string, but it was an object).\" + nameOrObject));\n          }\n          extend(bindingHandlersObject, nameOrObject);\n          </handleSetForObject>\n        } else {\n          options.onError(\n            new Error(\"Given a bad binding handler type: \" + nameOrObject));\n        }\n      }\n    },\n  </defineSetProperty>\n    <defineGetProperty>\n    'get': {\n      configurable: true,\n      value: function getBindingHandler(name) {\n        <retrieveValue>\n        return bindingHandlersObject[name];\n        </retrieveValue>\n      }\n    }\n  </defineGetProperty>\n  });\n}\n"], "```"]