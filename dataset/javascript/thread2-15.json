[["function", "\nfunction(json) {\n    <argumentHandling>\n    if (arguments.length === 2) {\n        if (!(this instanceof jDoc)) {\n            return new jDoc(arguments[0], arguments[1]);\n        }\n        var list = arguments[0];\n        var index = arguments[1];\n        this._list = list;\n        this._index = index;\n    } else {\n        if (!(this instanceof jDoc)) {\n            return new jDoc(json);\n        }\n        \n        \n        this._list = (json !== null) ? [json] : [];\n        this._index = 0;\n    }\n    </argumentHandling>\n}\n"], ["registerExtension", "\nfunction registerExtension(name, extension, options, mergeConfig) {\n  var params = name;\n\n  <constructParams>\n  if (!isObject(name)) {\n    params = {};\n    params[name] = {\n      extension: extension,\n      options: options\n    };\n  }\n  </constructParams>\n\n  <extensionsIteration>\n  each(params, function (v, name) {\n    if (v) {\n      var _extension = v.extension,\n          _options3 = v.options;\n\n      <updateExtensions>\n      if (_extension) {\n        extensions[name] = _extension;\n      } else if (!mergeConfig) {\n        extensions[name] = v;\n      }\n      </updateExtensions>\n\n      <mergeOrUpdateConfig>\n      if (mergeConfig) {\n        if (!extensionConfig[name]) {\n          extensionConfig[name] = _config();\n        }\n\n        assign(extensionConfig[name], _options3);\n      } else {\n        extensionConfig[name] = _config(_options3);\n      }\n      </mergeOrUpdateConfig>\n    }\n  }, false);\n  </extensionsIteration>\n}\n"], ["angle2String", "\nfunction angle2String (angleObj) {\n    <convertUnits>\n\tlet deg = angleObj.deg;\n\tif (angleObj.unit && angleObj.unit !== \"deg\") {\n\t\t\n\t\tdeg = (deg * angleUnitMap[angleObj.unit] / 360);\n\t}\n    </convertUnits>\n\n    <formatDegrees>\n\t\n\tdeg = parseFloat(deg.toFixed(4));\n\tif (deg === 0) {\n\t\t\n\t\tdeg = \"0\";\n\t} else {\n\t\t\n\t\tdeg += angleObj.unit || \"deg\";\n\t}\n    </formatDegrees>\n\treturn deg;\n}\n"], ["isEqual", "\nfunction isEqual( left , right , like , oneWay ) {\n    <setupRuntime>\n\tvar runtime = {\n\t\tleftStack: [] ,\n\t\trightStack: [] ,\n\t\tlike: !! like ,\n\t\toneWay: !! oneWay\n\t} ;\n    </setupRuntime>\n\n    <executeComparison>\n\treturn isEqual_( runtime , left , right ) ;\n    </executeComparison>\n}\n"], ["oschina", "\nfunction oschina(repo, clone) {\n    <initializeURL>\n\tlet url;\n\n\t\n\tclone = true;\n\n\tif (clone)\n\t\turl = addProtocol(repo.host) + '/' + repo.owner + '/' + repo.name;\n\t\t\n\telse\n\t\turl = addProtocol(repo.host) + '/' + repo.owner + '/' + repo.name + '/repository/archive/' + repo.checkout;\n    </initializeURL>\n\n    <returnResult>\n\treturn {url, clone};\n    </returnResult>\n}\n"], ["getWebpackSizes", "\nasync function getWebpackSizes() {\n  <ensureBuildDirectory>\n  await fse.mkdirp(path.join(__dirname, 'build'));\n  </ensureBuildDirectory>\n\n  <generateStats>\n  const configPath = path.join(__dirname, 'webpack.config.js');\n  const statsPath = path.join(__dirname, 'build', 'stats.json');\n  await exec(`webpack --config ${configPath} --json > ${statsPath}`);\n  </generateStats>\n\n  <processStats>\n  const stats = await fse.readJSON(statsPath);\n  const assets = new Map(stats.assets.map(asset => [asset.name, asset]));\n  </processStats>\n\n  <calculateSizes>\n  return Object.entries(stats.assetsByChunkName).map(([chunkName, assetName]) => {\n    const parsedSize = assets.get(assetName).size;\n    const gzipSize = assets.get(`${assetName}.gz`).size;\n    return [chunkName, { parsed: parsedSize, gzip: gzipSize }];\n  });\n  </calculateSizes>\n}\n"], ["anonymousShaderProgram", "\nfunction (gl) {\n    <shaderSources>\n    var vertexShaderSource = ...,\n        fragmentShaderSource = ...;\n    </shaderSources>\n    \n    <initializeProgram>\n    GpuProgram.call(this, gl, vertexShaderSource, fragmentShaderSource);\n    </initializeProgram>\n\n    <assignShaderAttributes>\n    \n    this.vertexPointLocation = this.attributeLocation(gl, \"vertexPoint\");\n    \n    this.vertexTexCoordLocation = this.attributeLocation(gl, \"vertexTexCoord\");\n    </assignShaderAttributes>\n\n    <assignUniformLocations>\n    \n    this.mvpMatrixLocation = this.uniformLocation(gl, \"mvpMatrix\");\n    \n    this.colorLocation = this.uniformLocation(gl, \"color\");\n    \n    this.modulateColorLocation = this.uniformLocation(gl, \"modulateColor\");\n    \n    this.texSamplerMatrixLocation = this.uniformLocation(gl, \"texSamplerMatrix\");\n    this.texMaskMatrixLocation = this.uniformLocation(gl, \"texMaskMatrix\");\n    this.texSamplerLocation = this.uniformLocation(gl, \"texSampler\");\n    this.opacityLocation = this.uniformLocation(gl, \"opacity\");\n    </assignUniformLocations>\n\n    <overwriteDefaultLocation>\n    \n    this.vertexPointLocation = -1;\n    </overwriteDefaultLocation>\n}\n"], ["init", "\nfunction init(opts) {\n    <initializeDefaults>\n\tif (!opts) opts = {}\n\tvar result = {}\n\tfor (var p in settings) {\n\t\tresult[p] = settings[p]\n\t\tif (opts[p] != null) settings[p] = opts[p]\n\t}\n    </initializeDefaults>\n\treturn result\n}\n"], ["itemsFunction", "\nfunction(items, obj1, obj2, obj3) {\n    <filterUndefinedItems>\n\t\titems = _.reduce(_.filter(_.pairs(items), \n\t\t\tfunction(pair) { \n\t\t\t\treturn typeof pair[1] !== 'undefined';\n\t\t\t}),\n\t\t\tfunction(target, pair) { \n\t\t\t\ttarget[pair[0]] = pair[1];\n\t\t\t\treturn target;\n\t\t\t}, {}) || {};\n    </filterUndefinedItems>\n\n    <extendWithArguments>\n\t\treturn _.extend.apply(null, [items].concat(_.rest(arguments)));\n    </extendWithArguments>\n}\n"], ["_validateLibraryFiles", "\nfunction _validateLibraryFiles(repo, libraryName) {\n    <initialSetup>\n\tconst results = {\n\t\tvalid: true\n\t};\n\n\tconst directory = repo.libraryDirectory(libraryName);\n    </initialSetup>\n\n    <defineRequiredFiles>\n\tconst requiredFiles = {\n\t\t'README.md': /^README/i,\n\t\t'LICENSE': /^LICENSE/i,\n\t};\n    </defineRequiredFiles>\n\n    <mainSourceValidation>\n\treturn _mainSourceName(repo, libraryName)\n\t\t.then((mainSourceName) => {\n\t\t\trequiredFiles['main header'] = new RegExp('src[/\\\\\\\\][A-Za-z0-9][A-Za-z0-9-_\\+]*.h', 'i');\n\t\t})\n    </mainSourceValidation>\n    \n    <filePresenceValidation>\n\t\t.then(() => _libraryFiles(directory))\n\t\t.then((files) => {\n\t\t\tfor (const [requiredFile, filenamePattern] of Object.entries(requiredFiles)) {\n\t\t\t\tif (!files.find((f) => f.match(filenamePattern))) {\n\t\t\t\t\tresults.valid = false;\n\t\t\t\t\tresults.errors = Object.assign({}, results.errors, {\n\t\t\t\t\t\t[requiredFile]: 'is missing'\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!results.valid) {\n\t\t\t\tthrow new ValidationFailed(results);\n\t\t\t}\n\t\t});\n    </filePresenceValidation>\n}\n"], "```"]