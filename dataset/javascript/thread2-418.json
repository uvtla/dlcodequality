[["calculateMissingPosition", "\nfunction calculateMissingPosition(lookedUpVal, domain, sort) {\n  let i = -1;\n  let length = domain.length;\n  let found = domain[length - 1];\n\n  while(++i < length) {\n    let item = domain[i];\n\n    if(sort(lookedUpVal, item) < 0) {\n      found = item;\n      break;\n    }\n  }\n\n  return found;\n}\n"], ["predicateExprHasPositionalSelector", "\nfunction predicateExprHasPositionalSelector(expr, isRecursiveCall) {\n  if (!expr) {\n    return false;\n  }\n  if (!isRecursiveCall && exprReturnsNumberValue(expr)) {\n    <exprReturnsNumberValue>\n    return true;\n    </exprReturnsNumberValue>\n  }\n  if (expr instanceof FunctionCallExpr) {\n    var value = expr.name.value;\n    <checkForPositionalSelector>\n    return (value == 'last' || value == 'position');\n    </checkForPositionalSelector>\n  }\n  if (expr instanceof BinaryExpr) {\n    <recursivePositionalSelectorDetection>\n    return (\n      predicateExprHasPositionalSelector(expr.expr1, true) ||\n      predicateExprHasPositionalSelector(expr.expr2, true));\n    </recursivePositionalSelectorDetection>\n  }\n  return false;\n}\n"], ["unDashHyphen", "\nfunction unDashHyphen (str) {\n  <normalizeString>\n  return str\n    .trim()\n    .toLowerCase()\n    .replace(/[-_\\s]+(.)?/g, function (match, c) {\n      return c ? c.toUpperCase() : \"\";\n    });\n  </normalizeString>\n}\n"], ["anonymousFunction_threadProcess", "\nfunction(threadId, active, callback) {\n  <checkForActiveState>\n  if (active) {\n    <checkForCache>\n    if (hasCache && typeof queueDb == 'object') {\n      <queryWaitQueue>\n      queueDb.waitQ.where('threadId')\n        .equals(threadId)\n        .and(function(item) {\n          return item.owner == parseInt(userInfo.id);\n        })\n        .toArray()\n        .then(function(waitQueueOnCache) {\n          <processWaitQueueData>\n          var uniqueIds = [];\n          // Processing for waitQueueOnCache...\n          // Omitted repeated code for brevity...\n          callback && callback(waitQueueOnCache);\n          </processWaitQueueData>\n        })\n        .catch(function(error) {\n          <handleError>\n          fireEvent('error', {\n            code: error.code,\n            message: error.message,\n            error: error\n          });\n          </handleError>\n        });\n      </queryWaitQueue>\n    }\n    else {\n      <processChatWaitQueue>\n      var uniqueIds = [];\n      // Processing for chatWaitQueue...\n      // Omitted repeated code for brevity...\n      callback && callback([]);\n      </processChatWaitQueue>\n    }\n    </checkForCache>\n  }\n  else {\n    <handleInactiveState>\n    callback && callback([]);\n    </handleInactiveState>\n  }\n  </checkForActiveState>\n}\n"], ["_tripGoesTo", "\nfunction _tripGoesTo(trip, origin, destination) {\n  <checkTripStops>\n  let originFound = false;\n  for ( let i = 0; i < trip.stopTimes.length; i++ ) {\n    if ( !originFound && trip.stopTimes[i].stop.id === origin.id ) {\n      originFound = true;\n    }\n    else if ( originFound ) {\n      if ( trip.stopTimes[i].stop.id === destination.id ) {\n        return true;\n      }\n    }\n  }\n  return false;\n  </checkTripStops>\n}\n"], ["combineProfiles", "\nfunction combineProfiles(profiles, logger){\n  <logBuildingProfile>\n  logger.info('building combined profile');\n  </logBuildingProfile>\n\n  <initializeVariables>\n  var i = profiles.length,\n      x = 0\n      out = {};\n  </initializeVariables>\n\n  <processProfiles>\n  while (x < i) {\n    // Processing individual profile properties...\n    // Omitted repeated code for brevity...\n    x++;\n  }\n  </processProfiles>\n\n  return {type: ['h-card'], properties: out};\n}\n"], ["getParentsSelector", "\nfunction (selector) {\n  <findParentControls>\n  var self = this, ctrl, parents = new Collection();\n  for (ctrl = self.parent(); ctrl; ctrl = ctrl.parent()) {\n    parents.add(ctrl);\n  }\n  </findParentControls>\n\n  <applySelectorFilter>\n  if (selector) {\n    parents = parents.filter(selector);\n  }\n  </applySelectorFilter>\n\n  return parents;\n}\n"], ["PeersConstructor", "\nfunction Peers(options) {\n  <initializeOptions>\n  options = options || {}\n  if (typeof options === \"string\") {\n    options = { id: options }\n  }\n  </initializeOptions>\n\n  <setupPeers>\n  var peers = new ExpiryModel(),\n      interval = options.interval || 5000,\n      timeout = options.timeout || 1000 * 60,\n      heartbeats = {},\n      closed,\n      id,\n      timer;\n  </setupPeers>\n\n  <assignPeersMethods>\n  peers.close = close;\n  peers.join = join;\n  peers.on(\"update\", onupdate);\n  </assignPeersMethods>\n\n  return peers;\n\n  // Rest of the functions have been omitted for brevity.\n  // They each represent different responsibilities within this larger context,\n  // such as handling the heartbeat, and dealing with updates and closing events.\n}\n"], ["resubscribeService", "\nfunction (service, sid, timeout) {\n  <setupResubscription>\n  var self = this;\n  this.service = service;\n  this.sid = sid; \n  this.timeout = timeout; \n  this.timer = setTimeout(function () {\n    self._resubscribe();\n  }, (this.timeout * 1000) - 5000);\n  </setupResubscription>\n}\n"], ["getSchema", "\nfunction getSchema(path) {\n  <splitPath>\n  var parts = path.split('.');\n  var collectionName = parts[0];\n  var fieldName = parts[1];\n  </splitPath>\n\n  <validateSchema>\n  if (parts.length !== 2 || !schemaDefinitions[collectionName] || !schemaDefinitions[collectionName][fieldName]) {\n    <logError>\n    log.error('No schemaDefinitions for : ' + path, null);\n    </logError>\n    return {};\n  }\n  </validateSchema>\n\n  return schemaDefinitions[collectionName][fieldName];\n}\n"], "```"]