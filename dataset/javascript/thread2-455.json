[["groupData", "\nfunction groupData(data, dim) {\n    var groups = {};\n\n    each(data, function (record) {\n      var value = record[dim];\n      if (value === undefined) {\n        <setDefaultY>\n        value = record[dim] = DEFAULT_Y;\n        </setDefaultY>\n      }\n      if (!groups[value]) {\n        <initializeGroup>\n        groups[value] = [];\n        </initializeGroup>\n      }\n      <addToGroup>\n      groups[value].push(record);\n      </addToGroup>\n    });\n\n    return groups;\n}\n"], ["_cmdClose", "\nfunction _cmdClose(clientId) {\n    <getClient>\n    var client = _clients[clientId];\n    if (client) {\n        </getClient>\n        <closeSocket>\n        client.socket.close();\n        </closeSocket>\n        <removeClient>\n        delete _clients[clientId];\n        </removeClient>\n    }\n}\n"], ["interpolate", "\nfunction interpolate (template, data, opts) {\n  <setupInterpolation>\n  var regex,\n      lDel,\n      rDel,\n      delLen,\n      lDelLen,\n      delimiter,\n      \n      regexEscape = /([$\\^\\\\\\/()|?+*\\[\\]{}.\\-])/g\n\n  opts = opts || {}\n\n  delimiter = opts.delimiter || '{}'\n  delLen = delimiter.length\n  lDelLen = Math.ceil(delLen / 2)\n  \n  lDel = delimiter.substr(0, lDelLen).replace(regexEscape, \"\\\\$1\")\n  rDel = delimiter.substr(lDelLen, delLen).replace(regexEscape, \"\\\\$1\") || lDel\n\n  regex = new RegExp(lDel + \"[^\" + lDel + rDel + \"]+\" + rDel, \"g\")\n  </setupInterpolation>\n\n  <replacePlaceholders>\n  return template.replace(regex, function (placeholder) {\n    var key = placeholder.slice(lDelLen, -lDelLen),\n        keyParts = key.split(\".\"),\n        val,\n        i = 0,\n        len = keyParts.length\n\n    if (key in data) {\n      val = data[key]\n    }\n    else {\n      val = data\n      for (; i < len; i++) {\n        if (keyParts[i] in val) {\n          val = val[ keyParts[i] ]\n        } else {\n          return placeholder\n        }\n      }\n    }\n    return val\n  })\n  </replacePlaceholders>\n}\n"], ["getViews", "\nfunction getViews(property, options) {\n    <logActivity>\n    logger.debug('getting views for', property);\n    </logActivity>\n    <listAnalyticsProfiles>\n    return analytics.management.profiles.listAsync({\n        auth: auth,\n        accountId: accountId,\n        webPropertyId: property.id\n    })\n    </listAnalyticsProfiles>\n    <processProfiles>\n    .then((profiles) => {\n        if (options.metagroup !== 'view') {\n            profiles.items = _.where(profiles.items, {name: 'All Web Site Data'});\n        }\n        return _.map(profiles.items, (profile) => {\n            return {\n                webPropertyId: property.id,\n                webProperty: property.name,\n                viewId: profile.id,\n                view: profile.name\n            };\n        });\n    });\n    </processProfiles>\n}\n"], ["timeFormatParsing", "\nfunction (timeFormat) {\n    <parseFormat>\n    var finds = timeFormat.toLowerCase().match(/(h{1,2}|m{1,2}|s{1,2}|l{1}|c{1}|t{1,2}|z|'.*?')/g),\n        orders = {\n            h: -1,\n            m: -1,\n            s: -1,\n            l: -1,\n            c: -1,\n            t: -1,\n            z: -1\n        };\n    </parseFormat>\n    \n    <determineOrder>\n    if (finds) {\n        for (var i = 0; i < finds.length; i++) {\n            if (orders[finds[i].toString().charAt(0)] === -1) {\n                orders[finds[i].toString().charAt(0)] = i + 1;\n            }\n        }\n    }\n    </determineOrder>\n    return orders;\n}\n"], ["parseArguments$3", "\nfunction parseArguments$3(args) {\n    <parseArgs>\n    var first = args[0];\n    var second = args[1];\n\n    return typeof first === 'string' ? { namespace: first, mappings: second } : { namespace: null, mappings: first };\n    </parseArgs>\n}\n"], ["removeFromList", "\nfunction() {\n    <checkList>\n    if ( list ) {\n        </checkList>\n        <removeElements>\n        _each( arguments, function( arg ) {\n            var index;\n            while( ( index = _inArray( arg, list, index ) ) > -1 ) {\n                list.splice( index, 1 );\n                <updateIndexesWhenFiring>\n                if ( firing ) {\n                    if ( index <= firingLength ) {\n                        firingLength--;\n                    }\n                    if ( index <= firingIndex ) {\n                        firingIndex--;\n                    }\n                }\n                </updateIndexesWhenFiring>\n            }\n        });\n        </removeElements>\n    }\n    return this;\n}\n"], ["Frame", "\nfunction Frame(callback, tasks) {\n    <checkReadiness>\n    this.isReady = function() {\n        for (var i=0; i < tasks.length; i++) {\n            if (tasks[i].blocked)\n                return false;\n        }\n        return true;\n    };\n    </checkReadiness>\n    \n    <flushTasks>\n    this.flush = function() {\n        for (var i=0; i < tasks.length; i++)\n            tasks[i].execute();\n        if (callback) callback();\n    };\n    </flushTasks>\n}\n"], ["RequestSigner", "\nfunction RequestSigner(options) {\n  assert.object(options, 'options');\n\n  <setUpAlgorithm>\n  var alg = [];\n  if (options.algorithm !== undefined) {\n    assert.string(options.algorithm, 'options.algorithm');\n    alg = validateAlgorithm(options.algorithm);\n  }\n  this.rs_alg = alg;\n  </setUpAlgorithm>\n\n  <setUpSigning>\n  if (options.sign !== undefined) {\n    assert.func(options.sign, 'options.sign');\n    this.rs_signFunc = options.sign;\n  </setUpSigning>\n  <setUpHmac>\n  } else if (alg[0] === 'hmac' && options.key !== undefined) {\n    assert.string(options.keyId, 'options.keyId');\n    this.rs_keyId = options.keyId;\n\n    if (typeof (options.key) !== 'string' && !Buffer.isBuffer(options.key))\n      throw (new TypeError('options.key for HMAC must be a string or Buffer'));\n\n    this.rs_signer = crypto.createHmac(alg[1].toUpperCase(), options.key);\n    this.rs_signer.sign = function () {\n      var digest = this.digest('base64');\n      return ({\n        hashAlgorithm: alg[1],\n        toString: function () { return (digest); }\n      });\n    };\n  </setUpHmac>\n  <setUpKey>\n  } else if (options.key !== undefined) {\n    var key = options.key;\n    if (typeof (key) === 'string' || Buffer.isBuffer(key))\n      key = sshpk.parsePrivateKey(key);\n\n    assert.ok(sshpk.PrivateKey.isPrivateKey(key, [1, 2]),\n      'options.key must be a sshpk.PrivateKey');\n    this.rs_key = key;\n\n    assert.string(options.keyId, 'options.keyId');\n    this.rs_keyId = options.keyId;\n    \n    if (!PK_ALGOS[key.type]) {\n      throw (new InvalidAlgorithmError(key.type.toUpperCase() + ' type ' +\n        'keys are not supported'));\n    }\n\n    if (alg[0] !== undefined && key.type !== alg[0]) {\n      throw (new InvalidAlgorithmError('options.key must be a ' +\n        alg[0].toUpperCase() + ' key, was given a ' +\n        key.type.toUpperCase() + ' key instead'));\n    }\n\n    this.rs_signer = key.createSign(alg[1]);\n  </setUpKey>\n  <checkSignOrKeyRequirement>\n  } else {\n    throw (new TypeError('options.sign (func) or options.key is required'));\n  }\n  </checkSignOrKeyRequirement>\n\n  <initializeHeadersAndLines>\n  this.rs_headers = [];\n  this.rs_lines = [];\n  </initializeHeadersAndLines>\n}\n"], ["addEvent", "\nfunction addEvent(elem, event, fn) {\n  <addEventListenerSupport>\n  if (elem.addEventListener) {\n    elem.addEventListener(event, fn, false);\n    return fn;\n  } else {\n  </addEventListenerSupport>\n  <attachEventSupport>\n    let fn2 = function() {\n      return(fn.call(elem, window.event));\n    };\n    elem.attachEvent(\"on\" + event, fn2);\n    return fn2;\n  }\n  </attachEventSupport>\n}\n"], ""]