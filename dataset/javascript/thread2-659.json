[["extractBlobData", "\nfunction extractBlobData(blob) {\n  <handleUnsupportedBlobData>\n  switch (true) {\n    case blob.lzma_data !== null:\n      throw new Error('unsupported osmpbf blob data type: lzma_data')\n    case blob.OBSOLETE_bzip2_data !== null:\n      throw new Error('unsupported osmpbf blob data type: OBSOLETE_bzip2_data')\n    case blob.raw === null && blob.zlib_data === null:\n      throw new Error('unsupported osmpbf blob data type: <empty blob>')\n  </handleUnsupportedBlobData>\n\n  <decodeBlobData>\n  switch (true) {\n    case blob.raw !== null:\n      return blob.raw\n    case blob.zlib_data !== null:\n      var blobData = new Buffer(blob.raw_size)\n      inflate(blob.zlib_data.slice(2), blobData)\n      return blobData\n  }\n  </decodeBlobData>\n}\n"], ["_ioStart", "\nfunction _ioStart(id, c) {\n  <triggerEvents>\n  var a = c.arguments;\n  \n  if (a) {\n      Y.fire(E_START, id, a);\n  }\n  else {\n      Y.fire(E_START, id);\n  }\n  \n  if (c.on && c.on.start) {\n      _tE('start', c).fire(id);\n  }\n  </triggerEvents>\n}\n"], ["AnimatedColorSetter", "\nfunction(element, transition_value) {\n  <calculateCurrentValue>\n  var current_value = [\n    Math.floor(this.from[0] + this.delta[0] * transition_value),\n    Math.floor(this.from[1] + this.delta[1] * transition_value),\n    Math.floor(this.from[2] + this.delta[2] * transition_value)\n  ];\n  </calculateCurrentValue>\n\n  <setStyle>\n  Firestorm.Element.setStyle(\n    element,\n    this.property_name,\n    'rgb(' + current_value.join(',') + ')'\n  );\n  </setStyle>\n}\n"], ["arrayJoin", "\nfunction arrayJoin(results, args) {\n  <preparation>\n  var srcDataArray = results,\n      joinCollection = args.joinCollection,\n      joinQuery = args.joinQuery,\n      joinType = args.joinType || 'left',\n      rightKeys = args.rightKeys || [args.rightKey],\n      newKey = args.newKey,\n      callback = args.callback,\n\n      length,\n      i,\n\n      subqueries,\n      keyHashBin = {},\n      accessors = [],\n      joinLookups = [],\n      inQueries = [],\n      leftKeys = args.leftKeys || [args.leftKey];\n\n  rightKeys.forEach(function () {\n      inQueries.push([]);\n  });\n\n  leftKeys.forEach(function (key) {\n      accessors.push(getKeyValueAccessorFromKey(key));\n  });\n\n  length = results.length;\n  </preparation>\n\n  <buildHashTable>\n  for (i = 0; i < length; i += 1) {\n      buildHashTableIndices(keyHashBin, results[i], i, accessors, rightKeys, inQueries, joinLookups, {});\n  }\n\n  buildQueriesFromHashBin(keyHashBin, rightKeys, 0, [], joinLookups, inQueries);\n  </buildHashTable>\n\n  <runJoining>\n  if (!Array.isArray(srcDataArray)) {\n      srcDataArray = [srcDataArray];\n  }\n\n  subqueries = getSubqueries(inQueries, joinLookups, joinQuery, args.pageSize || 25, rightKeys);\n  runSubqueries(subqueries, function (items) {\n      var un;\n      performJoining(srcDataArray, items, {\n          rightKeyPropertyPaths: rightKeys,\n          newKey: newKey,\n          keyHashBin: keyHashBin\n      });\n\n      if (joinType === \"inner\") {\n          removeNonMatchesLeft(srcDataArray, newKey);\n      }\n\n      if (joinStack.length > 0) {\n          arrayJoin(srcDataArray, joinStack.shift());\n      } else {\n          callIfFunction(finalCallback, [un, srcDataArray]);\n      }\n      callIfFunction(callback, [un, srcDataArray]);\n  }, joinCollection);\n  </runJoining>\n}\n"], ["resolveServer", "\nfunction resolveServer(path, options) {\n  <constructServerUrl>\n  if (options === void 0) { options = {}; }\n  var serverUrl = options.serverUrl || init.initOptions.serverUrl;\n  if (path) {\n      if (serverUrl) {\n          path = url.resolve(serverUrl, path);\n      }\n  }\n  else {\n      path = serverUrl;\n  }\n  </constructServerUrl>\n  <finalizePath>\n  return url.resolve(path, '/');\n  </finalizePath>\n}\n"], ["bind", "\nfunction bind(func, obj) {\n  <createBoundFunction>\n  var slice = Array.prototype.slice;\n  var args = slice.call(arguments, 2);\n  return function () {\n      return func.apply(obj, args.concat(slice.call(arguments)));\n  };\n  </createBoundFunction>\n}\n"], ["f_urun_bilgisi", "\nfunction f_urun_bilgisi(_urun, _optsUrun) {\n  <checkForUrun>\n  if (!_urun) {\n      return null;\n  }\n  </checkForUrun>\n\n  <createProductObject>\n  var \n  olusan_urun = schema.f_create_default_object(schema.SCHEMA.URUN);\n  \n  olusan_urun = _.extend(olusan_urun, _urun);\n  </createProductObject>\n\n  <retrieveRelatedData>\n  return result.dbQ.Q.all([\n      _optsUrun.bUreticiKurum ? f_urun_ureticisi(_urun.Id) : {Id: 0},\n      _optsUrun.bArrAnahtarKelimeler ? f_urun_anahtar_tumu(_urun.Id, _tahta_id) : [{Id: 0}]\n  ]).then(function (_ress) {\n      olusan_urun.Uretici = _ress[0];\n      olusan_urun.AnahtarKelimeler = _ress[1];\n      return olusan_urun;\n  });\n  </retrieveRelatedData>\n}\n"], ["parse", "\nfunction parse(template, block, data, callback) {\n  <handleArguments>\n  if (!callback && typeof block === 'object' && typeof data === 'function') {\n    callback = data;\n    data = block;\n    block = null;\n  }\n  if (typeof callback !== 'function') {\n    throw TypeError('Invalid Arguments: callback must be a function');\n  }\n  if (!template) {\n    callback('');\n    return;\n  }\n  </handleArguments>\n\n  <renderTemplate>\n  render(template, data, block).then(\n    output => setTimeout(callback, 0, output),\n    err => console.error(err), \n  );\n  </renderTemplate>\n}\n"], ["applyBindings", "\nfunction(bindingString, data, children, callback, done) {\n  <prepareContainer>\n  container = document.createElement(\"div\");\n  container.setAttribute(\"data-bind\", bindingString);\n  container.innerHTML = children || \"\";\n\n  sandbox.appendChild(container);\n  </prepareContainer>\n\n  <applyKnockoutBindings>\n  ko.cleanNode(sandbox);\n  ko.applyBindings(data, sandbox);\n  </applyKnockoutBindings>\n\n  <postBindingCallback>\n  setTimeout(callback, 50);\n  </postBindingCallback>\n}\n"], ["writeFile", "\nfunction (filepath, content) {\n  <writeContentToFile>\n  try {\n      grunt.file.write(filepath, content);\n      grunt.log.writeln('File \"' + filepath + '\" wrapped and saved.');\n  } catch (err) {\n      grunt.fail.fatal(err);\n  }\n  </writeContentToFile>\n}\n"], "```"]