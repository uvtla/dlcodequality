[["Statement", "\nfunction Statement (attributes) {\n  <assignAttributes>\n  for (var key in attributes) {\n    if (attributes.hasOwnProperty(key)) this[key] = result(attributes[key]);\n  }\n  </assignAttributes>\n\n  <populateTransactions>\n  var transactions = Table.prototype.rowsToArray(this.rows, {\n    processRow: function (row) {\n      return this.createTransaction(weld(this.columns, row));\n    }.bind(this)\n  });\n  this.transactions = new Transactions(transactions, this);\n  </populateTransactions>\n}\n"], ["save_allstate", "\nfunction save_allstate() {\n  var res = {};\n\n  <storeGlkObjects>\n  if (gli_rootwin)\n      res.rootwin = gli_rootwin.disprock;\n\n  if (gli_currentstr)\n      res.currentstr = gli_currentstr.disprock;\n\n  if (gli_timer_interval)\n      res.timer_interval = gli_timer_interval;\n  </storeGlkObjects>\n\n  <serializeWindows>\n  res.windows = [];\n  for (var win = gli_windowlist; win; win = win.next) {\n    // This loop consists of several responsibilities due to the different types of windows\n    // It serializes the state of all windows, adapts according to window type, and stores in res.windows\n  }\n  </serializeWindows>\n\n  <serializeStreams>\n  res.streams = [];\n  for (var str = gli_streamlist; str; str = str.next) {\n    // Similar to windows, this loop serializes streams with differing properties based on type\n  }\n  </serializeStreams>\n\n  <serializeFilerefs>\n  res.filerefs = [];\n  for (var fref = gli_filereflist; fref; fref = fref.next) {\n    // Filerefs are enumerated and serialized, creating an object for each with associated properties\n  }\n  </serializeFilerefs>\n\n  <serializeGlkoteState>\n  res.glkote = GlkOte.save_allstate();\n  </serializeGlkoteState>\n\n  return res;\n}\n"], ["findRequireComments", "\nfunction findRequireComments(source, source_path, options, deps) {\n  <defineRegex>\n  var comment_reg = /{! require\\(\"([\\w\\.\\/\\-_\\|[\\]]+)\\\"\\) !}/g, \n    bracket_reg = /\\[([^\\]]*)\\]/g,\n    result = null, bracket_result = null, alt, name;\n  </defineRegex>\n\n  \n  <processComments>\n  while ((result = comment_reg.exec(source)) !== null) {\n    \n    <handleBrackets>\n    bracket_result = bracket_reg.exec(result[1]);\n\n    \n    if (bracket_result) {\n      alt = bracket_result[1].split(\"|\");\n      for (var i = 0; i < alt.length; i++) {\n        name = result[1].replace(bracket_reg, alt[i]);\n        <logDependency>\n        log(options, 'found comment dependency \"' + name + '\"');\n        </logDependency>\n\n        <addDependency>\n        addDustDependency(name, source_path, options, deps);\n        </addDependency>\n      }\n    }\n    </handleBrackets>\n    \n    <handleSingleDependency>\n    else {\n      <logSingleDependency>\n      log(options, 'found comment dependency \"' + result[1] + '\"');\n      </logSingleDependency>\n      <addSingleDependency>\n      addDustDependency(result[1], source_path, options, deps);\n      </addSingleDependency>\n    }\n    </handleSingleDependency>\n  }\n  </processComments>\n}\n"], ["assertPublisherOptions", "\nfunction assertPublisherOptions(options) {\n  <validateOptions>\n  // The entire function is a single responsibility of input validation\n  mod_assert.object(options, 'options');\n  mod_assert.object(options.log, 'options.log');\n  mod_assert.object(options.moray, 'options.moray');\n  mod_assert.string(options.moray.bucketName, 'options.moray.bucketName');\n  mod_assert.optionalObject(options.backoff, 'options.backoff');\n  mod_assert.optionalObject(options.moray.client, 'options.moray.client');\n  mod_assert.optionalObject(options.restifyServer, 'options.restifyServer');\n  if (options.moray.client === undefined || options.moray.client === null) {\n      mod_assert.string(options.moray.host, 'options.moray.host');\n      mod_assert.number(options.moray.port, 'options.moray.port');\n  } else {\n      mod_assert.equal(options.moray.host, undefined, 'options.moray.host');\n      mod_assert.equal(options.moray.port, undefined, 'options.moray.port');\n  }\n  </validateOptions>\n}\n"], ["createStatEntry", "\nfunction createStatEntry(file, fullpath, callback) {\n  <performLstat>\n  fs.lstat(fullpath, function (err, stat) {\n    var entry = {\n      name: file\n    };\n\n    <handleError>\n    if (err) {\n      entry.err = err;\n      return callback(entry);\n    }\n    </handleError>\n    else {\n      <populateEntryWithStat>\n      entry.size = stat.size;\n      entry.mtime = stat.mtime.valueOf();\n\n      <assignMimeType>\n      if (stat.isDirectory()) {\n        entry.mime = \"inode/directory\";\n      } else if (stat.isBlockDevice()) entry.mime = \"inode/blockdevice\";\n      else if (stat.isCharacterDevice()) entry.mime = \"inode/chardevice\";\n      else if (stat.isSymbolicLink()) entry.mime = \"inode/symlink\";\n      else if (stat.isFIFO()) entry.mime = \"inode/fifo\";\n      else if (stat.isSocket()) entry.mime = \"inode/socket\";\n      else {\n        entry.mime = getMime(fullpath);\n      }\n      </assignMimeType>\n      </populateEntryWithStat>\n\n      <processSymbolicLink>\n      if (!stat.isSymbolicLink()) {\n        return callback(entry);\n      }\n      fs.readlink(fullpath, function (err, link) {\n        if (entry.name == link) {\n          entry.linkStatErr = \"ELOOP: recursive symlink\";\n          return callback(entry);\n        }\n\n        if (err) {\n          entry.linkErr = err.stack;\n          return callback(entry);\n        }\n        entry.link = link;\n        resolvePath(pathResolve(dirname(fullpath), link), {alreadyRooted: true}, function (err, newpath) {\n          if (err) {\n              entry.linkStatErr = err;\n              return callback(entry);\n          }\n          createStatEntry(basename(newpath), newpath, function (linkStat) {\n              entry.linkStat = linkStat;\n              linkStat.fullPath = newpath.substr(base.length) || \"/\";\n              return callback(entry);\n          });\n        });\n      });\n      </processSymbolicLink>\n    }\n  });\n  </performLstat>\n}\n"], ["anonymousRangeSelection", "\nfunction( element ) {\n\t<setRangeForElement>\n\tvar range = new CKEDITOR.dom.range( this.root );\n\trange.setStartBefore( element );\n\trange.setEndAfter( element );\n\tthis.selectRanges( [ range ] );\n\t</setRangeForElement>\n}\n"], ["maskString", "\nfunction maskString(srcStr, mask, start, length) {\n  <assignDefaults>\n  var str = String(srcStr), ptn = /[^\\u4e00-\\u9fa5]/mg, ptn_ = /[\\u4e00-\\u9fa5]/mg;\n  if (isNum(mask)) {\n    length = start, start = mask, mask = '*';\n  } else if (!isStr(mask)) {\n    mask = '*';\n  }\n  </assignDefaults>\n  \n  <maskSubString>\n  var maskStr = str.substr(start, length).replace(ptn, mask).replace(ptn_, mask + mask);\n  return str.substr(0, start) + maskStr + (isUdf(length) ? '' : str.substr(start + length));\n  </maskSubString>\n}\n"], ["getProtectedBinary", "\nfunction getProtectedBinary(node) {\n  <handleBinaryProtection>\n  if (node.protectedValue) {\n    return node.protectedValue;\n  }\n  var text = node.textContent;\n  var ref = node.getAttribute(XmlNames.Attr.Ref);\n  if (ref) {\n      return { ref: ref };\n  }\n  if (!text) {\n      return undefined;\n  }\n  var compressed = strToBoolean(node.getAttribute(XmlNames.Attr.Compressed));\n  var bytes = ByteUtils.base64ToBytes(text);\n  if (compressed) {\n      bytes = pako.ungzip(bytes);\n  }\n  return ByteUtils.arrayToBuffer(bytes);\n  </handleBinaryProtection>\n}\n"], ["logUrlTestStart", "\nfunction(url) {\n\t<outputStartMessage>\n\tif (silentMode) {\n\t\treturn;\n\t}\n\n\tconsole.log(\n\t\tcolors.bold('\\nTesting ' + link(url)) +\n\t\t\t' ... please wait, this may take a minute.'\n\t);\n\tif (program.timer) {\n\t\tconsole.time('Total test time');\n\t}\n\t</outputStartMessage>\n}\n"], ["callServer", "\nfunction callServer(params,key) {\n  <logEnteringProxy>\n  debug(\"enter proxy!\");\n  </logEnteringProxy>\n  \n  <initializeOptions>\n  var options = {\n    url: params.domain + params.api.url,\n    method: params.api.method,\n  };\n  </initializeOptions>\n  \n  <setRequestMethod>\n  if (params.api.apiMethod) {\n    options.method = params.api.apiMethod;\n  }\n  </setRequestMethod>\n\n  <assignQueryOrFormData>\n  if(options.method === 'GET') {\n    options.qs = params.params;\n  } else {\n    options.form = params.params;\n  }\n  </assignQueryOrFormData>\n  \n  <handleJsonPayload>\n  if(params.api.isJsonRaw) {\n    options.headers =  {\n       'Content-Type' : 'application/json'\n    };\n    options.body = JSON.stringify(params.params);\n    delete options.form;\n  }\n  </handleJsonPayload>\n  \n  <mergeHeaders>\n  if(params.req._yoheaders) {\n    options.headers = options.headers||{};\n    options.headers = _.merge(options.headers,params.req._yoheaders);\n  }\n  </mergeHeaders>\n\n  <logApiInput>\n  params.req.app.yolog.api.log('verbose','server api input: ',options);\n  params.req.app.yolog.profile('proxy api time:'+options.url,'api');\n  </logApiInput>\n  <makeRequestCall>\n  request(options, function(error, response, body) {\n    <profileApiTime>\n    params.req.app.yolog.profile('proxy api time:'+options.url,'api');\n    </profileApiTime>\n    if (response && response.statusCode === 200) {\n      <handleSuccessfulResponse>\n      params.req.app.yolog.api.log('verbose','server api status 200 output:',body);\n      if (params.res.setCache && params.api.cache) {\n        var cacheKey = params.res.genKey(params.domain, params.api.url, JSON.stringify(params.params));\n\n        params.res.setCache(cacheKey, body, params.api.cache);\n      }\n      params.body = body;\n      debug(\"proxy callback!\");\n      debug(params);\n      procRet(params,key);\n      </handleSuccessfulResponse>\n    } else {\n      <handleErrorResponse>\n      params.req.input = {\n          error:true,\n          message:'api server error!'\n      };\n      params.req.app.yolog.log('error','server api error input: %j',options,{});\n      \n      if (response) {\n        params.req.input.message = 'error: ' + response.statusCode;\n        params.req.app.yolog.log('error','server api error %d output: %j',response.statusCode,body,{});\n      } else {\n        params.req.app.yolog.log('error','call server api yo response: %j',params.req.input,{});\n      }\n      params.next();\n      </handleErrorResponse>\n    }\n  });\n  </makeRequestCall>\n}\n"], ""]