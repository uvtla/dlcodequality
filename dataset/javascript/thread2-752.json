[["createFunc", "\nfunction createFunc (a, info) {\n    var fn = function () {\n        \n        <parseArguments>\n        var args = slice.call(arguments), alen = args.length;\n        var cbk, opts;\n        if (alen === 0 || 'function' !== typeof args[alen-1]) {\n            throw new Error('Lack callback function');\n        } else {\n            cbk = args[alen-1];\n            opts = alen > 1 ? args[0] : {};\n        }\n        </parseArguments>\n\n        <validateRequiredParams>\n        for (var i in info.required) {\n            var p = info.required[i];\n            if (opts[p] === undefined)\n                return cbk(new Error('Lack required params: ' + p));\n            if (Reg.test(p) && !Object.isArray(opts[p]))\n                return cbk(new Error('Param ' + p + ' should be a array'));\n        }\n        </validateRequiredParams>\n\n        <prepareParams>\n        var params = createCommonParam();\n        params.action = a;\n        var ps = [].concat(info.required).concat(info.optional);\n        for (var i in ps) {\n            var p = ps[i];\n            if (opts[p] !== undefined) {\n                if (!Reg.test(p)) {\n                    params[p] = opts[p];\n                } else if (Array.isArray(opts[p])) {  \n                    for(var j in opts[p]){\n                        var tmpp = p;\n                        params[tmpp.replace(Reg, '.'+(Number(j)+1))] = opts[p][j];\n                    }\n                } else {\n                    return cbk(new Error('Param ' + p + ' should be a array'));\n                }\n            }\n        }\n        </prepareParams>\n\n        <buildQueryString>\n        var params_arra = [];\n        for (var i in params) {\n            params_arra.push(i + '=' + utils.escape(params[i]));\n        }\n        </buildQueryString>\n\n        <generateSignature>\n        var query = params_arra.sort().join('&');\n        var sign_str = 'GET' + \"\\n\" + '/iaas/' + \"\\n\" + query;\n        var signature = utils.sign(sign_str, qing.secret_access_key, 'sha256');\n        query += '&signature=' + utils.escape(signature);  \n        </generateSignature>\n\n        <makeApiRequest>\n        var url = config.host + '?' + query;\n        request(url, function(err, response, body){\n            if (err)\n                cbk(err);\n            else\n                cbk(null, JSON.parse(body));\n        });\n        </makeApiRequest>\n    }\n    return fn;\n}\n"], ["transformIERangeToRange", "\nfunction transformIERangeToRange( ieRange, range ) {\n        <setRangeStart>\n        if ( ieRange.item ) {\n            range.selectNode( ieRange.item( 0 ) );\n        } else {\n            var bi = getBoundaryInformation( ieRange, true );\n            range.setStart( bi.container, bi.offset );\n        </setRangeStart>\n        <setRangeEnd>\n            if ( ieRange.compareEndPoints( 'StartToEnd', ieRange ) != 0 ) {\n                bi = getBoundaryInformation( ieRange, false );\n                range.setEnd( bi.container, bi.offset );\n            }\n        </setRangeEnd>\n        return range;\n}\n"], ["destRoot", "\nfunction destRoot(type, drizzle) {\n  \n  const options = drizzle.options;\n\n  \n  <mapTypeToKey>\n  const keys = new Map([\n    ['page', 'pages'],\n    ['collection', 'collections'],\n    ['pattern', 'patterns']\n  ]);\n  </mapTypeToKey>\n\n  <generateRelativePath>\n  return relativePath(options.dest.root, options.dest[keys.get(type)]);\n  </generateRelativePath>\n}\n"], ["clip", "\nfunction( clip ) {\n\n    <initializeActions>\n    var actions = this._actions,\n        clipUuid = clip.uuid,\n        actionsByClip = this._actionsByClip,\n        actionsForClip = actionsByClip[ clipUuid ];\n    </initializeActions>\n\n    <deactivateAndRemoveActions>\n    if (actionsForClip !== undefined) {\n        var actionsToRemove = actionsForClip.knownActions;\n        for ( var i = 0, n = actionsToRemove.length; i !== n; ++ i ) {\n            var action = actionsToRemove[ i ];\n            this._deactivateAction( action );\n            var cacheIndex = action._cacheIndex,\n                lastInactiveAction = actions[ actions.length - 1 ];\n            action._cacheIndex = null;\n            action._byClipCacheIndex = null;\n            lastInactiveAction._cacheIndex = cacheIndex;\n            actions[ cacheIndex ] = lastInactiveAction;\n            actions.pop();\n            this._removeInactiveBindingsForAction( action );\n        }\n        delete actionsByClip[ clipUuid ];\n    }\n    </deactivateAndRemoveActions>\n}\n"], ["processSlotOutlet", "\nfunction processSlotOutlet (el) {\n    <slotProcessing>\n    if (el.tag === 'slot') {\n        el.slotName = getBindingAttr(el, 'name');\n        if (process.env.NODE_ENV !== 'production' && el.key) {\n            warn$2(\n                \"`key` does not work on <slot> because slots are abstract outlets \" +\n                \"and can possibly expand into multiple elements. \" +\n                \"Use the key on a wrapping element instead.\",\n                getRawBindingAttr(el, 'key')\n            );\n        }\n    }\n    </slotProcessing>\n}\n"], ["deleteCommandOnCmdEditor", "\nfunction deleteCommandOnCmdEditor (config) {\n    <initializeDeletionOptions>\n    var commands = config.commands || {};\n    var command_names = Object.keys(commands);\n    command_names.unshift('<< Cancel');\n    var promise = inquirer.prompt([{\n        type: 'list',\n        name: 'cmdName',\n        message: 'Choose the command you want to delete',\n        choices: command_names\n    }]);\n    </initializeDeletionOptions>\n\n    <processDeletion>\n    return promise.then(function (answer) {\n        if (answer.cmdName == '<< Cancel') {\n            return false;\n        }\n        delete config.commands[answer.cmdName];\n        console.log(colors.bold.green('\\n\\nThis command has been deleted: ' + answer.cmdName));\n        console.log('\\nWriting to ' + process.cwd() + '/' + COMMANDS_FILENAME);\n        fs.writeFileSync(COMMANDS_FILENAME, JSON.stringify(config.commands));\n        console.log('Writing has been completed.\\n\\n');\n        return true;\n    });\n    </processDeletion>\n}\n"], ["objectSchema", "\nfunction objectSchema(obj) {\n    <constructSchema>\n    const props = Object.entries(obj).reduce(\n        (reduced, [key, val]) => Object.assign(reduced, { [key]: typeof val }),\n        {}\n    );\n    </constructSchema>\n    return props;\n}\n"], ["wrapInner", "\nfunction wrapInner(parent, wrapper) {\n    <createAndAppendWrapper>\n    if (typeof wrapper === \"string\") wrapper = document.createElement(wrapper);\n    parent.appendChild(wrapper);\n    </createAndAppendWrapper>\n    <relocateChildren>\n    while (parent.firstChild !== wrapper) wrapper.appendChild(parent.firstChild);\n    </relocateChildren>\n}\n"], ["UnnamedFunctionWithExtension", "\nfunction(extension, tab, pageStatus, pageOptions, port) {\n  \n  <initializeProperties>\n  this.extension_ = extension;\n  this.tabId_ = tab.id;\n  this.pageUrl_ = URI.canonicalize(tab.url);\n  this.pageOptions_ = pageOptions;\n  this.port_ = port;\n  this.debugger_ = null;\n  </initializeProperties>\n\n  <configureDebugger>\n  if (pageStatus == PageStatus.WHITELISTED &&\n      pageOptions['wtf.trace.provider.chromeDebug'] !== false) {\n    var timelineEnabled =\n        pageOptions['wtf.trace.provider.chromeDebug.timeline'] !== false;\n    var memoryInfoEnabled =\n        pageOptions['wtf.trace.provider.chromeDebug.memoryInfo'];\n    var tracingEnabled =\n        pageOptions['wtf.trace.provider.chromeDebug.tracing'];\n    if (timelineEnabled || memoryInfoEnabled || tracingEnabled) {\n      this.debugger_ = new Debugger(this.tabId_, this.pageOptions_);\n    }\n  }\n  </configureDebugger>\n\n  <setMessageHandlers>\n  this.eventHandlers_ = {\n    onMessage: this.messageReceived_.bind(this),\n    onDisconnect: this.disconnected_.bind(this)\n  };\n  this.port_.onMessage.addListener(this.eventHandlers_.onMessage);\n  this.port_.onDisconnect.addListener(this.eventHandlers_.onDisconnect);\n  </setMessageHandlers>\n\n  <scheduleDebuggerDataTransmission>\n  this.debuggerTransmitId_ = -1;\n  if (this.debugger_) {\n    this.debuggerTransmitId_ = window.setInterval((function() {\n      var records = this.debugger_.getRecords();\n      if (records.length) {\n        this.port_.postMessage(JSON.stringify({\n          'command': 'debugger_data',\n          'records': records\n        }));\n        this.debugger_.clearRecords();\n      }\n    }).bind(this), 1000);\n  }\n  </scheduleDebuggerDataTransmission>\n}\n"], ["unregister", "\nfunction unregister() {\n    <checkPresenceInDOM>\n    for (var p = d.wrapper.parentNode; p && p != document.body; p = p.parentNode) {}\n    if (p) setTimeout(unregister, 5000);\n    else off(window, \"resize\", onResize);\n    </checkPresenceInDOM>\n}\n"], ""]