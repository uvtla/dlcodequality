[["functionPrompt", "\nfunction Prompt() {\n  <applyParentClass>\n  Base.apply(this, arguments);\n  </applyParentClass>\n\n  <initializeRawDefault>\n  var rawDefault = true;\n  </initializeRawDefault>\n\n  <extendOptions>\n  utils.extend(this.opt, {\n    <customFilterFunction>\n    filter: function(input) {\n      <determineFilterValue>\n      var value = rawDefault;\n      if (input != null && input !== '') {\n        value = /^y(es)?/i.test(input);\n      }\n      </determineFilterValue>\n      return value;\n    }.bind(this)\n    </customFilterFunction>\n  });\n  </extendOptions>\n\n  <setDefaultOption>\n  if (typeof this.opt.default === 'boolean') {\n    rawDefault = this.opt.default;\n  }\n  </setDefaultOption>\n\n  <formatDefaultOption>\n  this.opt.default = rawDefault ? 'Y/n' : 'y/N';\n  </formatDefaultOption>\n\n  return this;\n}\n"], ["fireEvent", "\nfunction (event, type) {\n  <checkMapPresence>\n  if (!this.getMap()) {\n    return;\n  }\n  </checkMapPresence>\n\n  <defineEventType>\n  const eventType = type || this._getEventTypeToFire(event);\n  </defineEventType>\n\n  <handleContextMenuEvent>\n  if (eventType === 'contextmenu' && this.listens('contextmenu')) {\n    stopPropagation(event);\n    preventDefault(event);\n  }\n  </handleContextMenuEvent>\n\n  <prepareEventParamsAndFire>\n  const params = this._getEventParams(event);\n  this._fireEvent(eventType, params);\n  </prepareEventParamsAndFire>\n}\n"], ["handleChat", "\nfunction handleChat(request, response, chat) {\n  var resp, id;\n  <handlePostRequest>\n  if (request.method === \"POST\") {\n    requestBody(request, function(form) {\n      while (chat.length > CHATLINES) {\n        chat.shift();\n      }\n\n      if (chat.length) {\n        id = chat[chat.length-1].id + 1;\n      } else {\n        id = 0;\n      }\n      chat.push({\n        id: id,  \n        name: form.name,  \n        input: form.input  \n      });\n      respOk(response, '', 'text/json');\n    });\n  }\n  </handlePostRequest>\n  \n  <handleGetRequest>\n  else {\n    var form = requestQuery(request);\n    var lastid = +form.lastid;\n    if (lastid >= 0) {\n      for (var i=0; i<chat.length; i++) {\n        if (chat[i].id === lastid) {\n          break;\n        }\n      }\n      resp = JSON.stringify(chat.slice(i+1));\n    } else {\n      resp = JSON.stringify(chat);\n    }\n    respOk(response, resp, 'text/json');\n  }\n  </handleGetRequest>\n}\n"], ["frame", "\nfunction frame() {\n  <checkIfFrameIsRunning>\n  if (!frameRunning) {\n    frameRunning = true;\n    requestAnimationFrame(animationLoop);\n  }\n  </checkIfFrameIsRunning>\n  <createNewFrame>\n  return create.apply(qframe, arguments);\n  </createNewFrame>\n}\n"], ["unknownFunctionName", "\nfunction(content, start, removed, added) {\n  var addedViews = [];\n  var view, item, idx, len, itemViewClass, emptyView;\n\n  <calculateContentLength>\n  len = content ? get(content, 'length') : 0;\n  </calculateContentLength>\n\n  <handleContent>\n  if (len) {\n    itemViewClass = get(this, 'itemViewClass');\n    itemViewClass = handlebarsGetView(content, itemViewClass, this.container);\n\n    for (idx = start; idx < start+added; idx++) {\n      item = content.objectAt(idx);\n\n      <createAddedViews>\n      view = this.createChildView(itemViewClass, {\n        content: item,\n        contentIndex: idx\n      });\n\n      addedViews.push(view);\n      </createAddedViews>\n    }\n  }\n  </handleContent>\n  \n  <handleEmptyContent>\n  else {\n    emptyView = get(this, 'emptyView');\n\n    if (!emptyView) { return; }\n\n    <resolveGlobalPath>\n    if ('string' === typeof emptyView && isGlobalPath(emptyView)) {\n      emptyView = get(emptyView) || emptyView;\n    }\n    </resolveGlobalPath>\n\n    <createEmptyView>\n    emptyView = this.createChildView(emptyView);\n    addedViews.push(emptyView);\n    set(this, 'emptyView', emptyView);\n\n    if (CoreView.detect(emptyView)) {\n      this._createdEmptyView = emptyView;\n    }\n    </createEmptyView>\n  }\n  </handleEmptyContent>\n\n  <replaceViews>\n  this.replace(start, 0, addedViews);\n  </replaceViews>\n}\n"], ["makeMappingArray", "\nfunction makeMappingArray (N, data, gamma) {\n  let i;\n  const x = [];\n  const y0 = [];\n  const y1 = [];\n  const lut = [];\n\n  <setGamma>\n  gamma = gamma === null ? 1 : gamma;\n  </setGamma>\n\n  <populateXYArrays>\n  for (i = 0; i < data.length; i++) {\n    const element = data[i];\n\n    x.push((N - 1) * element[0]);\n    y0.push(element[1]);\n    y1.push(element[1]);\n  }\n  </populateXYArrays>\n\n  <createLinearSpace>\n  const xLinSpace = linspace(0, 1, N);\n  </createLinearSpace>\n\n  <applyGammaCorrection>\n  for (i = 0; i < N; i++) {\n    xLinSpace[i] = (N - 1) * Math.pow(xLinSpace[i], gamma);\n  }\n  </applyGammaCorrection>\n\n  <findIndexes>\n  const xLinSpaceIndexes = searchSorted(x, xLinSpace);\n  </findIndexes>\n\n  <interpolateColors>\n  for (i = 1; i < N - 1; i++) {\n    const index = xLinSpaceIndexes[i];\n    const colorPercent = ((xLinSpace[i] - x[index - 1]) / (x[index] - x[index - 1]));\n    const colorDelta = (y0[index] - y1[index - 1]);\n\n    lut[i] = colorPercent * colorDelta + y1[index - 1];\n  }\n  </interpolateColors>\n\n  <setLutEdges>\n  lut[0] = y1[0];\n  lut[N - 1] = y0[data.length - 1];\n  </setLutEdges>\n\n  return lut;\n}\n"], ["mkId", "\nfunction mkId(value, mayBeNegative) {\n  <initializeIdAndSign>\n  var id = -1,\n      sign = 1;\n  </initializeIdAndSign>\n  \n  <handleNegativeValue>\n  if (value.charAt(0) == '-') {\n    sign = -1;\n    value = value.substring(1);\n  }\n  </handleNegativeValue>\n\n  <parseIdValue>\n  if (Lang.NUMBER_DEC.test(value))\n    id = parseInt(value);\n  else if (Lang.NUMBER_HEX.test(value))\n    id = parseInt(value.substring(2), 16);\n  else if (Lang.NUMBER_OCT.test(value))\n    id = parseInt(value.substring(1), 8);\n  else\n    throw Error(\"illegal id value: \" + (sign < 0 ? '-' : '') + value);\n  </parseIdValue>\n\n  <adjustAndCheckId>\n  id = (sign*id)|0; \n  if (!mayBeNegative && id < 0)\n    throw Error(\"illegal id value: \" + (sign < 0 ? '-' : '') + value);\n  </adjustAndCheckId>\n\n  return id;\n}\n"], ["readLineStringGeometry_", "\nfunction readLineStringGeometry_(text) {\n  <assertLineStringFormat>\n  console.assert(text.substring(0, 2) === 'l(');\n  console.assert(text[text.length - 1] == ')');\n  </assertLineStringFormat>\n  \n  <extractText>\n  text = text.substring(2, text.length - 1);\n  </extractText>\n  \n  <decodeCoordinatesAndCreateGeometry>\n  const flatCoordinates = this.decodeCoordinates_(text);\n  return new olGeomLineString(flatCoordinates, olGeomGeometryLayout.XY);\n  </decodeCoordinatesAndCreateGeometry>\n}\n"], ["cacheAndResolveSVG", "\nfunction(response) {\n  <checkAndUpdateSVGCached>\n  if (!svgCache[url]) {\n    svgCache[url] = angular.element('<div>').append(response)[0].querySelector('svg');\n  }\n  </checkAndUpdateSVGCached>\n  <resolveSVG>\n  resolve(svgCache[url]);\n  </resolveSVG>\n}\n"], ["initOrSetSettings", "\nfunction(setting) {\n  <handleUndefinedSetting>\n  if (typeof setting === \"undefined\") {\n    if (typeof window !== \"undefined\") {\n      if (typeof window.reckonSettings !== \"undefined\") {\n        <setDelimSettingsFromGlobal>\n        if (typeof window.reckonSettings.delimStart) {\n          settings.delimStart = window.reckonSettings.delimStart;\n        }\n        if (typeof window.reckonSettings.delimEnd) {\n          settings.delimEnd = window.reckonSettings.delimEnd;\n        }\n        </setDelimSettingsFromGlobal>\n      }\n    }\n  }\n  </handleUndefinedSetting>\n  <handleDefinedSetting>\n  else {\n    <setDelimSettingsFromArgument>\n    if (typeof setting.delimStart) {\n      settings.delimStart = setting.delimStart;\n    }\n    if (typeof setting.delimEnd) {\n      settings.delimEnd = setting.delimEnd;\n    }\n    </setDelimSettingsFromArgument>\n  }\n  </handleDefinedSetting>\n  <setInstanceDelimeters>\n  this.delimStart = settings.delimStart;\n  this.delimEnd = settings.delimEnd;\n  </setInstanceDelimeters>\n  \n  return this;\n}\n"], ""]