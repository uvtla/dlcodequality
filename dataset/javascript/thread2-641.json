[["commitInternally", "\nfunction commitInternally( targetFields ) {\n  <initializeDialog>\n  var dialog = this.getDialog(),\n      element = dialog._element && dialog._element.clone() || new CKEDITOR.dom.element( 'div', editor.document );\n  </initializeDialog>\n\n  <commitElement>\n  this.commit( element, true );\n  </commitElement>\n\n  <setupFields>\n  targetFields = [].concat( targetFields );\n  var length = targetFields.length,\n      field;\n  for ( var i = 0; i < length; i++ ) {\n    field = dialog.getContentElement.apply( dialog, targetFields[ i ].split( ':' ) );\n    field && field.setup && field.setup( element, true );\n  }\n  </setupFields>\n}\n"], ["removeElementByIndex", "\nfunction (index) {\n  <validateIndex>\n  validateListIndex(this, index);\n  </validateIndex>\n\n  <removeElement>\n  var i = index,\n      len = --this.length;\n\n  for (; i < len; i++) {\n      this[i] = this[i + 1];\n  }\n\n  delete this[len];\n  </removeElement>\n}\n"], ["reportSyntaxIssue", "\nfunction report(node) {\n  <identifyParentheses>\n  const leftParenToken = sourceCode.getTokenBefore(node);\n  const rightParenToken = sourceCode.getTokenAfter(node);\n  </identifyParentheses>\n\n  <checkAndIgnoreTokens>\n  if (!isParenthesisedTwice(node)) {\n      if (tokensToIgnore.has(sourceCode.getFirstToken(node))) {\n          return;\n      }\n\n      if (isIIFE(node) && !isParenthesised(node.callee)) {\n          return;\n      }\n  }\n  </checkAndIgnoreTokens>\n\n  <reportIssue>\n  context.report({\n      node,\n      loc: leftParenToken.loc.start,\n      messageId: \"unexpected\",\n      fix(fixer) {\n          const parenthesizedSource = sourceCode.text.slice(leftParenToken.range[1], rightParenToken.range[0]);\n\n          return fixer.replaceTextRange([\n              leftParenToken.range[0],\n              rightParenToken.range[1]\n          ], (requiresLeadingSpace(node) ? \" \" : \"\") + parenthesizedSource + (requiresTrailingSpace(node) ? \" \" : \"\"));\n      }\n  });\n  </reportIssue>\n}\n"], ["printResult", "\nfunction printResult(result, isDeploy, isCompressed, prefix, fn) {\n  <prepareStatistics>\n  const relpath = truncate(path.relative(process.cwd(), result.filepath));\n  </prepareStatistics>\n\n  <gzipAndPrint>\n  if ((result.type == 'js' || result.type == 'css') && isDeploy) {\n    zlib.gzip(result.content, (err, buffer) => {\n      if (err) return fn(err);\n\n      <calculateFileSizes>\n      const stat = fs.statSync(result.filepath);\n      const bytes = stat.size;\n      const over = bytes > recommendedFileSizeLimit;\n      </calculateFileSizes>\n\n      <printCompressedSize>\n      const overZipped = buffer.length > recommendedFileSizeLimit;\n\n      print(chalk.green(`${chalk.green(prefix)} built and compressed ${strong(relpath)}`), 1);\n      print(`[compressed size: ${chalk[over ? 'red' : 'green'](prettyBytes(bytes))}]`, 2 + prefix.length);\n      print(`[gzipped size: ${chalk[overZipped ? 'red' : 'green'](prettyBytes(buffer.length))}]`, 2 + prefix.length);\n      </printCompressedSize>\n\n      <warnIfOverLimit>\n      if (over || overZipped) {\n        warn(\n          `the output file exceeds the recommended ${strong(prettyBytes(recommendedFileSizeLimit))} size`,\n          2 + prefix.length\n        );\n        print(\n          'Consider splitting into smaller bundles to help improve browser startup execution time',\n          2 + prefix.length\n        );\n      }\n      </warnIfOverLimit>\n\n      fn();\n    });\n  }\n  </gzipAndPrint>\n\n  <printNonCompressedResult>\n  else {\n    print(chalk.green(`${chalk.green(prefix)} built${isCompressed ? ' and compressed' : ''} ${strong(relpath)}`), 1);\n    fn();\n  }\n  </printNonCompressedResult>\n}\n"], ["configMissingError", "\nfunction configMissingError(configName) {\n  <generateError>\n  const error = new Error(`Failed to load config \"${configName}\" to extend from.`);\n\n  error.messageTemplate = \"extend-config-missing\";\n  error.messageData = {\n      configName\n  };\n  </generateError>\n  return error;\n}\n"], ["thunkify", "\nfunction thunkify(input, ctx, key) {\n  <thunkCreation>\n  return function() {        \n      ctx = ctx || this;\n      \n      <collectArguments>\n      var args = [];\n      for (var i = 0; i < arguments.length; ++i) {\n          args.push(arguments[i]);\n      }\n      </collectArguments>\n\n      <delayedExecution>\n      return function(done) {\n          <ensureSingleCall>\n          var called;\n          args.push(function() {\n              if (!called) {\n                  called = true;\n                  done.apply(null, arguments);\n              }\n          });\n          </ensureSingleCall>\n\n          <applyFunction>\n          try {\n              input.apply(ctx, args);\n          } catch (err) {\n              done(err);\n          }\n          </applyFunction>\n      };\n      </delayedExecution>\n  };\n  </thunkCreation>\n}\n"], ["fileCopy", "\nfunction(checks, callback) {\n  <checkSourceFile>\n  fs.lstat(options.source, function(err, stats) {\n    \n    <fileTypeActions>\n    if (stats.isFile()) {\n      copyFile(options, callback);\n    } else if (stats.isDirectory()) {\n      copyDir(options, callback);\n    } else if (stats.isSymbolicLink()) {\n      copySymlink(options, callback);\n    } else {\n      callback(new Error('Unsupported file type !'));\n    }\n    </fileTypeActions>\n  });\n  </checkSourceFile>\n}\n"], ["onExit", "\nfunction onExit () {\n  <exitCheckAndErrorHandling>\n  if (!responded) {\n    errState = true;\n    responded = true;\n    error = new Error('Error spawning drone');\n    error.blame = {\n      type: 'user',\n      message: 'Script prematurely exited'\n    }\n    error.stdout = stdout.join('\\n');\n    error.stderr = stderr.join('\\n');\n    callback(error);\n    \n    <cleanupListenersAndTimeout>\n    drone.removeListener('error', onError);\n    drone.removeListener('message', onCarapacePort);\n    clearTimeout(timeout);\n    </cleanupListenersAndTimeout>\n  }\n  </exitCheckAndErrorHandling>\n}\n"], ["resolveCategory", "\nfunction resolveCategory(categoryParam: number | string, defaultCategory: number): number {\n  <categoryResolution>\n  if (typeof categoryParam === 'number') {\n    return categoryParam;\n  }\n\n  if (typeof categoryParam === 'string') {\n    if (categoryParam in primaryCategoryNumbers) {\n      return primaryCategoryNumbers[categoryParam];\n    }\n  }\n  </categoryResolution>\n\n  return defaultCategory;\n}\n"], ["patchType", "\nfunction patchType (content, type, peerPaths) {\n  <normalizePaths>\n  let normalizedPaths = peerPaths.map(path => slash(normalize(path)));\n  </normalizePaths>\n\n  <injectDependencies>\n  switch (type) {\n    case 'script':\n      <scriptInjection>\n      let scriptImports = normalizedPaths.map(path => `import '${path}'\\n`);\n      content = content.replace(RE_SCRIPT, match => {\n        return `${match}\\n${scriptImports.join('')}`;\n      });\n      </scriptInjection>\n      break;\n    case 'style':\n      <styleInjection>\n      let styleImports = normalizedPaths.map(path => {\n        let langStr = '';\n        let ext = getExtname(path);\n        if (ext !== 'css') {\n          langStr = `lang=\"${ext}\" `;\n        }\n        return `<style ${langStr}src=\"${path}\"></style>\\n`;\n      });\n      content += styleImports.join('');\n      </styleInjection>\n      break;\n    default:\n      break;\n  }\n  </injectDependencies>\n\n  return content;\n}\n"], "```"]