[["onSignUp", "\nfunction onSignUp() {\n  var email = $('#signup-email').val();\n  var password = $('#signup-password').val();\n  auth.createUserWithEmailAndPassword(email, password)\n      .then(onAuthUserCredentialSuccess, onAuthError);\n}\n"], ["isOneOf", "\nfunction isOneOf(x) {\n    var typeName = (0, _typeOf.typeOf)(x);\n\n    for (var _len3 = arguments.length, types = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n      types[_key3 - 1] = arguments[_key3];\n    }\n\n    return toTypeRefNames(types).some(function (name) {\n      return typeName === name;\n    });\n  }\n"], ["map", "\nfunction map(project, thisArg) {\n    return function mapOperation(source) {\n        if (typeof project !== 'function') {\n            throw new TypeError('argument is not a function. Are you looking for `mapTo()`?');\n        }\n        return source.lift(new MapOperator(project, thisArg));\n    };\n}\n"], ["convertAttributesToData", "\nfunction(el, name) {\n  var readAll = arguments.length === 1;\n  <deserializeAndAssignData>\n  var domNames, domName, jsNames, jsName, value, idx, length;\n\n  if (readAll) {\n    domNames = Object.keys(el.attribs).filter(function(attrName) {\n      return attrName.slice(0, dataAttrPrefix.length) === dataAttrPrefix;\n    });\n    jsNames = domNames.map(function(_domName) {\n      return camelCase(_domName.slice(dataAttrPrefix.length));\n    });\n  } else {\n    domNames = [dataAttrPrefix + cssCase(name)];\n    jsNames = [name];\n  }\n\n  for (idx = 0, length = domNames.length; idx < length; ++idx) {\n    domName = domNames[idx];\n    jsName = jsNames[idx];\n    if (hasOwn.call(el.attribs, domName)) {\n      value = el.attribs[domName];\n\n      if (hasOwn.call(primitives, value)) {\n        value = primitives[value];\n      } else if (value === String(Number(value))) {\n        value = Number(value);\n      } else if (rbrace.test(value)) {\n        try {\n          value = JSON.parse(value);\n        } catch(e){ }\n      }\n\n      el.data[jsName] = value;\n    }\n  }\n  </deserializeAndAssignData>\n  \n  return readAll ? el.data : value;\n}\n"], ["onSaveSuccess", "\nfunction onSaveSuccess(model, params, result) {\n  Flux.dispatch(actionTypes.API_SAVE_SUCCESS, {\n    model: model,\n    params: params,\n    result: result,\n  })\n  return result\n}\n"], ["allocateBones", "\nfunction allocateBones ( object ) {\n\n\t\tif ( _supportsBoneTextures && object && object.useVertexTexture ) {\n\n\t\t\treturn 1024;\n\n\t\t} else {\n\n\t\t\tvar nVertexUniforms = _gl.getParameter( _gl.MAX_VERTEX_UNIFORM_VECTORS );\n\t\t\tvar nVertexMatrices = Math.floor( ( nVertexUniforms - 20 ) / 4 );\n\n\t\t\tvar maxBones = nVertexMatrices;\n\n\t\t\tif ( object !== undefined && object instanceof THREE.SkinnedMesh ) {\n\n\t\t\t\tmaxBones = Math.min( object.bones.length, maxBones );\n\n\t\t\t\tif ( maxBones < object.bones.length ) {\n\n\t\t\t\t\tconsole.warn( \"WebGLRenderer: too many bones - \" + object.bones.length + \", this GPU supports just \" + maxBones + \" (try OpenGL instead of ANGLE)\" );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn maxBones;\n\n\t\t}\n\n\t}\n"], ["interpolateColors", "\nfunction interpolateColors(themeColors) {\n  var rgbColors = {};\n\n  var hasColorProperty = themeColors.hasOwnProperty('color');\n\n  angular.forEach(themeColors, function (value, key) {\n    var color = extractColorOptions(value);\n    var hasBackground = key.indexOf('background') > -1;\n\n    rgbColors[key] = parseColor(color);\n    if (hasBackground && !hasColorProperty) {\n      rgbColors.color = parseColor(color, true);\n    }\n  });\n\n  return rgbColors;\n}\n"], ["createAndAwaitVolume", "\nfunction(details, options, callback) {\n        var self = this;\n\n        if (typeof(options) === 'function') {\n            callback = options;\n            options = {};\n        }\n\n        <createVolume>\n        self.createVolume(details, function(err, volume) {\n            if (err) {\n                callback(err);\n                return;\n            }\n        </createVolume>\n        \n        <waitForVolumeStatus>\n        var waitOptions = {\n            interval: 5000,\n            maxWait: options.maxWait ? options.maxWait : 30 * 60, \n            update: options.update,\n            finish: options.finish\n        };\n\n        volume.setWait({ status: 'available' }, waitOptions, function(err, volume) {\n            callback(err, volume);\n        });\n        </waitForVolumeStatus>\n    });\n}\n"], ["coverFile", "\nfunction coverFile(srcFile) {\n  var srcCode = grunt.file.read(srcFile);\n  Instrument = require('coverjs').Instrument;\n\n  try {\n    return new Instrument(srcCode, {name: srcFile}).instrument();\n  } catch (e) {\n    grunt.log.error('File ' + srcFile + ' could not be instrumented.');\n    grunt.fatal(e, 3);\n  }\n}\n"], ["initDragDropManager", "\nfunction() {\n  var DDM = YAHOO.util.DDM;\n  if ( YAHOO.util.Event && document ) {\n    DDM._onLoad();\n  } else {\n    <delayedDDMSetup>\n    if (DDM._timeoutCount > 2000) {\n      YAHOO.log(\"DragDrop requires the Event Utility\", \"error\", \"DragDropMgr\");\n    } else {\n      setTimeout(DDM._addListeners, 10);\n      if (document && document.body) {\n        DDM._timeoutCount += 1;\n      }\n    }\n    </delayedDDMSetup>\n  }\n}\n"], "This function is not SRP compliant because it is responsible for both initializing the DragDrop Manager and setting up listeners in a delayed fashion if initialization can't proceed. Therefore, the relevant block of code handling delayed setup is annotated."]