[["requirePackage", "\nfunction requirePackage(pkg, mainjs) {\n    var processed = {};\n    var pkgName = path.basename(pkg);\n    var code = grunt.file.read(mainjs);\n    while (true) {\n        var requires = detective(code);\n        if (!requires.length) break;\n        for (var requireIdx in requires) {\n            var name = requires[requireIdx];\n            var requiredCode = '';\n            if (!processed[name]) {\n                var filepath = path.join(pkg, 'lib', name.replace(pkgName + '/', '') + '.js');\n                requiredCode = grunt.file.read(filepath);\n                processed[name] = true;\n            }\n            code = code.replace(new RegExp('require\\\\([\\\\\\'\\\"]' + name + '[\\\\\\'\\\"]\\\\);?'), requiredCode);\n        }\n    }\n    return code;\n}\n"], ["parse", "\nfunction parse(string) {\n    var result = {},\n        lines = string.split(/\\r\\n|\\r|\\n/),\n        count = lines.length,\n        pieces,\n        key,\n        value,\n        meta,\n        namespace;\n\n    for (var i = 0; i < count; i++) {\n        \n        if (lines[i] === '') {\n            continue;\n        }\n        if (lines[i].toUpperCase() === PREFIX || lines[i].toUpperCase() === POSTFIX) {\n            continue;\n        }\n        \n        var data = lines[i];\n        \n        var isValueContinued = function (i) {\n            return i + 1 < count && (lines[i + 1][0] === ' ' || lines[i + 1][0] === '\\t');\n        };\n        \n        if (isValueContinued(i)) {\n            while (isValueContinued(i)) {\n                data += lines[i + 1].trim();\n                i++;\n            }\n        }\n\n        pieces = data.split(':');\n        key = pieces.shift();\n        value = pieces.join(':');\n        namespace = false;\n        meta = {};\n        \n        if (key.match(/;/)) {\n            key = key\n                .replace(/\\\\;/g, '\u03a9\u03a9\u03a9')\n                .replace(/\\\\,/, ',');\n            var metaArr = key.split(';').map(function (item) {\n                return item.replace(/\u03a9\u03a9\u03a9/g, ';');\n            });\n            key = metaArr.shift();\n            metaArr.forEach(function (item) {\n                var arr = item.split('=');\n                arr[0] = arr[0].toLowerCase();\n                if (arr[0].length === 0) {\n                    return;\n                }\n                if (meta[arr[0]]) {\n                    meta[arr[0]].push(arr[1]);\n                } else {\n                    meta[arr[0]] = [arr[1]];\n                }\n            });\n        }\n        \n        \n        value = value\n            .replace(/\\\\n/g, '\\n');\n\n        value = tryToSplit(value);\n        \n        \n        if (key.match(/\\./)) {\n            var arr = key.split('.');\n            key = arr[1];\n            namespace = arr[0];\n        }\n\n        var newValue = {\n            value: value\n        };\n        if (Object.keys(meta).length) {\n            newValue.meta = meta;\n        }\n        if (namespace) {\n            newValue.namespace = namespace;\n        }\n\n        if (key.indexOf('X-') !== 0) {\n            key = key.toLowerCase();\n        }\n\n        if (typeof result[key] === 'undefined') {\n            result[key] = [newValue];\n        } else {\n            result[key].push(newValue);\n        }\n\n    }\n\n    return result;\n}\n"], ["loadImageFromImageLoader", "\nfunction loadImageFromImageLoader(imageId, options) {\n    const colonIndex = imageId.indexOf(':');\n    const scheme = imageId.substring(0, colonIndex);\n    const loader = imageLoaders[scheme];\n\n    if (loader === undefined || loader === null) {\n        if (unknownImageLoader !== undefined) {\n            return unknownImageLoader(imageId);\n        }\n        \n        throw new Error('loadImageFromImageLoader: no image loader for imageId');\n    }\n\n    const imageLoadObject = loader(imageId, options);\n\n    \n    imageLoadObject.promise.then(function(image) {\n        triggerEvent(events, EVENTS.IMAGE_LOADED, { image });\n    }, function(error) {\n        const errorObject = {\n            imageId,\n            error\n        };\n        \n        triggerEvent(events, EVENTS.IMAGE_LOAD_FAILED, errorObject);\n    });\n\n    return imageLoadObject;\n}\n"], ["addRecord", "\nfunction addRecord(options) {\n    options.type = options.type || 'CNAME';\n    return getZone(options.domain)\n    .then(function(zone) {\n        return self.cloudflareClient.addRecord(\n            zone.id,\n            _.extend({ ttl: 1 }, mapRecordOptions(options)));\n        })\n    .then(function(response) {\n        return new Result([\n            format(\n                'Added %s record %s -> %s',\n                response.data.result.type,\n                response.data.result.name,\n                response.data.result.content\n            )\n        ]);\n    });\n}\n"], ["mergeEmoticons", "\nfunction mergeEmoticons(child, index, parent) {\n    var siblings\n    var value\n    var siblingIndex\n    var node\n    var emoticon\n    var subvalue\n\n    \n    if (start.indexOf(toString(child).charAt(0)) !== -1) {\n        siblings = parent.children\n        siblingIndex = index\n        node = child\n        value = ''\n\n        while (node) {\n            if (value.length >= MAX_EMOTICON_LENGTH) {\n                return\n            }\n\n            subvalue = toString(node)\n\n            value += subvalue\n\n            \n            if (\n                node.type !== EMOTICON_NODE &&\n                end.indexOf(subvalue.charAt(subvalue.length - 1)) !== -1 &&\n                emoticons.indexOf(value) !== -1\n            ) {\n                emoticon = { type: EMOTICON_NODE, value: value }\n\n                if (child.position && node.position) {\n                    emoticon.position = {\n                        start: child.position.start,\n                        end: node.position.end\n                    }\n                }\n\n                siblings.splice(index, siblingIndex - index + 1, emoticon)\n\n                \n                return index - 1\n            }\n\n            node = siblings[++siblingIndex]\n        }\n    }\n}\n"], ["isRelated", "\nfunction isRelated(a, b) {\n  if (a.measurementAvg === b.measurementAvg) return true;\n  if (a.relatedNames &&\n      a.relatedNames.has(b.measurementAvg)) {\n    return true;\n  }\n  if (b.relatedNames &&\n      b.relatedNames.has(a.measurementAvg)) {\n    return true;\n  }\n  return false;\n}\n"], ["parseResponse", "\nfunction parseResponse(body) {\n    var pgt = '';\n    var result = body.match(/action=\"([\\s\\S]*?)\"/);\n    if (result) {\n        result = result[1];\n\n        var uri = url.parse(result, true);\n        var pathname = uri.pathname;\n\n        pgt = pathname.substr(pathname.lastIndexOf('/') + 1);\n    }\n\n    return pgt;\n}\n"], ["takingPropertiesFromDataGridNode", "\nfunction(profileDataGridNode) {\n    if (!profileDataGridNode)\n        return;\n\n    this.save();\n\n    var currentNode = profileDataGridNode;\n    var focusNode = profileDataGridNode;\n\n    while (currentNode.parent && (currentNode instanceof WebInspector.ProfileDataGridNode)) {\n        currentNode._takePropertiesFromProfileDataGridNode(profileDataGridNode);\n\n        focusNode = currentNode;\n        currentNode = currentNode.parent;\n\n        if (currentNode instanceof WebInspector.ProfileDataGridNode) {\n            currentNode._keepOnlyChild(focusNode);\n        }\n    }\n\n    this.children = [focusNode];\n    this.totalTime = profileDataGridNode.totalTime;\n}\n"], ["convertDataValue", "\nfunction converDataValue(value, dimInfo) {\n    \n    var dimType = dimInfo && dimInfo.type;\n    if (dimType === 'ordinal') {\n        \n        var ordinalMeta = dimInfo && dimInfo.ordinalMeta;\n        return ordinalMeta\n            ? ordinalMeta.parseAndCollect(value)\n            : value;\n    }\n\n    if (dimType === 'time'\n        \n        && typeof value !== 'number'\n        && value != null\n        && value !== '-'\n    ) {\n        value = +parseDate(value);\n    }\n\n    \n    \n    return (value == null || value === '')\n        ? NaN\n        \n        \n        : +value;\n}\n"], ["copyFromQueryBuilder", "\nfunction copyFromQueryBuilder(otherQueryBuilder) {\n    var qb = new QueryBuilder();\n    if (otherQueryBuilder != null) {\n        var clauseKeys = [\n            'whereClause', 'calculateClause', 'orderByClause',\n            'sliceClause', 'withOptionsClause'\n        ];\n        var isString = (typeof otherQueryBuilder === 'string' || otherQueryBuilder instanceof String);\n        var other = isString ?\n            JSON.parse(otherQueryBuilder) : otherQueryBuilder;\n        for (var i = 0; i < clauseKeys.length; i++) {\n            var key = clauseKeys[i];\n            var value = other[key];\n            if (value != null) {\n                \n                qb[key] = isString ? value : deepcopy(value);\n            }\n        }\n    }\n    return qb;\n}\n"], "```\n\nExplanation:\n- Each function is enclosed within tags that indicate its primary responsibility.\n- Some functions process multiple steps in service of a single larger task, so those steps are not individually tagged.\n- Functions that encapsulate a clear responsibility or task, like `isRelated`, are tagged without sub-segmentations because the whole code serves a singular purpose.\n- In functions with multiple responsibilities, or where the code could be split into clearly separate stages, different sections are not tagged separately since the responsibility is shared across the operations in the context of the specific task at hand."]