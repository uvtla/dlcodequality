[["dispatchKeyEvent", "\nfunction dispatchKeyEvent(keyCode, opt_modifiers) {\n    var mod = opt_modifiers || {};\n\n    angular.element(element).triggerHandler({\n      type: 'keydown',\n      keyCode: keyCode,\n      which: keyCode,\n      ctrlKey: mod.ctrl,\n      altKey: mod.alt,\n      metaKey: mod.meta,\n      shortKey: mod.shift\n    });\n}\n"], ["validateCertChain", "\nfunction validateCertChain(cert, cb) {\n  \n  <buildCertificateChain>\n  var certs = [];\n  while (cert && cert.issuerCertificate &&\n  (cert.fingerprint !== cert.issuerCertificate.fingerprint)) {\n    certs.push(cert);\n    cert = cert.issuerCertificate;\n  }\n  </buildCertificateChain>\n\n  \n  var errors = new Array(certs.length);\n\n  \n  var eachCallback = function(certs, index) {\n    var cert = certs[index];\n    validateCert(cert, function(err, data) {\n      completed++;\n      errors[index] = err;\n\n      \n      if (data) {\n        getOcspResponseCache().set(cert, data);\n      }\n\n      \n      if (completed === certs.length) {\n        \n        \n        for (var errorIndex = 0, length = errors.length;\n             errorIndex < length; errorIndex++) {\n          var error = errors[errorIndex];\n          if (error) {\n            break;\n          }\n        }\n        cb(error);\n      }\n    });\n  };\n\n  \n  var completed = 0;\n  for (var index = 0, length = certs.length; index < length; index++) {\n    eachCallback(certs, index);\n  }\n}\n"], ["getComponentForControl", "\nfunction (oControl) {\n  var oComponent = null;\n  var sComponentId = null;\n\n  \n  if (oControl) {\n    sComponentId = Utils._getComponentIdForControl(oControl);\n    if (sComponentId) {\n      oComponent = Utils._getComponent(sComponentId);\n    }\n  }\n\n  return oComponent;\n}\n"], ["isDynamicArrayAccess", "\nfunction isDynamicArrayAccess(node) {\n  return node && nodeType(node, exactMatch(nodeTypes.IDENTIFIER)) && (node.attributes.type.endsWith('[] storage ref') || node.attributes.type === 'bytes storage ref' || node.attributes.type === 'string storage ref')\n}\n"], ["mongoCompare", "\nfunction mongoCompare(a, b) {\n  \n\n  if (a === undefined) {\n    if (b === undefined) {\n      return 0;\n    }\n    return -1;\n  } else if (b === undefined) {\n    return 1;\n  }\n\n  if (a === null) {\n    if (b === null) {\n      return 0;\n    }\n    return -1;\n  } else if (b === null) {\n    return 1;\n  }\n\n  if (_.isNumber(a)) {\n    if (_.isNumber(b)) {\n      return a - b;\n    }\n    return -1;\n  } else if (_.isNumber(b)) {\n    return 1;\n  }\n\n  if (_.isString(a)) {\n    if (_.isString(b)) {\n      return a.localeCompare(b);\n    }\n    return -1;\n  } else if (_.isString(b)) {\n    return 1;\n  }\n\n  if (_.isObject(a) && !_.isDate(a)) {\n    if (_.isObject(b) && !_.isDate(b)) {\n      if (_.isEmpty(a)) {\n        return _.isEmpty(b) ? 0 : -1;\n      } else if (_.isEmpty(b)) {\n        return 1;\n      }\n\n      for (const key of _.union(_.keys(a), _.keys(b)).sort()) {\n        const av = a[key],\n          bv = b[key];\n\n        if (av === undefined) {\n          return 1;\n        } else if (bv === undefined) {\n          return -1;\n        }\n\n        const v = mongoCompare(av, bv);\n\n        if (v) {\n          return v;\n        }\n      }\n\n      return 0;\n    }\n    return -1;\n  } else if (_.isObject(b) && !_.isDate(b)) {\n    return 1;\n  }\n\n  if (_.isDate(a)) {\n    if (_.isDate(b)) {\n      return a.valueOf() - b.valueOf();\n    }\n    return -1;\n  } else if (_.isDate(b)) {\n    return 1;\n  }\n\n  \n  if (a < b) {\n    return -1;\n  } else if (a > b) {\n    return 1;\n  }\n\n  return 0;\n}\n"], ["requirifyImageReference", "\nfunction requirifyImageReference(markdownImageReference) {\n  const [, mdImageStart, mdImagePath, optionalMdTitle, mdImageEnd ] = imagePathRE.exec(markdownImageReference) || []\n  if (!mdImagePath) {\n    return JSON.stringify(markdownImageReference)\n  } else {\n    const imageRequest = loaderUtils.stringifyRequest(\n      this,\n      loaderUtils.urlToRequest(mdImagePath)\n    )\n    const mdImageTitleAndEnd = optionalMdTitle ? JSON.stringify(optionalMdTitle + mdImageEnd) : JSON.stringify(mdImageEnd)\n\n    return `${JSON.stringify(mdImageStart)} + require(${imageRequest}) + ${mdImageTitleAndEnd}`\n  }\n}\n"], ["deepFilterAndTransform", "\nfunction (obj, filter) {\n    var result = {};\n\n    \n    var walk = function (obj, filter, result, path, originObj) {\n        var elem\n            , arrResult;\n        if (!originObj) {\n            var originObj = obj;\n        }\n        if (!path) {\n            path = '';\n        }\n        if (_.isObject(obj) && !_.isRegExp(obj) && !_.isFunction(obj)) {\n            \n            if (_.isEmpty(obj)) {\n                result[path] = {}\n            }\n            else {\n                \n                for (var value in obj) {\n                    \n                    if (_.isObject(obj[value]) && !_.isRegExp(obj[value]) && !_.isFunction(obj[value]) && !['public', 'virtual', 'allow', 'deny', 'convert'].includes(value)) {\n                        if (_.isArray(obj[value])) {\n                            \n                            if (_.isEmpty((obj[value]))) {\n                                if (_.isEmpty(path)) {\n                                    elem = value;\n                                }\n                                else {\n                                    elem = path + '.' + value + '';\n                                }\n\n                                if (!result[elem]) {\n                                    result[elem] = [];\n                                }\n                            }\n                            else {\n                                \n                                for (var thisArrayElem in obj[value]) {\n                                    if (_.isEmpty(path)) {\n                                        elem = value;\n                                    }\n                                    else {\n                                        elem = path + '.' + value + ''; \n                                    }\n                                    if (!result[elem]) {\n                                        result[elem] = [];\n                                    }\n                                    arrResult = find(obj[value][thisArrayElem], filter);\n                                    \n                                    if (arrResult) {\n                                        (result[elem]).push(arrResult);\n                                    }\n                                }\n                            }\n                        }\n                        else {\n                            \n                            var subPath = _.isEmpty(path) ? value : path + '.' + value + '';\n\n                            \n                            if (!filter || value == filter) {\n                                if (path == '') {\n                                    try {\n                                        result[value] = eval('originObj' + generateObjectPath(value) + '');\n                                    } catch (e) {\n                                    }\n                                }\n                                else {\n                                    try {\n                                        result[path] = eval('originObj' + generateObjectPath(path) + '');\n                                    } catch (e) {\n                                    }\n                                }\n                            }\n\n                            result = walk(obj[value], filter, result, subPath, originObj);\n                        }\n                    }\n                    else {\n                        \n                        if (!filter || value == filter) {\n                            if (path == '') {\n                                try {\n                                    result[value] = eval('originObj' + generateObjectPath(value) + '');\n                                } catch (e) {\n                                }\n                            }\n                            else {\n                                try {\n                                    result[path] = eval('originObj' + generateObjectPath(path) + '');\n                                } catch (e) {\n                                }\n                            }\n                        }\n\n                    }\n                }\n            }\n        }\n\n        return result;\n    };\n\n    var resultArray = walk(obj, filter, result);\n    return _.isEmpty(resultArray) ? false : resultArray;\n}\n"], ["readToTTF", "\nfunction readToTTF(path) {\n    <convertFileToTTFObject>\n    let otf2ttfObj = TTF.otf2ttfobject\n    let ttfReader  = TTF.TTFReader\n    let woff2ttf   = TTF.woff2ttf\n    let ext = extname(path).toLowerCase()\n    let content = grunt.file.read(path, {encoding: null})\n    let ab = toArrayBuffer(content)\n    </convertFileToTTFObject>\n    switch(ext){\n        case '.otf':\n            return otf2ttfObj(ab)\n        case '.ttf':\n        case '.ttc':\n            return new ttfReader().read(ab)\n        case '.woff':\n        case '.woff2':\n            return ttfReader(woff2ttf(ab))\n        default:\n            throw new Error('Unsupported extension: '+ext)\n    }\n}\n"], ["renderCurrentTemplates", "\nfunction() {\n    <concatenateRenderedTemplates>\n    var buffer = '',\n        i = 0,\n        count = this._current_templates.length;\n\n    for (; i < count; i++) {\n        buffer += this._current_templates[i].render();\n    }\n    </concatenateRenderedTemplates>\n\n    return buffer;\n}\n"], ["justifyValue", "\nfunction(value, leftJustify, minWidth, precision, zeroPad) {\n    <adjustStringValue>\n    if (precision != null) {\n        value = value.slice(0, precision);\n    }\n    </adjustStringValue>\n    return justify(value, '', leftJustify, minWidth, zeroPad);\n}\n"], "```\n\nIn this set of annotations, each function is enclosed in tags named after the main responsibility represented by the respective function. These annotations indicate whether the functions are SRP compliant or not based on the given instructions. The major functionality within each function is tagged accordingly."]