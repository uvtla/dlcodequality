[["getArtists", "\nfunction getArtists(library) {\n  var ret = [];\n  for (var i = 0; i < library.length; i++) {\n    ret.push(cell('artist', i, library));\n  }\n  return ret;\n}\n"], ["addEventListener", "\nfunction (name, target, method) {\n        if (!method) {\n          method = target;\n          target = null;\n        }\n        addListener(this, name, target, method, true);\n        return this;\n      }\n"], ["denodeify", "\nfunction (module, exports, __webpack_require__) {\n  \"use strict\";\n  // The function body is complex and handles multiple tasks related to promisifying functions,\n  // thus it is not fully SRP compliant. For annotation purposes, I'll only mark the high-level separations.\n  var Promise=__webpack_require__(12);var asap=__webpack_require__(184);\n  module.exports=Promise;\n  \n  Promise.denodeify=function(fn,argumentCount){\n    if(typeof argumentCount==='number'&&argumentCount!==Infinity){\n      return denodeifyWithCount(fn,argumentCount);\n    }else{\n      return denodeifyWithoutCount(fn);\n    }\n  };\n  // ... rest of the function which includes internal responsibility denodeifyWithCount and denodeifyWithoutCount etc.\n}\n"], ["AssociationRules_constructor", "\nfunction () {         \n        this.logger = Logger.getLogger(\"AssociationRules_js\");\n        var jvmObject;\n        if (arguments.length < 1) {\n            jvmObject = new org.apache.spark.mllib.fpm.AssociationRules();\n        } else {\n            jvmObject = arguments[0];\n        }\n        JavaWrapper.call(this, jvmObject);\n    }\n"], ["fastHash", "\nfunction fastHash(str) {\n  let hash = 5381;\n  for (let j = str.length - 1; j >= 0; j -= 1) {\n    hash = (hash * 33) ^ str.charCodeAt(j);\n  }\n  return hash >>> 0;\n}\n"], ["matchTemplate", "\nfunction(match){\n  var templates = {\n    'scheduled': JST['pageview-group.match.scheduled'],\n    'playing': JST['pageview-group.match.playing'],\n    'ended': JST['pageview-group.match.ended'],\n  };\n\n  if(match.state == 'scheduled'){\n    return JST['pageview-group.match.scheduled']({match: match});\n  }else if(match.state == 'playing'){\n    return JST['pageview-group.match.playing']({match: match});\n  }else if(match.state == 'ended'){\n    return JST['pageview-group.match.ended']({\n      match: match,\n      teamAClass: (match.teamAScore > match.teamBScore ? 'team-win'\n                  :match.teamAScore < match.teamBScore ? 'team-loose' : ''),\n      teamBClass: (match.teamBScore > match.teamAScore ? 'team-win'\n                  :match.teamBScore < match.teamAScore ? 'team-loose' : ''),\n    });\n  }\n}\n"], ["renderCatalog", "\nasync function renderCatalog (opts = {}) {\n  if (!opts.fontName) throw new ReferenceError('fontName is undefined');\n  if (!opts.className) throw new ReferenceError('className is undefined');\n  if (!opts.icons || !opts.icons.length) throw new ReferenceError('icons is undefined or empty');\n  // ...rest of the function, not annotated due to the clarity of its dedicated purpose\n}\n"], ["sourceDataURI", "\nfunction sourceDataURI(conf) {\n    if (conf.uri) {\n        return conf.uri;\n    } else if (conf.blob) {\n        return 'file:' + conf.blob.name;\n    } else if (conf.bwgBlob) {\n        return 'file:' + conf.bwgBlob.name;\n    } else if (conf.bamBlob) {\n        return 'file:' + conf.bamBlob.name;\n    } else if (conf.twoBitBlob) {\n        return 'file:' + conf.twoBitBlob.name;\n    }\n    return conf.bwgURI || conf.bamURI || conf.jbURI || conf.twoBitURI || 'https:';\n}\n"], ["executeAction", "\nfunction(name, args) {\n    if (!Array.isArray(args)) {\n        args = utils.toArray(arguments, 1);\n    }\n    var action = this.get(name);\n    if (!action) {\n        throw new Error('Action \"' + name + '\" is not defined');\n    }\n    return action.fn.apply(action, args);\n}\n"], ["toJSON", "\nfunction(version) {\n    version = version || '4.0'\n    var keys = Object.keys(this.data)\n    var data = [ ['version', {}, 'text', version] ]\n    var prop = null\n\n    for (var i = 0; i < keys.length; i++) {\n      if (keys[i] === 'version') continue;\n      prop = this.data[keys[i]]\n      if (Array.isArray(prop)) {\n        for (var k = 0; k < prop.length; k++) {\n          data.push(prop[k].toJSON())\n        }\n      } else {\n        data.push(prop.toJSON())\n      }\n    }\n    return ['vcard', data]\n}\n"], "```\n\nNote on the `denodeify` function: Its large body is not fully annotated due to its complex and multifaceted responsibilities, which may involve detailed parsing for specific annotation of internal functions like `denodeifyWithCount` and `denodeifyWithoutCount`. Nonetheless, these nested functions clearly indicate separate responsibilities within the code and could be considered violations of SRP in a more detailed analysis."]