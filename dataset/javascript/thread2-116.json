[["anonymousFunction1", "\nfunction (e, point) {\n    <checkCrosshairExistence>\n    if (!this.crosshair) { return; }</checkCrosshairExistence>\n\n    <checkPointDefinedOrSnapCrosshair>\n    if ((defined(point) || !pick(this.crosshair.snap, true)) === false) {\n        this.hideCrosshair();\n        return;\n    }</checkPointDefinedOrSnapCrosshair>\n\n    var path,\n      options = this.crosshair,\n      animation = options.animation,\n      pos;\n\n    <setPositionBasedOnOptions>\n    if (!pick(options.snap, true)) {\n        pos = (this.horiz ? e.chartX - this.pos : this.len - e.chartY + this.pos);\n    } else if (defined(point)) {\n        \n        pos = (this.chart.inverted != this.horiz) ? point.plotX : this.len - point.plotY;\n        \n    }</setPositionBasedOnOptions>\n\n    <getPathForCrosshair>\n    if (this.isRadial) {\n        path = this.getPlotLinePath(this.isXAxis ? point.x : pick(point.stackY, point.y));\n    } else {\n        path = this.getPlotLinePath(null, null, null, null, pos);\n    }</getPathForCrosshair>\n\n    <checkPathNotNullAndHideCrosshair>\n    if (path === null) {\n        this.hideCrosshair();\n        return;\n    }</checkPathNotNullAndHideCrosshair>\n\n    <updateOrAddCrossElement>\n    if (this.cross) {\n        this.cross\n          .attr({ visibility: VISIBLE })[animation ? 'animate' : 'attr']({ d: path }, animation);\n    } else {\n        var attribs = {\n            'stroke-width': options.width || 1,\n            stroke: options.color || '#C0C0C0',\n            zIndex: options.zIndex || 2\n        };\n        if (options.dashStyle) {\n            attribs.dashstyle = options.dashStyle;\n        }\n        this.cross = this.chart.renderer.path(path).attr(attribs).add();\n    }</updateOrAddCrossElement>\n}\n"], ["extendPrototypeFunction", "\nfunction (p) {\n    var parent = ariaHtmlControllersSuggestions.prototype;\n    for (var key in parent) {\n        <copyParentProperties>\n        if (parent.hasOwnProperty(key) && !p.hasOwnProperty(key)) {\n            p[key] = parent[key];\n        }</copyParentProperties>\n    }\n}\n"], ["mapFunction", "\nfunction map(arr, iter) {\n    if (Immutable.Map.isMap(arr)) {\n        var type = 'Map';\n        if (Immutable.OrderedMap.isOrderedMap(arr)) {\n            type = 'OrderedMap';\n        }\n\n        <mapAsListConvertToType>\n        return mapAsList(arr, function(value, key) {\n            return Q(iter(value, key))\n            .then(function(result) {\n                return [key, result];\n            });\n        })\n        .then(function(result) {\n            return Immutable[type](result);\n        });</mapAsListConvertToType>\n    } else {\n        <mapAsListConvertToList>\n        return mapAsList(arr, iter)\n        .then(function(result) {\n            return Immutable.List(result);\n        });</mapAsListConvertToList>\n    }\n}\n"], ["readLayerFunction", "\nfunction readLayer(map, data, z) {\n    <createLayerAndSetRenderer>\n    var layer = new me.TMXLayer(data, map.tilewidth, map.tileheight, map.orientation, map.tilesets, z);\n    \n    layer.setRenderer(map.getRenderer());\n    </createLayerAndSetRenderer>\n    return layer;\n}\n"], ["jsonFieldCleanFunction", "\nfunction(json, fields) {\n    <checkJsonType>\n    if (((typeof json) === 'object') && !Array.isArray(json))\n      return hasFields(json,fields);\n    else if (Array.isArray(json)) {\n      var spliced = [];\n      var n = json.length;\n      while (n--)\n        <checkAndPushFields>\n        if (hasFields(json[n],fields))\n          spliced.push(json[n]);\n        </checkAndPushFields>\n\n      <returnSplicedOrFalse>\n      if (spliced.length)\n        return spliced;\n      else\n        return false;</returnSplicedOrFalse>\n    }\n    else\n      <logErrorOnBadData>\n      return console.error(new Error('Bad data passed to clean.forFields()'));</logErrorOnBadData>\n  }</checkJsonType>\n"], ["getSvnRevisionFunction", "\nfunction( target, options, callback ) {\n    if (typeof options === \"function\") {\n        <handleOptionsAsCallback>\n        callback = options;\n        options = null;\n        </handleOptionsAsCallback>\n    }\n    <setDefaultOptions>\n    options = options || {};</setDefaultOptions>\n    <retrieveInfoAndParseRevision>\n    info( target, options, function( err, data ) {\n        var rev;\n        if ( !err ) {\n            var revString;\n            if (options.lastChangeRevision) {\n                if (data && data.entry && data.entry.commit && data.entry.commit.$ && data.entry.commit.$.revision) {\n                    revString = data.entry.commit.$.revision;\n                }\n            } else {\n                if (data && data.entry && data.entry.$ && data.entry.$.revision) {\n                    revString = data.entry.$.revision;\n                }\n            }\n            if (revString !== undefined) {\n                try {\n                    rev = parseInt(revString, 10);\n                }\n                catch (err3) {\n                    err = 'Invalid revision value [' + revString + ']';\n                }\n            } else {\n                err = 'Could not parse info result to get revision [' + JSON.stringify(data) + ']';\n            }\n        }\n        callback(err, rev);\n    });\n    </retrieveInfoAndParseRevision>\n}\n"], ["decryptFunction", "\nfunction decrypt(userKey, chiperText) {\n    <validateInputs>\n    if (utils.isAnArray(userKey) &&\n      utils.isAnArray(chiperText)) {\n\n      userKey = new Uint8Array(userKey);\n      chiperText = new Uint8Array(chiperText);\n    } else {\n\n      throw 'Inputs must be an array';\n    }</validateInputs>\n    <prepareKey>\n    userKey = makeKey(userKey);</prepareKey>\n\n    var i, offset, cpt = [], tmpBlockDecrypt;\n    <decryptBlocks>\n    for (offset = 0; offset < chiperText.length; offset += 16) {\n\n      tmpBlockDecrypt = blockDecrypt(chiperText, offset, userKey);\n      for (i = 0; i < tmpBlockDecrypt.length; i += 1) {\n\n        cpt.push(tmpBlockDecrypt[i]);\n      }\n    }</decryptBlocks>\n\n    return cpt;\n}\n"], ["strategyConstructor", "\nfunction Strategy(options, verify) {\n    <validateOptionsAndVerify>\n    if (typeof options == 'function') {\n        verify = options;\n        options = {};\n    }\n\n    if (!verify) throw new Error('userapp authentication strategy requires a verify function');\n    if (!options.appId) throw new Error('userapp strategy requires an app id');</validateOptionsAndVerify>\n\n    <initializeStrategyProperties>\n    this._appId = options.appId;\n    this._usernameField = options.usernameField || 'username';\n    this._passwordField = options.passwordField || 'password';\n    this._sessionCookie = options.sessionCookie || 'ua_session_token';\n    this._realm = options.realm || 'Users';</initializeStrategyProperties>\n\n    <callPassportStrategy>\n    passport.Strategy.call(this);</callPassportStrategy>\n    this.name = 'userapp';\n    this._verify = verify;\n\n    <initializeUserApp>\n    UserApp.initialize({ appId: this._appId });</initializeUserApp>\n}\n"], ["persistentStorageConstructor", "\nfunction PersistentStorage(namespace, override) {\n  <initializeStorageKeys>\n  this.prefix = ['__', namespace, '__'].join('');\n  this.ttlKey = '__ttl__';\n  this.keyMatcher = new RegExp('^' + _.escapeRegExChars(this.prefix));</initializeStorageKeys>\n\n  \n  <setStorageImplementation>\n  this.ls = override || LOCAL_STORAGE;</setStorageImplementation>\n\n  \n  <checkLocalStorageAvailability>\n  !this.ls && this._noop();</checkLocalStorageAvailability>\n}\n"], ["gruntYakTaskFunction", "\nfunction gruntYakTask(grunt) {\n    'use strict';\n\n    <initializeFilesToUpload>\n    let filesToUpload = [];</initializeFilesToUpload>\n\n    \n    let requestSender;\n\n    <registerGruntTask>\n    grunt.registerMultiTask('yakjs', 'A grunt task to update the YAKjs via rest API.', function task() {\n        <asyncTaskCompletionHandle>\n        let done = this.async();</asyncTaskCompletionHandle>\n\n        <setTaskOptions>\n        let options = this.options(new TaskOptions());</setTaskOptions>\n\n        filesToUpload = [];\n\n        <collectFilesToUpload>\n        this.files.forEach(file => {\n            filesToUpload = filesToUpload.concat(file.src);\n        });</collectFilesToUpload>\n\n        let logger = {\n            log: grunt.log.writeln,\n            error: grunt.log.error\n        };\n\n        <uploadFilesProcess>\n        uploadFiles(filesToUpload, options, logger)\n            .then(() => {\n                grunt.log.writeln('');\n                grunt.log.ok('All files uploaded.');\n            })</uploadFilesProcess>\n            <clearModuleCacheProcess>\n            .then(() => {\n                return clearModuleCache(options, logger);\n            })</clearModuleCacheProcess>\n            <startInstancesProcess>\n            .then(() => {\n                return startInstances(options, logger);\n            })</startInstancesProcess>\n            .then(done)\n            .catch((message, error) => {\n                <handleTaskErrors>\n                grunt.log.writeln('');\n                grunt.log.error(JSON.stringify(message, null, 4));\n                grunt.fatal('One or more files could not be uploaded.');\n                done();</handleTaskErrors>\n            });\n    });</registerGruntTask>\n}\n"], "```"]