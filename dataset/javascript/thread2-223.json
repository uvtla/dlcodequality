[["assertObject", "\nfunction assertObject(attr, data) {\n  <inputValidation>\n  if (data === null || data === undefined) {\n    return null;\n  }\n\n  if (typeof data !== 'object' || Array.isArray(data)) {\n    throw new ParseError(`Attribute ${attr} must be of type \"object\"`);\n  }\n  </inputValidation>\n\n  return data;\n}\n"], ["setHue", "\nfunction setHue(hue: number | string, color: string): string {\n  <hueSetting>\n  if (color === 'transparent') return color\n  return toColorString({\n    ...parseToHsl(color),\n    hue: parseFloat(hue),\n  })\n  </hueSetting>\n}\n"], ["sanitizeField", "\nfunction sanitizeField (sanitizations, value, rules) {\n  let result = value\n\n  <sanitizationProcess>\n  rules.forEach((rule) => {\n    const ruleFn = snakeToCamelCase(rule.name)\n    if (typeof (sanitizations[ruleFn]) !== 'function') {\n      throw new Error(`${ruleFn} is not a sanitization method`)\n    }\n    result = sanitizations[ruleFn](result, rule.args)\n  })\n  </sanitizationProcess>\n\n  return result\n}\n"], ["resolveDependencies", "\nfunction resolveDependencies(binds, obj) {\n  <dependencyResolution>\n  let slotset = context[context.length - 1];\n  for (let key in injections) {\n    if (binds && injections[key] in binds) {\n      obj[key] = binds[injections[key]];\n      continue;\n    }\n\n    let slot = slotset[injections[key]];\n    let policy = slot.getViable(key, tags[key], multiple[key]);\n    if (!multiple[key])\n      obj[key] = policy([]);\n    else {\n      let out = obj[key] = [];\n      for (let i = 0; i < policy.length; ++i)\n        out[i] = policy[i]([]);\n    }\n  }\n  </dependencyResolution>\n}\n"], ["startPoll", "\nfunction startPoll(mode, callback) {\n  <pollingSetup>\n  var channel = (mode >> 4) & 7;\n  channels[channel].poller = setInterval(function () { read(mode, callback) },\n    channels[channel].timeout);\n  </pollingSetup>\n}\n"], ["handleRequestBody", "\nfunction handleRequestBody(request) {\n  var body = \"\";\n  <dataConcatenation>\n  request.on('data', function(chunk) {\n    body += chunk.toString();\n  });\n  </dataConcatenation>\n  return new Promise(function (fulfill, reject) {\n    <promiseResolution>\n    request.on('end', function () {\n      fulfill(body);\n    });\n    </promiseResolution>\n  });\n}\n"], ["calculateFlowLayout", "\nfunction (flowOrientation, numberOfRows, numberOfCols, noItems) {\n  <layoutCalculation>\n  var numItemsLastCol;\n\n  /* Conditional structure handles vertical/horizontal flow layouts uniquely */\n  // ... existing code ...\n  </layoutCalculation>\n\n  <jsonValueSetting>\n  this.json.setValue(this._data, \"numberOfRows\", numberOfRows);\n  this.json.setValue(this._data, \"numberOfColumns\", numberOfCols);\n  </jsonValueSetting>\n}\n"], ["_fnLog", "\nfunction _fnLog(oSettings, iLevel, sMesg) {\n  <logging>\n  var sAlert = (oSettings === null) ?\n    \"DataTables warning: \" + sMesg :\n    \"DataTables warning (table id = '\" + oSettings.sTableId + \"'): \" + sMesg;\n\n  if (iLevel === 0) {\n    if (DataTable.ext.sErrMode == 'alert') {\n      alert(sAlert);\n    } else {\n      throw new Error(sAlert);\n    }\n    return;\n  } else if (window.console && console.log) {\n    console.log(sAlert);\n  }\n  </logging>\n}\n"], ["registerCommands", "\nfunction (verbs, patterns, method) {\n  <commandRegistration>\n  if (!verbs.each) verbs = [verbs];\n\n  if (!patterns.each) { patterns = [patterns]; }\n  method = method || this['do_' + verbs[0]];\n  if (!method) { return false; }\n\n  if (method.length) { method = this[method]; }\n  this.commands.push({\n    'verbs': verbs,\n    'syntax': patterns,\n    'handler': method\n  });\n  </commandRegistration>\n}\n"], ["isRunning", "\nasync function isRunning(address) {\n  <serviceCheck>\n  try {\n    await call(address, {\n      url: '/gateway',\n      timeout: 6e5,\n    })\n    return true\n  } catch (e) {\n    return false\n  }\n  </serviceCheck>\n}\n"], "```\n\nIn the `<calculateFlowLayout>` function, I have separated `<layoutCalculation>` and `<jsonValueSetting>` as different responsibilities since the former calculates the layout, which is a separate responsibility from setting values in an object. Please let me know if you require a more granular breakdown within the layout calculation logic."]