[["watcher", "\nfunction watcher (specs, options) {\n  <validateSpecs>\n  const err = fileOptions.validate(specs);\n  if (err) {\n    return Promise.reject(err);\n  }\n  </validateSpecs>\n  <createWatcher>\n  const w = new Watcher(fileOptions.normalize(specs), options || {});\n  return w._promise.then(() => w);\n  </createWatcher>\n}\n"], ["emitEvent", "\nfunction() {\n  <checkAndEmitEndEvent>\n  if (self._eventEmitter && (self._emittedEnd === false)) {\n    self._emittedEnd = true;\n    self._eventEmitter.emit('end');\n  }\n  </checkAndEmitEndEvent>\n  <resolvePromise>\n  resolve();\n  </resolvePromise>\n}\n"], ["reformatUpdateProperty", "\nfunction reformatUpdateProperty(next) {\n  <processDocumentUpdate>\n  const document = this._update['$set'];\n  if (document) {\n    paths.forEach(function(path) {\n      try {\n        const splitted = path.path.split('.');\n        const key      = splitted.shift();\n        if (document[key] === undefined) { return; }\n        const value   = determineValue(splitted, document[key]);\n        document[key] = nest(splitted, value);\n      } catch (error) { return next(error); }\n    });\n  }\n  </processDocumentUpdate>\n  <callNextFunction>\n  next();\n  </callNextFunction>\n}\n"], ["parseUrlHashParameters", "\nfunction(){\n  <extractHashParameters>\n  var url = window.location.href;\n  var vars = {};\n  var hashes = url.slice(url.indexOf('#') + 1).split('&');\n  for(var i = 0; i < hashes.length; i++) {\n      var hash = hashes[i].split('=');\n      if(hash.length > 1) {\n          vars[hash[0]] = hash[1];\n      } else {\n          vars[hash[0]] = null;\n      }\n  }\n  </extractHashParameters>\n  <returnVariables>\n  return vars;\n  </returnVariables>\n}\n"], ["dispatch", "\nfunction dispatch(event) {\n  <initializeHandlers>\n  const asterisk = _handlers['*'];\n  let key = event.keyCode || event.which || event.charCode;\n  </initializeHandlers>\n\n  <trackDownKeys>\n  if (_downKeys.indexOf(key) === -1 && key !== 229) _downKeys.push(key);\n  </trackDownKeys>\n\n  <normalizeKey>\n  if (key === 93 || key === 224) key = 91;\n  </normalizeKey>\n\n  <updateModifierKeys>\n  if (key in _mods) {\n    _mods[key] = true;\n    for (const k in _modifier) {\n      if (_modifier[k] === key) hotkeys[k] = true;\n    }\n    if (!asterisk) return;\n  }\n  </updateModifierKeys>\n\n  <setModifiersState>\n  for (const e in _mods) {\n    if (Object.prototype.hasOwnProperty.call(_mods, e)) {\n      _mods[e] = event[modifierMap[e]];\n    }\n  }\n  </setModifiersState>\n\n  <filterKey>\n  if (!hotkeys.filter.call(this, event)) return;\n  </filterKey>\n\n  <getScopeAndCheckAsterisk>\n  const scope = getScope();\n  if (asterisk) {\n    for (let i = 0; i < asterisk.length; i++) {\n      if (asterisk[i].scope === scope && ((event.type === 'keydown' && !asterisk[i].keyup) || (event.type === 'keyup' && asterisk[i].keyup))) {\n        eventHandler(event, asterisk[i], scope);\n      }\n    }\n  }\n  </getScopeAndCheckAsterisk>\n\n  <checkHandlersAndExecute>\n  if (!(key in _handlers)) return;\n  for (let i = 0; i < _handlers[key].length; i++) {\n    if ((event.type === 'keydown' && _handlers[key][i].keydown) || (event.type === 'keyup' && _handlers[key][i].keyup)) {\n      if (_handlers[key][i].key) {\n        const keyShortcut = _handlers[key][i].key.split('+');\n        let _downKeysCurrent = []; \n        for (let a = 0; a < keyShortcut.length; a++) {\n          _downKeysCurrent.push(code(keyShortcut[a]));\n        }\n        _downKeysCurrent = _downKeysCurrent.sort();\n        if (_downKeysCurrent.join('') === _downKeys.sort().join('')) {\n          eventHandler(event, _handlers[key][i], scope);\n        }\n      }\n    }\n  }\n  </checkHandlersAndExecute>\n}\n"], ["getAllCommands", "\nfunction getAllCommands() {\n    <prepareResourceTypes>\n    let resourceTypes = [];\n    let tables = {};\n    operations.forEach((operation) => {\n        let opCategory = operation.target[0];\n        if (resourceTypes.indexOf(opCategory) < 0) {\n            resourceTypes.push(opCategory);\n            tables[opCategory] = [];\n        }\n        tables[opCategory].push([chalk.cyan.bold(operation.command), operation.description]);\n    });\n    resourceTypes.sort();\n    </prepareResourceTypes>\n\n    <generateSections>\n    let sections = [];\n    for (let resourceType of resourceTypes) {\n        tables[resourceType].sort((a, b) => a[0].localeCompare(b[0]));\n        sections.push({\n            head: chalk.white.bold(resourceType),\n            table: tables[resourceType]\n        });\n    }\n    </generateSections>\n\n    <returnSections>\n    return sections;\n    </returnSections>\n}\n"], ["setTargetsValue", "\nfunction setTargetsValue(targets, properties) {\n  <animateTargets>\n  const animatables = getAnimatables(targets);\n  animatables.forEach(animatable => {\n    for (let property in properties) {\n      const value = getFunctionValue(properties[property], animatable);\n      const target = animatable.target;\n      const valueUnit = getUnit(value);\n      const originalValue = getOriginalTargetValue(target, property, valueUnit, animatable);\n      const unit = valueUnit || getUnit(originalValue);\n      const to = getRelativeValue(validateValue(value, unit), originalValue);\n      const animType = getAnimationType(target, property);\n      setProgressValue[animType](target, property, to, animatable.transforms, true);\n    }\n  });\n  </animateTargets>\n}\n"], ["setGeckoEditingOptions", "\nfunction setGeckoEditingOptions() {\n  <setEditorOptions>\n  function setOpts() {\n    <refreshAndSetCommands>\n    refreshContentEditable();\n    setEditorCommandState(\"StyleWithCSS\", false);\n    setEditorCommandState(\"enableInlineTableEditing\", false);\n    </refreshAndSetCommands>\n\n    <disableObjectResizing>\n    if (!settings.object_resizing) {\n      setEditorCommandState(\"enableObjectResizing\", false);\n    }\n    </disableObjectResizing>\n  }\n  </setEditorOptions>\n\n  <addEditorEventListeners>\n  if (!settings.readonly) {\n    editor.on('BeforeExecCommand MouseDown', setOpts);\n  }\n  </addEditorEventListeners>\n}\n"], ["_visitSpecializations", "\nfunction _visitSpecializations(entities, visitedEntities) {\n  <traverseSpecializations>\n  for (var entityName in entities) {\n    if (!visitedEntities.hasOwnProperty(entityName)) {\n      visitedEntities[entityName] = entities[entityName];\n      _visitSpecializations(\n        entities[entityName].directSpecializations,\n        visitedEntities\n      );\n    }\n  }\n  </traverseSpecializations>\n}\n"], ["mergeRoomsIfDifferent", "\nfunction(cell1,cell2){\n\t<checkRooms>\n\tif(!cell1.room || !cell2.room || cell1.room===cell2.room){ return;}\n\t</checkRooms>\n\t<identifyTopCells>\n\tvar merged, keep;\n\tvar tcell1 = cell1.room.top;\n\tvar tcell2 = cell2.room.top;\n\tif(tcell1.bx>tcell2.bx || (tcell1.bx===tcell2.bx && tcell1.by>tcell2.by)){ merged = tcell1; keep = tcell2;}\n\telse                                                                     { merged = tcell2; keep = tcell1;}\n\t</identifyTopCells>\n\n\t<mergeValuesAndRedraw>\n\tif(merged.isNum()){\n\t\tif(keep.noNum()){\n\t\t\tkeep.setQnum(merged.qnum);\n\t\t\tkeep.draw();\n\t\t}\n\t\tmerged.setQnum(-1);\n\t\tmerged.draw();\n\t}\n\t</mergeValuesAndRedraw>\n}\n"], "```"]