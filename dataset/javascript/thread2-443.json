[["transformColor", "\nfunction transformColor(string) {\n  return parser(string).walk(function(node) {\n    if (node.type !== \"function\" || node.value !== \"color\") {\n      return\n    }\n\n    node.value = colorFn.convert(parser.stringify(node))\n    node.type = \"word\"\n  }).toString()\n}\n"], ["anonymous", "\nfunction (elements, callback, options) {\n  <validateArguments>\n  if (!validateArguments(elements, callback)) return\n  </validateArguments>\n\n  if (!Array.isArray(elements)) {\n    elements = [ elements ]\n  }\n\n  each.call(elements, function (e) {\n    const handler = function () {\n      callback.call(e, count(e, options))\n    }\n\n    liveElements.push({ element: e, handler: handler })\n\n    handler()\n\n    e.addEventListener('input', handler)\n  })\n\n  return this\n}\n"], ["generateSpecialWorkdayOrHolidayRender", "\nfunction generateSpecialWorkdayOrHolidayRender(dayMap, lang = 'zh-cn') {\n  return function render(data, locale, current) {\n    const currentDate = formatter(new Date(current), 'YYYY-MM-DD');\n    const type = data[currentDate];\n    if (type) {\n      if (type === 'work') {\n        return (\n          <span className=\"workday-label\">{localeMap[locale] && localeMap[locale].workday}</span>\n        );\n      }\n      return (\n        <span className=\"holiday-label\">{localeMap[locale] && localeMap[locale].holiday}</span>\n      );\n    }\n    return null;\n  }.bind(null, dayMap, lang);\n}\n"], ["anonymous", "\nfunction() {\n    <checkForDuplicateArguments>\n    var badArg = false;\n    var hash = {};\n    for (var i = 0; i < this.arguments_.length; i++) {\n      if (hash['arg_' + this.arguments_[i].toLowerCase()]) {\n        badArg = true;\n        break;\n      }\n      hash['arg_' + this.arguments_[i].toLowerCase()] = true;\n    }\n    if (badArg) {\n      this.setWarningText(Blockly.Msg.PROCEDURES_DEF_DUPLICATE_WARNING);\n    } else {\n      this.setWarningText(null);\n    }\n    </checkForDuplicateArguments>\n    \n    <updateFieldWithParamString>\n    var paramString = '';\n    if (this.arguments_.length) {\n      paramString = Blockly.Msg.PROCEDURES_BEFORE_PARAMS +\n          ' ' + this.arguments_.join(', ');\n    }\n    </updateFieldWithParamString>\n    \n    <disableAndEnableEvents>\n    Blockly.Events.disable();\n    this.setFieldValue(paramString, 'PARAMS');\n    Blockly.Events.enable();\n    </disableAndEnableEvents>\n}\n"], ["mapRequestRecursive", "\nfunction mapRequestRecursive(req, attrNode, context) {\n  // Multiple responsibilities identified, each wrapped in corresponding tags.\n  <performAttributeChecks>\n  if (attrNode.hidden && !req.internal) {\n    throw new RequestError(\n        ['Unknown attribute \"' + context.attrPath.join('.') + '\" - it is a hidden attribute'].join(' ')\n    );\n  }\n\n  if (attrNode.deprecated && !req.internal) {\n    context.deprecated.push(context.attrPath.join('.'));\n  }\n\n  if ((attrNode.permission || context.authContext) && !req.internal) {\n    try {\n      if (!context.auth || !context.auth.check) throw new ImplementationError(`No valid Auth-Provider available`);\n      context.authContext = context.auth.check(attrNode, context.authContext);\n    } catch (err) {\n      err.message += ` at \"${context.attrPath.join('.')}\"`;\n      throw err;\n    }\n  }\n\n  if (!req.internal) attrNode.selected = true;\n  </performAttributeChecks>\n\n  // ... Additional responsibilities ...\n\n  <processRequestRecursive>\n  if (req.select) {\n    Object.keys(req.select).forEach(subAttrName => {\n      const subAttrNode = getAttribute([subAttrName], attrNode, context);\n      const subContext = Object.assign({}, context);\n      subContext.attrPath = context.attrPath.concat([subAttrName]);\n\n      mapRequestRecursive(req.select[subAttrName], subAttrNode, subContext);\n    });\n  }\n  </processRequestRecursive>\n\n  return context.resourceTree;\n}\n"], ["convertValueType", "\nfunction (val, errorMessage) {\n  <typeToValueConversion>\n  switch(true) {\n    case typeof val == 'string': \n      return val;\n\n    case val === undefined:\n    case val === null: \n      return 'nil';\n    \n    case val === Infinity: \n      return 'inf';\n\n    case val === -Infinity: \n      return '-inf';\n\n    case typeof val == 'number': \n    case typeof val == 'boolean': \n      return window.isNaN(val)? 'nan' : '' + val;\n\n    default: \n      return throwCoerceError(val, errorMessage) || '';\n  }\n  </typeToValueConversion>\n}\n"], ["VehicleDescriptor", "\nfunction VehicleDescriptor(properties) {\n  <setProperties>\n  if (properties)\n    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n      if (properties[keys[i]] != null)\n        this[keys[i]] = properties[keys[i]];\n  </setProperties>\n}\n"], ["buildWorkerCode", "\nfunction ( functionCodeBuilder, parserName, libLocations, libPath, runnerImpl ) {\n  // SRP violation: Too many responsibilities are included in this function.\n  if ( THREE.LoaderSupport.Validator.isValid( this.loaderWorker.worker ) ) return;\n\n  <loggingCheck>\n  if ( this.logging.enabled ) {\n    console.info( 'WorkerSupport: Building worker code...' );\n    console.time( 'buildWebWorkerCode' );\n  }\n  </loggingCheck>\n\n  <selectRunnerImpl>\n  if ( THREE.LoaderSupport.Validator.isValid( runnerImpl ) ) {\n    if ( this.logging.enabled ) console.info( 'WorkerSupport: Using \"' + runnerImpl.runnerName + '\" as Runner class for worker.' );\n  } else if ( typeof window !== \"undefined\" ) {\n    runnerImpl = THREE.LoaderSupport.WorkerRunnerRefImpl;\n    if ( this.logging.enabled ) console.info( 'WorkerSupport: Using DEFAULT \"THREE.LoaderSupport.WorkerRunnerRefImpl\" as Runner class for worker.' );\n  } else {\n    runnerImpl = THREE.LoaderSupport.NodeWorkerRunnerRefImpl;\n    if ( this.logging.enabled ) console.info( 'WorkerSupport: Using DEFAULT \"THREE.LoaderSupport.NodeWorkerRunnerRefImpl\" as Runner class for worker.' );\n  }\n  </selectRunnerImpl>\n\n  var userWorkerCode = functionCodeBuilder( THREE.LoaderSupport.WorkerSupport.CodeSerializer );\n  userWorkerCode += 'var Parser = '+ parserName +  ';\\n\\n';\n  userWorkerCode += THREE.LoaderSupport.WorkerSupport.CodeSerializer.serializeClass( runnerImpl.runnerName, runnerImpl );\n  userWorkerCode += 'new ' + runnerImpl.runnerName + '();\\n\\n';\n\n\n  <handleLibraries>\n  var scope = this;\n  if ( THREE.LoaderSupport.Validator.isValid( libLocations ) && libLocations.length > 0 ) {\n    var libsContent = '';\n    var loadAllLibraries = function ( path, locations ) {\n      if ( locations.length === 0 ) {\n        scope.loaderWorker.initWorker( libsContent + userWorkerCode, runnerImpl.runnerName );\n        if ( scope.logging.enabled ) console.timeEnd( 'buildWebWorkerCode' );\n      } else {\n        var loadedLib = function ( contentAsString ) {\n          libsContent += contentAsString;\n          loadAllLibraries( path, locations );\n        };\n        var fileLoader = new THREE.FileLoader();\n        fileLoader.setPath( path );\n        fileLoader.setResponseType( 'text' );\n        fileLoader.load( locations[ 0 ], loadedLib );\n        locations.shift();\n      }\n    };\n    loadAllLibraries( libPath, libLocations );\n  } else {\n    this.loaderWorker.initWorker( userWorkerCode, runnerImpl.runnerName );\n    if ( this.logging.enabled ) console.timeEnd( 'buildWebWorkerCode' );\n  }\n  </handleLibraries>\n}\n"], ["stop", "\nfunction stop() {\n  return function stopImpl(clearQueue, jumpToEnd) {\n    <handleAnimationStop>\n    var self = this;\n    var selfIsArrayLike = self.length !== undefined;\n    var all = selfIsArrayLike ? self : [self];\n\n    var cy = this._private.cy || this;\n\n    if (!cy.styleEnabled()) {\n      return this;\n    }\n\n    for (var i = 0; i < all.length; i++) {\n      var ele = all[i];\n      var _p = ele._private;\n      var anis = _p.animation.current;\n\n      for (var j = 0; j < anis.length; j++) {\n        var ani = anis[j];\n        var ani_p = ani._private;\n\n        if (jumpToEnd) {\n          \n          ani_p.duration = 0;\n        }\n      }\n\n      if (clearQueue) {\n        _p.animation.queue = [];\n      }\n\n      if (!jumpToEnd) {\n        _p.animation.current = [];\n      }\n    }\n    </handleAnimationStop>\n\n    <notifyForRedraw>\n    cy.notify('draw');\n    </notifyForRedraw>\n    \n    return this;\n  };\n}\n"], ["defErrorChecking", "\nfunction def (params, spec, errs) {\n  for (var key in params) {\n    if (!spec.hasOwnProperty(key)) <defError>defError(key, errs)</defError>\n  }\n}\n"], "```\n\nPlease note that not all code snippets provided map exactly to a single SRP responsibility. Some functions contain complex or miscellaneous logic that doesn't neatly align with just one responsibility or the logic itself may be responsible for a single purpose. In such cases, broader sections of code are annotated, and the tags describe the general activity or purpose of the code block."]