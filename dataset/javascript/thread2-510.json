[["fuseAnnotation", "\nfunction fuseAnnotation(tx, annos) {\n  <inputValidation>\n  if (!isArray(annos) || annos.length < 2) {\n    throw new Error('fuseAnnotation(): at least two annotations are necessary.')\n  }\n  </inputValidation>\n  let sel, annoType\n  <processAnnotations>\n  annos.forEach(function(anno, idx) {\n    if (idx === 0) {\n      sel = anno.getSelection()\n      annoType = anno.type\n    } else {\n      if (anno.type !== annoType) {\n        throw new Error('fuseAnnotation(): all annotations must be of the same type.')\n      }\n      sel = sel.expand(anno.getSelection())\n    }\n  })\n  </processAnnotations>\n\n  <deleteAndExpandAnnotations>\n  for (var i = 1; i < annos.length; i++) {\n    tx.delete(annos[i].id)\n  }\n  expandAnnotation(tx, annos[0], sel)\n  tx.setSelection(sel)\n  </deleteAndExpandAnnotations>\n}\n"], ["anonymousFunction", "\nfunction(query, mongooseQuery, attributesFilter, associations, model, logger) {\n  <initializeLogger>\n  const Log = logger.bind()\n  </initializeLogger>\n  <handleEmbedding>\n  if (query.$embed) {\n    if (!Array.isArray(query.$embed)) {\n      query.$embed = query.$embed.split(',')\n    }\n    query.$embed.forEach(function(embed) {\n      let embeds = embed.split('.')\n      let populate = {}\n\n      populate = nestPopulate(\n        query,\n        populate,\n        0,\n        embeds,\n        associations,\n        model,\n        Log\n      )\n\n      mongooseQuery.populate(populate)\n\n      attributesFilter = attributesFilter + ' ' + embeds[0]\n    })\n    delete query.$embed\n    delete query.populateSelect\n  }\n  </handleEmbedding>\n  return { mongooseQuery: mongooseQuery, attributesFilter: attributesFilter }\n}\n"], ["webpackRequireWrapper", "\nfunction(module, exports, __webpack_require__) {\n  <exportDataView>\n  var $export = __webpack_require__(269);\n  $export($export.G + $export.W + $export.F * !__webpack_require__(480).ABV, {\n    DataView: __webpack_require__(481).DataView\n  });\n  </exportDataView>\n}\n"], ["getObjectValue", "\nfunction get(obj, key) {\n  var i, accessor = key.split('.'), empty = true;\n  <navigateObject>\n  for (i = 0; i < accessor.length; i++) {\n\n    if (!obj) return '';\n    obj = obj[accessor[i]];\n  }\n  </navigateObject>\n\n  <handleEmptyValues>\n  if (obj === undefined || obj === null || obj === false) return '';\n\n  if (obj instanceof Array && obj.length == 0) return '';\n  if (obj.constructor === Object) {\n    for (i in obj)\n      if (obj.hasOwnProperty(i)) empty = !i;\n    if (empty) return '';\n  }\n  </handleEmptyValues>\n  return obj;\n}\n"], ["validateInputParameters", "\nfunction validate({ separator, transformer }) {\n  <validateSeparator>\n  if (null != separator) {\n    if ('string' !== typeof separator) {\n      throw new Error(`The separator must be a string: \"${separator}\".`)\n    } else if (INVALID_SEPARATOR.test(separator)) {\n      throw new Error(`The separator has invalid characters: \"${separator}\".`)\n    }\n  }\n  </validateSeparator>\n\n  <validateTransformer>\n  if (null != transformer) {\n    if (false !== transformer\n      && 'function' !== typeof transformer\n      && !defaultTransformers[transformer]\n    ) {\n      throw new Error(`The transformer must be a function: \"${transformer}\".`)\n    }\n  }\n  </validateTransformer>\n}\n"], ["onloadConfiguration", "\nfunction onload(app, options) {\n  <initializeContext>\n  ctx.app = app;\n  ctx.options = options || {};\n  </initializeContext>\n\n  <setupOptions>\n  const config = app.c();\n  options.logDir = options.logDir || path.join(process.cwd(), 'logs');\n  ensureLogDir(options.logDir);\n  </setupOptions>\n\n  <configureTransportsAndHandlers>\n  const transports = options.transports || [\n    new winston.transports.Console({\n      humanReadableUnhandledException: true,\n      colorize: true,\n      json: false\n    }),\n    new winston.transports.File({\n      filename: path.join(options.logDir, 'error.log'),\n      level: 'error',\n      colorize: true,\n      maxsize: 20971520,\n      maxFiles: 5\n    }),\n    new winston.transports.File({\n      filename: path.join(options.logDir, 'combined.log'),\n      colorize: true,\n      maxsize: 52428800,\n      maxFiles: 5\n    })\n  ];\n  const exceptionHandlers = options.exceptionHandlers || [\n    new winston.transports.File({\n      filename: path.join(options.logDir, 'exceptions.log'),\n      colorize: true,\n      maxsize: 20971520,\n      maxFiles: 5\n    }),\n  ];\n  </configureTransportsAndHandlers>\n\n  <setupFormatterAndLogger>\n  const formatter = (typeof options.formatter === 'function') ? options.formatter :\n    info => `${new Date(info.timestamp).toLocaleString()} [${info.label}] ${info.level}: ${info.message}`;\n  const opts = options.logOpts || {\n    level: 'info',\n    format: combine(\n      label({ label: config.name || 'ibird' }),\n      timestamp(),\n      printf(formatter)\n    ),\n    transports,\n    exceptionHandlers\n  };\n  const logger = winston.createLogger(opts);\n  app.config({ logger });\n  </setupFormatterAndLogger>\n\n  <bindLoggingMethods>\n  Object.assign(api, {\n    error: logger.error.bind(logger),\n    warn: logger.warn.bind(logger),\n    info: logger.info.bind(logger),\n    verbose: logger.verbose.bind(logger),\n    debug: logger.debug.bind(logger),\n    silly: logger.silly.bind(logger)\n  });\n  </bindLoggingMethods>\n}\n"], ["sanitizeFunctionCall", "\nfunction sanitizeFunctionCall(tokens, start) {\n  <initializeParsing>\n  var parenDepth = 1, end = start + 1, n = tokens.length;\n  while (end < n && parenDepth) {\n    var token = tokens[end++];\n\n    parenDepth += (token === ')' ? -1 : /^[^\"']*\\($/.test(token));\n  }\n  </initializeParsing>\n\n  <sanitizeAndReturn>\n  if (!parenDepth) {\n    var fnToken = tokens[start].toLowerCase();\n    var bareFnToken = withoutVendorPrefix(fnToken);\n\n    var fnTokens = tokens.splice(start, end - start, '');\n    var fns = propertySchema['cssFns'];\n\n    for (var i = 0, nFns = fns.length; i < nFns; ++i) {\n      if (fns[i].substring(0, bareFnToken.length) == bareFnToken) {\n        fnTokens[0] = fnTokens[fnTokens.length - 1] = '';\n\n        sanitize(\n          fns[i],\n\n          fnTokens,\n          opt_naiveUriRewriter, opt_baseUri);\n\n        return fnToken + fnTokens.join(' ') + ')';\n      }\n    }\n  }\n  </sanitizeAndReturn>\n  return '';\n}\n"], ["changesDbFunction", "\nfunction changesDb(dbName, qs0, callback0) {\n  <extractOptions>\n  const { opts, callback } = getCallback(qs0, callback0)\n  </extractOptions>\n  <makeDbCall>\n  return relax({ db: dbName, path: '_changes', qs: opts }, callback)\n  </makeDbCall>\n}\n"], ["ckeditorTextProcessing", "\nfunction(text) {\n  <htmlEncode>\n  var standard = function(text) {\n    var span = new CKEDITOR.dom.element('span');\n    span.setText(text);\n    return span.getHtml();\n  };\n  </htmlEncode>\n\n  <replaceBreaksAndGt>\n  var fix1 = (standard('\\n').toLowerCase() == '<br>') ?\n    function(text) {\n\n      return standard(text).replace(/<br>/gi, '\\n');\n    } :\n    standard;\n  var fix2 = (standard('>') == '>') ?\n    function(text) {\n\n      return fix1(text).replace(/>/g, '&gt;');\n    } :\n    fix1;\n  </replaceBreaksAndGt>\n\n  <handleNbsp>\n  var fix3 = (standard('  ') == '&nbsp; ') ?\n    function(text) {\n\n      return fix2(text).replace(/&nbsp;/g, ' ');\n    } :\n    fix2;\n  </handleNbsp>\n\n  <setHtmlEncodeFunction>\n  this.htmlEncode = fix3;\n  </setHtmlEncodeFunction>\n\n  <returnHtmlEncode>\n  return this.htmlEncode(text);\n  </returnHtmlEncode>\n}\n"], ["jCalValueHydration", "\nfunction() {\n  var len = this.jCal.length - VALUE_INDEX;\n  <checkIfEmpty>\n  if (len < 1) {\n\n    return [];\n  }\n  </checkIfEmpty>\n\n  var i = 0;\n  var result = [];\n\n  <hydrateValues>\n  for (; i < len; i++) {\n    result[i] = this._hydrateValue(i);\n  }\n  </hydrateValues>\n\n  return result;\n}\n"], ""]