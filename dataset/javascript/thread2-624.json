[["Browser", "\nfunction Browser() {\n      var _this;\n\n      var ua = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n      var flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var cssFlagsPrefix = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'browser';\n\n      _classCallCheck(this, Browser);\n\n      _this = _possibleConstructorReturn(this, _getPrototypeOf(Browser).call(this, ua, flags, cssFlagsPrefix));\n\n      _this._createTestElements();\n\n      _this.setVersion();\n\n      return _this;\n    }\n"], ["SliderStepFunction", "\nfunction (right) {\n            var p = this.coords.p_pointer;\n            <SliderStepCalculation>\n            var p_step = (this.options.max - this.options.min) / 100;\n            p_step = this.options.step / p_step;\n            </SliderStepCalculation>\n            if (right) {\n                p += p_step;\n            } else {\n                p -= p_step;\n            }\n            <PointerPositionCalculation>\n            this.coords.x_pointer = this.toFixed(this.coords.w_rs / 100 * p);\n            this.is_key = true;\n            this.calc();\n            </PointerPositionCalculation>\n        }\n"], ["ArrayUniquifier", "\nfunction(a) {\n\t\tif (!Array.isArray(a)) { return []; }\n\t\treturn a.filter(function(item, index) {\n\t\t\treturn a.indexOf(item) === index;\n\t\t});\n\t}\n"], ["CloseFunction", "\nfunction close (vexOrId) {\n    <CloseParameterParsing>\n    var id\n    if (vexOrId.id) {\n      id = vexOrId.id\n    } else if (typeof vexOrId === 'string') {\n      id = vexOrId\n    } else {\n      throw new TypeError('close requires a vex object or id string')\n    }\n    </CloseParameterParsing>\n    <CloseCheckAndAction>\n    if (!vexes[id]) {\n      return false\n    }\n    return vexes[id].close()\n    </CloseCheckAndAction>\n  }\n"], ["CheckPointerRules", "\nfunction checkPointerRules(meta, core, node, callback) {\n        var result = {\n                hasViolation: false,\n                messages: []\n            };\n        <GatherPointerInformation>\n        var metaPointers = filterPointerRules(meta).pointers,\n            checkPromises = [],\n            pointerNames = core.getPointerNames(node);\n        </GatherPointerInformation>\n\n        checkPromises = pointerNames.map(function (pointerName) {\n            <ProcessPointers>\n            var metaPointer = metaPointers[pointerName],\n                pointerPath,\n                pointerPaths = [];\n            </ProcessPointers>\n\n            <HandleIllegalPointer>\n            if (!metaPointer) {\n                if (pointerName === 'base') {\n                    return {hasViolation: false};\n                } else {\n                    return Q({\n                        hasViolation: true,\n                        messages: ['Illegal pointer \"' + pointerName + '\".']\n                    });\n                }\n            }\n            </HandleIllegalPointer>\n            else {\n                <LoadNodesAndCheck>\n                pointerPath = core.getPointerPath(node, pointerName);\n                if (pointerPath !== null) {\n                    pointerPaths.push(pointerPath);\n                }\n                return loadNodes(core, node, pointerPaths)\n                    .then(function (nodes) {\n                        return checkNodeTypesAndCardinality(core, node, nodes, metaPointer,\n                            '\"' + pointerName + '\" target', true);\n                    });\n                </LoadNodesAndCheck>\n            }\n        });\n\n        <AggregateResults>\n        return Q.all(checkPromises)\n            .then(function (results) {\n                results.forEach(function (res) {\n                    if (res.hasViolation) {\n                        result.hasViolation = true;\n                        result.messages = result.messages.concat(res.messages);\n                    }\n                });\n\n                return result;\n            })\n            </AggregateResults>\n            .nodeify(callback);\n    }\n"], ["ExplorerFlatModel", "\nfunction ExplorerFlatModel(rootPath, fetchItems, root) {\n\t\tthis.rootPath = rootPath;\n\t\tthis.fetchItems = fetchItems;\n\t\tthis.root = root;\n\t}\n"], ["RpnToTreeFunction", "\nfunction rpnToTree(values) {\n    <TreeInitialization>\n    let ii, len, op, stack, slice, count;\n    stack = [];\n    </TreeInitialization>\n\n    <ProcessRpnValues>\n    for (ii = 0, len = values.length; ii < len; ii++) {\n        op = values[ii];\n        </ProcessRpnValues>\n\n        <ParenthesisHandling>\n        if (op === LEFT_PAREN) {\n            slice = findMatchingRightParam(values, ii);\n            if (!slice || slice.length === 0) {\n                throw new Error('mismatch parentheses');\n            }\n            ii += slice.length + 1;\n            slice = rpnToTree(slice);\n            stack.push(slice);\n        }\n        </ParenthesisHandling>\n        else {\n            <TreeConstruction>\n            if (Array.isArray(op)) {\n                stack.push(op);\n            } else {\n                count = argCount(op);\n                slice = stack.splice(stack.length - count, count);\n                if (Array.isArray(slice) && slice.length === 1) {\n                    slice = arrayFlatten(slice, true);\n                }\n                if (slice[0] === VALUE) {\n                    slice = [slice];\n                }\n                stack.push([op].concat(slice));\n            }\n            </TreeConstruction>\n        }\n    }\n\n    <TreeReturn>\n    return stack;\n    </TreeReturn>\n}\n"], ["InheritAttrs", "\nfunction( applyTo, applyFrom ) {\n            <ApplyAttributes>\n            for ( var attr in applyFrom ) {\n                if ( applyFrom.hasOwnProperty( attr ) ) {\n                    if ( ( applyTo[attr] instanceof Object && applyFrom[attr] instanceof Object ) && ( typeof applyFrom[attr] !== 'function' ) ) {\n                        this.inheritAttrs( applyTo[attr], applyFrom[attr] );\n                    }\n                    else {\n                        applyTo[attr] = applyFrom[attr];\n                    }\n                }\n            }\n            </ApplyAttributes>\n            return applyTo;\n        }\n"], ["VsHashFunction", "\nfunction vsHash(text) {\n    <HashInitialization>\n    let codes = [];\n    let pos = 0;\n    let partPos = 0;\n    </HashInitialization>\n\n    <CharacterProcessing>\n    for (let i = 0; i < text.length; i++) {\n        if (!codes[pos]) codes[pos]=[];\n        let code = decodeCharCode2Int36(text.charCodeAt(i));\n        if (code !== null) {\n            codes[pos][partPos] = code;\n            partPos += 1;\n        }\n        if (partPos === LEN) {\n            partPos = 0;\n            pos += 1;\n        }\n    }\n    </CharacterProcessing>\n\n    <PaddingAndReduction>\n    if (partPos) {\n        for (let i = 0; i < LEN - partPos; i++) {\n            codes[pos].push(0);\n        }\n    }\n    return [codes.reduce((result, code) => {\n        result = result ^ code.reduce((r, v, i) => {\n            return r + v * Math.pow(36, i);\n        }, 0);\n        return result;\n    }, 0)];\n    </PaddingAndReduction>\n}\n"], ["CreateSubscriptionProgram", "\nfunction (fn) {\n  <ContainerAssignment>\n  var container = this;\n  </ContainerAssignment>\n  <ProgramFunctionDefinition>\n  var program = function () {\n    <SubscriptionCreation>\n    var subscriber = new Subscription(fn, null, container);\n    </SubscriptionCreation>\n    return subscriber.execute.apply(subscriber, arguments);\n  };\n  </ProgramFunctionDefinition>\n\n  <ExtendProgram>\n  Utils.extend(program, fn);\n  </ExtendProgram>\n\n  return program;\n}\n"], ""]