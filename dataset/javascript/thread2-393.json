[["updateExtractsAndMaps", "\nfunction(){\n    var insertedMap = {};\n    var deletedMap = {};\n    var delta;\n\n    for (var key in this.sourceMap_)\n    {\n      var sourceObjectInfo = this.sourceMap_[key];\n      var sourceObject = sourceObjectInfo.source;\n\n      if (sourceObject instanceof DataObject)\n      {\n        var newValue = this.rule(sourceObject) || null;\n        var oldValue = sourceObjectInfo.value;\n\n        if (isEqual(newValue, oldValue))\n          continue;\n\n        <handleInserts>\n        if (newValue instanceof DataObject || newValue instanceof ReadOnlyDataset)\n        {\n          var inserted = addToExtract(this, newValue, sourceObject);\n          for (var i = 0; i < inserted.length; i++)\n          {\n            var item = inserted[i];\n            var id = item.basisObjectId;\n            if (deletedMap[id])\n              delete deletedMap[id];\n            else\n              insertedMap[id] = item;\n          }\n        }\n        </handleInserts>\n\n        <handleDeletions>\n        if (oldValue)\n        {\n          var deleted = removeFromExtract(this, oldValue, sourceObject);\n          for (var i = 0; i < deleted.length; i++)\n          {\n            var item = deleted[i];\n            var id = item.basisObjectId;\n            if (insertedMap[id])\n              delete insertedMap[id];\n            else\n              deletedMap[id] = item;\n          }\n        }\n        </handleDeletions>\n\n        <updateSourceValue>\n        sourceObjectInfo.value = newValue;\n        </updateSourceValue>\n      }\n    }\n\n    <emitDelta>\n    if (delta = getDelta(values(insertedMap), values(deletedMap)))\n      this.emit_itemsChanged(delta);\n    </emitDelta>\n\n    return delta;\n  }\n"], ["recursiveFormatting", "\nfunction formatNumber(number, precision, thousand, decimal) {\n\n  <handleArrayInput>\n  if (Array.isArray(number)) {\n    return number.map(function(val) {\n      return formatNumber(val, precision, thousand, decimal);\n    });\n  }\n  </handleArrayInput>\n\n  <applyFormatting>\n  number = unformat(number);\n\n  const opts = defaults(\n      (isObject(precision) ? precision : {\n        precision : precision,\n        thousand : thousand,\n        decimal : decimal\n      }),\n      numberSettings\n    );\n\n  const usePrecision = checkPrecision(opts.precision);\n\n  const fixedNumber = toFixed(number || 0, usePrecision);\n  const negative = fixedNumber < 0 ? \"-\" : \"\";\n  const base = String(parseInt(Math.abs(fixedNumber), 10));\n  const mod = base.length > 3 ? base.length % 3 : 0;\n\n  return negative + (mod ? base.substr(0, mod) + opts.thousand : \"\") + base.substr(mod).replace(/(\\d{3})(?=\\d)/g, \"$1\" + opts.thousand) + (usePrecision ? opts.decimal + toFixed(Math.abs(number), usePrecision).split('.')[1] : \"\");\n  </applyFormatting>\n}\n"], ["handlePromiseError", "\nfunction (error) {\n    <recordError>\n    results[index] = error;\n    hasError = true;\n    </recordError>\n\n    <incrementFulfillment()>\n    fulfilled += 1;\n    </incrementFulfillment>\n\n    <emitErrorOnComplete>\n    if (fulfilled === length) {\n        deferred.emitError(results);\n    }\n    </emitErrorOnComplete>\n}\n"], ["defineSingleTest", "\nfunction only(testName, callback) {\n    <checkAndResetQueue>\n    if (focused$1) {\n        return;\n    }\n\n    config.queue.length = 0;\n    focused$1 = true;\n    </checkAndResetQueue>\n\n    <queueTest>\n    var newTest = new Test({\n        testName: testName,\n        callback: callback\n    });\n\n    newTest.queue();\n    </queueTest>\n}\n"], ["resetApplicationState", "\nasync function reset () {\n    \n    try {\n        <checkAndStopApp>\n        if (immutableApp && immutableApp.server && immutableApp.started) {\n            await stop()\n        }\n        </checkAndStopApp>\n        \n        <resetConfiguration>\n        immutableApp = global.__immutable_app__ = _.cloneDeep(defaultGlobalConfig)\n        \n        immutableApp.express = express()\n        </resetConfiguration>\n    }\n    catch (err) {\n        <handleResetError>\n        throw err\n        </handleResetError>\n    }\n}\n"], ["getMaxSatisfyingVersion", "\nfunction maxSatisfying (versions, range) {\n  return versions\n    .filter(function (v) { return satisfies(v, range) })\n    .sort(compare)\n    .pop()\n}\n"], ["initializeSaveToMongo", "\nfunction SaveToMongo(opts) {\n  if (!(this instanceof SaveToMongo)) return new SaveToMongo(opts);\n\n  <validateAndSetOptions>\n  var options = this.options = opts || {};\n\n  if (options.bulk) {\n\n    if (typeof options.bulk !== 'object') {\n      throw new TypeError('Option `bulk` must be an object');\n    }\n\n    if (options.bulk.mode !== 'ordered' && options.bulk.mode !== 'unordered') {\n      throw new Error('Option `bulk.mode` must be a string and can be \"ordered\" or \"unordered\"');\n    }\n\n    if (options.bulk.bufferSize && (typeof options.bulk.bufferSize !== 'number' or options.bulk.bufferSize <= 0)) {\n      throw new Error('Option `bulk.bufferSize` must be a number greater than 0');\n    }\n\n  }\n\n  this.bulk = options.bulk;\n  this.opCounter = options.bulk ? 0 : null;\n  if (this.bulk && !this.bulk.bufferSize) this.bulk.bufferSize = 1000;\n  </validateAndSetOptions>\n\n  <extendWritableStream>\n  Writable.call(this, options.streamOptions || {\n    objectMode: true\n  });\n  </extendWritableStream>\n\n  \n  <handleFinishEvent>\n  this.on('finish', function() {\n    if (this.bulk && this.opCounter > 0) {\n      debug('Executing remaining bulk inserts');\n\n      this.executeBulkOps(function(err, result) {\n        this._db.close();\n        this.emit('done');\n      });\n    } else {\n      this._db.close();\n      this.emit('done');\n    }\n  });\n  </handleFinishEvent>\n}\n"], ["initializeMysqlTransit", "\nfunction MysqlTransit(dbOriginal, dbTemp, connectionParameters) {\n  this.dbOriginal = dbOriginal;\n  this.dbTemp = dbTemp;\n  this.connectionParameters = connectionParameters;\n  this.queryQueue = [];\n  this.tablesToDrop = [];\n  this.tablesToCreate = [];\n  this.interactive = true;\n  return this._init();\n}\n"], ["handleDatabaseInsertionResult", "\nfunction(err, status) {\n    <processInsertionError>\n    if (err) {\n        callback(err);\n        return;\n    }\n    </processInsertionError>\n    \n    <updateInsertionStatus>\n    if (status || status === 'OK') {\n        report.inserted += _.isNumber(status) ? status : 1;\n    } else {\n        report.errors += 1;\n    }\n    </updateInsertionStatus>\n\n    <continueInsertions>\n    AddRecursive();\n    </continueInsertions>\n}\n"], ["removeToolFromStore", "\nfunction(enabledElement) {\n    <filterTools>\n    store.state.tools = store.state.tools.filter(\n        tool => tool.element !== enabledElement\n    );\n    </filterTools>\n}\n"], "```"]