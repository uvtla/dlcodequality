[["init", "\nfunction init(_pluginInterface) {\n    <setup_pluginInterface>\n    pi = _pluginInterface;\n    localStorage = pi.localStorage;\n    log = pi.log;\n    </setup_pluginInterface>\n    <setNetCallbackFunctions>\n    ipv4.setNetCallbackFunctions(\n        function(net, newmac, newip) {\n            <onMacFound>\n            for (const callbacks of Object.values(NetCallbacks)) {\n                if (callbacks.onMacFoundCallback != undefined) {\n                    callbacks.onMacFoundCallback(net, newmac, newip);\n                }\n            }\n            </onMacFound>\n        }\n        , function(net, lostmac, lostip) {\n            <onMacLost>\n            for (const callbacks of Object.values(NetCallbacks)) {\n                if (callbacks.onMacLostCallback != undefined) {\n                    callbacks.onMacLostCallback(net, lostmac, lostip);\n                }\n            }\n            </onMacLost>\n        }\n        , function(net, mac, oldip, newip) {\n            <onIPChanged>\n            for (const callbacks of Object.values(NetCallbacks)) {\n                if (callbacks.onIPChangedCallback != undefined) {\n                    callbacks.onIPChangedCallback(net, mac, oldip, newip);\n                }\n            }\n            </onIPChanged>\n        }\n    );\n    </setNetCallbackFunctions>\n}\n"], ["getRowById", "\nfunction(gridRow){\n        <extractIdentifier>\n\t\tvar rowId =  gridRow['$_#_@_id']\n        </extractIdentifier>\n        <findRow>\n\t\tvar row = null\n\t\tvar rowIndex = this.dataTable.getIndexByRowId(rowId)\n\t\tif(rowIndex > -1)\n\t\t\trow = this.dataTable.getRow(rowIndex);\n        </findRow>\n\t\treturn row\n}\n"], ["storeToken", "\nfunction storeToken(token) {\n  <createDirectoryIfMissing>\n  try {\n    fs.mkdirSync(TOKEN_DIR);\n  } catch (err) {\n    if (err.code != 'EEXIST') {\n      throw err;\n    }\n  }\n  </createDirectoryIfMissing>\n  <writeTokenToFile>\n  fs.writeFile(TOKEN_PATH, JSON.stringify(token), function(err) {\n    if (err) throw err;\n    console.log('Token stored to ' + TOKEN_PATH);\n  });\n  </writeTokenToFile>\n}\n"], ["splitHostPort", "\nfunction splitHostPort(hostport) {\n   \n   let host = hostport;\n   let port = 80;\n   <extractParts>\n   const parts = hostport.split(':');\n   if (parts.length > 1) {\n      host = parts[0];\n      port = parts[1];\n   }\n   </extractParts>\n\n   <returnResult>\n   return {'host': host, 'port': port};\n   </returnResult>\n}\n"], ["queryResponse", "\nfunction queryResponse(rawData) {\n    var entry = rawData.feed.entry || [];\n    <mapEntries>\n    return entry.map(function(item) {\n        return worksheetEntry(item);\n    });\n    </mapEntries>\n}\n"], ["resolveResolutions", "\nfunction resolveResolutions (toResolve, components, messages) {\n  <displaySubHeading>\n  messages.subHeading('Resolving tymlyRefs')\n  </displaySubHeading>\n  <processResolutions>\n  for (const { target, path, ref } of toResolve) {\n    <findComponent>\n    const [ targetName, targetObj ] = findComponent(target, components)\n    </findComponent>\n    <findRefObject>\n    const refObj = findRefObject(ref, components, targetName)\n    </findRefObject>\n\n    <applyResolution>\n    if (!refObj) {\n      throw new Error(`Could not resolve ${ref} in ${target}`)\n    }\n\n    applyToTarget(targetObj, refObj, path)\n    </applyResolution>\n    <logInfo>\n    messages.info(`Resolved ${ref} in ${targetName}`)\n    </logInfo>\n  }\n  </processResolutions>\n}\n"], ["setupHooks", "\nfunction setupHooks (InstanceModel, config) {\n  <hookSetup>\n  const ourHookedFnNames = ['save', 'remove', 'index']\n  const schema = InstanceModel.schema\n  const hooks = _.values(schema.hooks)\n  </hookSetup>\n  \n  <configureHooks>\n  _.forEach(hooks, ho => {\n    <determineHookFunction>\n    let addHookFn = 'addDynamicHooks'\n    if (!config.promisify) {\n      addHookFn = 'addFlexibleHooks'\n    }\n    </determineHookFunction>\n    <initializeHook>\n    InstanceModel.prototype[addHookFn](ho.name)\n    </initializeHook>\n    const mwopts = { passParams: true }\n    <applyMiddleware>\n    _.forEach(ho.fns, (fn, index) => {\n      if (ourHookedFnNames.indexOf(ho.name) >= 0) {\n        const mwFn = fn\n        if (ho.hook === 'post') {\n          <createModifiedFunction>\n          ho.fns[index] = function (next) {\n            mwFn.apply(this)\n            next()\n          }\n          </createModifiedFunction>\n        }\n\n        <adjustOptions>\n        mwopts.passParams = false\n        </adjustOptions>\n      }\n    })\n    </applyMiddleware>\n    <addHook>\n    InstanceModel.prototype[ho.hook](ho.name, ho.fns, mwopts)\n    </addHook>\n  })\n  </configureHooks>\n}\n"], ["createNDEFRecord", "\nfunction (ndefRecords, id) {\n        var payload = [];\n\n        if (!id) { <initializeId>id = []; </initializeId>}\n\n        <processNDEFRecords>\n        if (ndefRecords)\n        {\n            <encodeMessage>\n            if (ndefRecords[0] instanceof Object && ndefRecords[0].hasOwnProperty('tnf')) {\n                payload = ndef.encodeMessage(ndefRecords);\n            } else {\n            </encodeMessage>\n                <useRawPayload>\n                payload = ndefRecords;\n                </useRawPayload>\n            }\n        </processNDEFRecords>\n        else {\n            <logWarning>\n            console.log(\"WARNING: Expecting an array of NDEF records\");\n            </logWarning>\n        }\n\n        <returnRecord>\n        return ndef.record(ndef.TNF_WELL_KNOWN, ndef.RTD_SMART_POSTER, id, payload);\n        </returnRecord>\n}\n"], ["manageAttributes", "\nfunction(element, params) {\n            var attrs;\n            <checkParamType>\n            if ('object' == typeof params) {\n                attrs = params;\n            }\n            if ('string' == typeof params) {\n                </checkParamType>\n                <handleArguments>\n                if (arguments.length > 2) {\n                    attrs = {};\n                    attrs[params] = arguments[2];\n                }\n                </handleArguments>\n                <getNumAttributes>\n                else{\n                    return getElAttributes(element,params);\n                }\n                </getNumAttributes>\n            }\n            <setAttribute>\n            if (attrs) {\n                setAttributes(element, attrs);\n            }\n            </setAttribute>\n}\n"], ["setEventHandler", "\nfunction setEventHandler(name, handler, dom, tag) {\n\n  <defineEventFunction>\n  dom[name] = function(e) {\n\n    <determineContext>\n    var ptag = tag._parent,\n      item = tag._item,\n      el\n\n    if (!item)\n      while (ptag && !item) {\n        item = ptag._item\n        ptag = ptag._parent\n      }\n    </determineContext>\n\n    <normalizeEventObject>\n    e = e || window.event\n\n    if (isWritable(e, 'currentTarget')) e.currentTarget = dom\n    if (isWritable(e, 'target')) e.target = e.srcElement\n    if (isWritable(e, 'which')) e.which = e.charCode || e.keyCode\n    </normalizeEventObject>\n\n    <setItemData>\n    e.item = item\n    </setItemData>\n\n    <handleEvent>\n    if (handler.call(tag, e) !== true && !/radio|check/.test(dom.type)) {\n      if (e.preventDefault) e.preventDefault()\n      e.returnValue = false\n    }\n    </handleEvent>\n\n    <conditionallyUpdate>\n    if (!e.preventUpdate) {\n      el = item ? getImmediateCustomParentTag(ptag) : tag\n      el.update()\n    }\n    </conditionallyUpdate>\n\n  }\n  </defineEventFunction>\n\n}\n"], ""]