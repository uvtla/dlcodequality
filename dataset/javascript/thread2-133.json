[["defaultAssets", "\nfunction defaultAssets( { name, category, descriptor } ) {\n   switch( category ) {\n      case 'themes':\n         return {\n            assetUrls: [ descriptor.styleSource || 'css/theme.css' ]\n         };\n      case 'layouts':\n      case 'widgets':\n      case 'controls':\n         return {\n            assetsForTheme: [ descriptor.templateSource || `${name}.html` ],\n            assetUrlsForTheme: [ descriptor.styleSource || `css/${name}.css` ]\n         };\n      default:\n         return {};\n   }\n}\n"], ["getFieldValue", "\nfunction( field ){\n    var tagName = field.tagName.toLowerCase();\n\n    if( tagName == 'input' && field.type == 'checkbox' ){\n        return field.checked;\n    }\n\n    if( tagName == 'select' ){\n        return field.options[field.selectedIndex].value;\n    }\n\n    return field.value;\n}\n"], ["anonymousFunction", "\nfunction () {\n\n    this.middlewarePaths.forEach(function (mwPath) {\n      <loadAndMountMiddleware>\n      require(mwPath)(this);\n\n      debug(format('mounted middleware/%s', path.basename(mwPath)));\n      </loadAndMountMiddleware>\n    }, this);\n\n  }\n"], ["SpanData", "\nfunction SpanData(agent, trace, name, parentSpanId, isRoot, skipFrames) {\n  <initializeSpanData>\n  var spanId = uid++;\n  this.agent = agent;\n  var spanName = traceUtil.truncate(name, constants.TRACE_SERVICE_SPAN_NAME_LIMIT);\n  this.span = new TraceSpan(spanName, spanId, parentSpanId);\n  this.trace = trace;\n  this.isRoot = isRoot;\n  trace.spans.push(this.span);\n  </initializeSpanData>\n  if (agent.config().stackTraceLimit > 0) {\n    <captureStackTrace>\n    \n    \n    \n    \n    var origLimit = Error.stackTraceLimit;\n    Error.stackTraceLimit = agent.config().stackTraceLimit + skipFrames;\n\n    var origPrepare = Error.prepareStackTrace;\n    Error.prepareStackTrace = function(error, structured) {\n      return structured;\n    };\n    var e = {};\n    Error.captureStackTrace(e, SpanData);\n\n    var stackFrames = [];\n    e.stack.forEach(function(callSite, i) {\n      if (i < skipFrames) {\n        return;\n      }\n      var functionName = callSite.getFunctionName();\n      var methodName = callSite.getMethodName();\n      var name = (methodName && functionName) ?\n        functionName + ' [as ' + methodName + ']' :\n        functionName || methodName || '<anonymous function>';\n      stackFrames.push(new StackFrame(undefined, name,\n        callSite.getFileName(), callSite.getLineNumber(),\n        callSite.getColumnNumber()));\n    });\n    </captureStackTrace>\n    <setLabelForStackTrace>\n    this.span.setLabel(TraceLabels.STACK_TRACE_DETAILS_KEY,\n      traceUtil.truncate(JSON.stringify({stack_frame: stackFrames}),\n        constants.TRACE_SERVICE_LABEL_VALUE_LIMIT));\n    </setLabelForStackTrace>\n    <restoreErrorSettings>\n    Error.stackTraceLimit = origLimit;\n    Error.prepareStackTrace = origPrepare;\n    </restoreErrorSettings>\n  }\n}\n"], ["getStopByName", "\nfunction getStopByName(db, name, callback) {\n\n  <checkCache>\n  let cacheKey = db.id + \"-\" + name;\n  let cache = cache_stopByName.get(cacheKey);\n  if ( cache !== null ) {\n    return callback(null, cache);\n  }\n  </checkCache>\n\n  <prepareQueries>\n  let queries = [\n    \"SELECT stop_id FROM gtfs_stops WHERE stop_name='\" + name + \"' COLLATE NOCASE;\",\n    \"SELECT stop_id FROM rt_alt_stop_names WHERE alt_stop_name='\" + name + \"' COLLATE NOCASE;\",\n    \"SELECT stop_id FROM rt_stops_extra WHERE display_name='\" + name + \"' COLLATE NOCASE;\"\n  ];\n  </prepareQueries>\n\n  <executeQueries>\n  let found = false;\n  let count = 0;\n  for ( let i = 0; i < queries.length; i++ ) {\n    _queryForStopByName(db, queries[i], function(stop) {\n\n    <checkResultAndUpdateCache>\n      if ( !found && stop !== undefined ) {\n        found = true;\n        cache_stopByName.put(cacheKey, stop);\n        return callback(null, stop);\n      }\n    </checkResultAndUpdateCache>\n\n    <checkCompletion>\n      count ++;\n      if ( count === queries.length ) {\n        return callback(null, undefined);\n      }\n    </checkCompletion>\n\n    });\n  }\n  </executeQueries>\n}\n"], ["kolkrabbiRequest", "\nfunction kolkrabbiRequest (url, token) {\n  <makeHTTPRequest>\n  return cli.got.get(KOLKRABBI_BASE_URL + url, {\n    headers: {\n      authorization: 'Bearer ' + token\n    },\n    json: true\n  })\n    </makeHTTPRequest>\n    <processResponse>\n    .then(res => res.body)\n    </processResponse>\n    <handleError>\n    .catch(err => {\n      switch (err.statusCode) {\n        case 404:\n          err = new Error(`404 ${url}`)\n          err.name = 'NOT_FOUND'\n          throw err\n        default:\n          throw err\n      }\n    })\n    </handleError>\n}\n"], ["createResponseHandler", "\nfunction createResponseHandler(callback, okStatusCodes, noBuffer, retryFn) {\n    <validateArguments>\n    if (typeof callback !== 'function') {\n        callback = function () {};\n    }\n\n    if (typeof okStatusCodes === 'function') {\n        retryFn = okStatusCodes;\n        okStatusCodes = null;\n        noBuffer = retryFn;\n    }\n    if (typeof noBuffer === 'function') {\n        retryFn = noBuffer;\n        noBuffer = false;\n    }\n\n    okStatusCodes = okStatusCodes || [200];\n    </validateArguments>\n\n    <retryHandler>\n    function retry(response) {\n        var retryAfter = response.headers['retry-after'];\n        if (typeof retryFn === 'function' && retryAfter) {\n            retryAfter = parseInt(retryAfter, 10);\n            setTimeout(retryFn, retryAfter * 1000);\n            return true;\n        }\n        return false;\n    }\n    </retryHandler>\n\n    <responseHandler>\n    function handleResponse(response, body) {\n        var error;\n\n        \n        if (noBuffer !== true && typeof body === 'undefined') {\n            response.pipe(concat(function (body) {\n                handleResponse(response, parseJSONBody(body));\n            }));\n            return;\n        }\n\n        if (okStatusCodes.indexOf(response.statusCode) > -1) {\n            if (!retry(response)) {\n                if (noBuffer) {\n                    callback(null, response);\n                } else {\n                    callback(null, body, response);\n                }\n            }\n        } else {\n            if (response.statusCode === 429) {\n                if (retry(response)) {\n                    return;\n                }\n            }\n\n            handleError(body, response, callback);\n        }\n    }\n    </responseHandler>\n\n    return function (error, response) {\n        if (error) {\n            callback(error, response);\n        } else {\n            handleResponse(response);\n        }\n    };\n}\n"], ["ws_get_cell_stub", "\nfunction ws_get_cell_stub(ws, R, C) {\n\t\n\tif(typeof R == \"string\") return ws[R] || (ws[R] = {t:'z'});\n\t\n\tif(typeof R != \"number\") return ws_get_cell_stub(ws, encode_cell(R));\n\t\n\treturn ws_get_cell_stub(ws, encode_cell({r:R,c:C||0}));\n}\n"], ["init", "\nfunction init(names) {  \n\n  <setupState>\n  this.count = 0;\n  this.deps = {};\n  this.groups = {};\n  this.cb = null;\n  </setupState>\n\n  if (! names) return;\n\n  <buildDependencies>\n  this.add(names[0], function(cb) { cb() });\n  for (var i = 1; i < names.length; i++) {\n    this.add(names[i], names[i-1], function(cb) { cb() });\n  }\n  </buildDependencies>\n\n  return;\n}\n"], ["processSection", "\nfunction processSection(section, config, parentDepth) {\n\t\n\t<resolveContentPath>\n\tconst contentRelativePath = section.content\n\tlet content\n\tif (contentRelativePath) {\n\t\tconst contentAbsolutePath = path.resolve(config.configDir, contentRelativePath)\n\t\tif (!fs.existsSync(contentAbsolutePath)) {\n\t\t\tthrow new Error(`Styleguidist: Section content file not found: ${contentAbsolutePath}`)\n\t\t}\n\t\tcontent = requireIt(`!!${examplesLoader}?customLangs=vue|js|jsx!${contentAbsolutePath}`)\n\t}\n\t</resolveContentPath>\n\n\t<determineSectionDepth>\n\tlet sectionDepth\n\tif (parentDepth === undefined) {\n\t\tsectionDepth = section.sectionDepth !== undefined ? section.sectionDepth : 0\n\t} else {\n\t\tsectionDepth = parentDepth === 0 ? 0 : parentDepth - 1\n\t}\n\t</determineSectionDepth>\n\n\treturn {\n\t\t<assembleSectionObject>\n\t\tname: section.name,\n\t\texampleMode: section.exampleMode || config.exampleMode,\n\t\tusageMode: section.usageMode || config.usageMode,\n\t\tsectionDepth,\n\t\tdescription: section.description,\n\t\tslug: slugger.slug(section.name),\n\t\tsections: getSections(section.sections || [], config, sectionDepth),\n\t\tfilepath: contentRelativePath,\n\t\thref: section.href,\n\t\tcomponents: getSectionComponents(section, config),\n\t\tcontent,\n\t\texternal: section.external\n\t\t</assembleSectionObject>\n\t}\n}\n"], "```"]