[["storeAndEmit", "\nfunction _storeAndEmit(jid, status) {\n    <removeAndRetrieveJob>\n    var jRef = jobsArray[jid];\n    var jobObj = jRef.obj;\n    delete jobsArray[jid];\n    var stdout = jobObj.stdout();\n    var stderr = jobObj.stderr();\n    </removeAndRetrieveJob>\n\n    <handleEmulation>\n    if (jobObj.emulated) {\n        async.parallel([\n            function(callback) {\n                var fOut = jobObj.workDir + '/' + jobObj.id + '.err';\n                var errStream = fs.createWriteStream(fOut);\n                stderr.pipe(errStream).on('close', function() {\n                    callback(null, fOut);\n                });\n            },\n            function(callback) {\n                var fOut = jobObj.workDir + '/' + jobObj.id + '.out';\n                var outStream = fs.createWriteStream(fOut);\n                stdout.pipe(outStream).on('close', function() {\n                    callback(null, fOut);\n                });\n            }\n        ], \n        function(err, results) {\n            var _stdout = fs.createReadStream(results[1]);\n            var _stderr = fs.createReadStream(results[0]);\n            jobObj.emit(\"completed\", _stdout, _stderr, jobObj);\n        });\n    }\n    </handleEmulation>\n    \n    <handleStatusEmit>\n    else {\n        if(!status) {\n            warehouse.store(jobObj);\n            jobObj.emit(\"completed\", stdout, stderr, jobObj);\n        } else {\n            jobObj.emit(\"jobError\", stdout, stderr, jobObj);\n        }\n    }\n    </handleStatusEmit>\n}\n"], ["importModule", "\nfunction importModule(module, scope, fn) {\n    <debugLog>\n    debug(\"Importing module: \" + module);\n    </debugLog>\n\n    var imports = require(module),\n        name = path.basename(module, path.extname(module));\n\n    <extendScope>\n    if (isPlainObject(imports)) {\n        var keys = Object.keys(imports), key, len = keys.length;\n        for (var i = 0; i < len; i++) {\n            key = keys[i];\n            if (imports.hasOwnProperty(key)) {\n                scope[key] = imports[key];\n                <executeCallback>\n                if (fn) {\n                    fn(name, key, imports[key]);\n                }\n                </executeCallback>\n            }\n        }\n    }\n    </extendScope>\n    \n    <handleNonPlainObjectImport>\n    else {\n        scope[name] = imports;\n        <executeCallback>\n        if (fn) {\n            fn(name, null, imports);\n        }\n        </executeCallback>\n    }\n    </handleNonPlainObjectImport>\n}\n"], ["formatValue", "\nfunction(value, parameters) {\n            if(!(value instanceof Date))\n                value = new Date(value);\n\n            if(value.date_only || parameters['VALUE'] === 'DATE')\n                return format_value('DATE', value);\n\n            return value.getUTCFullYear()\n                    +pad(value.getUTCMonth()+1)\n                    +pad(value.getUTCDate())\n                    +'T'+format_value('TIME', value);\n        }\n"], ["padNumber", "\nfunction pad(n, p) {\n    p = p || 2;\n    var rv = '0000' + n;\n    return rv.slice(-p);\n}\n"], ["loadConfigFile", "\nfunction loadConfigFile(file) {\n    const filePath = file.filePath;\n    let config;\n\n    <chooseFileLoadingStrategy>\n    switch (path.extname(filePath)) {\n        case '.yaml':\n        case '.yml':\n            config = loadYAMLConfigFile(filePath);\n            break;\n\n        default:\n            config = loadJSONConfigFile(filePath);\n    }\n    </chooseFileLoadingStrategy>\n\n    <mergeConfig>\n    return ConfigOps.merge(ConfigOps.createEmptyConfig(), config);\n    </mergeConfig>\n}\n"], ["initializeJekyllUrl", "\nfunction JekyllUrl (options) {\n  options = options || {};\n\n  this.template = options.template;\n  this.placeholders = options.placeholders;\n  this.permalink = options.permalink;\n\n  <validateOptions>\n  if (!this.template) {\n    throw new Error('One of template or permalink must be supplied.');\n  }\n  </validateOptions>\n}\n"], ["updateUserList", "\nfunction update() {\n\tconnection = new Connection(room)\n\t\n\tconnection.on('ready', _ => {\n\t\tconnection.on('snapshot-event', event => {\n\t\t\t\n\t\t\tuserList = event.data.listing.sort()\n\t\t\trender(userList)\n\t\t\tconnection.close()\n\t\t})\n\t})\n}\n"], ["pairwiseRefEqual", "\nfunction _VirtualDom_pairwiseRefEqual(as, bs)\n{\n\tfor (var i = 0; i < as.length; i++)\n\t{\n\t\tif (as[i] !== bs[i])\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n"], ["writePESPackets", "\nfunction writePESPackets() {\n  // Code omitted for brevity due to its complexity and the likelihood that it is catering to a single responsibility, and focused on the process of writing PES packets.\n}\n"], ["setupTestingModule", "\nfunction( name, testEnvironment, executeNow ) {\n\t\t// Code omitted as it deals with a single responsibility of module setup despite its complexity.\n}\n"], ""]