[["normalizeConnectArgs", "\nfunction normalizeConnectArgs(args)\n{\n\tif( typeof args[0]==='object' && args[0]!==null )\n\t\treturn args[0]\n\telse if( typeof args[0]==='string' && !(Number(args[0]) >= 0) )\n\t\treturn {path: args[0]}\n\tvar options= {port: args[0]}\n\tif( typeof args[1]==='string' )\n\t\toptions.host= args[1]\n\treturn options\n}\n"], ["checkFirstNodeLineIndent", "\nfunction checkFirstNodeLineIndent(node, firstLineIndent) {\n            const startIndent = getNodeIndent(node, false);\n\n            if ((startIndent.goodChar !== firstLineIndent || startIndent.badChar !== 0) && isNodeFirstInLine(node)) {\n                report(\n                    node,\n                    firstLineIndent,\n                    startIndent.space,\n                    startIndent.tab,\n                    { line: node.loc.start.line, column: node.loc.start.column }\n                );\n            }\n        }\n"], ["proxyMethods", "\nfunction proxyMethods(exec, query) {\n    const methods = [].concat(END_POINT_METHODS).concat(CHAINABLE_METHODS);\n    for (let name of methods) {\n        const oldMethod = query[name];\n        query[name] = function (...args) {\n            const clonedQuery = query.clone();\n            proxyMethods(exec, clonedQuery);\n            oldMethod.apply(clonedQuery, args);\n            if (CHAINABLE_METHODS.indexOf(name) > -1) {\n                return clonedQuery;\n            } else {\n                return exec(clonedQuery.toString());\n            }\n        }\n    }\n}\n"], ["isomorphic", "\nfunction isomorphic(options = {}) {\n    <handleOverload>\n    if (!(typeof options === 'object' && options.template))\n        return isomorphic({\n            routes: arguments[0],\n            configStore: arguments[1],\n            template: arguments[2],\n            distPathName: arguments[3],\n            injection: {\n                js: arguments[4]\n            }\n        })\n    </handleOverload>\n\n    let { routes, configStore } = options\n\n    return async (ctx, next) => {\n\n        try {\n            <setUpHistoryAndStore>\n            const memoryHistory = createMemoryHistory(ctx.url)\n            const store = configStore() \n            const history = syncHistoryWithStore(memoryHistory, store)\n            </setUpHistoryAndStore>\n            <matchRoutes>\n            const { redirectLocation, renderProps } = await asyncMatch({ history, routes, location: ctx.url })\n            </matchRoutes>\n\n            if (redirectLocation) {\n                ctx.redirect(redirectLocation.pathname + redirectLocation.search)\n            } else if (renderProps) {\n                const cookies = cookie.parse(ctx.request.header.cookie || '')\n\n                <determineLanguage>\n                let lang = ctx.query.hl\n\n                if (!lang && cookies.spLocaleId)\n                    lang = cookies.spLocaleId\n                \n                if (!lang)\n                    lang = ctx.header['accept-language']\n                \n                if (!lang)\n                    lang = 'en'\n                </determineLanguage>\n\n                <dispatchActions>\n                store.dispatch({ type: CHANGE_LANGUAGE, data: lang })\n                store.dispatch({ type: TELL_ME_URL, data: ctx.origin })\n                store.dispatch(i18nActionInit(store.getState()))\n                store.dispatch(i18nActionLocales())\n                </dispatchActions>\n\n                <asyncStoreFetch>\n                await asyncStore(store, renderProps)\n                </asyncStoreFetch>\n\n                <renderHtml>\n                extendHtml(store, renderProps)\n\n                ctx.body = renderHtml(\n                    renderToString(\n                        <Provider store={store}>\n                            <RouterContext {...renderProps } />\n                        </Provider>\n                    ),\n                    store.getState(),\n                    options\n                )\n                </renderHtml>\n            } else {\n                await next()\n            }\n\n        } catch (e) {\n            console.error('Server-Render Error Occures: %s', e.stack)\n            ctx.status = 500\n            ctx.body = e.message\n        }\n    }\n}\n"], ["extractMinFromHeap", "\nfunction () {\n            var heap = this.__heap,\n                l = heap.length,\n                ret;\n            if (l) {\n                ret = heap[0];\n                if (l === 1) {\n                    heap.length = 0;\n                } else {\n                    heap[0] = heap.pop();\n                    this.__downHeap(0);\n                }\n            }\n            return ret ? ret.value : ret;\n        }\n"], ["replace", "\nfunction replace(haystack, needle) {\n\t\t\tconst replacement = options.resolve ? notate(data, needle.trim()) : data[needle.trim()];\n\n\t\t\treturn VALID_RESULT_TYPES.includes(typeof replacement) ? replacement : options.clean ? '' : haystack;\n\t\t}\n"], ["toPromise", "\nfunction toPromise( obj ) {\n    if( !obj ) {\n        return obj;\n    }\n    if( isPromise( obj ) ) {\n        return obj;\n    }\n    if( isGeneratorFunction( obj ) || isGenerator( obj ) ) {\n        return co.call( this, obj );\n    }\n    if( 'function' == typeof obj ) {\n        return thunkToPromise.call( this, obj );\n    }\n    if( Array.isArray( obj ) ) {\n        return arrayToPromise.call( this, obj );\n    }\n    if( isObject( obj ) ) {\n        return objectToPromise.call( this, obj );\n    }\n    return obj;\n}\n"], ["indentLine", "\nfunction(direction) {\n      if (!this.container.firstChild) return;\n      \n      <highlight>\n      if (!this.highlightAtCursor()) return;\n      var cursor = select.selectionTopNode(this.container, false);\n      </highlight>\n      \n      <checkAndMoveCursor>\n      if (cursor === false)\n        return;\n      var lineStart = startOfLine(cursor);\n      var whiteSpace = this.indentLineAfter(lineStart, direction);\n      if (cursor == lineStart && whiteSpace)\n          cursor = whiteSpace;\n      </checkAndMoveCursor>\n      \n      <refocus>\n      if (cursor == whiteSpace)\n        select.focusAfterNode(cursor, this.container);\n      </refocus>\n    }\n"], ["serializeDoctype", "\nfunction serializeDoctype (node) {\n  var r = '<!DOCTYPE ' + node.name;\n\n  if (node.publicId) {\n    r += ' PUBLIC \"' + node.publicId + '\"';\n  }\n\n  if (!node.publicId && node.systemId) {\n    r += ' SYSTEM';\n  }\n\n  if (node.systemId) {\n    r += ' \"' + node.systemId + '\"';\n  }\n\n  r += '>';\n  return r;\n}\n"], ["renderStatistics", "\nfunction(){\n\t\tvar color = munit.color.get[ munit.failed > 0 ? 'red' : 'green' ],\n\t\t\tcallback = render.callback;\n\n\t\t<ensureRenderState>\n\t\trender.requireState( munit.RENDER_STATE_FINISHED );\n\t\trender.state = munit.RENDER_STATE_COMPLETE;\n\t\t</ensureRenderState>\n\n\t\t<logStatistics>\n\t\tmunit.log([\n\t\t\t\"\\n\",\n\t\t\tcolor( \"Tests Passed: \" + munit.passed ),\n\t\t\tcolor( \"Tests Failed: \" + munit.failed ),\n\t\t\tcolor( \"Tests Skipped: \" + munit.skipped ),\n\t\t\tcolor( \"Time: \" + munit._relativeTime( munit.end - munit.start ) ),\n\t\t\t\"\\n\"\n\t\t].join( \"\\n\" ));\n\t\t</logStatistics>\n\n\t\t<handleFailureOrCallback>\n\t\tif ( munit.failed > 0 ) {\n\t\t\tmunit.exit( 1, \"Test failed with \" + munit.failed + \" errors\" );\n\t\t}\n\t\telse if ( callback ) {\n\t\t\trender.callback = undefined;\n\t\t\tcallback( null, munit );\n\t\t}\n\t\t</handleFailureOrCallback>\n\t}\n"], "```"]