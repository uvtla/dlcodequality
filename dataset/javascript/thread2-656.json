[["get", "\nfunction get(nucleus, keyOrList, func) {\n\t<valueDetermination>\n    var isList = isArray(keyOrList), keys = isList ? keyOrList : [keyOrList],\n    \tkey, values = [], props = nucleus.props, missing = {},\n    \tresult = { values: values };\n    for (var i = keys.length; --i >= 0;) {\n        key = keys[i];\n        if (!hasOwn.call(props, key)) {\n            result.missing = missing;\n            missing[key] = true;\n        }\n        values.unshift(props[key]);\n    }\n    </valueDetermination>\n\treturn func ? func.apply({}, values) : result;\n}\n"], ["calculateLabelIndex", "\nfunction () {\n\t<findLabelIndex>\n    var cfg = this._cfg, showLabel = (!cfg.hideLabel && !!cfg.label), idx;\n    if (showLabel) {\n        idx = ((cfg.labelPos === \"right\" && !this._fullWidth) || cfg.labelPos === \"bottom\") ? 0 : 1;\n    } else {\n        idx = 0;\n    }\n\t</findLabelIndex>\n\t<getDomElement>\n    var dom = this.getDom();\n    if (this._isIE7OrLess) {\n        dom = dom ? dom.firstChild : null;\n    }\n    return ariaUtilsDom.getDomElementChild(dom, idx);\n\t</getDomElement>\n}\n"], ["processRows", "\nfunction(rows){\n\t<checkEmptyRows>\n\tif (rows.length === 0)\n\t\treturn onDone();\n\t</checkEmptyRows>\n\t<handleConnection>\n\tdb.takeConnectionFromPool(function (conn) {\n\t\t<processEachRow>\n\t\tasync.eachSeries(\n\t\t\trows,\n\t\t\tfunction (row, cb) {\n\t\t\t\tbreadcrumbs.add(\"--------------- archiving uncovered unit \" + row.unit);\n\t\t\t\tstorage.readJoint(conn, row.unit, {\n\t\t\t\t\tifNotFound: function () {\n\t\t\t\t\t\tthrow Error(\"nonserial unit not found?\");\n\t\t\t\t\t},\n\t\t\t\t\tifFound: function (objJoint) {\n\t\t\t\t\t\tmutex.lock([\"write\"], function(unlock){\n\t\t\t\t\t\t\tvar arrQueries = [];\n\t\t\t\t\t\t\tconn.addQuery(arrQueries, \"BEGIN\");\n\t\t\t\t\t\t\tarchiving.generateQueriesToArchiveJoint(conn, objJoint, 'uncovered', arrQueries, function(){\n\t\t\t\t\t\t\t\tconn.addQuery(arrQueries, \"COMMIT\");\n\t\t\t\t\t\t\t\tasync.series(arrQueries, function(){\n\t\t\t\t\t\t\t\t\tbreadcrumbs.add(\"------- done archiving \"+row.unit);\n\t\t\t\t\t\t\t\t\tvar parent_units = storage.assocUnstableUnits[row.unit].parent_units;\n\t\t\t\t\t\t\t\t\tstorage.forgetUnit(row.unit);\n\t\t\t\t\t\t\t\t\tparent_units.forEach(function(parent_unit){\n\t\t\t\t\t\t\t\t\t\tif (!storage.assocUnstableUnits[parent_unit]) \n\t\t\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t\t\tvar bHasChildren = false;\n\t\t\t\t\t\t\t\t\t\tfor (var unit in storage.assocUnstableUnits){\n\t\t\t\t\t\t\t\t\t\t\tvar o = storage.assocUnstableUnits[unit];\n\t\t\t\t\t\t\t\t\t\t\tif (o.parent_units.indexOf(parent_unit) >= 0)\n\t\t\t\t\t\t\t\t\t\t\t\tbHasChildren = true;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tif (!bHasChildren)\n\t\t\t\t\t\t\t\t\t\t\tstorage.assocUnstableUnits[parent_unit].is_free = 1;\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\tunlock();\n\t\t\t\t\t\t\t\t\tcb();\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t},\n\t\t\tfunction () {\n\t\t\t\t<updateUnitsAndRelease>\n\t\t\t\tconn.query(\n\t\t\t\t\t\"UPDATE units SET is_free=1 WHERE is_free=0 AND is_stable=0 \\n\\\n\t\t\t\t\tAND (SELECT 1 FROM parenthoods WHERE parent_unit=unit LIMIT 1) IS NULL\",\n\t\t\t\t\tfunction () {\n\t\t\t\t\t\tconn.release();\n\t\t\t\t\t\tif (rows.length > 0)\n\t\t\t\t\t\t\treturn purgeUncoveredNonserialJoints(false, onDone); \n\t\t\t\t\t\tonDone();\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t\t</updateUnitsAndRelease>\n\t\t\t}\n\t\t);\n\t\t</processEachRow>\n\t});\n\t</handleConnection>\n}\n"], ["generateStackedTotals", "\nfunction() {\n      <initializeValues>\n      this.totals = [];\n      this.maxTotal = 0;\n      this.bounds.reset();\n\n      if (this.series_.length === 0)\n        return;\n\n      var firstSeries = this.series_[0];\n      var lastSeries = this.series_[this.series_.length - 1];\n\n      this.bounds.addValue(firstSeries.getTimestamp(0));\n      this.bounds.addValue(lastSeries.getTimestamp(lastSeries.length - 1));\n\n      var numSeries = this.numSeries;\n      this.maxTotal = -Infinity;\n\t</initializeValues>\n      \n\t  <calculateTotals>\n      for (var i = 0; i < firstSeries.length; ++i) {\n        var total = 0;\n        this.series_.forEach(function(series) {\n          total += series.getSample(i).value;\n          this.totals.push(total);\n        }.bind(this));\n\n        this.maxTotal = Math.max(total, this.maxTotal);\n      }\n      </calculateTotals>\n}\n"], ["handleODataExpression", "\nfunction (oPathValue, oParameters) {\n\t<processODataFunction>\n\tvar oFunction = Basics.descend(oPathValue, \"$Function\", \"string\");\n\n\tswitch (oFunction.value) {\n\t\tcase \"odata.concat\": \n\t\t\treturn Expression.concat(oParameters);\n\t\tcase \"odata.fillUriTemplate\": \n\t\t\treturn Expression.fillUriTemplate(oParameters);\n\t\tcase \"odata.uriEncode\": \n\t\t\treturn Expression.uriEncode(oParameters);\n\t\tdefault:\n\t\t\treturn asyncError(oFunction, \"unknown function: \" + oFunction.value);\n\t}\n\t</processODataFunction>\n}\n"], ["resolveType", "\nfunction(context, arg) {\n\t<setType>\n\tvar type = null;\n\tswitch (gui.Type.of(arg)) {\n\t\tcase \"function\":\n\t\t\ttype = arg; \n\t\t\tbreak;\n\t\tcase \"string\":\n\t\t\ttype = gui.Object.lookup(arg, context);\n\t\t\tbreak;\n\t\tcase \"object\":\n\t\t\tconsole.error(this + \": expected edb.Type constructor (not an object)\");\n\t\t\tbreak;\n\t}\n\tif (!type) {\n\t\tthrow new TypeError(\"The type \\\"\" + arg + \"\\\" does not exist\");\n\t}\n\treturn type;\n\t</setType>\n}\n"], ["createCombination", "\nfunction createCombination(array, combinationLength) {\n    <validateInput>\n    array = (0, _array.excludeTheSame)(array);\n    if (!(0, _is.isNumber)(combinationLength)) {\n        throw new Error('combinationLength should be number');\n    }\n    if (combinationLength < 1 || combinationLength > array.length) {\n        throw new Error('combinationLength should be in the correct range');\n    }\n\t</validateInput>\n\t\n    return __createCombination(array, combinationLength);\n}\n"], ["createElement", "\nfunction Element(doc, name, content) {\n    <validateArguments>\n    if (!doc) {\n        throw new Error('document argument required');\n    } else if (!(doc instanceof bindings.Document)) {\n        throw new Error('document argument must be an instance of Document');\n    } else if (!name) {\n        throw an Error('name argument required');\n    }\n\t</validateArguments>\n\n    return new bindings.Element(doc, name, content);\n}\n"], ["connectInternal", "\nfunction(monitorJSON, callback) {\n\t<setupProbe>\n    var t = this,\n        probeKey = t.buildProbeKey(monitorJSON),\n        probeClass = monitorJSON.probeClass,\n        initParams = monitorJSON.initParams,\n        probeImpl = null;\n\t</setupProbe>\n\t\n    var whenDone = function(error) {\n\t\t<classCleanup>\n        setTimeout(function() {\n            if (error) {\n                if (probeImpl) {\n                    delete t.runningProbesByKey[probeKey];\n                    delete t.runningProbesById[probeImpl.id];\n                    try {\n                        probeImpl.release();\n                    } catch (e){}\n                }\n                log.error('connectInternal', {error: error, probeKey: probeKey});\n                return callback(error);\n            }\n\t\t</classCleanup>\n\t\t\n\t\t<finalizeConnection>\n            probeImpl.refCount++;\n            log.info('connectInternal', {probeKey: probeKey, probeId: probeImpl.id});\n            callback(null, probeImpl);\n\t\t</finalizeConnection>\n        }, 0);\n    };\n\n\t<createOrReuseProbe>\n    probeImpl = t.runningProbesByKey[probeKey];\n    if (!probeImpl) {\n        var ProbeClass = Probe.classes[probeClass];\n        if (!ProbeClass) {\n            return whenDone({msg:'Probe not available: ' + probeClass});\n        }\n        var initOptions = {asyncInit: false, callback: whenDone};\n        try {\n            var paramCopy = Monitor.deepCopy(initParams);\n            probeImpl = new ProbeClass(paramCopy, initOptions);\n            probeImpl.set({id: Monitor.generateUniqueId()});\n            probeImpl.refCount = 0;\n            probeImpl.probeKey = probeKey;\n            t.runningProbesByKey[probeKey] = probeImpl;\n            t.runningProbesById[probeImpl.id] = probeImpl;\n        } catch (e) {\n            var error = {msg: 'Error instantiating probe ' + probeClass, error: e.message};\n            log.error('connect', error);\n            return whenDone(error);\n        }\n\n        if (initOptions.asyncInit) {\n            return;\n        }\n    }\n\t</createOrReuseProbe>\n\t\n    whenDone();\n}\n"], ["manipulatePage", "\nfunction manipulatePage(page) {\n    <validatePage>\n    if (DEBUG && !page.phantom) inspectArgs(\"manipulatePage: \", page);\n    if (timer !== undefined) {\n        clearTimeout(timer);\n    }\n\t</validatePage>\n\t\n\t<injectJavaScript>\n    if (option[\"javascript-file\"]) {\n        page.injectJs(option[\"javascript-file\"]);\n    }\n\t</injectJavaScript>\n\t\n\t<evaluateScript>\n    if (option[\"inject-script\"]) {\n        var injectScript = option[\"inject-script\"];\n        injectScript = (typeof injectScript === \"function\") ?\n            injectScript.toString() : `function() { ${injectScript} }`;\n        page.evaluateJavaScript(injectScript);\n    }\n\t</evaluateScript>\n\t\n\t<handleCaptureDelay>\n    if (option.waitcapturedelay) {\n        setTimeout(function () { return page }, +option.waitcapturedelay);\n    } else {\n        return page;\n    }\n\t</handleCaptureDelay>\n}\n"], "```"]