[["matchedText", "\nfunction matchedText(pattern, candidate) {\n        ts.Debug.assert(isPatternMatch(pattern, candidate));\n        return candidate.substr(pattern.prefix.length, candidate.length - pattern.suffix.length);\n}\n"], ["unnamedFunction", "\nfunction () {\n        this.logger = Logger.getLogger(\"LogisticGradient_js\");\n        var jvmObject;\n        if (arguments[0]) {\n            if (arguments[0] instanceof org.apache.spark.mllib.optimization.LogisticGradient) {\n                jvmObject = arguments[0];\n            } else {\n                jvmObject = new org.apache.spark.mllib.optimization.LogisticGradient(arguments[0]);\n            }\n        } else {\n            jvmObject = new org.apache.spark.mllib.optimization.LogisticGradient();\n        }\n\n        Gradient.call(this, jvmObject);\n\n}\n"], ["compile", "\nfunction compile(emit) {\n    self.bundler.run(function(err, stats) {\n      if (err || stats.compilation.errors.length) {\n        var errors = stats.toJson({ errorDetails: true }).errors;\n        <handleCompilationErrors>\n        var recompile = errors.reduce(function(recompile, err) {\n          if (Resolver.isMissingModuleError(err))\n            recompile = Resolver.installPackageFromError(err);\n          return recompile;\n        }, false);\n        if (recompile) return compile();\n        \n        if (err) global.shipp.logger.error(err);\n        if (stats.compilation.errors.length) global.shipp.logger.error(stats.toString({ errorDetails: true }));\n\n        return;\n        </handleCompilationErrors>\n      }\n\n      global.shipp.log(\"Bundled\", self.path);\n      if (emit) global.shipp.emit(\"route:refresh\", { route: self.path });\n    });\n}\n"], ["midRange", "\nfunction midRange(start, end, count) {\n    count = Math.max(+count || 0, 2); \n    count -= 1; \n    var diff = end - start;\n    var incr = diff / count;\n    var ret = [];\n    for (var i = 0; i <= count; i++) {\n        ret.push(start + incr * i);\n    }\n    return ret;\n}\n"], ["unnamedFunction_2", "\nfunction() {\n      this.writeDebug('sorting',arguments);\n      var _this = this,\n          $mapDiv = $('#' + _this.settings.mapID),\n          $sortSelect = $('#' + _this.settings.sortID);\n\n      if ($sortSelect.length === 0) {\n          return;\n      }\n\n      $sortSelect.on('change.'+pluginName, function (e) {\n          e.stopPropagation();\n\n          if (_this.settings.pagination === true) {\n              _this.paginationChange(0);\n          }\n\n          var sortMethod,\n              sortVal;\n\n          sortMethod = (typeof $(this).find(':selected').attr('data-method') !== 'undefined') ?  $(this).find(':selected').attr('data-method') : 'distance';\n          sortVal = $(this).val();\n\n          _this.settings.sortBy.method = sortMethod;\n          _this.settings.sortBy.prop = sortVal;\n\n          if (_this.settings.callbackSorting) {\n              _this.settings.callbackSorting.call(this, _this.settings.sortBy);\n          }\n\n          if ($mapDiv.hasClass('bh-sl-map-open')) {\n              _this.mapping(mappingObj);\n          }\n      });\n}\n"], ["dataUpdatePaddings", "\nfunction (forceUpdatePaddings) {\n            var state = this.state,\n                pages = state.pages,\n                rows = state.rows,\n                scrollTop = this.$viewport.scrollTop(),\n                scrollLeft = this.$viewport.scrollLeft(),\n                rowIndex = 0,\n                lastY1 = 0,\n                rightmostPageIndex = 0,\n                bottommostPageIndex = 0,\n                i,\n                len,\n                page,\n                pageEl,\n                $pageEl;\n\n            rows.length = state.sumWidths = state.sumHeights = state.totalWidth = state.totalHeight = 0;\n            state.widestPage.totalActualWidth = state.tallestPage.totalActualHeight = 0;\n\n            for (i = 0, len = this.$pages.length; i < len; ++i) {\n                $pageEl = this.$pages.eq(i);\n                pageEl = $pageEl[0];\n                page = pages[i];\n                if (!page || forceUpdatePaddings) {\n                    $pageEl.css('padding', '');\n                    page = {\n                        index: i,\n                        paddingLeft: parseFloat($pageEl.css(STYLE_PADDING_LEFT)),\n                        paddingRight: parseFloat($pageEl.css(STYLE_PADDING_RIGHT)),\n                        paddingTop: parseFloat($pageEl.css(STYLE_PADDING_TOP)),\n                        paddingBottom: parseFloat($pageEl.css(STYLE_PADDING_BOTTOM))\n                    };\n                }\n\n                if (!page.actualWidth) {\n                    page.actualWidth = parseFloat(pageEl.getAttribute('data-width'));\n                }\n                if (!page.actualHeight) {\n                    page.actualHeight = parseFloat(pageEl.getAttribute('data-height'));\n                }\n\n                page.totalActualWidth = page.actualWidth + page.paddingLeft + page.paddingRight;\n                page.totalActualHeight = page.actualHeight + page.paddingTop + page.paddingBottom;\n\n                page.width = pageEl.offsetWidth;\n                page.height = pageEl.offsetHeight;\n                page.x0 = pageEl.offsetLeft;\n                page.y0 = pageEl.offsetTop;\n\n                page.x1 = page.width + page.x0;\n                page.y1 = page.height + page.y0;\n\n                if (lastY1 && getMaxY1InRow(pages, rows[rowIndex]) <= page.y0 + 2) {\n                    rowIndex++;\n                }\n                lastY1 = page.y1;\n                if (!rows[rowIndex]) {\n                    rows[rowIndex] = [];\n                }\n                if (page.totalActualWidth > state.widestPage.totalActualWidth) {\n                    state.widestPage = page;\n                }\n                if (page.totalActualHeight > state.tallestPage.totalActualHeight) {\n                    state.tallestPage = page;\n                }\n                state.sumWidths += page.width;\n                state.sumHeights += page.height;\n                page.rowIndex = rowIndex;\n                pages[i] = page;\n                rows[rowIndex].push(i);\n\n                if (pages[rightmostPageIndex].x0 + pages[rightmostPageIndex].width < page.x0 + page.width) {\n                    rightmostPageIndex = i;\n                }\n                if (pages[bottommostPageIndex].y0 + pages[bottommostPageIndex].height < page.y0 + page.height) {\n                    bottommostPageIndex = i;\n                }\n            }\n\n            state.totalWidth = pages[rightmostPageIndex].x0 + pages[rightmostPageIndex].width;\n            state.totalHeight = pages[bottommostPageIndex].y0 + pages[bottommostPageIndex].height;\n            state.scrollTop = scrollTop;\n            state.scrollLeft = scrollLeft;\n            this.setCurrentPage(this.calculateCurrentPage());\n}\n"], ["_fnStringToCss", "\nfunction _fnStringToCss( s )\n{\n    if ( s === null )\n    {\n        return \"0px\";\n    }\n\n    if ( typeof s == 'number' )\n    {\n        if ( s < 0 )\n        {\n            return \"0px\";\n        }\n        return s+\"px\";\n    }\n\n    var c = s.charCodeAt( s.length-1 );\n    if (c < 0x30 || c > 0x39)\n    {\n        return s;\n    }\n    return s+\"px\";\n}\n"], ["get", "\nfunction get(arr, n) {\n    return n >= 0 ? arr[n] : arr[arr.length + n];\n}\n"], ["bsearch", "\nfunction bsearch(arr, val, key) {\n  var pred = typeof val === 'function' ? val : (typeof key === 'string'\n    ? function(item) { return val <= item[key]; }\n    : function(item) { return val <= item; });\n\n  var lo = -1, hi = arr.length;\n  while (1 + lo !== hi) {\n    var mi = lo + ((hi - lo) >> 1);\n    if (pred(arr[mi])) {\n      hi = mi;\n    } else {\n      lo = mi;\n    }\n  }\n  return hi;\n}\n"], ["_handleDataUpdate", "\nfunction _handleDataUpdate() {\n    const rawData = dataEditor.getValue();\n    let freshData = null;\n\n    <parseData>\n    try {\n        freshData = evalDataString(rawData);\n    } catch(e) {\n        errors.push(new Error('Could not parse the data from the input field', rawData));\n    }\n    </parseData>\n\n    storage.setDataByKey(savedDataKey, freshData);\n\n    if (freshData) {\n        setNewChart();\n    }\n}\n"], "```"]