[["Insert", "\nfunction Insert(dst, src) {\n  for (var id in src) {\n    if (src.hasOwnProperty(id)) {\n      <deepCopyQualifier>\n      if (typeof src[id] === 'object' && !(src[id] instanceof Array) &&\n        (typeof dst[id] === 'object' || typeof dst[id] === 'function'))\n      {\n        Insert(dst[id], src[id])\n      } else {\n        dst[id] = src[id]\n      }\n      </deepCopyQualifier>\n    }\n  }\n  return dst;\n}\n"], ["baseUniq", "\nfunction baseUniq(array, iteratee, comparator) {\n  var index = -1,\n    includes = _arrayIncludes,\n    length = array.length,\n    isCommon = true,\n    result = [],\n    seen = result;\n\n  <initializeComparator>\n  if (comparator) {\n    isCommon = false;\n    includes = _arrayIncludesWith;\n  }\n  </initializeComparator>\n  <initializeSet>\n  else if (length >= LARGE_ARRAY_SIZE$1) {\n    var set = iteratee ? null : _createSet(array);\n    if (set) {\n      return _setToArray(set);\n    }\n    isCommon = false;\n    includes = _cacheHas;\n    seen = new _SetCache;\n  }\n  </initializeSet>\n  else {\n    seen = iteratee ? [] : result;\n  }\n\n  <mainLoop>\n  outer:\n  while (++index < length) {\n    var value = array[index],\n      computed = iteratee ? iteratee(value) : value;\n\n    value = (comparator || value !== 0) ? value : 0;\n    if (isCommon && computed === computed) {\n      var seenIndex = seen.length;\n      while (seenIndex--) {\n        if (seen[seenIndex] === computed) {\n          continue outer;\n        }\n      }\n      if (iteratee) {\n        seen.push(computed);\n      }\n      result.push(value);\n    }\n    else if (!includes(seen, computed, comparator)) {\n      if (seen !== result) {\n        seen.push(computed);\n      }\n      result.push(value);\n    }\n  }\n  </mainLoop>\n  return result;\n}\n"], ["optimize", "\nfunction optimize(svg, prefix, params) {\n  var nodeColorIndex = {},\n    edgeColorIndex = {},\n    count = 0,\n    color,\n    style,\n    styleText = '',\n    f,\n    i,\n    l;\n\n  <initStyle>\n  if (params.classes) {\n    style = document.createElementNS(XMLNS, 'style');\n    style.setAttribute('type', 'text/css')\n    svg.insertBefore(style, svg.firstChild);\n  }\n  </initStyle>\n\n  <processNodes>\n  var nodes = svg.querySelectorAll('[id=\"' + prefix + '-group-nodes\"] > [class=\"' + prefix + '-node\"]');\n  for (i = 0, l = nodes.length, f = true; i < l; i++) {\n    color = nodes[i].getAttribute('fill');\n    if (!params.data)\n      nodes[i].removeAttribute('data-node-id');\n    if (params.classes) {\n      if (!(color in nodeColorIndex)) {\n        nodeColorIndex[color] = (f ? prefix + '-node' : 'c-' + (count++));\n        styleText += '.' + nodeColorIndex[color] + '{fill: ' + color + '}';\n      }\n      if (nodeColorIndex[color] !== prefix + '-node')\n        nodes[i].setAttribute('class', nodes[i].getAttribute('class') + ' ' + nodeColorIndex[color]);\n      nodes[i].removeAttribute('fill');\n    }\n    f = false;\n  }\n  </processNodes>\n\n  <processEdges>\n  var edges = svg.querySelectorAll('[id=\"' + prefix + '-group-edges\"] > [class=\"' + prefix + '-edge\"]');\n  for (i = 0, l = edges.length, f = true; i < l; i++) {\n    color = edges[i].getAttribute('stroke');\n    if (!params.data)\n      edges[i].removeAttribute('data-edge-id');\n    if (params.classes) {\n      if (!(color in edgeColorIndex)) {\n        edgeColorIndex[color] = (f ? prefix + '-edge' : 'c-' + (count++));\n        styleText += '.' + edgeColorIndex[color] + '{stroke: ' + color + '}';\n      }\n      if (edgeColorIndex[color] !== prefix + '-edge')\n        edges[i].setAttribute('class', edges[i].getAttribute('class') + ' ' + edgeColorIndex[color]);\n      edges[i].removeAttribute('stroke');\n    }\n    f = false;\n  }\n  </processEdges>\n\n  <appendStyles>\n  if (params.classes)\n    style.appendChild(document.createTextNode(styleText));\n  </appendStyles>\n}\n"], ["getNullLogger", "\nfunction getNullLogger() {\n  return new Proxy(\n    {},\n    {\n      <proxyGet>\n      get: function(target, propKey) {\n        if (propKey === 'Timer') {\n          return _.bind(InnerTimer, {}, undefined)\n        }\n        return function() {}\n      },\n      </proxyGet>\n      <proxyApply>\n      apply: function(target, object, args) {}\n      </proxyApply>\n    }\n  )\n}\n"], ["convertToIcns", "\nfunction convertToIcns(pngSrc, icnsDest, callback) {\n  <checkOSX>\n  if (!isOSX()) {\n    callback('OSX is required to convert .png to .icns icon', pngSrc);\n    return;\n  }\n  </checkOSX>\n  <shellExecConvert>\n  shell.exec(\n    `\"${PNG_TO_ICNS_BIN_PATH}\" \"${pngSrc}\" \"${icnsDest}\"`,\n    { silent: true },\n    (exitCode, stdOut, stdError) => {\n      if (stdOut.includes('icon.iconset:error') || exitCode) {\n        if (exitCode) {\n          callback(\n            {\n              stdOut,\n              stdError,\n            },\n            pngSrc,\n          );\n          return;\n        }\n        callback(stdOut, pngSrc);\n        return;\n      }\n      callback(null, icnsDest);\n    },\n  );\n  </shellExecConvert>\n}\n"], ["push", "\nfunction(base, extra, protect) {\n  if (base) {\n    Object.keys(extra || {}).forEach(function(key) {\n      if (base[key] && protect) {\n        throw new Error('utils.push attempted to overwrite \"' + key + '\" while running in protected mode');\n      }\n      <mergeObjects>\n      if (typeof base[key] == 'object' && typeof extra[key] == 'object') {\n        this.push(base[key], extra[key]);\n      } else {\n        base[key] = extra[key];\n      }\n      </mergeObjects>\n    }, this);\n  }\n  return base;\n}\n"], ["toggleChoice", "\nfunction toggleChoice(choice, evt) {\n  <preventEventPropagation>\n  if (lxSelect.multiple && !lxSelect.autocomplete && angular.isDefined(evt)) {\n    evt.stopPropagation();\n  }\n  </preventEventPropagation>\n  <manageChoices>\n  if (lxSelect.areChoicesOpened() && lxSelect.multiple) {\n    var dropdownElement = angular.element(angular.element(evt.target).closest('.dropdown-menu--is-open')[0]);\n    \n    <adjustDropdown>\n    if (dropdownElement.scrollTop() > 0) {\n      var dropdownContentElement = angular.element(dropdownElement.find('.dropdown-menu__content')[0]);\n      var dropdownFilterElement = angular.element(dropdownContentElement.find('.lx-select-choices__filter')[0]);\n      var newHeight = dropdownContentElement.height();\n      newHeight -= (dropdownFilterElement.length) ? dropdownFilterElement.outerHeight() : 0;\n      var dropdownListElement = angular.element(dropdownContentElement.find('ul > div')[0]);\n      dropdownListElement.css('height', newHeight + 'px');\n      \n      lxSelect.resetDropdownSize = function() {\n        dropdownListElement.css('height', 'auto');\n        lxSelect.resetDropdownSize = undefined;\n      }\n    }\n    </adjustDropdown>\n  }\n  </manageChoices>\n  <selectChoice>\n  if (lxSelect.multiple && isSelected(choice)) {\n    lxSelect.unselect(choice);\n  } else {\n    lxSelect.select(choice);\n  }\n  </selectChoice>\n  <autocompleteActions>\n  if (lxSelect.autocomplete) {\n    lxSelect.activeChoiceIndex = -1;\n    lxSelect.filterModel = undefined;\n  }\n  <closeDropdown>\n  if (lxSelect.autocomplete || (lxSelect.choicesViewMode === 'panes' && !lxSelect.multiple)) {\n    LxDropdownService.close('dropdown-' + lxSelect.uuid);\n  }\n  </closeDropdown>\n  </autocompleteActions>\n}\n"], ["buildImdbApiUrl", "\nfunction(params) {\n  var baseUrl = 'http://www.omdbapi.com/';\n  var query = '?';\n  \n  <appendSearchParams>\n  query += 's='.concat(encodeURIComponent(params.query));\n  \n  if (params.year) {\n    query += '&y='.concat(params.year);\n  }\n  if (params.type) {\n    query += '&type='.concat(params.type);\n  }\n  if (params.apiKey) {\n    query += '&apikey='.concat(params.apiKey);\n  }\n  </appendSearchParams>\n  \n  return baseUrl.concat(query, '&r=json&v=1');\n}\n"], ["getPushRules", "\nasync function getPushRules() {\n  try {\n    debuglog(\"Getting push rules...\");\n    const result = await client.getPushRules();\n    debuglog(\"Got push rules\");\n    <storePushRules>\n    client.pushRules = result;\n    </storePushRules>\n  } catch (err) {\n    console.error(\"Getting push rules failed\", err);\n    if (self._shouldAbortSync(err)) return;\n    <handleSyncError>\n    debuglog(\"Waiting for saved sync before retrying push rules...\");\n    await self.recoverFromSyncStartupError(savedSyncPromise, err);\n    getPushRules();\n    </handleSyncError>\n    return;\n  }\n  <checkLazyLoadStatus>\n  checkLazyLoadStatus(); \n  </checkLazyLoadStatus>\n}\n"], ["transact", "\nfunction transact(transaction, api, secret, options, converter, callback) {\n  if (options.submit === false) {\n    prepareAndOptionallySign.apply(this, arguments);\n  } else {\n    prepareAndSignAndSubmit.apply(this, arguments);\n  }\n}\n"], "```\nThese annotations seek to identify distinct blocks of responsibility while avoiding over-segmentation. Each tagged section outlines coherent sets of instructions towards a particular purpose within the functions."]