[["checkQuery", "\nfunction checkQuery(expected, actual){\n    if(!expected){\n        return;\n    }\n\n    <parseQueries>\n    var actualObj = actual ? queryString.parse(actual.replace(/\\&$/, '')) : {};\n    var expectedObj = queryString.parse(expected);\n    </parseQueries>\n\n    <compareQueries>\n    if(! _.isEqual(actualObj, expectedObj)){\n        return {\n            error: \"Query parameters do not match\",\n            expected: expectedObj,\n            actual: actualObj\n        };\n    }\n    </compareQueries>\n}\n"], ["getOrdinalNumberString", "\nfunction(n) {\n    <convertToOrdinal>\n    var num = abs(n), last = +num.toString().slice(-2);\n    return n + getOrdinalSuffix(last);\n    </convertToOrdinal>\n}\n"], ["getOptionOrDefault", "\nfunction(opt, field_name, default_value) {\n    if(typeof field_name === 'string') {\n      \n      return (typeof opt[field_name] !== 'undefined') ? opt[field_name] : default_value;\n    } else {\n      \n      <extractMultipleFieldsOrDefault>\n      var ret = default_value;\n      for(var i=0;i<field_name.length;i++) {\n        var f = field_name[i];\n        if (typeof opt[f] !== 'undefined') {\n          ret = opt[f]; \n        }\n      }\n      return ret;\n      </extractMultipleFieldsOrDefault>\n    }\n}\n"], ["initializeConnection", "\nfunction Connection (options, clientOptions, label) {\n        <setConnectionProperties>\n        this.options = options;\n        this.clientOptions = clientOptions;\n        this.label = label;\n        this.initialConnection = false;\n        this.initialConnectionRetries = 0;\n        this.maxConnectionRetries = 60;\n        </setConnectionProperties>\n\n        <defineConnectionExchanges>\n        Object.defineProperty(this, 'exchanges', {\n            get: function () {\n                if (this.connection) {\n                    return this.connection.exchanges;\n                }\n            }\n        });\n        </defineConnectionExchanges>\n\n        <defineConnectionStatus>\n        Object.defineProperty(this, 'connected', {\n            get: function () {\n                return this.connection !== undefined;\n            }\n        });\n        </defineConnectionStatus>\n}\n"], ["replaceGlobalExpression", "\nfunction(nodePath, state) {\n        var replacements = [];\n        <computeExpressionAssignment>\n        var expr = getGlobalExpression(state, getFilenameNoExt(state.file.opts.filename), true);\n        createGlobal(expr, replacements, true);\n        var originalGlobal = getGlobalExpression(state, nodePath.node.source.value, true);\n        replacements.push(t.expressionStatement(t.callExpression(\n          t.memberExpression(\n            t.callExpression(\n              t.memberExpression(t.identifier('Object'), t.identifier('keys')),\n              [originalGlobal]\n            ),\n            t.identifier('forEach')\n          ),\n          [t.functionExpression(\n            null,\n            [t.identifier('key')],\n            t.blockStatement(\n              [t.expressionStatement(t.assignmentExpression(\n                '=',\n                t.memberExpression(expr, t.identifier('key'), true),\n                t.memberExpression(originalGlobal, t.identifier('key'), true)\n              ))]\n            )\n          )]\n        )));\n        </computeExpressionAssignment>\n        <nodeReplacement>\n        nodePath.replaceWithMultiple(replacements);\n        </nodeReplacement>\n}\n"], ["processServerResponse", "\nfunction (serverResponse, request) {\n    <parseServerResponseBody>\n    serverResponse = serverResponse.body;\n    const bids = [];\n    if (!serverResponse || serverResponse.error) {\n      let errorMessage = `in response for ${request.bidderCode} adapter`;\n      if (serverResponse && serverResponse.error) { errorMessage += `: ${serverResponse.error}`; }\n      utils.logError(errorMessage);\n      return bids;\n    }\n    </parseServerResponseBody>\n\n    <createBidsFromResponse>\n    if (serverResponse.ad) {\n      serverResponse.ad.forEach(ad => {\n        const creativeBid = getCreative(ad);\n        if (creativeBid) {\n          if (parseInt(creativeBid.cpm) !== 0) {\n            const bid = newBid(ad, creativeBid, request);\n            bid.mediaType = parseMediaType(creativeBid);\n            bids.push(bid);\n          }\n        }\n      });\n    }\n    </createBidsFromResponse>\n\n    return bids;\n}\n"], ["annotationAtParameter", "\nfunction annotationAtParameter(sSegment, sWholeSegment) {\n\t\t\t\tvar mAnnotationsXAllOverloads,\n\t\t\t\t\tsIndividualOverloadTarget,\n\t\t\t\t\taOverloads,\n\t\t\t\t\tsSignature = \"\",\n\t\t\t\t\tsTerm = sWholeSegment.slice(sSegment.length);\n\n\t\t\t\tif (sTerm && maybeParameter(sSegment, vResult)) {\n\t\t\t\t\t\n\t\t\t\t\tsName = sSegment;\n\t\t\t\t\tif (vBindingParameterType) {\n\t\t\t\t\t\taOverloads = vResult.filter(isRightOverload);\n\t\t\t\t\t\tif (aOverloads.length !== 1) {\n\t\t\t\t\t\t\treturn log(WARNING, \"Expected a single overload, but found \"\n\t\t\t\t\t\t\t\t+ aOverloads.length);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (vBindingParameterType !== UNBOUND) {\n\t\t\t\t\t\t\tsSignature = aOverloads[0].$Parameter[0].$isCollection\n\t\t\t\t\t\t\t\t? \"Collection(\" + vBindingParameterType + \")\"\n\t\t\t\t\t\t\t\t: vBindingParameterType;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsIndividualOverloadTarget = sTarget + \"(\" + sSignature + \")/\" + sSegment;\n\t\t\t\t\t\tif (mScope.$Annotations[sIndividualOverloadTarget]) {\n\t\t\t\t\t\t\tif (sTerm === \"@\") {\n\t\t\t\t\t\t\t\tvResult = mScope.$Annotations[sIndividualOverloadTarget];\n\t\t\t\t\t\t\t\tmAnnotationsXAllOverloads\n\t\t\t\t\t\t\t\t\t= mScope.$Annotations[sTarget + \"/\" + sSegment];\n\t\t\t\t\t\t\t\tif (mAnnotationsXAllOverloads) {\n\t\t\t\t\t\t\t\t\tvResult = Object.assign({}, mAnnotationsXAllOverloads, vResult);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\treturn false; \n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (mScope.$Annotations[sIndividualOverloadTarget][sTerm]) {\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tsTarget = sIndividualOverloadTarget;\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\tsTarget += \"/\" + sSegment;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n}\n"], ["gitUrlParse", "\nfunction gitUrlParse(url) {\n    <validateInput>\n    if (typeof url !== \"string\") {\n        throw new Error(\"The url must be a string.\");\n    }\n    </validateInput>\n\n    let urlInfo = gitUp(url)\n    <processUrlParts>\n      , sourceParts = urlInfo.resource.split(\".\")\n      , splits = null\n      ;\n    </processUrlParts>\n\n    <urlToStringMethod>\n    urlInfo.toString = function (type) {\n        return gitUrlParse.stringify(this, type);\n    };\n    </urlToStringMethod>\n\n    <setUrlInfoSource>\n    urlInfo.source = sourceParts.length > 2\n                   ? sourceParts.slice(1 - sourceParts.length).join(\".\")\n                   : urlInfo.source = urlInfo.resource\n                   ;\n    </setUrlInfoSource>\n\n    <parseUrlComponents>\n    \n    urlInfo.git_suffix = /\\.git$/.test(urlInfo.pathname);\n    urlInfo.name = decodeURIComponent(urlInfo.pathname.replace(/^\\\n    urlInfo.owner = decodeURIComponent(urlInfo.user);\n    </parseUrlComponents>\n\n    <urlInfoCases>\n    switch (urlInfo.source) {\n        \n        default:\n            splits = urlInfo.name.split(\"/\");\n            let nameIndex = splits.length - 1;\n            if (splits.length >= 2) {\n                const blobIndex = splits.indexOf(\"blob\", 2);\n                const treeIndex = splits.indexOf(\"tree\", 2);\n                const commitIndex = splits.indexOf(\"commit\", 2);\n                nameIndex = blobIndex > 0 ? blobIndex - 1\n                          : treeIndex > 0 ? treeIndex - 1\n                          : commitIndex > 0 ? commitIndex - 1\n                          : nameIndex;\n\n                urlInfo.owner = splits.slice(0, nameIndex).join('/');\n                urlInfo.name = splits[nameIndex];\n                if (commitIndex) {\n                    urlInfo.commit = splits[nameIndex + 2]\n                }\n            }\n\n            urlInfo.ref = \"\";\n            urlInfo.filepathtype = \"\";\n            urlInfo.filepath = \"\";\n            if ((splits.length > nameIndex + 2) && ([\"blob\", \"tree\"].indexOf(splits[nameIndex + 1]) >= 0)) {\n                urlInfo.filepathtype = splits[nameIndex + 1];\n                urlInfo.ref = splits[nameIndex + 2];\n                if (splits.length > nameIndex + 3) {\n                    urlInfo.filepath = splits.slice(nameIndex + 3).join('/');\n                }\n            }\n            urlInfo.organization = urlInfo.owner;\n            break;\n    }\n    </urlInfoCases>\n\n    <finalizeFullName>\n    if (!urlInfo.full_name) {\n        urlInfo.full_name = urlInfo.owner;\n        if (urlInfo.name) {\n            urlInfo.full_name && (urlInfo.full_name += \"/\");\n            urlInfo.full_name += urlInfo.name;\n        }\n    }\n    </finalizeFullName>\n\n    return urlInfo;\n}\n"], ["initCaches", "\nfunction init(){\n    self.caches = [];\n    <checkConfiguration>\n    if(isEmpty(cacheModules)){\n      log(false, 'No cacheModules array provided--using the default configuration.');\n      getDefaultConfiguration();\n    }\n    </checkConfiguration>\n    else{\n      <useCustomConfiguration>\n      log(false, 'cacheModules array provided--using a custom configuration.');\n      getCustomConfiguration();\n      </useCustomConfiguration>\n      <validateCaches>\n      if(self.caches.length < 1){\n        throw new Exception('NoCacheException', 'No caches were succesfully initialized.');\n      }\n      </validateCaches>\n    }\n}\n"], ["executeFunctions", "\nfunction(fnStr, options) {\n    options = options || {};\n    <invokeTargetFunction>\n    var fns = [\n      this[fnStr].apply(this, [options])\n    ];\n    </invokeTargetFunction>\n    <invokeRelatedFunctions>\n    _.each(this.relationDefinitions, function(relationAttributes, relationKey) {\n      var relation = this.get(relationKey);\n      if (relation) {\n        fns.push(relation[fnStr](options));\n      }\n    }, this);\n    </invokeRelatedFunctions>\n    <aggregatePromises>\n    return Promises.when.all(fns);\n    </aggregatePromises>\n}\n"], "```"]