[["App", "\nfunction App(appManager, config, options) {\n    const app = this;\n    this.expressApp = Express();\n\n    <RouterSetup>\n    this.Router = function() {\n        Router.apply(this, arguments);\n    };\n    this.Router.prototype = Object.create(Router.prototype);\n    this.Router.prototype.constructor = Router;\n    this.Router.prototype.App = this;\n    </RouterSetup>\n    \n    <AppIInitialization>\n    AppI.call(this, appManager, config, options);\n    app.$normalizeConfig();\n    </AppIInitialization>\n}\n"], ["sluggable", "\nfunction sluggable(options) {\n  <OptionDefaults>\n  options = options || {};\n  var key = options.key || 'slug'\n  var properties = _.extend({}, { type: String, lowercase: true, trim: true, unique: true }, options.properties)\n  var source = options.source || 'title';\n  </OptionDefaults>\n    \n  <SluggableFunction>\n  return function sluggable(schema) {\n    <SchemaSetup>\n    var obj = {};\n    obj[key] = properties;\n    schema.add(obj);\n    </SchemaSetup>    \n    \n    <SlugValueSetter>\n    schema.path(key).set(function(v) {\n      <Normalization>\n      v = v.toLowerCase();\n      </Normalization>\n      \n      <CharacterReplacement>\n      var from = \"\u00e0\u00e1\u00e4\u00e2\u00e8\u00e9\u00eb\u00ea\u00ec\u00ed\u00ef\u00ee\u00f2\u00f3\u00f6\u00f4\u00f9\u00fa\u00fc\u00fb\u00f1\u00e7\";\n      var to = \"aaaaeeeeiiiioooouuuunc\";\n      for (var i = 0, l = from.length; i < l; i++) {\n        v = v.replace(new RegExp(from.charAt(i), 'g'), to.charAt(i));\n      }\n      </CharacterReplacement>\n      \n      <SlugTransformation>\n      v = v.replace(/[^a-z0-9]/g, '').replace(/-+/g, '');\n      v = v.replace(/\\s+/g, '-');\n      v = v.substr(0, 255);\n      </SlugTransformation>\n      \n      return v;\n    });\n    </SlugValueSetter>\n    \n    <SourceValueSetter>\n    schema.path(source).set(function(v) {\n      if (!this[key]) {\n        this[key] = v;\n      }\n      return v;\n    });\n    </SourceValueSetter>\n  }\n  </SluggableFunction>\n}\n"], ["compareScreenshot", "\nfunction compareScreenshot(path1, path2, compareOpts) {\n    <OptionSetup>\n    var compareOptions = _.extend({}, options, compareOpts || {});\n    </OptionSetup>\n\n    <DeferredSetup>\n    var deferred = Q.defer();\n    </DeferredSetup>\n    \n    <ImageComparison>\n    gm.compare(path1, path2, compareOptions, function (err, isEqual, equality ) {\n      if (err) { throw err; }\n      <ResultProcessing>\n      isEqual ? deferred.resolve(equality) : deferred.reject([path2, ' is not equal to ', path1, ' (tolerance:', compareOptions.tolerance, ', result:', equality, ')'].join(''));\n      </ResultProcessing>\n    });\n    </ImageComparison>\n    \n    return deferred.promise;\n}\n"], ["function(helper)", "\nfunction(helper) {\n                \n    var target = {},\n        <RetrieveClientRects>\n        rects = this.__instance._$origin[0].getClientRects();\n        </RetrieveClientRects>\n\n        <OpacityAdjustment>\n        if (rects.length > 1) {\n            var opacity = this.__instance._$origin.css('opacity');\n            if (opacity == 1) {\n                this.__instance._$origin.css('opacity', 0.99);\n                rects = this.__instance._$origin[0].getClientRects();\n                this.__instance._$origin.css('opacity', 1);\n            }\n        }\n        </OpacityAdjustment>\n        \n        <SingleRectCalculation>\n        if (rects.length < 2) {\n            target.top = Math.floor(helper.geo.origin.windowOffset.left + (helper.geo.origin.size.width / 2));\n            target.bottom = target.top;\n            target.left = Math.floor(helper.geo.origin.windowOffset.top + (helper.geo.origin.size.height / 2));\n            target.right = target.left;\n        }\n        </SingleRectCalculation>\n        \n        <MultipleRectCalculation>\n        else {\n            <CalculateInitialValues>\n            var targetRect = rects[0];\n            target.top = Math.floor(targetRect.left + (targetRect.right - targetRect.left) / 2);\n            </CalculateInitialValues>\n            \n            <MiddleRectCalculation>\n            if (rects.length > 2) {\n                targetRect = rects[Math.ceil(rects.length / 2) - 1];\n            }\n            else {\n                targetRect = rects[0];\n            }\n            target.right = Math.floor(targetRect.top + (targetRect.bottom - targetRect.top) / 2);\n            </MiddleRectCalculation>\n            \n            <LastRectCalculation>\n            targetRect = rects[rects.length - 1];\n            target.bottom = Math.floor(targetRect.left + (targetRect.right - targetRect.left) / 2);\n            </LastRectCalculation>\n            \n            <CenterRectCalculation>\n            if (rects.length > 2) {\n                targetRect = rects[Math.ceil((rects.length + 1) / 2) - 1];\n            }\n            else {\n                targetRect = rects[rects.length - 1];\n            }\n            target.left = Math.floor(targetRect.top + (targetRect.bottom - targetRect.top) / 2);\n            </CenterRectCalculation>\n        }\n        </MultipleRectCalculation>\n        \n        return target;\n}\n"], ["internal", "\nfunction internal(obj) {\n  <PrivateMapInitialization>\n  if (!privateMap.has(obj)) {\n    privateMap.set(obj, {});\n  }\n  </PrivateMapInitialization>\n  <ReturnPrivateProperties>\n  return privateMap.get(obj);\n  </ReturnPrivateProperties>\n}\n"], ["loadFromConfig", "\nfunction loadFromConfig(router, providers, sessionStore) {\n  <SiteMapConstruction>\n  const sitesMap = siteService.sites(),\n    siteHosts = _.uniq(_.map(sitesMap, 'host'));\n  </SiteMapConstruction>\n\n  <AddHostToRouter>\n  _.each(siteHosts, hostname => {\n    const sites = _.filter(sitesMap, {host: hostname}).sort(sortByDepthOfPath);\n    addHost({\n      router,\n      hostname,\n      sites,\n      providers,\n      sessionStore\n    });\n  });\n  </AddHostToRouter>\n\n  return router;\n}\n"], ["addParent", "\nfunction addParent(obj, parent) {\n  <CheckIfNode>\n  var isNode = obj && typeof obj.type === 'string';\n  var childParent = isNode ? obj : parent;\n  </CheckIfNode>\n  \n  <RecursiveParentAddition>\n  for (var k in obj) {\n    var value = obj[k];\n    if (Array.isArray(value)) {\n      value.forEach(function(v) { addParent(v, childParent); });\n    } else if (value && typeof value === 'object') {\n      addParent(value, childParent);\n    }\n  }\n  </RecursiveParentAddition>\n  \n  <DefineParentProperty>\n  if (isNode) {\n    Object.defineProperty(obj, 'parent', {\n      configurable: true,\n      writable: true,\n      enumerable: false,\n      value: parent || null\n    });\n  }\n  </DefineParentProperty>\n\n  return obj;\n}\n"], ["function", "\nfunction(context, descriptor, args, stack) {\n    var opt = args[0],\n        template = args[1],\n        sod = new SOD();\n    <SecondPassExecution>\n    secondPass(template, context, sod, stack);\n    </SecondPassExecution>\n    <AddingChildren>\n    if (sod.children)\n        descriptor.children += sod.children;\n    </AddingChildren>\n}\n"], ["pollForJobs", "\nfunction pollForJobs(state, ms) {\n    <UpdateStatusDisplay>\n    o('h1').text(state);\n    </UpdateStatusDisplay>\n    <RefreshJobsAndSetupInfiniteScroll>\n    refreshJobs(state, function () {\n        infiniteScroll();\n    });\n    </RefreshJobsAndSetupInfiniteScroll>\n    <PollingSetup>\n    if (!pollForJobs.timer) pollForJobs.timer = setTimeout(function () {\n        delete pollForJobs.timer;\n        pollForJobs(state, ms);\n    }, ms);\n    </PollingSetup>\n}\n"], ["resolveBuild", "\nfunction resolveBuild(schema) {\n  <RetrieveBuildPromise>\n  const build = _.get(schema, 'definition._build');\n  return isPromise(build) ? build : Promise.resolve();\n  </RetrieveBuildPromise>\n}\n"], "```\n"]