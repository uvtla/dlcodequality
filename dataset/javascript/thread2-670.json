[["parsePathParams", "\nfunction parsePathParams(req, res, next) {\n  <validateSwaggerRequest>\n  if (util.isSwaggerRequest(req)) {\n    req.pathParams = {};\n\n    <constructPathPattern>\n    if (req.swagger.pathName.indexOf(\"{\") >= 0) {\n      let paramNames = [];\n      let pathPattern = req.swagger.pathName.replace(util.swaggerParamRegExp, (match, paramName) => {\n        paramNames.push(paramName);\n        return \"([^\\/]+)\";\n      });\n    </constructPathPattern>\n\n    <extractPathValues>\n    let values = new RegExp(pathPattern + \"\\/?$\", \"i\").exec(req.path);\n    </extractPathValues>\n\n    <parsePathParameters>\n    for (let i = 1; i < values.length; i++) {\n      let paramName = paramNames[i - 1];\n      let paramValue = decodeURIComponent(values[i]);\n      let param = _.find(req.swagger.params, { in: \"path\", name: paramName });\n\n      util.debug('    Parsing the \"%s\" path parameter', paramName);\n      req.pathParams[paramName] = paramParser.parseParameter(param, paramValue, param);\n    }\n    </parsePathParameters>\n  }\n  </validateSwaggerRequest>\n\n  next();\n}\n"], ["sanitizeOptions", "\nfunction sanitizeOptions(userOptions) {\n  <setDefaultOptions>\n  userOptions = userOptions || {};\n\n  let options = {\n    index: getIndexValue(userOptions)\n  }\n  </setDefaultOptions>\n\n  <handleOptions>\n  if (userOptions.index) {\n    delete userOptions.index;\n  }\n\n  if (typeof (userOptions.enableBrotli) !== \"undefined\") {\n    options.enableBrotli = !!userOptions.enableBrotli;\n  }\n\n  if (typeof (userOptions.customCompressions) === \"object\") {\n    options.customCompressions = userOptions.customCompressions;\n  }\n\n  if (typeof (userOptions.orderPreference) === \"object\") {\n    options.orderPreference = userOptions.orderPreference;\n  }\n  </handleOptions>\n\n  return options;\n}\n"], ["setDefaultFields", "\nfunction(options) {\n  options.usernameField || (options.usernameField = 'username');\n  options.passwordField || (options.passwordField = 'password');\n  return options;\n}\n"], ["addOutProperty", "\nfunction addOutProperty(out, directory, extensions) {\n  <initializeProperty>\n  out[directory] = {\n    extensions: extensions\n  };\n  </initializeProperty>\n  \n  <defineProperty>\n  Object.defineProperty(\n    out[directory],\n    'directory',\n    {\n      get: function () {\n        return Config.fileLoaderDirs[directory];\n      },\n      set: function (value) {\n        Config.fileLoaderDirs[directory] = value;\n      },\n      enumerable: true,\n      configurable: false\n    }\n  );\n  </defineProperty>\n  \n  <setDefaultDirectory>\n  out[directory].directory = out[directory].directory || directory;\n  </setDefaultDirectory>\n}\n"], ["elementStyleProp", "\nfunction elementStyleProp(index, styleIndex, value, suffix) {\n  <prepareValue>\n  var valueToAdd = null;\n  if (value) {\n    if (suffix) {\n      valueToAdd = stringify$1(value) + suffix;\n    } else {\n      valueToAdd = value;\n    }\n  }\n  </prepareValue>\n  \n  <updateStyle>\n  updateStyleProp(getStylingContext(index), styleIndex, valueToAdd);\n  </updateStyle>\n}\n"], ["addDirective", "\nfunction addDirective(tDirectives, name, location, maxPriority, ignoreDirective, startAttrName,\n  endAttrName) {\n  <directiveIgnoredCheck>\n  if (name === ignoreDirective) return null;\n  </directiveIgnoredCheck>\n  \n  <findMatchDirective>\n  var match = null;\n  if (hasDirectives.hasOwnProperty(name)) {\n    for (var directive, directives = $injector.get(name + Suffix),\n      i = 0, ii = directives.length; i < ii; i++) {\n      try {\n        directive = directives[i];\n        if ((maxPriority === undefined || maxPriority > directive.priority) &&\n          directive.restrict.indexOf(location) != -1) {\n          if (startAttrName) {\n            directive = inherit(directive, { $$start: startAttrName, $$end: endAttrName });\n          }\n          tDirectives.push(directive);\n          match = directive;\n        }\n      } catch (e) { $exceptionHandler(e); }\n    }\n  }\n  </findMatchDirective>\n  \n  return match;\n}\n"], ["reduce", "\nfunction reduce(f, seed, arr) {\n  <performReduction>\n  var result = seed, i, n;\n  for (i = 0, n = arr.length; i < n; i++) {\n    result = f(result, arr[i]);\n  }\n  </performReduction>\n  return result;\n}\n"], ["TcpStreamError", "\nfunction TcpStreamError(err) {\n  <handleError>\n  this.simulator.Debug(3, \"TcpStream [%s:%s] connection err=%s\", this.simulator.opts.host, this.simulator.opts.port, err);\n  delete ActiveClients[this];\n  </handleError>\n  \n  <retryConnection>\n  setTimeout(function () {\n    simulator.TcpClient();\n  }, this.timeout);\n  </retryConnection>\n}\n"], ["defaultAddElementRev", "\nfunction defaultAddElementRev(segment, addSrcRev, elementSetting) {\n  <replaceSourceWithRevision>\n  elementSetting.pathReg.lastIndex = 0;\n  var match = elementSetting.pathReg.exec(segment);\n  if (match) {\n    var src = match[2];\n    var revSrc = addSrcRev(src);\n    return segment.replace(elementSetting.pathReg, '$1' + revSrc + '$3');\n  } else {\n    return segment;\n  }\n  </replaceSourceWithRevision>\n}\n"], ["toMap", "\nfunction toMap(val, id, def) {\n  <handleIdAndDefaultParameters>\n  if (is_1.isValue(id) && !is_1.isString(id)) {\n    def = id;\n    id = undefined;\n  }\n  if (is_1.isPlainObject(val))\n    return val;\n  if (!is_1.isValue(val) || (!is_1.isString(val) && !is_1.isArray(val)))\n    return toDefault(null, def);\n  </handleIdAndDefaultParameters>\n\n  <convertStringOrArrayToMap>\n  id = id || '$id';\n  var exp = /(\\/|\\.|,|;|\\|)/g;\n  var i = 0;\n  var obj = {};\n  if (is_1.isString(val)) {\n    if (!exp.test(val))\n      return { 0: val };\n    val = string_1.split(val);\n    val.forEach(function (v, i) { return obj[i] = v; });\n    return obj;\n  }\n  \n  while (i < val.length) {\n    if (is_1.isString(val[i])) {\n      obj[i] = val[i];\n    }\n    else if (is_1.isPlainObject(val[i])) {\n      var itm = Object.assign({}, val[i]);\n      var key = itm[id] ? itm[id] : i;\n      obj[key] = itm[id] ? object_1.del(itm, id) : itm;\n    }\n    i++;\n  }\n  </convertStringOrArrayToMap>\n  \n  return obj;\n}\n"], "```"]