[["upsertKVM", "\nfunction upsertKVM(filepath, cb2) {\n    if(filepath.options.type === 'env') {\n        <getKVMsEnvironment>\n        apigeeSdk.getKVMsEnvironment(grunt.config.get(\"apigee_profiles\"),\n            function(error, response, body) {\n                grunt.log.debug(response.statusCode);grunt.log.debug(body);\n                upsertKVMList(body, filepath, cb2);\n            }, grunt.option('curl'));\n        </getKVMsEnvironment>\n    } else if(filepath.options.type === 'org') {\n        <getKVMsOrganization>\n        apigeeSdk.getKVMsOrganization(grunt.config.get(\"apigee_profiles\"),\n            function(error, response, body) {\n                grunt.log.debug(response.statusCode);grunt.log.debug(body);\n                upsertKVMList(body, filepath, cb2);\n            }, grunt.option('curl'));\n        </getKVMsOrganization>\n    }\n}\n"], ["navigateCallbacks", "\nfunction (navigationInstruction, callbackName, next, ignoreResult) {\n    <setupNavigation>\n    var plan = navigationInstruction.plan;\n    var infos = findDeactivatable(plan, callbackName);\n    var i = infos.length;\n    </setupNavigation>\n    function inspect(val) {\n        if (ignoreResult || shouldContinue(val)) {\n            return iterate();\n        }\n        return next.cancel(val);\n    }\n    function iterate() {\n        if (i--) {\n            try {\n                <navigationCallback>\n                var viewModel = infos[i];\n                var result = viewModel[callbackName](navigationInstruction);\n                return processPotential(result, inspect, next.cancel);\n                </navigationCallback>\n            }\n            catch (error) {\n                return next.cancel(error);\n            }\n        }\n        <updateRouterDeactivation>\n        navigationInstruction.router.couldDeactivate = true;\n        </updateRouterDeactivation>\n        return next();\n    }\n    return iterate();\n}\n"], ["trimmedLeftIndexCalculation", "\nfunction trimmedLeftIndex(string) {\n    var index = -1,\n        length = string.length;\n\n    while (++index < length) {\n        var c = string.charCodeAt(index);\n        if (!((c <= 160 && (c >= 9 && c <= 13) || c == 32 || c == 160) || c == 5760 || c == 6158 ||\n            (c >= 8192 && (c <= 8202 || c == 8232 || c == 8233 || c == 8239 || c == 8287 || c == 12288 || c == 65279)))) {\n            break;\n        }\n    }\n    return index;\n}\n"], ["objectMetaEnhancement", "\nfunction object(baseObj) {\n    <initializeBaseObject>\n    baseObj = baseObj || {};\n    var metaObj = baseObj.__objmeta || {};\n    Object.defineProperty(baseObj, '__objmeta', {value: metaObj});\n    </initializeBaseObject>\n\n    <setOpeningMeta>\n    function setOpening(tokenOrLexer) {\n        metaObj.line = tokenOrLexer.line;\n        metaObj.col = tokenOrLexer.col;\n        metaObj.prelude = tokenOrLexer.prelude;\n    }\n    Object.defineProperty(baseObj, 'setOpening', {value: setOpening});\n    </setOpeningMeta>\n\n    <setClosingMeta>\n    function setClosing(tokenOrLexer) {\n        metaObj.endLine = tokenOrLexer.line;\n        metaObj.endCol = tokenOrLexer.col;\n        metaObj.endPrelude = tokenOrLexer.prelude;\n    }\n    Object.defineProperty(baseObj, 'setClosing', {value: setClosing});\n    </setClosingMeta>\n\n    return baseObj;\n}\n"], ["foldMapValidationAndExecution", "\nfunction foldMap(fn, m) {\n    <validateFunctionForFoldMap>\n    if(!isFunction(fn)) {\n        throw new TypeError(\n            'foldMap: Function returning Semigroups of the same type required for first argument'\n        )\n    }\n    </validateFunctionForFoldMap>\n\n    <executeFoldMap>\n    if(isArray(m)) {\n        return _array.foldMap(fn, m)\n    }\n\n    if(m && isFunction(m.foldMap)) {\n        return m.foldMap(fn)\n    }\n    </executeFoldMap>\n\n    <throwErrorForInvalidFoldable>\n    throw new TypeError(\n        'foldMap: Non-empty Foldable with at least one Semigroup required for second argument'\n    )\n    </throwErrorForInvalidFoldable>\n}\n"], ["SyncPromiseImplementation", "\nfunction SyncPromise(fnExecutor) {\n    <promiseInitialization>\n    var bCaught = false,\n        iState, \n        fnReject,\n        fnResolve,\n        vResult,\n        that = this;\n    </promiseInitialization>\n\n    <promiseRejectFunction>\n    function reject(vReason) {\n        vResult = vReason;\n        iState = -1;\n\n        if (!bCaught && SyncPromise.listener) {\n            SyncPromise.listener(that, false);\n        }\n\n        if (fnReject) {\n            fnReject(vReason);\n            fnReject = fnResolve = null;\n        }\n    }\n    </promiseRejectFunction>\n\n    <promiseResolveFunction>\n    function resolve(vResult0) {\n        var fnThen;\n\n        if (vResult0 === that) {\n            reject(new TypeError(\"A promise cannot be resolved with itself.\"));\n            return;\n        }\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n\n        iState = 1;\n        if (fnResolve) {\n            fnResolve(vResult);\n            fnReject = fnResolve = null;\n        }\n    }\n    </promiseResolveFunction>\n\n    <promiseStateFunctions>\n    this.caught = function () {\n        ...\n    };\n\n    this.getResult = function () {\n        ...\n    };\n\n    this.isFulfilled = function () {\n        ...\n    };\n\n    this.isPending = function () {\n        ...\n    };\n\n    this.isRejected = function () {\n        ...\n    };\n    </promiseStateFunctions>\n\n    <promiseExecuteFnExecutor>\n    call(fnExecutor, resolve, reject);\n    </promiseExecuteFnExecutor>\n\n    <setDefaultState>\n    if (iState === undefined) {\n        vResult = new Promise(function (resolve, reject) {\n            fnResolve = resolve;\n            fnReject = reject;\n        });\n        vResult.catch(function () {});\n    }\n    </setDefaultState>\n}\n"], ["toHexStringFormatting", "\nfunction toHexString(buffer, options) {\n    <handleOptions>\n    options = options || {};\n    var prefix = options.prefix || '', digits, idx;\n    </handleOptions>\n\n    <processBufferBasedOnFormat>\n    if ((options.format || 'BE') !== 'BE') {\n        _reverseBuffer(buffer);\n    }\n    </processBufferBasedOnFormat>\n\n    <convertToHexAndTrim>\n    digits = buffer.toString('hex');\n    idx = _lastHeadIndex(digits, '0');\n    idx = idx >= 0 ? idx : digits.length - 1;\n    </convertToHexAndTrim>\n\n    <formatAndReturnHexString>\n    return prefix + _pad(\n        _split(digits.slice(idx), options.groupsize, options.delimiter), prefix, options.padstr, options.size);\n    </formatAndReturnHexString>\n}\n"], ["refValidatorAndSetter", "\nfunction (ref, component) {\n    <validateInstNotNull>\n    var inst = this.getPublicInstance();\n    !(inst != null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Stateless function components cannot have refs.') : _prodInvariant('110') : void 0;\n    </validateInstNotNull>\n    <getAndWarnOnPublicComponentInstance>\n    var publicComponentInstance = component.getPublicInstance();\n    ...\n    </getAndWarnOnPublicComponentInstance>\n    <setRefOnInstance>\n    var refs = inst.refs === emptyObject ? inst.refs = {} : inst.refs;\n    refs[ref] = publicComponentInstance;\n    </setRefOnInstance>\n}\n"], ["hideStepElements", "\nfunction (steps) {\n    for (var i = 0; i < steps.length; i++) {\n        steps[i].style.display = 'none';\n    }\n}\n"], ["renderMessagesFromTemplate", "\nfunction renderMessages(messages, parentIndex) {\n    <generateMessagesMap>\n    return lodash.map(messages, function(message) {\n        var lineNumber,\n            columnNumber;\n\n        lineNumber = message.line || 0;\n        columnNumber = message.column || 0;\n\n        return messageTemplate({\n            parentIndex: parentIndex,\n            lineNumber: lineNumber,\n            columnNumber: columnNumber,\n            severityNumber: message.severity,\n            severityName: message.severity === 1 ? \"Warning\" : \"Error\",\n            message: message.message,\n            ruleId: message.ruleId\n        });\n    }).join(\"\\n\");\n    </generateMessagesMap>\n}\n"], "```"]