[["reportCoverage", "\nfunction reportCoverage(cov) {\n    <formatReportHeader>\n    print('\\n   [bold]{Test Coverage}\\n');\n    var sep = '   +------------------------------------------+----------+------+------+--------+',\n        lastSep = '                                              +----------+------+------+--------+';\n\tresult = sep+'\\n';\n    result += '   | filename                                 | coverage | LOC  | SLOC | missed |\\n';\n    result += sep+'\\n'; </formatReportHeader>\n    \n    <constructCoverageReport>\n    for (var name in cov) {\n        var file = cov[name];\n        if (Array.isArray(file)) {\n            result += '   | ' + rpad(name, 40);\n            result += ' | ' + lpad(file.coverage.toFixed(2), 8);\n            result += ' | ' + lpad(file.LOC, 4);\n            result += ' | ' + lpad(file.SLOC, 4);\n            result += ' | ' + lpad(file.totalMisses, 6);\n            result += ' |\\n';\n        }\n    }\n    result += sep+'\\n';\n    result += '     ' + rpad('', 40);\n    result += ' | ' + lpad(cov.coverage.toFixed(2), 8);\n    result += ' | ' + lpad(cov.LOC, 4);\n    result += ' | ' + lpad(cov.SLOC, 4);\n    result += ' | ' + lpad(cov.totalMisses, 6);\n    result += ' |\\n';\n    result += lastSep; </constructCoverageReport>\n\n    <outputCoverageReport>\n    console.log(result); </outputCoverageReport>\n\n    <annotateAndWriteFiles>\n    for (var name in cov) {\n\t\tif (name.match(file_matcher)) {\n\t\t\tvar file = cov[name];\n\t\t\tvar annotated = '';\n\t\t\tannotated += colorize('\\n  [bold]{' + name + '}:');\n\t\t\tannotated += colorize(file.source);\n\t\t\tannotated += '\\n';\n\t\t\tfs.writeFileSync('annotated/'+name, annotated);\n\t\t}\n\t} </annotateAndWriteFiles>\n}\n"], ["toggleMaximise", "\nfunction( e ) {\n\t\te && e.preventDefault();\n\t\t<changeMaximisationState>\n\t\tif( this.isMaximised === true ) {\n\t\t\tthis.layoutManager._$minimiseItem( this );\n\t\t} else {\n\t\t\tthis.layoutManager._$maximiseItem( this );\n\t\t}\n\n\t\tthis.isMaximised = !this.isMaximised; </changeMaximisationState>\n        \n        <emitStateChanged>\n\t\tthis.emitBubblingEvent( 'stateChanged' ); </emitStateChanged>\n\t}\n"], ["processTagAttributes", "\nfunction(tag, options) {\n    var seenAttrs = false;\n    var attributeNames = [];\n    var selfClosingAllowed = options && options.selfClosingAllowed;\n    \n    <handleTagAttributeTokens>\n    out:\n      while (true) {\n        switch (this.peek().type) {\n          case 'id':\n          case 'class':\n            var tok = this.advance();\n            if (tok.type === 'id') {\n              if (attributeNames.indexOf('id') !== -1) {\n                this.error('DUPLICATE_ID', 'Duplicate attribute \"id\" is not allowed.', tok);\n              }\n              attributeNames.push('id');\n            }\n            tag.attrs.push({\n              name: tok.type,\n              val: \"'\" + tok.val + \"'\",\n              line: tok.loc.start.line,\n              column: tok.loc.start.column,\n              filename: this.filename,\n              mustEscape: false\n            });\n            continue;\n          case 'start-attributes':\n            if (seenAttrs) {\n              console.warn(this.filename + ', line ' + this.peek().loc.start.line + ':\\nYou should not have pug tags with multiple attributes.');\n            }\n            seenAttrs = true;\n            tag.attrs = tag.attrs.concat(this.attrs(attributeNames));\n            continue;\n          case '&attributes':\n            var tok = this.advance();\n            tag.attributeBlocks.push({\n              type: 'AttributeBlock',\n              val: tok.val,\n              line: tok.loc.start.line,\n              column: tok.loc.start.column,\n              filename: this.filename\n            });\n            break;\n          default:\n            var pluginResult = this.runPlugin('tagAttributeTokens', this.peek(), tag, attributeNames);\n            if (pluginResult) break;\n            break out;\n        }\n      }\n    </handleTagAttributeTokens>\n\n    <parseSpecialTagsAndDirectives>\n    // Parsing '.'\n    if ('dot' == this.peek().type) {\n      tag.textOnly = true;\n      this.advance();\n    }\n\n    // Handling various token types\n    switch (this.peek().type) {\n      case 'text':\n      case 'interpolated-code':\n        var text = this.parseText();\n        if (text.type === 'Block') {\n          tag.block.nodes.push.apply(tag.block.nodes, text.nodes);\n        } else {\n          tag.block.nodes.push(text);\n        }\n        break;\n      case 'code':\n        tag.block.nodes.push(this.parseCode(true));\n        break;\n      case ':':\n        this.advance();\n        var expr = this.parseExpr();\n        tag.block = expr.type === 'Block' ? expr : this.initBlock(tag.line, [expr]);\n        break;\n      case 'newline':\n      case 'indent':\n      case 'outdent':\n      case 'eos':\n      case 'start-pipeless-text':\n      case 'end-pug-interpolation':\n        break;\n      case 'slash':\n        if (selfClosingAllowed) {\n          this.advance();\n          tag.selfClosing = true;\n          break;\n        }\n      default:\n        var pluginResult = this.runPlugin('tagTokens', this.peek(), tag, options);\n        if (pluginResult) break;\n        this.error('INVALID_TOKEN', 'Unexpected token `' + this.peek().type + '` expected `text`, `interpolated-code`, `code`, `:`' + (selfClosingAllowed ? ', `slash`' : '') + ', `newline` or `eos`', this.peek())\n    }\n    \n    while ('newline' == this.peek().type) this.advance();\n    </parseSpecialTagsAndDirectives>\n\n    <parseTagBlockContent>\n    if (tag.textOnly) {\n      tag.block = this.parseTextBlock() || this.emptyBlock(tag.line);\n    } else if ('indent' == this.peek().type) {\n      var block = this.block();\n      for (var i = 0, len = block.nodes.length; i < len; ++i) {\n        tag.block.nodes.push(block.nodes[i]);\n      }\n    }\n    </parseTagBlockContent>\n\n    return tag;\n  }\n"], ["buildObject", "\nfunction buildObject(node, blueprintKey, blueprint ) {\n    var value = {};\n\n    <defineObjectProperty>\n    defineProperty(node, blueprintKey, value);\n    </defineObjectProperty>\n\n    <setObjectMetaData>\n    setMeta(value, blueprintKey);\n    </setObjectMetaData>\n\n    return [value, blueprint];\n  }\n"], ["ResourceManager", "\nfunction ResourceManager(servernode) {\n\n    this.servernode = servernode;\n\n    <initializeGames>\n    this.games = games;\n    </initializeGames>\n\n    <addRootGame>\n    this.addGame('/', servernode.rootDir + path.sep);\n    </addRootGame>\n}\n"], ["deletePanel", "\nfunction _deletePanel( oPanel, bDestroyLayout ) {\n\n\t\toPanel.setLayout(null);\n\t\toPanel.setContainer(null);\n\n\t\tif (!bDestroyLayout || !oPanel.getParent()) {\n\t\t\t<destroyPanel>\n\t\t\toPanel.setContent(null);\n\t\t\toPanel.destroy(); </destroyPanel>\n\t\t}\n\n\t}\n"], ["gpfProcessDefineParamResolveBase", "\nfunction _gpfProcessDefineParamResolveBase (params) {\n    var Super = params[_GPF_DEFINE_PARAM_SUPER];\n    <resolveSuperClass>\n    if (!(Super instanceof Function)) {\n        params[_GPF_DEFINE_PARAM_SUPER] = _gpfContext(Super.toString().split(\".\"));\n    }\n    </resolveSuperClass>\n}\n"], ["isAccessedVarChanged", "\nfunction isAccessedVarChanged(cacheData) {\n  <compareEnvironmentVariables>\n  for (let key in cacheData.env) {\n    if (cacheData.env[key] !== process.env[key]) {\n      return true;\n    }\n  }\n  </compareEnvironmentVariables>\n\n  return false;\n}\n"], ["encode", "\nfunction encode (filename) {\n  <readAndEncodeFile>\n  var ext = path.extname(filename)\n  var data = fs.readFileSync(filename)\n  var prefix = 'data:audio/' + ext.substring(1) + ';base64,'\n  var encoded = new Buffer(data).toString('base64')\n  return prefix + encoded\n  </readAndEncodeFile>\n}\n"], ["getRedoChanges", "\nfunction() {\n\t\t\tthis._commitUndo();\n\t\t\tvar changes = [];\n\t\t\t<accumulateRedoChanges>\n\t\t\tfor (var i=this.index; i<this.stack.length; i++) {\n\t\t\t\tchanges = changes.concat(this.stack[i].getRedoChanges());\n\t\t\t}\n\t\t\t</accumulateRedoChanges>\n\t\t\treturn changes;\n\t\t}\n"], "```"]