[["constructor", "\nfunction (application) {\n    \n    <initializeConnectorId>\n    var id = os.platform() + \"-\" + application;\n    <lookupConnector>\n    var cn = connectors[id];\n    <validateConnector>\n    if (typeof cn === \"undefined\")\n        throw new Error(\"unsupported platform/application combination: \" + id);\n    <constructFileName>\n    var filename = path.join(__dirname, cn);\n    <spawnChildProcess>\n    this.c = spawn(filename, [], {\n        stdio: [ \"pipe\", \"pipe\", process.stderr ],\n        env: { \"CONNECTOR\": \"FIXME\" }\n    });\n    <setStdinEncoding>\n    this.c.stdin.setEncoding(\"utf8\");\n    <setStdoutEncoding>\n    this.c.stdout.setEncoding(\"utf8\");\n    <createDuplexStream>\n    this.io = es.duplex(\n        this.c.stdin,\n        this.c.stdout.pipe(es.split(/\\r?\\n/))\n    );\n    <handleResponseData>\n    this.responses = [];\n    this.io.pipe(es.through(function onData (data) {\n        if (typeof data === \"undefined\" || data === \"\")\n            return;\n        var response = this.responses.shift();\n        if (typeof response === \"function\")\n            response(data);\n    }.bind(this), function onEnd () {\n        \n    }));\n}\n"], ["__", "\nfunction __() {\n    <initializeDefaultArguments>\n    var us = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    var store = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    <processArguments>\n    store = typeof us === \"boolean\" ? us : store;\n    us = typeof us === \"boolean\" ? [] : us;\n    <initializeSequence>\n    var seq = []; \n    seq.id = getID();\n    seq.store = store;\n    seq.us = us;\n    seq.ds = [];\n    seq.updatedTo = {};\n    <updateDependencies>\n    seq.us.map(function (u) {\n      \n      u.ds[u.ds.length] = seq;\n      u.updatedTo[seq.id] = 0; \n    });\n    <setupTimestampMappings>\n    seq.IndexOnTimestamp = {};\n    seq.TimestampOnIndex = {};\n    <initializeFlags>\n    seq.propagating = 0;\n    seq.done = 0;\n    \n    <sequenceEquations>\n    seq.eqs = [];\n    <addEqMethod>\n    seq.addEq = function (eq) {\n      return seq.eqs[seq.eqs.length] = eq;\n    };\n    <evalEqsMethod>\n    seq.evalEqs = function (val) {\n      var val0 = val;\n      seq.eqs.map(function (eq) {\n        return val = eq(val);\n      });\n      return seq.us.length === 0 ? val0 : val;\n    };\n    <extendSequenceWithApi>\n    Object.keys(__.api).map(function (api) {\n      seq[api] = __.api[api](__, seq, store);\n    });\n    <definePropertyForSequence>\n    Object.defineProperties(seq, \n    {\n      t: {\n        <getter>\n        get: function get() {\n          return seq.valOnT;\n        },\n        <setter>\n        set: function set(tval) {\n          var sanityCheck = seq.propagating === 0 && seq.us.length !== 0 ? function () {\n            throw new Error(\"Do not set a value of the sequence that depends on other sequences!\");\n          }() : function () {\n            seq.propagating = 0;\n            <coreSetterLogic>\n            var core = seq.done === 0 ? function () {\n              seq.valOnT = seq.evalEqs(tval); \n              seq.T = Date.now();\n              <storeManagement>\n              var core1 = store ? function () {\n                seq.IndexOnTimestamp[seq.T] = seq.length;\n                seq.TimestampOnIndex[seq.length] = seq.T;\n                seq[seq.length] = seq.valOnT; \n              }() : true;\n              <updateDependenciesStatus>\n              Object.keys(seq.updatedTo).map(function (key) {\n                seq.updatedTo[key] = 1;\n              });\n              <resetUpdateStatus>\n              seq.us.map(function (u) {\n                return u.updatedTo[seq.id] = 0;\n              });\n              <propagateChanges>\n              seq.ds.map(function (d) {\n                var usAllUpdated = d.us.map(function (u) {\n                  return u.updatedTo[d.id];\n                }).reduce(function (a, b) {\n                  return a * b;\n                });\n                var core2 = usAllUpdated === 1 ? function () {\n                  d.propagating = 1;\n                  d.t = d.us.map(function (u) {\n                    return u.t;\n                  });\n                }() : true;\n              });\n            }() : true;\n          }();\n        }\n      }\n    });\n    <returnSequence>\n    return seq;\n  }\n"], ["setUserColor", "\nfunction setUserColor(option){\n  <determineColor>\n  var col;\n   switch (option){\n                  case 'red':\n                    col=chalk.red;\n                    break;\n                  case 'green':\n                    col=chalk.green;\n                    break;\n                  case 'yellow':\n                    col=chalk.yellow;\n                    break;\n                  case 'blue':\n                    col=chalk.blue;\n                    break;\n                  case 'grey':\n                    col=chalk.grey;\n                    break;\n                  case 'white':\n                    col=chalk.white;\n                    break;     \n                  default:\n                    col=option;\n                    break;\n                }\n    <returnColor>\n    return col;\n}\n"], ["editOnCodepen", "\nfunction editOnCodepen(demo) {\n      <collectExternalScripts>\n      var externalScripts = $demoAngularScripts.all();\n      <appendCodepenScript>\n      externalScripts.push('https://codepen...');\n      <translateDataForCodepen>\n      var data = codepenDataAdapter.translate(demo, externalScripts);\n      <buildSubmissionForm>\n      var form = buildForm(data);\n      <appendFormToBody>\n      $document.find('body').append(form);\n      <submitForm>\n      form[0].submit();\n      <removeForm>\n      form.remove();\n    }\n"], ["generateSelectorCommand", "\nfunction (strategy, selector, mult, context) {\n    <initializeQueryExtensions>\n    let ext = mult ? 's' : '';\n    let command = '';\n    <setupContextParameter>\n    context = !context ? context : `, '${context}'` ;\n    <generateCommandBasedOnStrategy>\n    switch (strategy) {\n      case 'name':\n        command = `au.getElement${ext}ByName('${selector}'${context})`;\n        break;\n      case 'accessibility id':\n        command = `au.getElement${ext}ByAccessibilityId('${selector}'${context})`;\n        break;\n      case 'id':\n        command = `au.getElement${ext}ById('${selector}')`;\n        break;\n      case '-ios uiautomation':\n        command = `au.getElement${ext}ByUIAutomation('${selector}'${context})`;\n        break;\n      default:\n        command = `au.getElement${ext}ByType('${selector}'${context})`;\n    }\n    <returnCommand>\n    return command;\n  }\n"], ["bucketerFunction", "\nfunction(bucketerParams) {\n    \n    <findExperiment>\n    var experiment = bucketerParams.experimentKeyMap[bucketerParams.experimentKey];\n    <findGroup>\n    var groupId = experiment['groupId'];\n    <checkAndProcessGroup>\n    if (groupId) {\n      <lookupGroup>\n      var group = bucketerParams.groupIdMap[groupId];\n      <validateGroup>\n      if (!group) {\n        throw new Error(sprintf(ERROR_MESSAGES.INVALID_GROUP_ID, MODULE_NAME, groupId));\n      }\n      <handleRandomPolicyGroup>\n      if (group.policy === RANDOM_POLICY) {\n        <bucketUserIntoExperiment>\n        var bucketedExperimentId = module.exports.bucketUserIntoExperiment(group,\n                                                                          bucketerParams.bucketingId,\n                                                                          bucketerParams.userId,\n                                                                          bucketerParams.logger);\n\n        <handleUserNotBucketedInAnyExperiment>\n        if (bucketedExperimentId === null) {\n          var notbucketedInAnyExperimentLogMessage = sprintf(LOG_MESSAGES.USER_NOT_IN_ANY_EXPERIMENT, MODULE_NAME, bucketerParams.userId, groupId);\n          bucketerParams.logger.log(LOG_LEVEL.INFO, notbucketedInAnyExperimentLogMessage);\n          return null;\n        }\n        <handleUserNotBucketedIntoExpectedExperimentInGroup>\n        if (bucketedExperimentId !== bucketerParams.experimentId) {\n          var notBucketedIntoExperimentOfGroupLogMessage = sprintf(LOG_MESSAGES.USER_NOT_BUCKETED_INTO_EXPERIMENT_IN_GROUP, MODULE_NAME, bucketerParams.userId, bucketerParams.experimentKey, groupId);\n          bucketerParams.logger.log(LOG_LEVEL.INFO, notBucketedIntoExperimentOfGroupLogMessage);\n          return null;\n        }\n        <logUserBucketedIntoExperimentInGroup>\n        var bucketedIntoExperimentOfGroupLogMessage = sprintf(LOG_MESSAGES.USER_BUCKETED_INTO_EXPERIMENT_IN_GROUP, MODULE_NAME, bucketerParams.userId, bucketerParams.experimentKey, groupId);\n        bucketerParams.logger.log(LOG_LEVEL.INFO, bucketedIntoExperimentOfGroupLogMessage);\n      }\n    }\n    <generateBucketingId>\n    var bucketingId = sprintf('%s%s', bucketerParams.bucketingId, bucketerParams.experimentId);\n    <generateBucketValue>\n    var bucketValue = module.exports._generateBucketValue(bucketingId);\n    <logBucketedUser>\n    var bucketedUserLogMessage = sprintf(LOG_MESSAGES.USER_ASSIGNED_TO_VARIATION_BUCKET, MODULE_NAME, bucketValue, bucketerParams.userId);\n    bucketerParams.logger.log(LOG_LEVEL.DEBUG, bucketedUserLogMessage);\n    <findEntityBucket>\n    var entityId = module.exports._findBucket(bucketValue, bucketerParams.trafficAllocationConfig);\n    <handleUserWithoutVariation>\n    if (entityId === null) {\n      var userHasNoVariationLogMessage = sprintf(LOG_MESSAGES.USER_HAS_NO_VARIATION, MODULE_NAME, bucketerParams.userId, bucketerParams.experimentKey);\n      bucketerParams.logger.log(LOG_LEVEL.DEBUG, userHasNoVariationLogMessage);\n    } <handleInvalidVariationID>\n    else if (entityId === '' || !bucketerParams.variationIdMap.hasOwnProperty(entityId)) {\n      var invalidVariationIdLogMessage = sprintf(LOG_MESSAGES.INVALID_VARIATION_ID, MODULE_NAME);\n      bucketerParams.logger.log(LOG_LEVEL.WARNING, invalidVariationIdLogMessage);\n      return null;\n    } <logUserInVariation>\n    else {\n      var variationKey = bucketerParams.variationIdMap[entityId].key;\n      var userInVariationLogMessage = sprintf(LOG_MESSAGES.USER_HAS_VARIATION, MODULE_NAME, bucketerParams.userId, variationKey, bucketerParams.experimentKey);\n      bucketerParams.logger.log(LOG_LEVEL.INFO, userInVariationLogMessage);\n    }\n    <returnEntityId>\n    return entityId;\n  }\n"], ["modulePreloadDefinition", "\nfunction require_define(moduleId, prereqs, factory) {\n    <presetVariables>\n    var rem = [\"require\", \"exports\", \"module\"]\n    <validateModuleId>\n    if (typeof moduleId != \"string\") {\n        console.log(\"modjewel.define(): first parameter must be a string; was: \" + moduleId)\n        return\n    }\n    <adjustFactoryAndPrereqsBasedOnArguments>\n    if (arguments.length == 2) {\n        factory = prereqs\n        prereqs = null\n    }\n    <setDefaultPrereqs>\n    if (!prereqs || prereqs.length == 0) {\n        prereqs = rem\n    }\n    <validateFactory>\n    if (typeof factory != \"function\") {\n        <handleNonFunctionFactory>\n        if (factory) {\n            ModulePreloadStore[moduleId] = [factory, prereqs]\n            return\n        }\n        console.log(\"modjewel.define(): factory was falsy: \" + factory)\n        return\n    }\n    <validateModuleIdFormat>\n    if (moduleId.match(/^\\./)) {\n        console.log(\"modjewel.define(): moduleId must not start with '.': '\" + moduleName + \"'\")\n        return\n    }\n    <preventDuplicateModuleDefinition>\n    if (hop(ModulePreloadStore, moduleId)) {\n        console.log(\"modjewel.define(): module '\" + moduleId + \"' has already been defined\")\n        return\n    }\n    <storeModuleDefinition>\n    ModulePreloadStore[moduleId] = [factory, prereqs]\n}\n"], ["invokeBaidu", "\nfunction invokeBaidu(options, cbk) {\n    \n    <validateOptions>\n    if (!options || !options.uri || !options.params) {\n        throw new Error('Lack required parameters');\n    }\n    <constructUriWithFormat>\n    var uri = util.format(\"http://... );\n    <appendTimestampAndApikeyToParams>\n    var params = options.params;\n    params.timestamp = Math.round(Date.now() / 1000);\n    params.apikey = options.apiKey;\n    <createHttpInfo>\n    var httpInfo = {\n        href: uri,\n        method: defaultMethod\n    };\n    <signRequestParams>\n    params.sign = signKey(httpInfo, params, options.secretKey);\n    <setupRequestOptions>\n    var requestOptions = {\n        uri: uri,\n        headers: defaultHeaders,\n        method: defaultMethod,\n        form: params\n    };\n    <executeRequestWithCallbackOrPromise>\n    if (typeof cbk === 'function') {\n        request(requestOptions, function (err, response, body) {\n            var result = dealResult(err, body);\n            result.error ? cbk(result.error) : cbk(null, result.data);\n        });\n    } else {\n        return new Promise(function(resolve, reject) {\n            request(requestOptions, function(err, response, body) {\n                var result = dealResult(err, body);\n                result.error ? reject(result.error) : resolve(result.data);\n            });\n        });\n    }\n}\n"], ["generatePrefixed", "\nfunction generatePrefixed(prefix) {\n\t<initializeOutputs>\n\tlet output = '';\n\tlet children = '';\n    <iterateOverAllParts>\n\tfor (const part of allParts) {\n\t\t<createCurrentPartsList>\n\t\tconst parts = prefix.concat([part]);\n        <skipNonUniqueOrInvalidParts>\n\t\tif (prefix.indexOf(part) !== -1 || !verify(parts, true)) {\n\t\t\t\n\t\t\tcontinue;\n\t\t}\n\t\t<handleNonSortedArrays>\n\t\tif (!isArraySorted(parts)) {\n\t\t\t<checkExistenceAndSort>\n\t\t\tif (exists(parts)) {\n\t\t\t\tparts.sort();\n                <generateChain>\n\t\t\t\tlet chain;\n                <checkAndHandleChildrenOfPart>\n\t\t\t\tif (hasChildren(parts)) {\n\t\t\t\t\tchain = parts.join('_') + '<T>';\n\t\t\t\t} else {\n\t\t\t\t\t<handleLastPart>\n\t\t\t\t\tconst last = parts.pop();\n\t\t\t\t\tconst joined = parts.join('_');\n\t\t\t\t\tchain = `${joined}<T>['${last}']`;\n\t\t\t\t}\n                <addToOutput>\n\t\t\t\toutput += `\\t${part}: Register_${chain};\\n`;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n        <verifyAndHandleTodoAndCallback>\n\t\tif (verify(parts, false)) {\n\t\t\tif (arrayHas(parts)('todo')) {\n\t\t\t\t\n\t\t\t\toutput += `\\t${part}: (name: string) => void;\\n`;\n\t\t\t} else {\n\t\t\t\tif (arrayHas(parts)('cb')) {\n\t\t\t\t\toutput += `\\t${part}: CallbackRegisterBase<T>`;\n\t\t\t\t} else {\n\t\t\t\t\toutput += `\\t${part}: RegisterBase<T>`;\n\t\t\t\t}\n\t\t\t\tif (hasChildren(parts)) {\n\t\t\t\t\t\n\t\t\t\t\tconst joined = parts.join('_');\n\t\t\t\t\toutput += ` & Register_${joined}<T>`;\n\t\t\t\t}\n\t\t\t\toutput += ';\\n';\n\t\t\t}\n\t\t}\n\t\t<generateChildren>\n\t\tchildren += generatePrefixed(parts);\n\t}\n\t<returnTypes>\n\tif (output === '') {\n\t\treturn children;\n\t}\n    <assembleTypeBody>\n\tconst typeBody = `{\\n${output}}\\n${children}`;\n    <returnFinalInterface>\n\tif (prefix.length === 0) {\n\t\t\n\t\treturn `export interface Register<T> extends RegisterBase<T> ${typeBody}`;\n\t}\n\tconst namespace = ['Register'].concat(prefix).join('_');\n\treturn `interface ${namespace}<T> ${typeBody}`;\n}\n"], ["makeShallowOptions", "\nfunction makeShallowOptions(nodes, root, passedOptions, wrapper) {\n  <mergePassedOptionsWithDefaults>\n  const options = makeOptions(passedOptions);\n  <getAdapterFromOptions>\n  const adapter = getAdapter(passedOptions);\n  <storeProviderValues>\n  privateSet(options, PROVIDER_VALUES, passedOptions[PROVIDER_VALUES]);\n  <checkRootComponent>\n  if (root || !isCustomComponent(options.wrappingComponent, adapter)) {\n    return options;\n  }\n  <validateAdapterWrapMethod>\n  if (typeof adapter.wrapWithWrappingComponent !== 'function') {\n    throw new TypeError('your adapter does not support `wrappingComponent`. Try upgrading it!');\n  }\n  <wrapNodesWithWrappingComponent>\n  const { node: wrappedNode, RootFinder } = adapter.wrapWithWrappingComponent(nodes, options);\n  <createWrappingComponentWrapper>\n  const wrappingComponent = new WrappingComponentWrapper(wrappedNode, wrapper, RootFinder);\n  <getLegacyContextAndProviderValues>\n  const {\n    legacyContext: wrappingComponentLegacyContext,\n    providerValues: wrappingComponentProviderValues,\n  } = getContextFromWrappingComponent(wrappingComponent, adapter);\n  <setWrappingComponent>\n  privateSet(wrapper, WRAPPING_COMPONENT, wrappingComponent);\n  <returnOptionsWithContextAndProviderValues>\n  return {\n    ...options,\n    context: {\n      ...options.context,\n      ...wrappingComponentLegacyContext,\n    },\n    [PROVIDER_VALUES]: wrappingComponentProviderValues,\n  };\n}\n"], "```"]