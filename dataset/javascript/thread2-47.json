[["initializeStateNameMapping", "\nfunction(options) {\n    this.stateName = {};\n    this.stateName[OpenLayers.State.INSERT] = \"wfs:Insert\";\n    this.stateName[OpenLayers.State.UPDATE] = \"wfs:Update\";\n    this.stateName[OpenLayers.State.DELETE] = \"wfs:Delete\";\n    OpenLayers.Format.XML.prototype.initialize.apply(this, [options]);\n}\n"], ["createOnChangeHandler", "\nfunction OnChange(defaultValue) {\n    var suffix = 'Change';\n    return function OnChangeHandler(target, propertyKey) {\n        var _key = \" __\" + propertyKey + \"Value\";\n        Object.defineProperty(target, propertyKey, {\n            get: function () { return this[_key]; },\n            set: function (value) {\n                var prevValue = this[_key];\n                this[_key] = value;\n                <emitChangeEventIfValueChanged>\n                if (prevValue !== value && this[propertyKey + suffix]) {\n                    this[propertyKey + suffix].emit(value);\n                }\n                </emitChangeEventIfValueChanged>\n            }\n        });\n    };\n}\n"], ["loadView", "\nfunction (url, async) {\n    <resolveUrlSuffix>\n    var suffix = url.match(/\\.[\\w\\d]+$/),\n        el,\n        id,\n        jqXHR;\n    if (url.match(/^#/)) {\n        url = url.substr(1);\n    }\n    if (el = document.getElementById(url)) {\n        suffix = \".\" + el.type.match(/\\/(x\\-)?(.+)/)[2];\n    }\n    if (!suffix && !$view.cached[url]) {\n        url += (suffix = $view.ext);\n    }\n    if (can.isArray(suffix)) {\n        suffix = suffix[0]\n    }\n    </resolveUrlSuffix>\n    \n    <resolveUrlId>\n    id = $view.toId(url);\n    </resolveUrlId>\n    \n    <handleSlashPrefixInUrl>\n    if (url.match(/^\\/\\//)) {\n        var sub = url.substr(2);\n        url = !window.steal ? sub : steal.config().root.mapJoin(sub);\n    }\n    </handleSlashPrefixInUrl>\n\n    <determineViewType>\n    type = $view.types[suffix];\n    </determineViewType>\n\n    <checkCacheOrLoad>\n    if ($view.cached[id]) {\n        return $view.cached[id];\n    } else if (el) {\n        return $view.registerView(id, el.innerHTML, type);\n    } else {\n        var d = new can.Deferred();\n        can.ajax({\n            async: async,\n            url: url,\n            dataType: \"text\",\n            error: function (jqXHR) {\n                checkText(\"\", url);\n                d.reject(jqXHR);\n            },\n            success: function (text) {\n                checkText(text, url);\n                $view.registerView(id, text, type, d)\n            }\n        });\n        return d;\n    }\n    </checkCacheOrLoad>\n}\n"], ["aggregateStats", "\nfunction getStats() {\n    var o = {};\n    o.total_connections_received = this.stats.connections;\n    o.total_commands_processed = this.stats.commands;\n    o.total_net_input_bytes = this.stats.ibytes;\n    o.total_net_output_bytes = this.stats.obytes;\n    \n    o.rejected_connections = this.stats.rejected;\n    \n    o.expired_keys = this.stats.expired;\n    o.keyspace_hits = this.stats.hits;\n    o.keyspace_misses = this.stats.misses;\n    \n    o.pubsub_channels = this.stats.pubsub_channels;\n    o.pubsub_patterns = this.stats.pubsub_patterns;\n    \n    return o;\n}\n"], ["findClosestPoints", "\nfunction findClosestPointsFromSegmentToSegment(closestA, closestB, segmentA, segmentB) {\n    <findInitialClosestPoints>\n    const {distA, distB} = findClosestPointsFromLineToLine(\n        segmentA.start, segmentA.dir, segmentB.start, segmentB.dir);\n    </findInitialClosestPoints>\n    \n    <checkBoundsAndAdjust>\n    const isDistAInBounds = distA >= 0 && distA <= 1;\n    const isDistBInBounds = distB >= 0 && distB <= 1;\n    \n    if (isDistAInBounds) {\n        if (isDistBInBounds) {\n            vec3.scaleAndAdd(closestA, segmentA.start, segmentA.dir, distA);\n            vec3.scaleAndAdd(closestB, segmentB.start, segmentB.dir, distB);\n        } else {\n            <fixOutOfBoundsB>\n            if (distB < 0) {\n                vec3.copy(closestB, segmentB.start);\n            } else {\n                vec3.copy(closestB, segmentB.end);\n            }\n            findClosestPointOnSegmentToPoint(closestA, segmentA, closestB);\n            </fixOutOfBoundsB>\n        }\n    } else {\n        if (isDistBInBounds) {\n            <fixOutOfBoundsA>\n            if (distA < 0) {\n                vec3.copy(closestA, segmentA.start);\n            } else {\n                vec3.copy(closestA, segmentA.end);\n            }\n            findClosestPointOnSegmentToPoint(closestB, segmentB, closestA);\n            </fixOutOfBoundsA>\n        } else {\n            <handleBothOutOfBounds>\n            if (distA < 0) {\n                vec3.copy(closestA, segmentA.start);\n            } else {\n                vec3.copy(closestA, segmentA.end);\n            }\n            if (distB < 0) {\n                vec3.copy(closestB, segmentB.start);\n            } else {\n                vec3.copy(closestB, segmentB.end);\n            }\n            const altClosestA = vec3.create();\n            const altClosestB = vec3.create();\n            findClosestPointOnSegmentToPoint(altClosestA, segmentA, closestB);\n            findClosestPointOnSegmentToPoint(altClosestB, segmentB, closestA);\n            if (vec3.squaredDistance(altClosestA, closestB) <\n                vec3.squaredDistance(altClosestB, closestA)) {\n                vec3.copy(closestA, altClosestA);\n            } else {\n                vec3.copy(closestB, altClosestB);\n            }\n            </handleBothOutOfBounds>\n        }\n    }\n    </checkBoundsAndAdjust>\n}\n"], ["resolveIncludeDirectives", "\nfunction resolveIncludeDirectives(text, fileItem) {\n    <parseSourceCode>\n    var result = [];\n    try {\n        var srcParsed = esprima.parse(text);\n    } catch (e) {\n        logger.error(buildErrMsg(fileItem.ancestor, 'Failed to parse a [%s] JavaScript file. Reason : [%s]', fileItem.filePath, e));\n        throw buildShortErrMsg(fileItem.ancestor, 'Failed to parse a [%s] JavaScript file. Reason : [%s]', path.basename(fileItem.filePath), e)\n    }\n    </parseSourceCode>\n    \n    <extractIncludeDirectives>\n    for (var key in srcParsed.body) {\n        var item = srcParsed.body[key];\n        var includeDirective = resolveIncludeDirectiveDom(item);\n        if (includeDirective != null) {\n            result.push(includeDirective);\n        }\n    }\n    </extractIncludeDirectives>\n    \n    return result;\n}\n"], ["addCAmethods", "\nfunction() {\n    var newMethods = $._.$.iot.extraCAMethods();\n    <logNewMethods>\n    $._.$.log && $._.$.log.debug('Adding CA methods:' +\n                                 JSON.stringify(Object.keys(newMethods)));\n    </logNewMethods>\n    <mixinNewMethods>\n    myUtils.mixin($.handler, newMethods, true);\n    </mixinNewMethods>\n}\n"], ["parseValidationRules", "\nfunction parseRules (fields, data) {\n    data = data || {}\n    return Object.keys(fields).reduce((result, field) => {\n        let rules = fields[field]\n        \n        <parseRuleFormat>\n        if (typeof (rules) === 'string') {\n            rules = Pipe(rules, new ArrayPresenter())\n        } else if (!Array.isArray(rules)) {\n            throw new Error('Rules must be defined as a string or an array')\n        }\n        </parseRuleFormat>\n        \n        <handleWildcardFields>\n        if (field.indexOf('*') > -1) {\n            const nodes = field.split(/\\.\\*\\.?/)\n            starToIndex(nodes, data).forEach((f) => { result[f] = rules })\n        } else {\n            result[field] = rules\n        }\n        </handleWildcardFields>\n        \n        return result\n    }, {})\n}\n"], ["checkIfObjectArray", "\nfunction isObjectArray( value ) {\n    var len;\n    if ( !isArray( value ) ) {\n        return false;\n    }\n    len = value.length;\n    if ( !len ) {\n        return false;\n    }\n    <verifyEachElementIsObject>\n    for ( var i = 0; i < len; i++ ) {\n        if ( !isObject( value[i] ) ) {\n            return false;\n        }\n    }\n    </verifyEachElementIsObject>\n    return true;\n}\n"], ["parseRGBtoRGBA", "\nfunction( rgb ){\n    var ret;\n    var number = $$.util.regex.number;\n    \n    <parseRGBstring>\n    var m = new RegExp(\"^\" + $$.util.regex.rgba + \"$\").exec(rgb);\n    if( m ){\n        ret = [];\n        var isPct = [];\n        for( var i = 1; i <= 3; i++ ){\n            var channel = m[i];\n            <convertPercentToValue>\n            if( channel[ channel.length - 1 ] === \"%\" ){\n                isPct[i] = true;\n            }\n            channel = parseFloat( channel );\n            if( isPct[i] ){\n                channel = channel/100 * 255;\n            }\n            </convertPercentToValue>\n            <validateChannelValue>\n            if( channel < 0 || channel > 255 ){ return; }\n            </validateChannelValue>\n            ret.push( Math.floor(channel) );\n        }\n        \n        <handlePartialPercentages>\n        var atLeastOneIsPct = isPct[1] || isPct[2] || isPct[3];\n        var allArePct = isPct[1] && isPct[2] && isPct[3];\n        if( atLeastOneIsPct && !allArePct ){ return; }\n        </handlePartialPercentages>\n        \n        <parseAlphaChannel>\n        var alpha = m[4];\n        if( alpha !== undefined ){\n            alpha = parseFloat( alpha );\n            if( alpha < 0 || alpha > 1 ){ return; }\n            ret.push( alpha );\n        }\n        </parseAlphaChannel>\n    }\n    </parseRGBstring>\n    \n    return ret;\n}\n"], "```"]