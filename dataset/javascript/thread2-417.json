[["getPropertyDescriptor", "\nfunction getPropertyDescriptor(target, key, dsc) {\n    const defaultDescriptor = { enumerable: true, configurable: true, writable: true };\n    return (target instanceof Function) \n        ? new KeyPropertyDescriptor().key(key).descriptor(dsc || Object.getOwnPropertyDescriptor(target, key) || defaultDescriptor) \n        : new KeyPropertyDescriptor().key(key).descriptor(dsc || Reflect.getMetadata('design:descriptor', target, key) || defaultDescriptor); \n}\n"], ["meshSetString", "\nfunction meshSetString (tiles) {\n    return JSON.stringify(\n        Object.entries(tiles).map(([,t]) => {\n            return Object.entries(t.meshes).map(([,s]) => {\n                return s.map(m => m.created_at);\n            });\n        })\n    );\n}\n"], ["update", "\nfunction update (client) {\n  return function update (pushApp) {\n    <requestSetup>\n    const req = {\n      url: `${client.baseUrl}/rest/applications/${pushApp.pushApplicationID}`,\n      body: pushApp,\n      method: 'PUT'\n    };\n    </requestSetup>\n\n    <handleResponse>\n    return request(client, req)\n      .then((response) => {\n        if (response.resp.statusCode !== 204) {\n          return Promise.reject(response.body);\n        }\n\n        return Promise.resolve(response.body);\n      });\n    </handleResponse>\n  };\n}\n"], ["liftChildNodes", "\nfunction liftChildNodes(oParent, oWithControl, oTarget) {\n    <visitAndLift>\n    return visitChildNodes(oParent, oWithControl).then(function () {\n        var oChild;\n\n        oTarget = oTarget || oParent;\n        while ((oChild = oParent.firstChild)) {\n            oTarget.parentNode.insertBefore(oChild, oTarget);\n        }\n    });\n    </visitAndLift>\n}\n"], ["function", "\nfunction(hljs) {\n  <defineCPPKeywords>\n  var CPP_KEYWORDS = {\n    // Keywords and built-ins are defined here...\n  };\n  </defineCPPKeywords>\n  \n  <returnHighlightConfiguration>\n  return {\n    aliases: ['c', 'h', 'c++', 'h++'],\n    keywords: CPP_KEYWORDS,\n    illegal: '</',\n    contains: [\n      // Highlight rules are defined here...\n    ]\n  };\n  </returnHighlightConfiguration>\n}\n"], ["logMessage", "\nfunction logMessage(message)\n    {\n        <trackRepeatMessages>\n        var repeatCount = 1;\n        if (message == WebInspector.log.lastMessage)\n            repeatCount = WebInspector.log.repeatCount + 1;\n\n        WebInspector.log.lastMessage = message;\n        WebInspector.log.repeatCount = repeatCount;\n        </trackRepeatMessages>\n\n        <createRemoteObject>\n        message = new WebInspector.RemoteObject.fromPrimitiveValue(message);\n        </createRemoteObject>\n\n        <constructConsoleMessage>\n        var msg = new WebInspector.ConsoleMessage(\n            // WebInspector.ConsoleMessage configurations...\n        );\n        </constructConsoleMessage>\n\n        <addMessageToConsole>\n        self.console.addMessage(msg);\n        </addMessageToConsole>\n    }\n"], ["initQuery", "\nfunction initQuery (args) {\n    \n    <prepareQueryMethod>\n    var methodName = `${this.name}Query`\n    var methodSignature = `${this.moduleName}.${methodName}`\n    var model = this\n    </prepareQueryMethod>\n    \n    <createQueryFunction>\n    this.query = immutable.method(methodSignature, function (args) {\n        \n        <prepareQueryArguments>\n        var session = args.session\n        delete args.session\n        var query = new ImmutableCoreModelQuery({\n            args: args,\n            model: model,\n            session: session,\n        })\n        </prepareQueryArguments>\n        \n        <executeQuery>\n        try {\n            return query.execute()\n        }\n        catch (err) {\n            return Promise.reject(err)\n        }\n        </executeQuery>\n        \n    }, {\n        freeze: false,\n    });\n    </createQueryFunction>\n}\n"], ["JavascriptXPathEngine", "\nfunction JavascriptXPathEngine() {\n    var engineDoc = document;\n\n    <isAvailableMethod>\n    this.isAvailable = function() { return true; };\n    </isAvailableMethod>\n    \n    <selectNodesMethod>\n    this.selectNodes = function(xpath, contextNode, namespaceResolver) {\n        if (contextNode != this.doc) {\n            xpath = '.' + xpath;\n        }\n\n        var nodes = [];\n\n        try {\n            var xpathResult = engineDoc.evaluate(xpath, contextNode,\n                namespaceResolver, 0, null);\n        }\n        catch (e) {\n            var msg = extractExceptionMessage(e);\n            throw new SeleniumError(\"Invalid xpath [1]: \" + msg);\n        }\n        finally {\n            if (xpathResult == null) {\n                throw new SeleniumError(\"Invalid xpath [2]: \" + xpath);\n            }\n        }\n\n        var node = xpathResult.iterateNext();\n\n        while (node) {\n            nodes.push(node);\n            node = xpathResult.iterateNext();\n        }\n\n        return nodes;\n    };\n    </selectNodesMethod>\n}\n"], ["decodeGlobal", "\nfunction decodeGlobal(config, result) {\n    var values = result.values;\n\n    <cleanResultValues>\n    delete values.generator;\n    delete values.output;\n    </cleanResultValues>\n\n    <updateConfigValues>\n    return config.updateValues(values);\n    </updateConfigValues>\n}\n"], ["removeLocalBranch", "\nfunction removeLocalBranch(options) {\n    <checkMandatoryBranch>\n    assert.ok(options.branch, 'branch is mandatory');\n    </checkMandatoryBranch>\n\n    <prepareGitArguments>\n    var args = [\n      'branch',\n      options.force ? '-D' : '-d',\n      options.branch\n    ];\n    </prepareGitArguments>\n\n    <executeGitCommand>\n    return git(args)\n        .then(silent);\n    </executeGitCommand>\n}\n"], "```"]