[["_submitRequest", "\nfunction _submitRequest(params, callback) {\n    var self = this;\n    var TaskId = params.TaskId;\n    <checkRunningTask>\n    if (TaskId && !self._isRunningTask(TaskId)) return;\n    </checkRunningTask>\n    <processIncomingParams>\n    var bucket = params.Bucket;\n    var region = params.Region;\n    var object = params.Key;\n    var method = params.method || 'GET';\n    var url = params.url;\n    var body = params.body;\n    var json = params.json;\n    var rawBody = params.rawBody;\n    </processIncomingParams>\n    <handleReadStream>\n    var readStream;\n    if (body && typeof body.pipe === 'function') {\n        readStream = body;\n        body = null;\n    }\n    </handleReadStream>\n    <constructURL>\n    url = url || getUrl({\n        ForcePathStyle: self.options.ForcePathStyle,\n        protocol: self.options.Protocol,\n        domain: self.options.Domain,\n        bucket: bucket,\n        region: region,\n        object: object,\n    });\n    if (params.action) {\n        url = url + '?' + params.action;\n    }\n    </constructURL>\n    <prepareRequestOptions>\n    var opt = {\n        method: method,\n        url: url,\n        headers: params.headers,\n        qs: params.qs,\n        body: body,\n        json: json,\n    };\n    </prepareRequestOptions>\n    <setAuthorizationHeaders>\n    opt.headers.Authorization = params.AuthData.Authorization;\n    params.AuthData.Token && (opt.headers['token'] = params.AuthData.Token);\n    params.AuthData.ClientIP && (opt.headers['clientIP'] = params.AuthData.ClientIP);\n    params.AuthData.ClientUA && (opt.headers['clientUA'] = params.AuthData.ClientUA);\n    params.AuthData.XCosSecurityToken && (opt.headers['x-cos-security-token'] = params.AuthData.XCosSecurityToken);\n    </setAuthorizationHeaders>\n    <configureRequestOptions>\n    opt.headers && (opt.headers = util.clearKey(opt.headers));\n    opt = util.clearKey(opt);\n    var Ip = this.options.Ip;\n    if (Ip) {\n        opt.url = opt.url.replace(/^(https?:\\/\\/)([^\\/]+)/, function (str, pre, Host) {\n            opt.headers.Host = Host;\n            return pre + Ip;\n        });\n    }\n    if (this.options.StrictSsl !== true) {\n        opt.strictSSL = this.options.StrictSsl;\n    }\n    if (this.options.Proxy) {\n        opt.proxy = this.options.Proxy;\n    }\n    if (this.options.Timeout) {\n        opt.timeout = this.options.Timeout;\n    }\n    if (this.options.KeepAlive) {\n        opt.forever = true;\n    }\n    </configureRequestOptions>\n    <preSendEmit>\n    self.emit('before-send', opt);\n    var sender = REQUEST(opt);\n    var retResponse;\n    var hasReturned;\n    </preSendEmit>\n    <setupCallback>\n    var cb = function (err, data) {\n        TaskId && self.off('inner-kill-task', killTask);\n        if (hasReturned) return;\n        hasReturned = true;\n        var attrs = {};\n        retResponse && retResponse.statusCode && (attrs.statusCode = retResponse.statusCode);\n        retResponse && retResponse.headers && (attrs.headers = retResponse.headers);\n        if (err) {\n            err = util.extend(err || {}, attrs);\n            callback(err, null);\n        } else {\n            data = util.extend(data || {}, attrs);\n            callback(null, data);\n        }\n        if (sender) {\n            sender.removeAllListeners && sender.removeAllListeners();\n            sender = null;\n        }\n    };\n    </setupCallback>\n    <xml2JsonConversion>\n    var xml2json = function (body) {\n        try {\n            json = util.xml2json(body) || {};\n        } catch (e) {\n            json = body || {};\n        }\n        return json;\n    };\n    </xml2JsonConversion>\n    <registerErrorEventHandler>\n    sender.on('error', function (err) {\n        cb({error: err});\n    });\n    </registerErrorEventHandler>\n    <processResponse>\n    sender.on('response', function (response) {\n        retResponse = response;\n        var responseContentLength = response.headers['content-length'] || 0;\n        var chunkList = [];\n        var statusCode = response.statusCode;\n        var statusSuccess = Math.floor(statusCode / 100) === 2; // 2xx status code check\n        if (statusSuccess && params.outputStream) {\n            sender.on('end', function () {\n                    cb(null, {});\n            });\n        } else if (responseContentLength >= process.binding('buffer').kMaxLength && opt.method !== 'HEAD') {\n            cb({error: 'file size large than ' + process.binding('buffer').kMaxLength + ', please use \"Output\" Stream to getObject.'});\n        } else {\n            var dataHandler = function (chunk) {\n                chunkList.push(chunk);\n            };\n            var endHandler = function () {\n                var json;\n                try {\n                    var body = Buffer.concat(chunkList);\n                } catch (e) {\n                    cb({error: e});\n                    return;\n                }\n                var bodyStr = body.toString();\n                if (statusSuccess) {\n                    if (rawBody) {\n                        cb(null, {body: body});\n                    } else if (body.length) {\n                        json = xml2json(body.toString());\n                        if (json && json.Error) {\n                            cb({error: json.Error});\n                        } else {\n                            cb(null, json);\n                        }\n                    } else {\n                        cb(null, {});\n                    }\n                } else {\n                    bodyStr && (json = xml2json(bodyStr));\n                    cb({error: json && json.Error || response.statusMessage || 'statusCode error'});\n                }\n                chunkList = null;\n            };\n            sender.on('data', dataHandler);\n            sender.on('end', endHandler);\n        }\n    });\n    </processResponse>\n    <manageDataTask>\n    var killTask = function (data) {\n        if (data.TaskId === TaskId) {\n            sender && sender.abort && sender.abort();\n            self.off('inner-kill-task', killTask);\n        }\n    };\n    TaskId && self.on('inner-kill-task', killTask);\n    </manageDataTask>\n    <handleProgressEvents>\n    if (params.onProgress && typeof params.onProgress === 'function') {\n        var contentLength = opt.headers['Content-Length'];\n        var time0 = Date.now();\n        var size0 = 0;\n        sender.on('drain', function () {\n            var time1 = Date.now();\n            var loaded = 0;\n            try {\n                loaded = sender.req.connection.bytesWritten - sender.req._header.length;\n            } catch (e) {}\n            var total = contentLength;\n            var speed = parseInt((loaded - size0) / ((time1 - time0) / 1000) * 100) / 100;\n            var percent = total ? (parseInt(loaded / total * 100) / 100) : 0;\n            time0 = time1;\n            size0 = loaded;\n            params.onProgress({\n                loaded: loaded,\n                total: total,\n                speed: speed,\n                percent: percent,\n            });\n        });\n    }\n\n    if (params.onDownloadProgress && typeof params.onDownloadProgress === 'function') {\n        var time0 = Date.now();\n        var size0 = 0;\n        var loaded = 0;\n        var total = 0;\n        sender.on('response', function (res) {\n            total = res.headers['content-length'];\n            sender.on('data', function (chunk) {\n                loaded += chunk.length;\n                var time1 = Date.now();\n                var speed = parseInt((loaded - size0) / ((time1 - time0) / 1000) * 100) / 100;\n                var percent = total ? (parseInt(loaded / total * 100) / 100) : 0;\n                time0 = time1;\n                size0 = loaded;\n                params.onDownloadProgress({\n                    loaded: loaded,\n                    total: total,\n                    speed: speed,\n                    percent: percent,\n                });\n            });\n        });\n    }\n    </handleProgressEvents>\n    <handleStreams>\n    if (readStream) {\n        readStream.on('error', function (err) {\n            sender && sender.abort && sender.abort();\n            cb(err);\n        });\n        readStream.pipe(sender);\n    }\n    if (params.outputStream) {\n        params.outputStream.on('error', function (err) {\n            sender && sender.abort && sender.abort();\n            cb(err)\n        });\n        sender.pipe(params.outputStream);\n    }\n    </handleStreams>\n    return sender;\n}\n"], ["retrieveImage", "\nfunction(id, callback) {\n    var self = this;\n    <makeRequestOptions>\n    var requestOptions = {\n        uri: '/images/' + id\n    };\n    </makeRequestOptions>\n    <makeAuthorizedRequest>\n    self.authorizedRequest(requestOptions, function(err, res, body) {\n        if (err || !body.image) {\n            callback(err);\n            return;\n        }\n        callback(err, new rackspace.Image(self, body.image));\n    });\n    </makeAuthorizedRequest>\n}\n"], ["LayoutConstructor", "\nfunction( config, parent ) {\n    var typeErrorMsg, contentItem;\n    <validateConfigType>\n    if( typeof config.type !== 'string' ) {\n        throw new lm.errors.ConfigurationError( 'Missing parameter \\'type\\'', config );\n    }\n    if( !this._typeToItem[ config.type ] ) {\n        typeErrorMsg = 'Unknown type \\'' + config.type + '\\'. ' +\n            'Valid types are ' + lm.utils.objectKeys( this._typeToItem ).join( ',' );\n        throw new lm.errors.ConfigurationError( typeErrorMsg );\n    }\n    </validateConfigType>\n    <adjustConfigForComponents>\n    if( config.type === 'component' && !( parent instanceof lm.items.Stack ) && !!parent ) {\n        config = {\n            type: 'stack',\n            isClosable: config.isClosable,\n            width: config.width,\n            height: config.height,\n            content: [ config ]\n        };\n    }\n    </adjustConfigForComponents>\n    <createContentItem>\n    contentItem = new this._typeToItem[ config.type ]( this, config, parent );\n    </createContentItem>\n    return contentItem;\n}\n"], ["moveCarousel", "\nfunction move (wrapBox, startIdx, endIdx, Duration) {\n    <earlyReturnCheck>\n    if (!wrapBox) {\n      return\n    }\n    \n    if (eleWidth !== ele.clientWidth) {\n      eleWidth = ele.clientWidth\n    }\n    </earlyReturnCheck>\n    <calculateMovingParameters>\n    imgIndex = endIdx\n    let endPosition = -eleWidth * endIdx\n    if (Duration) {\n      translateFn(endPosition, '0ms', wrapBox)\n      wrapBox.style.transitionDuration = '0ms'\n    } else {\n      translateFn(endPosition, '300ms', wrapBox)\n      wrapBox.style.transitionDuration = '300ms'\n    }\n    \n    let posIdxObj = resetPosAndIdx(imgIndex, childNum, eleWidth, endPosition)\n    curGestureClientx = posIdxObj.endPos\n    endIdx = posIdxObj.endIndex\n    imgIndex = endIdx\n    </calculateMovingParameters>\n    <updateIndicators>\n    if (dotItems.length > 0) {\n      changeIndicatorStyle(dotItems[startIdx - 1], dotItems[endIdx - 1], carouselParas.activeitem)\n    }\n    \n    if (curGestureClientx !== endPosition) {\n      setTimeout(function () {\n        translateFn(curGestureClientx, '0ms', wrapBox)\n        btnLock.stop = 1\n      }, 400)\n    }\n    </updateIndicators>\n    <finalizeMove>\n    btnLock.stop = 1\n    indicatorChange(imgIndex)\n    viewer.eventAction.execute('switchCompleted', ele, {\n      currIndex: imgIndex,\n      currCarouselItem: childNodes[imgIndex],\n      carouselChildrenLength: childNum\n    })\n    \n    prerenderSetSrc(childNodes, imgIndex, NUM, arraySrc)\n    \n    if (autoHeight) {\n      let time = 0.3\n      if (Duration) time = 0\n      changeCarouselHeight(wrapBox.parentNode.parentNode, imgIndex, time)\n    }\n    </finalizeMove>\n}\n"], ["getSSRRenderer", "\nfunction (ComponentClass) {\n    var renderer = ComponentClass.__ssrRenderer;\n    <createRendererFunction>\n    if (!renderer) {\n        var code = compileJSSource(ComponentClass);\n        renderer = (new Function('return ' + code))();\n        ComponentClass.__ssrRenderer = renderer;\n    }\n    </createRendererFunction>\n    return renderer;\n}\n"], ["initializeStateAction", "\nfunction (state, action) {\n    <cleanInitialState>\n    if (state) {\n      let initialValue = state.value || {}\n      if (state.baseModel) {\n        initialValue = recursiveClean(initialValue, state.baseModel)\n        state.baseModel = getDereferencedModelSchema(state.baseModel)\n        state.model = evaluateConditions(state.baseModel, initialValue, undefined, initialValue)\n        \n        state.value = undefined\n      }\n      if (state.view && !state.baseView) {\n        state.baseView = state.view\n      }\n      </cleanInitialState>\n      <evaluateInitialView>\n      if (state.baseView) {\n        state.view = evaluateViewConditions(state.baseView, initialValue)\n      }\n      </evaluateInitialView>\n    }\n    <setNewState>\n    const newState = initialState(state || {})\n    newState.lastAction = 'INIT'\n    newState.value = immutable(newState.value)\n    </setNewState>\n    return newState\n}\n"], ["createBatchMethod", "\nfunction createBatchMethod(name) {\n    var batch = this;\n    <addProxyFunctionToBatch>\n    batch[name] = proxy;\n    function proxy() {\n        var args = toArray(arguments)\n            , context = batch.__context__;\n        <deferCrossTickExecution>\n        if (!context) {\n            batch.__context__ = context = []\n            process.nextTick(exec.bind(null, batch))\n        }\n        </deferCrossTickExecution>\n        context.push([name, args]);\n        return batch;\n    }\n    </addProxyFunctionToBatch>\n}\n"], ["SpriteBatchNodeConstructor", "\nfunction SpriteBatchNode (opts) {\n    SpriteBatchNode.superclass.constructor.call(this, opts);\n    <processOptions>\n    var file         = opts.file\n      , url          = opts.url\n      , textureAtlas = opts.textureAtlas\n      , texture      = opts.texture;\n    </processOptions>\n    <initializeTextureAtlas>\n    if (url || file || texture) {\n        this.ready = url ? false : true;\n        textureAtlas = new TextureAtlas({url: url, file: file, texture: texture});\n        <waitUntilAtlasLoaded>\n        if (!this.ready) {\n            events.addListenerOnce(textureAtlas, 'load', function () {\n                    this.ready = true;\n            }.bind(this));\n        }\n        </waitUntilAtlasLoaded>\n    }\n    </initializeTextureAtlas>\n    <setTextureAtlas>\n    this.textureAtlas = textureAtlas;\n    </setTextureAtlas>\n    <attachOpacityPropertyListener>\n    events.addPropertyListener(this, 'opacity', 'change', function () {\n        for (var i = 0, len = this.children.length; i < len; i++) {\n            var child = this.children[i];\n            child.opacity = this.opacity;\n        }\n    }.bind(this));\n    </attachOpacityPropertyListener>\n}\n"], ["renderSequence", "\nfunction render(src, meta, block) {\n    var newSrc = [src];\n    <modifyExamples>\n    getExamples(meta).forEach(function(example, i){\n        if (i === 0) {\n            newSrc = [];\n        }\n        var lines = example.split('\\n');\n        lines.forEach(function(line) {\n            var regex = new RegExp(block, 'g');\n            line = line.replace(regex, src.split('\\n'));\n            newSrc.push(line);\n        });\n    });\n    </modifyExamples>\n    return newSrc.join('\\n')\n}\n"], ["formatErrorReports", "\nfunction formatter (fail) {\n    <mapErrorsToStructuredFormat>\n    return fail.map(function oops (err) {\n        return {\n                line: err.line\n            , column: err.character\n            , message: err.reason\n            , ref: err\n        };\n    });\n    </mapErrorsToStructuredFormat>\n}\n"], "```\n\nNotes:\n\n- The `renderSequence` function is compliant as the process is coherently modifying examples, which collectively serves the single responsibility of rendering the sequence.\n- The `formatErrorReports` function is also compliant, as the mapping step is a cohesive action to transform errors into a structured format.\n- In most cases, integral setup steps, parameter processing, or configuration steps haven't been segmented because they contribute to a single cohesive responsibility (e.g., initializing a `SpriteBatchNode` or setting up `initialValue` in the state action). They've been annotated only if they've reflected a distinctly separate responsibility.\n- The `createBatchMethod` function is close to the edge; the proxy batch creation and cross-tick execution are inherently tied together but embody a distinct setup of a delayed batch operation execution, justifying the split.\n"]