[["extractTypedef", "\nasync function extractTypedef(config) {\n  const {\n    source,\n    destination,\n    writable,\n  } = config\n  try {\n    \n    const s = createReadStream(source)\n    const ts = createRegexTransformStream(typedefRe)\n    const ps = new Properties()\n    const readable = new PassThrough()\n    const xml = new XML()\n\n    await writeOnce(readable, '<types>\\n')\n\n    s.pipe(ts).pipe(ps).pipe(xml).pipe(readable, { end: false })\n\n    <chooseStreamResponsibility>\n    const p = whichStream({\n      readable,\n      source,\n      writable,\n      destination,\n    })\n    </chooseStreamResponsibility>\n\n    <handleStreamEvents>\n    await new Promise((r, j) => {\n      s.on('error', e => { LOG('Error in Read'); j(e) })\n      ts.on('error', e => { LOG('Error in Transform'); j(e) })\n      ps.on('error', e => { LOG('Error in RegexTransform'); j(e) })\n      xml.on('error', e => { LOG('Error in XML'); j(e) })\n      readable.on('error', e => { LOG('Error in Stream'); j(e) })\n      xml.on('end', r)\n    })\n    </handleStreamEvents>\n\n    await new Promise(r => readable.end('</types>\\n', r))\n    await p\n  } catch (err) {\n    <handleError>\n    catcher(err)\n    </handleError>\n  }\n}\n"], ["_createRequestParams", "\nfunction _createRequestParams(params) {\n  var resourcePath = params.resourcePath;\n  \n  <modifyResourcePath>\n  resourcePath = resourcePath.replace(\":domain\", params.domain)\n    .replace(\":projectid\", params.projectid)\n    .replace(\":guid\", params.appid);\n  </modifyResourcePath>\n\n  <logActivity>\n  log.logger.debug(\"Creating Request Params For Core \", params);\n  </logActivity>\n\n  <constructCoreHost>\n  var coreHost = params.appMbaasModel.coreHost;\n  if(coreHost.indexOf(\"http\") !== 0){\n    coreHost = \"https://\" + coreHost;\n  }\n  </constructCoreHost>\n\n  <createRequestObject>\n  return {\n    url: url.format(coreHost + resourcePath),\n    method: params.method,\n    headers: {\n      'x-fh-auth-app' : params.apiKey\n    },\n    json: true,\n    body: params.data || {}\n  };\n  </createRequestObject>\n}\n"], ["handleUnpairedTags", "\nfunction (tag) {\n  if (voidElements.indexOf(tag.name) < 0) {\n    reporter.warn(\n      tag.pos,\n      '035',\n      'Tag ' + tag.name + ' is not paired.'\n    );\n  }\n}\n"], ["constructEventHandlingMetadata", "\nfunction(_element,_type,_handler,_capture){\n  var _result = {};\n  \n  _element = _e._$get(_element);\n  if (!_element){\n      return null;\n  }\n  _e._$id(_element);\n  _result.element = _element;\n  \n  if (!_u._$isFunction(_handler)){\n      return null;\n  }\n  _result.handler = _handler;\n  \n  var _type = _getTypeList(_type);\n  if (!_type){\n      return null;\n  }\n  \n  _result.type = _type;\n  _result.capture = !!_capture;\n  return _result;\n}\n"], ["updateCacheAndAddClassName", "\nfunction(_id,_clazz,_event){\n  _cache[_id] = _v._$page(_event);\n  _e._$addClassName(_id,_clazz);\n}\n"], ["quote", "\nfunction quote(inst, list, argv, event, fin) {\n    \n  if (!ok(inst, inst.options.quoteTransaction)) return exit(inst, list, fin);\n  var entity = list[list.length - 1];\n  if (_isValue(entity)) return fin(null, entity);\n  var quotation = {};\n  quotation[RUNIQ_QUOTED_ENTITY_PROP_NAME] = entity;\n  return fin(null, quotation);\n}\n"], ["hookChildProcEvents", "\nfunction hookChildProcEvents() {\n  childProc.on('error', function (err) {\n      logger.error('error: ', err);\n      _childProcLastError = err;\n  });\n  childProc.on('disconnect', function () {\n      logger.debug('script-boilerplate process disconnected');\n  });\n  \n  <handleUncaughtException>\n  childProc.on('uncaughtException', function (err) {\n      logger.error('uncaughtException: ', (err && err.stack) ? err.stack : err);\n      _childProcLastError = err;\n  });\n  </handleUncaughtException>\n\n  <handleExit>\n  childProc.on('exit', function (code, signal) {\n      logger.debug('script-boilerplate process exited with code: ' + code + ', signal: ' + signal);\n      if (dbg) {\n          dbg.close();\n      }\n  </handleExit>\n  \n  <handleExitConditionally>\n      if (code && code !== 0) {\n          var promise, error;\n          if (_isRunning || _isDisposing) {\n              promise = _isRunning ? _whenFinished : _whenDisposed;\n              error = _childProcLastError || new Error('script-boilerplate process exited with code: ' + code);\n              promise.reject(error);\n              resetGlobalVariables();\n          }\n      }\n  </handleExitConditionally>\n\n  <handleMessages>\n  childProc.on('message', function (msg) {\n    \n  });\n  </handleMessages>\n"], ["printFileSizesAfterBuild", "\nfunction printFileSizesAfterBuild( ... ) {\n  \n}\n"], ["recover", "\nfunction recover(rawTx, v, r, s) {\n  <decodeAndRecover>\n  const rawTransaction = typeof(rawTx) === 'string' ? new Buffer(stripHexPrefix(rawTx), 'hex') : rawTx;\n  const signedTransaction = rlp.decode(rawTransaction);\n  const raw = [];\n\n  transactionFields.forEach((fieldInfo, fieldIndex) => {\n    raw[fieldIndex] = signedTransaction[fieldIndex];\n  });\n\n  const publicKey = secp256k1.recoverPubKey((new Buffer(keccak256(rlp.encode(raw)), 'hex')), { r, s }, v - 27);\n  return (new Buffer(publicKey.encode('hex', false), 'hex')).slice(1);\n  </decodeAndRecover>\n}\n"], ["performDialogOperations", "\nfunction (fromQueue) {\n    \n    var item = queue[0],\n        self = this,\n        transitionDone;\n\n    \n    isopen = true;\n    \n    <bindTransition>\n    transitionDone = function (event) {\n        event.stopPropagation();\n        self.setFocus();\n        \n        self.unbind(elDialog, self.transition.type, transitionDone);\n    };\n    \n    if (this.transition.supported && !fromQueue) {\n        this.bind(elDialog, this.transition.type, transitionDone);\n    }\n    </bindTransition>\n    \n    <updateDialogContent>\n    elDialog.innerHTML = this.build(item);\n    \n    btnReset  = $(\"alertify-resetFocus\");\n    btnOK     = $(\"alertify-ok\")     || undefined;\n    btnCancel = $(\"alertify-cancel\") || undefined;\n    btnFocus  = (_alertify.buttonFocus === \"cancel\") ? btnCancel : ((_alertify.buttonFocus === \"none\") ? $(\"alertify-noneFocus\") : btnOK),\n    input     = $(\"alertify-text\")   || undefined;\n    form      = $(\"alertify-form\")   || undefined;\n    \n    if (typeof item.placeholder === \"string\" && item.placeholder !== \"\") input.value = item.placeholder;\n    if (fromQueue) this.setFocus();\n    this.addListeners(item.callback);\n    </updateDialogContent>\n}\n"], "```\n\nEach of these functions has been annotated according to the Single Responsibility Principle. Where multiple responsibilities were identified within a function, they were wrapped in separate tags. Some functions did not exhibit clearly separable responsibilities and hence are contained within a single set of tags."]