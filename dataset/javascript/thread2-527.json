[["createPage", "\nfunction createPage(filename) {\n\t<buildPageObject>\n\tlet page = {\n\t\tpath: filename,\n\t\trawContent: fs.readFileSync(filename, \"utf8\"),\n\t\tname: path.basename(filename).replace(/\\.[^/.]+$/, \"\"),\n\t\tfilename: path.basename(filename),\n\t\tfolder: path.dirname(filename),\n\t\text: path.extname(filename),\n\t\tuserData: {}\n\t};</buildPageObject>\n\t<processMarkdown>\n\tpage.isMarkdown = page.ext.toLocaleUpperCase() == \".MD\";\n\tif (page.isMarkdown)\n\t\tpage.ext = \".html\";</processMarkdown>\n\t<renderTemplate>\n\tpage.template = doT.template(page.rawContent, null, page.userData);</renderTemplate>\n\t<computeOutputPath>\n\tpage.outPath = path.join(path.relative(CONTENT, page.folder), page.name + page.ext);</computeOutputPath>\n\t<computeHref>\n\tpage.href = CONFIG.prefix + page.outPath;</computeHref>\n\treturn page;\n}\n"], ["_connectionFailureHandler", "\nfunction _connectionFailureHandler(self) {\n\treturn function() {\n\t\t<checkAlreadyHandled>\n\t\tif (this._connectionFailHandled) return;</checkAlreadyHandled>\n\t\tthis._connectionFailHandled = true;\n\t\t\n\t\t<destroyConnection>\n\t\tthis.destroy();</destroyConnection>\n\t\t\n\t\t<decrementRetries>\n\t\tself.retriesLeft = self.retriesLeft - 1;</decrementRetries>\n\t\t\n\t\t<emitReconnectFailed>\n\t\tif (self.retriesLeft <= 0) {\n\t\t  \n\t\t  self.destroy();\n\t\t  \n\t\t  self.emit(\n\t\t\t'reconnectFailed',\n\t\t\tnew MongoNetworkError(\n\t\t\t  f(\n\t\t\t\t'failed to reconnect after %s attempts with interval %s ms',\n\t\t\t\tself.options.reconnectTries,\n\t\t\t\tself.options.reconnectInterval\n\t\t\t  )\n\t\t\t)\n\t\t  );\n\t\t} else {\n\t\t  <attemptReconnect>\n\t\t  self.reconnectId = setTimeout(attemptReconnect(self), self.options.reconnectInterval);</attemptReconnect>\n\t\t}\n\t};\n}\n"], ["setWritableHeader", "\nfunction setWritableHeader(res, name, value) {\n\n\t<checkIfWritable>\n\tif (res._headerSent && res.finished) {\n\t\t  return false;\n\t}</checkIfWritable>\n\n\t<setHeader>\n\tres.setHeader(name, value);</setHeader>\n\treturn true;\n}\n"], ["listInstalledVer", "\nfunction listInstalledVer(name, dir) {\n\t<runNpmList>\n\tvar _child$spawnSync3 = _child_process2['default'].spawnSync(npmCommand, ['list', name, '--depth', '0', '--json'], { cwd: dir });\n\n\tvar stdout = _child$spawnSync3.stdout;\n\tvar error = _child$spawnSync3.error;\n\tvar status = _child$spawnSync3.status;</runNpmList>\n\n\t<checkErrorStatus>\n\tif (error || 0 !== status) {\n\t\t\treturn '';\n\t}</checkErrorStatus>\n\n\t<parseOutput>\n\treturn JSON.parse(stdout)['version'];</parseOutput>\n}\n"], ["do_update", "\nfunction do_update(self, ObjType, obj, orig_data) {\n\treturn nr_fcall(\"nopg:do_update\", function() {\n\t\t<setUpdateWhereClause>\n\t\tvar query, params, data, where = {};\n\n\t\tif(obj.$id) {\n\t\t\twhere.$id = obj.$id;\n\t\t} else if(obj.$name) {\n\t\t\twhere.$name = obj.$name;\n\t\t} else {\n\t\t\tthrow new TypeError(\"Cannot know what to update!\");\n\t\t}</setUpdateWhereClause>\n\n\t\t<compareData>\n\t\tif(orig_data === undefined) {\n\t\t\tdata = obj.valueOf();\n\t\t} else {\n\t\t\tdata = (new ObjType(obj)).update(orig_data).valueOf();\n\t\t}</compareData>\n\n\t\t<filterKeysForUpdate>\n\t\tvar keys = ARRAY(ObjType.meta.keys)\n\t\t\t.filter(first_letter_is_dollar)\n\t\t\t.map( parse_keyword_name )\n\t\t\t.filter(function(key) {\n\t\t\t\treturn data.hasOwnProperty(key);\n\t\t\t}).filter(function(key) {\n\t\t\t\treturn json_cmp(data[key], obj['$'+key]) ? false : true;\n\t\t\t});</filterKeysForUpdate>\n\n\t\t<returnUnmodifiedValues>\n\t\tif(keys.valueOf().length === 0) {\n\t\t\treturn do_select(self, ObjType, where);\n\t\t}</returnUnmodifiedValues>\n\n\t\t<buildUpdateQuery>\n\t\tquery = \"UPDATE \" + (ObjType.meta.table) + \" SET \"+ keys.map(function(k, i) { return k + ' = $' + (i+1); }).join(', ') +\" WHERE \";\n\n\t\tif(where.$id) {\n\t\t\tquery += \"id = $\"+ (keys.valueOf().length+1);\n\t\t} else if(where.$name) {\n\t\t\tquery += \"name = $\"+ (keys.valueOf().length+1);\n\t\t} else {\n\t\t\tthrow new TypeError(\"Cannot know what to update!\");\n\t\t}\n\n\t\tquery += \" RETURNING *\";\n\t\t</buildUpdateQuery>\n\n\t\t<prepareQueryParameters>\n\t\tparams = keys.map(function(key) {\n\t\t\treturn data[key];\n\t\t}).valueOf();\n\n\t\tif(where.$id) {\n\t\t\tparams.push(where.$id);\n\t\t} else if(where.$name){\n\t\t\tparams.push(where.$name);\n\t\t}</prepareQueryParameters>\n\n\t\t<executeQuery>\n\t\treturn do_query(self, query, params);\n\t\t</executeQuery>\n\t});\n}\n"], ["dropdownToggleBehavior", "\nfunction () {\n\t<toggleClass>\n\tthis.classes.toggle('menu-align', true);\n\t</toggleClass>\n\n\t<applySuperMethod>\n\tthis._super();\n\t</applySuperMethod>\n\n\t<resetHeight>\n\tthis.getEl().style.height = '';\n\tthis.getEl('body').style.height = '';\n\t</resetHeight>\n\n\treturn this;\n}\n"], ["isValidRestSpreadPair", "\nfunction isValidRestSpreadPair(ctorParam, superArg) {\n\t<evaluatePair>\n\treturn (\n\t\tctorParam.type === \"RestElement\" &&\n\t\tsuperArg.type === \"SpreadElement\" &&\n\t\tisValidIdentifierPair(ctorParam.argument, superArg.argument)\n\t);\n\t</evaluatePair>\n}\n"], ["stringInterpolation", "\nfunction(subject) {\n\tvar args = Array.prototype.slice.call(arguments, 1);\n\n\t<interpolateWithMap>\n\tif(typeof args[0] === 'object') {\n\t\t\tvar map = args[0];\n\t\t\treturn subject.replace(/{(.+?)}/g, function(match, key) {\n\t\t\t\t\tif( typeof map[key] == 'undefined' ) return match;\n\t\t\t\t\treturn map[key];\n\t\t\t});\n\t}</interpolateWithMap>\n\n\t<interpolateWithArray>\n\treturn subject.replace(/{(\\d+)}/g, function(match, number) {\n\t\t\treturn typeof args[number] != 'undefined'\n\t\t\t\t\t? args[number]\n\t\t\t\t\t: match;\n\t});</interpolateWithArray>\n}\n"], ["configureKarmaOptions", "\nfunction(configFile, customOptions) {\n\t<defineBaseOptions>\n\tvar options = { configFile: configFile, singleRun: true };</defineBaseOptions>\n\t<extendWithTravisOptions>\n\tvar travisOptions = process.env.TRAVIS && {\n\t  browsers: ['Chrome', 'Firefox'],\n\t  reporters: ['dots', 'coverage', 'coveralls'],\n\t  preprocessors: { 'src/*.js': ['coverage'] },\n\t  coverageReporter: {\n\t\treporters: [{\n\t\t  type: 'text'\n\t\t}, {\n\t\t  type: 'lcov',\n\t\t  dir: 'coverage/'\n\t\t}]\n\t  },\n\t};</extendWithTravisOptions>\n\t<mergeOptions>\n\treturn grunt.util._.extend(options, customOptions, travisOptions);\n\t</mergeOptions>\n}\n"], ["RemoteImage", "\nfunction RemoteImage(target) {\n\t<initContainer>\n\tthis.container = utils.isString(target) ? document.getElementById(target) : target;\n\t</initContainer>\n\t<initializeRemoteImage>\n\tthis.init();\n\t</initializeRemoteImage>\n}\n"], "```"]