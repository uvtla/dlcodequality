[["heamlFunction", "\nasync function heml(contents, options = {}) {\n  <parseOptions>\n  const results = {}\n  const {\n    beautify: beautifyOptions = {},\n    validate: validateOption = 'soft'\n  } = options\n  options.elements = flattenDeep(toArray(coreElements).concat(options.elements || []))\n  </parseOptions>\n\n  <parseContent>\n  const $heml = parse(contents, options)\n  </parseContent>\n\n  <validateContent>\n  const errors = validate($heml, options)\n  if (validateOption.toLowerCase() === 'strict' && errors.length > 0) { throw errors[0] }\n  if (validateOption.toLowerCase() === 'soft') { results.errors = errors }\n  </validateContent>\n\n  <renderContent>\n  const {\n    $: $html,\n    metadata\n  } = await render($heml, options)\n  </renderContent>\n\n  <inlineStyles>\n  inline($html, options)\n  </inlineStyles>\n\n  <beautifyHTML>\n  results.html = condition.replace(beautify($html.html(), {\n    indent_size: 2,\n    indent_inner_html: true,\n    preserve_newlines: false,\n    extra_liners: [],\n    ...beautifyOptions }))\n  </beautifyHTML>\n\n  <calculateMetadata>\n  metadata.size = `${(byteLength(results.html) / 1024).toFixed(2)}kb`\n  results.metadata = metadata\n  </calculateMetadata>\n\n  <returnResults>\n  return results\n  </returnResults>\n}\n"], ["replaceValuesWithVariableNamesFunction", "\nfunction replaceValuesWithVariableNames(variables, prefix) {\n  <createMap>\n  const map = {}\n  Object.keys(variables || {}).forEach((variableName) => {\n    <assignVariable>\n    map[variableName] = `var(${formatVariableName(variableName, prefix)})`\n    </assignVariable>\n  })\n  </createMap>\n\n  <returnMap>\n  return map\n  </returnMap>\n}\n"], ["loadListFunction", "\nfunction loadList(brain) {\n  <retrieveTabooList>\n  const taboolist = brain.get(\"taboo\");\n  </retrieveTabooList>\n  \n  <processTabooList>\n  if (taboolist != null) {\n    for (let topic of taboolist) {\n      <createRegExp>\n      taboo.set(topic, new RegExp(`\\\\b${topic}\\\\b`, \"i\"));\n      </createRegExp>\n    }\n  }\n  </processTabooList>\n}\n"], ["geometryFunction", "\nfunction(points, panLines, smoothFactor) {\n  <initializeResult>\n  var result = {};\n  </initializeResult>\n\n  <processPoints>\n  Utils.each(points, function(point, index) {\n    <calculateDistance>\n    var currentPanLine = panLines[index],\n        center = currentPanLine.center,\n        distance = {\n            x: center.x - point.x,\n            y: center.y - point.y\n        };\n    </calculateDistance>\n\n    <createCurrentResult>\n    var currentResult = result[index] = {\n        points: [],\n        center: {\n            x: point.x,\n            y: point.y\n        }\n    };\n    </createCurrentResult>\n\n    <applySmoothingFactor>\n    Utils.each(currentPanLine.points, function(controlPoint, index) {\n        var moved = {\n            x: controlPoint.x - distance.x,\n            y: controlPoint.y - distance.y\n        };\n        var vertex = currentResult.center;\n        var dx = moved.x - vertex.x;\n        var dy = moved.y - vertex.y;\n        moved.x = vertex.x + smoothFactor * dx;\n        moved.y = vertex.y + smoothFactor * dy;\n        currentResult.points.push(moved);\n    });\n    </applySmoothingFactor>\n\n  });\n  </processPoints>\n\n  <returnResult>\n  return result;\n  </returnResult>\n}\n"], ["ShadowMaterialFunction", "\nfunction ShadowMaterial(parameters) {\n  <callBaseConstructor>\n  Material.call(this);\n  </callBaseConstructor>\n\n  <setDefaultProperties>\n  this.type = 'ShadowMaterial';\n  this.color = new Color(0x000000);\n  this.transparent = true;\n  </setDefaultProperties>\n\n  <applyParameters>\n  this.setValues(parameters);\n  </applyParameters>\n}\n"], ["AssetManifestGeneratorFunction", "\nfunction AssetManifestGenerator(inputTrees, options) {\n  <setDefaultOptions>\n  options = options || {};\n  this.prepend = options.prepend || '';\n  this.filesToIgnore = options.filesToIgnore || [];\n  this.supportedTypes = options.supportedTypes || DEFAULT_SUPPORTED_TYPES;\n  this.generateURI = options.generateURI || function generateURI(filePath) {\n    return filePath;\n  };\n  </setDefaultOptions>\n\n  <callBaseConstructor>\n  Plugin.call(this, inputTrees, {\n    annotation: options.annotation\n  });\n  </callBaseConstructor>\n}\n"], ["useGatewayAuthenticationFunction", "\nfunction useGatewayAuthentication(req) {\n  <fastPathCheck>\n  if (req.useGateway == true) { return true; }\n  </fastPathCheck>\n\n  <determineGatewayUsage>\n  var origUrl = req.originalUrl;\n  var useGateway = false;\n  var idx = origUrl.indexOf(gatewayParameter);\n  if (idx >= 0) {\n    useGateway = true;\n  }\n  </determineGatewayUsage>\n\n  <returnDecision>\n  return useGateway;\n  </returnDecision>\n}\n"], ["getQueryFunction", "\nfunction(cb) {\n  <executeQuery>\n  req.linz.model.getQuery(req, filters, function(err, result) {\n    if (err) {\n      return cb(err);\n    }\n    query = result;\n    return cb(null);\n  });\n  </executeQuery>\n}\n"], ["normalizeTweenValuesFunction", "\nfunction normalizeTweenValues(tween, animatable) {\n  <processTweenProperties>\n  const t = {};\n  for (let p in tween) {\n    let value = getFunctionValue(tween[p], animatable);\n    if (is.arr(value)) {\n      <processArrayValues>\n      value = value.map(v => getFunctionValue(v, animatable));\n      </processArrayValues>\n      if (value.length === 1) value = value[0];\n    }\n    t[p] = value;\n  }\n  t.duration = parseFloat(t.duration);\n  t.delay = parseFloat(t.delay);\n  </processTweenProperties>\n\n  <returnNormalizedValues>\n  return t;\n  </returnNormalizedValues>\n}\n"], ["getStationaryLocationFunction", "\nfunction(successFn, errorFn) {\n  <setDefaultFunctions>\n  successFn = successFn || emptyFn;\n  errorFn = errorFn || emptyFn;\n  </setDefaultFunctions>\n\n  <invokeNativeModule>\n  RNBackgroundGeolocation.getStationaryLocation(successFn, errorFn);\n  </invokeNativeModule>\n}\n"], "```\n\nIn the annotation process, I've enclosed each function within a set of tags describing the primary responsibility of that function. Within each larger block, responsibilities were identified and annotated when distinct parts of the function represented clear, separate tasks. Functions like `replaceValuesWithVariableNames` and `ShadowMaterial` were straightforward and only required outer tags, as their inner operations were not distinct enough to warrant separate annotations. Other functions, like `heml`, had more complex internal operations, and each significant block was annotated to reflect different responsibilities within the single cohesive function."]