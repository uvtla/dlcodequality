[["function_1", "\nfunction( event, type, dd, x, elem ){\n                \n                if ( !dd )\n                    return;\n                \n                \n                <define_variables>\n                var orig = { event:event.originalEvent, type:event.type },\n                    \n                    mode = type.indexOf(\"drop\") ? \"drag\" : \"drop\",\n                    \n                    result, i = x || 0, ia, $elems, callback,\n                    len = !isNaN( x ) ? x : dd.interactions.length;\n                </define_variables>\n                \n                <modify_event>\n                event.type = type;\n                \n                var noop = function(){};\n                event.originalEvent = new jQuery.Event(orig.event, {\n                    preventDefault: noop,\n                    stopPropagation: noop,\n                    stopImmediatePropagation: noop\n                });\n                </modify_event>\n                \n                <initialize_results>\n                dd.results = [];\n                </initialize_results>\n                \n                <interaction_loop>\n                do if ( ia = dd.interactions[ i ] ){\n                    \n                    if ( type !== \"dragend\" && ia.cancelled )\n                        continue;\n                    \n                    callback = drag.properties( event, dd, ia );\n                    \n                    ia.results = [];\n                    \n                    $( elem || ia[ mode ] || dd.droppable ).each(function( p, subject ){\n                        \n                        <modify_callback_target>\n                        callback.target = subject;\n                        </modify_callback_target>\n                        \n                        <define_isPropagationStopped>\n                        event.isPropagationStopped = function(){ return false; };\n                        </define_isPropagationStopped>\n                        \n                        <dispatch_event>\n                        result = subject ? $event.dispatch.call( subject, event, callback ) : null;\n                        </dispatch_event>\n                        \n                        <process_result>\n                        if ( result === false ){\n                            if ( mode == \"drag\" ){\n                                ia.cancelled = true;\n                                dd.propagates -= 1;\n                            }\n                            if ( type == \"drop\" ){\n                                ia[ mode ][p] = null;\n                            }\n                        }\n                        \n                        else if ( type == \"dropinit\" )\n                            ia.droppable.push( drag.element( result ) || subject );\n                        \n                        if ( type == \"dragstart\" )\n                            ia.proxy = $( drag.element( result ) || ia.drag )[0];\n                        \n                        ia.results.push( result );\n                        \n                        delete event.result;\n                        \n                        if ( type !== \"dropinit\" )\n                            return result;\n                        </process_result>\n                    });\n                    \n                    <process_interaction_results>\n                    dd.results[ i ] = drag.flatten( ia.results );\n                    \n                    if ( type == \"dropinit\" )\n                        ia.droppable = drag.flatten( ia.droppable );\n                    \n                    if ( type == \"dragstart\" && !ia.cancelled )\n                        callback.update();\n                    </process_interaction_results>\n                }\n                while ( ++i < len )\n                </interaction_loop>\n                    \n                <reset_event>\n                event.type = orig.type;\n                event.originalEvent = orig.event;\n                </reset_event>\n                \n                <return_flattened_results>\n                return drag.flatten( dd.results );\n                </return_flattened_results>\n            }\n"], ["validateQuery", "\nfunction validateQuery(query) {\n\t\t<verify_query_object>\n\t\tAssert.ok(((query) && ((typeof query) === 'object')),\n\t\t\t'The Query object was not set?');\n\t\t</verify_query_object>\n\t\t<verify_query_string>\n\t\tAssert.ok(((query.QueryString) && ((typeof query.QueryString) === 'string')),\n\t\t\t'The query string was not set?');\n\t\t</verify_query_string>\n\t\t<verify_result_configuration>\n\t\tAssert.ok(((query.ResultConfiguration) && ((typeof query.ResultConfiguration) === 'object')),\n\t\t\t'The result configuration in the query object was not set?');\n\t\t</verify_result_configuration>\n\t\t<verify_output_location>\n\t\tAssert.ok(((query.ResultConfiguration.OutputLocation) && ((typeof query.ResultConfiguration.OutputLocation) === 'string')),\n\t\t\t'The output location of the result configuration in the query object was not set?');\n\t\t</verify_output_location>\n\t\t<return_validated_query>\n\t\treturn query;\n\t\t</return_validated_query>\n}\n"], ["function_3", "\nfunction(a, b) {\n         return {\n            <uniform_distribution_functions>\n            d: function(x, logp) { return dunif(a, b, logp)(x); },\n            p: function(q, lowerTail, logp) {\n               return punif(a, b, lowerTail, logp)(q);\n            },\n            q: function(p, lowerTail, logp) {\n               return qunif(a, b, lowerTail, logp)(p);\n            },\n            r: function() { return runif(a, b)(); }\n            </uniform_distribution_functions>\n         };\n      }\n"], ["request", "\nfunction request(url, options, callback) {\n\t<initialize_debug>\n\tvar debug = require('debug')('wayback:http');\n\tdebug('req', url);\n\t</initialize_debug>\n\n\t<define_callback>\n\tcallback = typeof callback === 'undefined' ? options : callback;\n\t</define_callback>\n\n\t<perform_request>\n\tvar stream = new fetch(url, typeof options === 'object' ? options : undefined);\n\n\tstream.on('error', function(err) {\n\t\t<debug_error>\n\t\tdebug('error', err);\n\t\t</debug_error>\n\t\t<error_callback>\n\t\tcallback(err, null);\n\t\t</error_callback>\n\t});\n\n\tstream.on('meta', function(meta) {\n\t\t<debug_response>\n\t\tdebug('resp', 'HTTP ' + meta.status);\n\t\tdebug('resp', meta.responseHeaders);\n\t\t</debug_response>\n\t\t<success_callback>\n\t\tcallback(null, stream);\n\t\t</success_callback>\n\t});\n\t</perform_request>\n}\n"], ["CordovaAudioPlugin", "\nfunction CordovaAudioPlugin() {\n\t\t<AbstractPlugin_constructor_call>\n\t\tthis.AbstractPlugin_constructor();\n\t\t</AbstractPlugin_constructor_call>\n\n\t\t<set_capabilities>\n\t\tthis._capabilities = s._capabilities;\n\t\t</set_capabilities>\n\n\t\t<set_loader_and_instance_classes>\n\t\tthis._loaderClass = createjs.CordovaAudioLoader;\n\t\tthis._soundInstanceClass = createjs.CordovaAudioSoundInstance;\n\t\t</set_loader_and_instance_classes>\n\n\t\t<initialize_srcDurationHash>\n\t\tthis._srcDurationHash = {};\n\t\t</initialize_srcDurationHash>\n\t}\n"], ["powMod_", "\nfunction powMod_(x, y, n) {\n  <initialize_variables>\n  var k1, k2, kn, np;\n  if (s7.length!=n.length)\n    s7=dup(n);\n  </initialize_variables>\n\n  <handle_even_n>\n  if ((n[0]&1)==0) {\n    <Calculate_power_mod>\n    copy_(s7, x);\n    copyInt_(x, 1);\n    while (!equalsInt(y, 0)) {\n      if (y[0]&1)\n        multMod_(x, s7, n);\n      divInt_(y, 2);\n      squareMod_(s7, n);\n    }\n    </Calculate_power_mod>\n    return;\n  }\n  </handle_even_n>\n\n  <preprocess_for_odd_n>\n  copyInt_(s7, 0);\n  for (kn=n.length; kn>0 && !n[kn-1]; kn--);\n  np=radix-inverseModInt(modInt(n, radix), radix);\n  s7[kn]=1;\n  multMod_(x, s7, n);\n  </preprocess_for_odd_n>\n\n  <prepare_s3_array>\n  if (s3.length!=x.length)\n    s3=dup(x);\n  else\n    copy_(s3, x);\n  </prepare_s3_array>\n\n  <find_nonzero_y_digits>\n  for (k1=y.length-1; k1>0 & !y[k1]; k1--);\n  if (y[k1]==0) {\n    copyInt_(x, 1);\n    return;\n  }\n  for (k2=1<<(bpe-1); k2 && !(y[k1] & k2); k2>>=1);\n  </find_nonzero_y_digits>\n\n  <perform_montgomery_multiplication>\n  for (;;) {\n    if (!(k2>>=1)) {\n      k1--;\n      if (k1<0) {\n        mont_(x, one, n, np);\n        return;\n      }\n      k2=1<<(bpe-1);\n    }\n    mont_(x, x, n, np);\n\n    if (k2 & y[k1]) \n      mont_(x, s3, n, np);\n  }\n  </perform_montgomery_multiplication>\n}\n"], ["tabView_closeGroup", "\nfunction tabView_closeGroup(aSpec) {\n    <verify_spec_and_group>\n    var spec = aSpec || {};\n    var group = spec.group;\n\n    if (!group) {\n      throw new Error(arguments.callee.name + \": Group not specified.\");\n    }\n    </verify_spec_and_group>\n\n    <locate_and_click_close_button>\n    var button = this.getElement({\n      type: \"group_closeButton\",\n      value: group\n    });\n    this._controller.click(button);\n    </locate_and_click_close_button>\n\n    <wait_for_group_close>\n    this.waitForGroupClosed({group: group});\n    </wait_for_group_close>\n  }\n"], ["once", "\nfunction once(f) {\n    <wrap_function>\n    function g() {\n      <apply_and_remove>\n      f.apply(this, arguments)\n      remove(g)\n      </apply_and_remove>\n    }\n    <add_listener>\n    add(g)\n    </add_listener>\n    <return_notify>\n    return notify\n    </return_notify>\n    </wrap_function>\n}\n"], ["_doReplaceInOneFile", "\nfunction _doReplaceInOneFile(fullPath, matchInfo, replaceText, options) {\n        <get_open_document_or_prepare_new>\n        var doc = DocumentManager.getOpenDocumentForPath(fullPath);\n        options = options || {};\n        \n        if (!doc && (options.forceFilesOpen || MainViewManager.findInWorkingSet(MainViewManager.ALL_PANES, fullPath) !== -1)) {\n            return DocumentManager.getDocumentForPath(fullPath).then(function (newDoc) {\n                <do_replace_in_document>\n                return _doReplaceInDocument(newDoc, matchInfo, replaceText, options.isRegexp);\n                </do_replace_in_document>\n            });\n        } else if (doc) {\n            <do_replace_in_document>\n            return _doReplaceInDocument(doc, matchInfo, replaceText, options.isRegexp);\n            </do_replace_in_document>\n        } else {\n            <do_replace_on_disk>\n            return _doReplaceOnDisk(fullPath, matchInfo, replaceText, options.isRegexp);\n            </do_replace_on_disk>\n        }\n        </get_open_document_or_prepare_new>\n    }\n"], ["getSelectValue", "\nfunction getSelectValue (elem) {\n  <initialize_variables>\n  var value, option, i\n  var options = elem.options\n  var index = elem.selectedIndex\n  var one = elem.type === 'select-one'\n  var values = one ? null : []\n  var max = one ? index + 1 : options.length\n  </initialize_variables>\n\n  <set_starting_index>\n  if (index < 0) {\n    i = max\n  } else {\n    i = one ? index : 0\n  }\n  </set_starting_index>\n\n  \n  <iterate_options>\n  for (; i < max; i++) {\n    option = options[i]\n\n    <validate_option>\n    if ((option.selected || i === index) &&\n\n        <check_disabled>\n        !option.disabled &&\n        (!option.parentNode.disabled ||\n          option.parentNode.tagName.toLowerCase() === 'optgroup')) {\n          </check_disabled>\n\n      <get_option_value>\n      value = option.value\n      </get_option_value>\n\n      <handle_selection_type>\n      if (one) {\n        return value\n      }\n      values.push(value)\n      </handle_selection_type>\n    }\n    </validate_option>\n  }\n  </iterate_options>\n\n  <return_values>\n  return values\n  </return_values>\n}\n"], ""]