[["checkFileExists", "\nfunction checkFileExists(filename, callback) {\n  <checkFsExists>\n  if (fs.exists !== undefined) {\n    fs.exists(filename, callback);\n  </checkFsExists> \n  else {\n    <performFsStat>\n    fs.stat(filename, function (err) {\n      callback(!err);\n    });\n    </performFsStat> \n  }\n}\n"], ["_getUpdateInformation", "\nfunction _getUpdateInformation(force, dontCache, _versionInfoUrl) {\n  <handleViewState>\n  var lastInfoURLFetchTime = PreferencesManager.getViewState(\"lastInfoURLFetchTime\");\n  </handleViewState>\n  \n  <initializeResult>\n  var result = new $.Deferred();\n  </initializeResult>\n\n  <determineFetchData>\n  var fetchData = false;\n  var data;      \n  if (force) {\n    fetchData = true;\n  }\n  data = PreferencesManager.getViewState(\"updateInfo\");\n  if (!data) {\n    fetchData = true;\n  }\n  if ((new Date()).getTime() > lastInfoURLFetchTime + ONE_DAY) {\n    fetchData = true;\n  }\n  </determineFetchData>\n  \n  <performFetchData>\n  if (fetchData) {\n    <initializeLookupPromiseAndLocale>\n    var lookupPromise = new $.Deferred(),\n        localVersionInfoUrl;    \n    var locale = brackets.getLocale().toLowerCase();\n    </initializeLookupPromiseAndLocale>\n    \n    <performLocaleCheckAndFetch>\n    if (locale !== \"en\" && locale !== \"en-us\") {\n      localVersionInfoUrl = _versionInfoUrl || _getVersionInfoUrl();\n      <performAjaxHead>\n      $.ajax({\n        url: localVersionInfoUrl,\n        cache: false,\n        type: \"HEAD\"\n      })\n      </performAjaxHead>\n      .fail(function (jqXHR, status, error) {\n        <handleFailLocaleFallback>\n        var tmpUrl = _getVersionInfoUrl(brackets.getLocale(), true);\n        if (tmpUrl !== localVersionInfoUrl) {\n          <performSecondaryAjaxHead>\n          $.ajax({\n            url: tmpUrl,\n            cache: false,\n            type: \"HEAD\"\n          })\n          </performSecondaryAjaxHead>\n          .fail(function (jqXHR, status, error) {\n            localVersionInfoUrl = _getVersionInfoUrl(\"en\");\n          })\n          .done(function (jqXHR, status, error) {\n            localVersionInfoUrl = tmpUrl;\n          })\n          .always(function (jqXHR, status, error) {\n            lookupPromise.resolve();\n          });\n        } else {\n          localVersionInfoUrl = _getVersionInfoUrl(\"en\");\n          lookupPromise.resolve();\n        }\n        </handleFailLocaleFallback>\n      })\n      .done(function (jqXHR, status, error) {\n        lookupPromise.resolve();\n      });\n    } else {\n      localVersionInfoUrl = _versionInfoUrl || _getVersionInfoUrl(\"en\");\n      lookupPromise.resolve();\n    }\n    </performLocaleCheckAndFetch>\n    \n    <handleLookupPromiseResolution>\n    lookupPromise.done(function () {\n      <performFinalDataFetch>\n      $.ajax({\n        url: localVersionInfoUrl,\n        dataType: \"json\",\n        cache: false\n      })\n      </performFinalDataFetch>\n      .done(function (updateInfo, textStatus, jqXHR) {\n        <cacheUpdateInfoAndResolve>\n        if (!dontCache) {\n          lastInfoURLFetchTime = (new Date()).getTime();\n          PreferencesManager.setViewState(\"lastInfoURLFetchTime\", lastInfoURLFetchTime);\n          PreferencesManager.setViewState(\"updateInfo\", updateInfo);\n        }\n        result.resolve(updateInfo);\n        </cacheUpdateInfoAndResolve>\n      })\n      .fail(function (jqXHR, status, error) {\n        <handleFailedFetchRequest>\n        if (!jqXHR.responseText) {\n          result.reject();\n          return;\n        }\n        try {\n          data = JSON.parse(jqXHR.responseText);\n          result.resolve(data);\n        } catch (e) {\n          result.reject();\n        }\n        </handleFailedFetchRequest>\n      });\n    });\n    </handleLookupPromiseResolution>\n  } else {\n    <resolveWithData>\n    result.resolve(data);\n    </resolveWithData>\n  }\n  </performFetchData>\n  \n  <returnPromise>\n  return result.promise();\n  </returnPromise>\n}\n"], ["ConstructorFunction", "\nfunction (deps) {\n  <validateDependencies>\n  if (!deps.layerGroupModel) throw new Error('layerGroupModel is required');\n  if (!deps.layersCollection) throw new Error('layersCollection is required');\n  if (!deps.dataviewsCollection) throw new Error('dataviewsCollection is required');\n  </validateDependencies>\n\n  <assignDependencies>\n  this._layerGroupModel = deps.layerGroupModel;\n  this._layersCollection = deps.layersCollection;\n  this._dataviewsCollection = deps.dataviewsCollection;\n  </assignDependencies>\n}\n"], ["ImageTransformationFunction", "\nfunction(src,dst,opt){\n  <initializeVariables>\n  var srcPixels = src.data,\n      dstPixels = dst.data,\n      xSize = src.width,\n      ySize = src.height,\n      xMid = opt.polarCenterX || xSize/2,\n      yMid = opt.polarCenterY || ySize/2,\n      i, x, y, r=0,g=0,b=0,a=0;\n  var rad, rMax = Math.sqrt( xMid*xMid + yMid*yMid );\n  x = xSize - xMid;\n  y = ySize - yMid;\n  rad = Math.sqrt( x*x + y*y );\n  rMax = (rad > rMax)?rad:rMax;\n  var rSize = ySize,\n      tSize = xSize,\n      radius, theta;\n  var conversion = 360/tSize*Math.PI/180, sin, cos;\n  </initializeVariables>\n\n  <performTransformation>\n  for( theta=0; theta<tSize; theta+=1 ){\n      sin = Math.sin(theta*conversion);\n      cos = Math.cos(theta*conversion);\n      for( radius=0; radius<rSize; radius+=1 ){\n          x = Math.floor(xMid+rMax*radius/rSize*cos);\n          y = Math.floor(yMid+rMax*radius/rSize*sin);\n          i = (y*xSize + x)*4;\n          r = srcPixels[i+0];\n          g = srcPixels[i+1];\n          b = srcPixels[i+2];\n          a = srcPixels[i+3];\n          i = (theta + radius*xSize) * 4;\n          dstPixels[i+0] = r;\n          dstPixels[i+1] = g;\n          dstPixels[i+2] = b;\n          dstPixels[i+3] = a;\n      }\n  }\n  </performTransformation>\n}\n"], ["getValueHandler", "\nfunction getValueHandler (value, localHandlers, globalHandlers) {\n  <retrieveHandler>\n  return _getValueHandler(value, localHandlers) || _getValueHandler(value, globalHandlers);\n  </retrieveHandler>\n}\n"], ["getArrayFromCache", "\nfunction( renderer, n ) {\n  <initializeCache>\n  var r = arrayCacheI32[ n ];\n  </initializeCache>\n\n  <allocateTextureUnits>\n  if ( r === undefined ) {\n    r = new Int32Array( n );\n    arrayCacheI32[ n ] = r;\n  }\n  for ( var i = 0; i !== n; ++ i )\n    r[ i ] = renderer.allocTextureUnit();\n  </allocateTextureUnits>\n\n  <returnArray>\n  return r;\n  </returnArray>\n}\n"], ["ResponsiveDataTableConstructor", "\nfunction ( settings, opts ) {\n  <checkDataTableVersion>\n  if ( ! DataTable.versionCheck || ! DataTable.versionCheck( '1.10.1' ) ) {\n    throw 'DataTables Responsive requires DataTables 1.10.1 or newer';\n  }\n  </checkDataTableVersion>\n\n  <initializeSettings>\n  this.s = {\n    dt: new DataTable.Api( settings ),\n    columns: []\n  };\n  </initializeSettings>\n\n  <preventMultipleInitializations>\n  if ( this.s.dt.settings()[0].responsive ) {\n    return;\n  }\n  </preventMultipleInitializations>\n\n  <configureDetailsOption>\n  if ( opts && typeof opts.details === 'string' ) {\n    opts.details = { type: opts.details };\n  }\n  </configureDetailsOption>\n\n  <setResponsiveOptions>\n  this.c = $.extend( true, {}, Responsive.defaults, DataTable.defaults.responsive, opts );\n  settings.responsive = this;\n  </setResponsiveOptions>\n\n  <callConstructor>\n  this._constructor();\n  </callConstructor>\n}\n"], ["buildDomWrapper", "\nfunction buildDomWrapper(el, options) {\n  <initializeDOMBuildingVariables>\n  let html = '';\n  let chart100percentWide = '';\n  let rangeChart = '';\n  </initializeDOMBuildingVariables>\n\n  <configureChartStyles>\n  if (options.legend.position === 'top' || options.legend.position === 'bottom') {\n    chart100percentWide = 'c3-chart-100-percent';\n  }\n  if (options.range) {\n    rangeChart = 'keen-dataviz-range';\n  }\n  let container = `<div class=\"c3-chart ${chart100percentWide} ${rangeChart}\"></div>`;\n  let align = 'horizontal';\n  if (options.legend.position === 'left' || options.legend.position === 'right') {\n    align = 'vertical';\n  }\n  </configureChartStyles>\n\n  <buildLegendContainer>\n  if (options.legend && options.legend.show) {\n    if (options.legend.position === 'top' || options.legend.position === 'left') {\n      container = `<div class=\"keen-c3-legend keen-c3-legend-${align} keen-c3-legend-${options.legend.position}\"></div>${container}`;\n    } else {\n      container = `${container}<div class=\"keen-c3-legend keen-c3-legend-${align} keen-c3-legend-${options.legend.position}\"></div>`;\n    }\n  }\n  </buildLegendContainer>\n\n  <buildHtmlStructure>\n  if(!options.react){\n    html += `<div class=\"${options.theme}\">`;\n  }\n  if (options.title && options.showTitle) {\n    html += `<div class=\"keen-dataviz-title ${options.theme}-title\">${options.title}</div>`;\n  }\n  html += `<div class=\"keen-dataviz-rendering keen-dataviz-rendering-${align} ${options.theme}-rendering ${options.theme}-rendering-${align}\">${container}</div>`;\n  if (options.notes) {\n    html += `<div class=\"keen-dataviz-notes ${options.theme}-notes\">${options.notes}</div>`;\n  }\n  if(!options.react){\n    html += '</div>';\n  }\n  el.innerHTML = html;\n  </buildHtmlStructure>\n}\n"], ["performSaveOperation", "\nfunction () {\n  <initializeSaveOperation>\n  this.saveOperation = {};\n  this.saveOperation.entity = this.ctrl.editor.getPlainValue();\n  this.saveOperation.oldEntity = this.ctrl.editor.getOldValue();\n  </initializeSaveOperation>\n  \n  <setupChangeBuffer>\n  var me =this;\n  var args = arguments;\n  this.ctrl.editor.bufferChange(function() {\n    <execInheritedBufferChange>\n    me.inherited(args);\n    </execInheritedBufferChange>\n  });\n  </setupChangeBuffer>\n}\n"], ["getTooltipPosition", "\nfunction (boxWidth, boxHeight, point) {\n  <initializeTooltipContext>\n  var chart = this.chart,\n    distance = this.distance,\n    ret = {},\n    swapped,\n    first = ['y', chart.chartHeight, boxHeight, point.plotY + chart.plotTop],\n    second = ['x', chart.chartWidth, boxWidth, point.plotX + chart.plotLeft],\n    preferFarSide = point.ttBelow || (chart.inverted && !point.negative) || (!chart.inverted && point.negative),\n  </initializeTooltipContext>\n\n  <definePositionCalculations>\n  firstDimension = function (dim, outerSize, innerSize, point) {\n      var roomLeft = innerSize < point - distance,\n        roomRight = point + distance + innerSize < outerSize,\n        alignedLeft = point - distance - innerSize,\n        alignedRight = point + distance;\n      if (preferFarSide && roomRight) {\n          ret[dim] = alignedRight;\n      } else if (!preferFarSide && roomLeft) {\n          ret[dim] = alignedLeft;\n      } else if (roomLeft) {\n          ret[dim] = alignedLeft;\n      } else if (roomRight) {\n          ret[dim] = alignedRight;\n      } else {\n          return false;\n      }\n  },\n  secondDimension = function (dim, outerSize, innerSize, point) {\n      if (point < distance or point > outerSize - distance) {\n          return false;\n      } else if (point < innerSize / 2) {\n          ret[dim] = 1;\n      } else if (point > outerSize - innerSize / 2) {\n          ret[dim] = outerSize - innerSize - 2;\n      } else {\n          ret[dim] = point - innerSize / 2;\n      }\n  },\n  swap = function (count) {\n      var temp = first;\n      first = second;\n      second = temp;\n      swapped = count;\n  },\n  run = function () {\n      if (firstDimension.apply(0, first) !== false) {\n          if (secondDimension.apply(0, second) === false && !swapped) {\n              swap(true);\n              run();\n          }\n      } else if (!swapped) {\n          swap(true);\n          run();\n      } else {\n          ret.x = ret.y = 0;\n      }\n  };\n  </definePositionCalculations>\n  \n  <executePositioning>\n  if (chart.inverted || this.len > 1) {\n      swap();\n  }\n  run();\n  </executePositioning>\n\n  <returnTooltipPosition>\n  return ret;\n  </returnTooltipPosition>\n}\n"], "```"]