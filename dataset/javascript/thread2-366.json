[["pleaseNotify", "\nfunction pleaseNotify (urlServer, domain, port, path, urlFeed, feedstats, callback) { \n\t\tvar now = new Date ();\n\t\t<buildRequestObject>\n\t\tvar theRequest = {\n\t\t\turl: urlServer,\n\t\t\tfollowRedirect: true, \n\t\t\theaders: {Accept: \"application/json\"},\n\t\t\tmethod: \"POST\",\n\t\t\tform: {\n\t\t\t\tport: port,\n\t\t\t\tpath: path,\n\t\t\t\turl1: urlFeed,\n\t\t\t\tprotocol: \"http-post\"\n\t\t\t\t}\n\t\t\t}; </buildRequestObject>\n\t\t\n\t\t<logActivity>\n\t\tmyConsoleLog (\"pleaseNotify: urlFeed == \" + urlFeed); </logActivity>\n\t\t<recordActivityStats>\n\t\tfeedstats.whenLastCloudRenew = now;\n\t\tfeedstats.ctCloudRenew++;\n\t\tflFeedsArrayChanged = true; </recordActivityStats>\n\t\t\n\t\t<sendRequest>\n\t\trequest (theRequest, function (err, response, body) {\n\t\t\t<recordErrorStats>\n\t\t\tfunction recordErrorStats (message) {\n\t\t\t\tfeedstats.ctCloudRenewErrors++; \n\t\t\t\tfeedstats.ctConsecutiveCloudRenewErrors++;\n\t\t\t\tfeedstats.whenLastCloudRenewError = now;\n\t\t\t\tfeedstats.lastCloudRenewError = message;\n\t\t\t\tflFeedsArrayChanged = true; \n\t\t\t\t} </recordErrorStats>\n\t\t\ttry {\n\t\t\t\tvar flskip = false;\n\t\t\t\t\n\t\t\t\t<errorHandling>\n\t\t\t\tif (err) {\n\t\t\t\t\tflskip = true;\n\t\t\t\t\tif (callback) {\n\t\t\t\t\t\tcallback (err.message);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (!body.success) {\n\t\t\t\t\t\tflskip = true;\n\t\t\t\t\t\tif (callback) {\n\t\t\t\t\t\t\tcallback (body.msg);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} </errorHandling>\n\t\t\t\t\n\t\t\t\t<updateStatsOnError>\n\t\t\t\tif (flskip) {\n\t\t\t\t\trecordErrorStats (err.message);\n\t\t\t\t\t} </updateStatsOnError>\n\t\t\t\t<resetErrorStats>\n\t\t\t\telse {\n\t\t\t\t\tfeedstats.ctConsecutiveCloudRenewErrors = 0;\n\t\t\t\t\tflFeedsArrayChanged = true; </resetErrorStats>\n\t\t\t\t\t<returnCallback>\n\t\t\t\t\tif (callback) {\n\t\t\t\t\t\tcallback (\"It worked.\");\n\t\t\t\t\t\t} </returnCallback>\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tcatch (err) {\n\t\t\t\t<recordError>\n\t\t\t\trecordErrorStats (err.message);\n\t\t\t\tif (callback) {\n\t\t\t\t\tcallback (err.message);\n\t\t\t\t\t} </recordError>\n\t\t\t\t}\n\t\t\t}); </sendRequest>\n\t\t}\n"], ["startUpgrade", "\nfunction startUpgrade(dirPath, options) {\n  <checkIfValidProject>\n  try {\n    fs.accessSync(path.join(dirPath, './package.json')) </checkIfValidProject>\n    <performUpgrade>\n    startUpgradeCustomComponent(dirPath, options) </performUpgrade>\n  } catch (err) {\n    <logErrorMessage>\n    console.log(`project is not a valid custom component project: ${dirPath}`) </logErrorMessage>\n  }\n}\n"], ["concatPubPath", "\nfunction concatPubPath(env, fileName) {\n\n        \"use strict\";\n\n        <buildHostPrefixMap>\n        var hostPrefixMap = {\n            'daily': 'h5.waptest',\n            'prepub': 'h5.wapa',\n            'wapp': 'wapp.m', \n            'online': 'h5.m'\n        }; </buildHostPrefixMap>\n\n        <returnCompleteURL>\n        return 'http://' + hostPrefixMap[env] + '.taobao.com/' + fileName; </returnCompleteURL>\n    }\n"], ["updateDescriptor", "\nfunction updateDescriptor(newDescriptor, options) {\n    \n\t<initializeVariables>\n\tvar descriptor,\n\t\ttypeTest,\n\t\teventType; </initializeVariables>\n\t\n\t<processNewDescriptor>\n\tif (newDescriptor) {\n\t\tif (!currentProperty)\n\t\t\tthrow exception('name');\n\t\t\n\t\tdescriptor = newDescriptor;\n\t} </processNewDescriptor>\n\t\n\t<processOptions>\n\tif (options) {\n\t\tif (!currentProperty)\n\t\t\tthrow exception('property');\n\t\t\n\t\tdescriptor = getCurrentDescriptor();\n\t\t\n\t\tif (options.type)\n\t\t\ttypeTest = getTestFor(options.type);\n\t\t\n\t\tif (options.event)\n\t\t\teventType = options.event === true ? ProtoTyper.CHANGE : options.event;\n\t\t\n\t\t<modifyDescriptorBasedOnOptions>\n\t\tif (descriptor.hasOwnProperty('value') && (typeTest || eventType)) {\n\t\t\t\n\t\t\tpush(currentTarget, '_'+currentProperty, {\n\t\t\t\t'value': descriptor.value,\n\t\t\t\t'enumerable': false,\n\t\t\t\t'writable': true\n\t\t\t});\n\t\t\tdelete descriptor.value;\n\t\t}\n\t\t\n\t\tif (descriptor.hasOwnProperty('writable') && (typeTest || eventType))\n\t\t\tdelete descriptor.writable;\n\t\t\n\t\tif (typeTest || eventType) {\n\t\t\tdescriptor.get = generateGet(currentProperty);\n\t\t\tdescriptor.set = generateSet(descriptor.set, currentProperty, typeTest, eventType);\n\t\t}\n\t\t\n\t\tif (options.notKey)\n\t\t\tdescriptor.enumerable = false;\n\t\t\n\t\tif (options.final)\n\t\t\tdescriptor.configurable = false; </modifyDescriptorBasedOnOptions>\n\t} </processOptions>\n\t\n\t\n\t<updatePropertyDescriptor>\n\tpush(currentTarget, currentProperty, descriptor); </updatePropertyDescriptor>\n}\n"], ["duplicateAndModifyInstance", "\nfunction() {\n    <createDuplicateInstance>\n    var dup = this._dup(); </createDuplicateInstance>\n    <modifyDuplicateInstance>\n    dup = dup.noload(); </modifyDuplicateInstance>\n    <setPropertyReferences>\n    dup._priorModel = dup._model;\n    dup._model = undefined; </setPropertyReferences>\n    <returnModifiedInstance>\n    return dup; </returnModifiedInstance>\n  }\n"], ["performServicePost", "\nfunction(relpath, params, callback) {\n\t<buildQualifiedURL>\n    var url = this.qualifiedPath;\n    if (relpath) {\n        url = url + \"/\" + relpath;    \n    } </buildQualifiedURL>\n    <executePostRequest>\n    return this.service.post(\n        url,\n        params,\n        callback\n    ); </executePostRequest>\n}\n"], ["runGruntTask", "\nfunction RunGruntTask(taskname,absolutePath) {\n\t<initializeExecutionModule>\n    var exec = require('child_process').exec; </initializeExecutionModule>\n    var gruntarg = ' --gruntfile ';\n    var space = ' ';\n\n    <executeWindowsTask>\n    if (os === 'Windows_NT') {\n        gruntPath = 'node_modules\\\\grunt-cli\\\\bin\\\\grunt' || absolutePath;\n        var ShellTask = gruntPath + space + gruntarg + gruntfile + space + taskname;\n        var GruntTask = new shell(ShellTask);\n        GruntTask.on('output', function(data) {\n            console.log(data);\n        });\n        GruntTask.on('end', function(code) {\n            console.log(\"Execution done\");\n        });\n    } </executeWindowsTask>\n\n    <executeUnixTask>\n    if (os === 'Darwin' || os === 'Linux') {\n        gruntPath = 'node_modules/grunt-cli/bin/grunt';\n        var child = exec(gruntPath + gruntarg + gruntfile + space + taskname, function(error, stdout, stderr) {\n            if (error !== null) {\n                console.log('exec error: ' + error);\n                var stdout = error;\n                return stdout;\n            } else {\n                console.log('stdout: ' + stdout);\n                return stdout;\n            }\n\n        });\n    } </executeUnixTask>\n}\n"], ["abstractSolrFilterTemplate", "\nfunction _abstract_solr_filter_template(filters){\n\t\n\t<initializeFilterBuffer>\n\tvar allbuf = new Array(); </initializeFilterBuffer>\n\tfor( var filter_key in filters ){\n\n\t    var filter_val = filters[filter_key];\n\n\t    <processArrayFilters>\n\t    if( filter_val &&\n\t\tfilter_val != null &&\n\t\ttypeof filter_val == 'object' &&\n\t\tfilter_val.length ){\n\n\t\t    for( var i = 0; i < filter_val.length; i++ ){\n\t\t\tvar minibuffer = new Array();\n\t\t\tvar try_val = filter_val[i];\n\t\t\tif( typeof(try_val) != 'undefined' &&\n\t\t\ttry_val != '' ){\n\t\t\t    minibuffer.push('fq=');\n\t\t\t    minibuffer.push(filter_key);\n\t\t\t    minibuffer.push(':');\n\t\t\t    minibuffer.push('\"');\n\t\t\t    minibuffer.push(filter_val[i]);\n\t\t\t    minibuffer.push('\"');\n\t\t\t    allbuf.push(minibuffer.join(''));\n\t\t\t}\n\t\t    }\t\t    \n\t\t} </processArrayFilters>\n\t\t<processSingleFilters>\n\t\telse{\n\t\t    var minibuf = new Array();\n\t\t    if( typeof(filter_val) != 'undefined' &&\n\t\t\tfilter_val != '' ){\n\t\t\t    minibuf.push('fq=');\n\t\t\t    minibuf.push(filter_key);\n\t\t\t    minibuf.push(':');\n\t\t\t    minibuf.push('\"');\n\t\t\t    minibuf.push(filter_val);\n\t\t\t    minibuf.push('\"');\n\t\t\t    allbuf.push(minibuf.join(''));\n\t\t\t}\n\t\t} </processSingleFilters>\n\t}\n\t<returnFilterString>\n\treturn allbuf.join('&'); </returnFilterString>\n    }\n"], ["createDefaults", "\nfunction createDefaults () {\n\t<constructDefaultsObject>\n return {\n    postsPerPage: 5,\n    posts: './_posts/',\n    showDrafts: process.env.NODE_ENV !== 'production',\n    showFuture: process.env.NODE_ENV !== 'production',\n    metaFormat: 'json',\n    readMoreLink: readMoreLink,\n    readMoreTag: '<!--more-->',\n    routes: {\n      '/post/:post': 'post',\n      '/page/:page': 'page',\n      '/tag/:tag': 'tag',\n      '/category/:category': 'category'\n    }\n  }; </constructDefaultsObject>\n}\n"], ["agentOnRequest", "\nfunction Agent_onRequest(message) {\n  <getMessageName>\n  var mName = message.name </getMessageName>\n\n  <getCallbackFunction>\n  var cb = this._receiveCBs.get(mName) </getCallbackFunction>\n\n  <validateCallbackPresence>\n  if (!cb) {\n    message = {\n      type:  \"response\",\n      name:  mName,\n      from:  this.info.id,\n      id:    message.id,\n      error: \"agent does not handle messages named '\" + mName + \"'\"\n    }\n\n    this._session._sendMessage(message)\n    return\n  } </validateCallbackPresence>\n\n  var agent = this;\n\n  <executeCallback>\n  try {\n    cb(message.body, reply)\n\n  }\n  catch (e) {\n    reply(err, null)\n  } </executeCallback>\n\n  \n  <prepareReply>\n  var replied = false\n\n  function reply(err, body) {\n    if (replied) return\n    replied = true\n\n    <constructResponseMessage>\n    var rMessage = {\n      type:  \"response\",\n      name:  mName,\n      from:  agent.info.id,\n      id:    message.id,\n      body:  body\n    }\n\n    if (err) rMessage.error = err\n\n    agent._session._sendMessage(rMessage) </constructResponseMessage>\n  } </prepareReply>\n}\n"], ""]