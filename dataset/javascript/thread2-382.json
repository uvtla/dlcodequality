[["setValue", "\nfunction setValue(option, value){\n\n\t<noAliasPropagationBlock>\n\tif(noAliasPropagation){\n\t\t<optionNameDetermination>\n\t\tlet name = option.lastMatchedName;\n\t\t\n\t\t<firstOnlyNameSelection>\n\t\tif(\"first-only\" === noAliasPropagation)\n\t\t\tname = option.longNames[0] || option.shortNames[0];\n\t\t</firstOnlyNameSelection>\n\t\t\n\t\t<nameFormatting>\n\t\tname = formatName(name, noCamelCase);\n\t\t</nameFormatting>\n\t\t\n\t\t<resolveOrSetValue>\n\t\tif(result.options[name])\n\t\t\tresolveDuplicate(option, name, value);\n\t\t\n\t\telse result.options[name] = value;\n\t\t</resolveOrSetValue>\n\t</noAliasPropagationBlock>\n\t\n\t<elseBlock>\n\telse{\n\t\t<iterateNames>\n\t\tconst {names} = option;\n\t\t\n\t\tfor(let name of names){\n\t\t\t\n\t\t\t<nameFormattingAll>\n\t\t\tname = formatName(name, noCamelCase);\n\t\t\t</nameFormattingAll>\n\t\t\t\n\t\t\t<resolveOrSetValueAll>\n\t\t\tif(result.options[name])\n\t\t\t\tresolveDuplicate(option, name, value);\n\t\t\t\n\t\t\tresult.options[name] = value;\n\t\t\t</resolveOrSetValueAll>\n\t\t}\n\t\t</iterateNames>\n\t}\n\t</elseBlock>\n}\n"], ["verifyPath", "\nfunction verifyPath(packageJson, jsonPath, packagePropertyKey) {\n  <pathVerification>\n  const isAtRoot = packagePropertyKey === 'module';\n  const packageJsonPropPath = path.join(path.dirname(jsonPath), packageJson[packagePropertyKey]);\n  let isInvalid = false;\n  \n  <logErrorChecks>\n  if (!isAtRoot && packageJsonPropPath.indexOf('dist') === -1) {\n    isInvalid = true;\n    logError(`${jsonPath} ${packagePropertyKey} property does not reference a file under dist`);\n  } else if (isAtRoot && packageJsonPropPath.indexOf('dist') !== -1) {\n    isInvalid = true;\n    logError(`${jsonPath} ${packagePropertyKey} property should not reference a file under dist`);\n  }\n  if (!fs.existsSync(packageJsonPropPath)) {\n    isInvalid = true;\n    logError(`${jsonPath} ${packagePropertyKey} property points to nonexistent ${packageJsonPropPath}`);\n  }\n  </logErrorChecks>\n\n  <updateInvalidCount>\n  if (isInvalid) {\n    switch (packagePropertyKey) {\n    case 'main':\n      invalidMains++;\n      break;\n    case 'module':\n      invalidModules++;\n      break;\n    case 'types':\n      invalidTypes++;\n      break;\n    }\n  }\n  </updateInvalidCount>\n  </pathVerification>\n}\n"], ["anonymousFunction1", "\nfunction (method, path, parameters) {\n  <parameterAdjustment>\n    if (path && !parameters) {\n      parameters = path;\n      path = null;\n    }\n    </parameterAdjustment>\n\n    <pathNormalization>\n    path = normalizePath(path);\n    </pathNormalization>\n\n    <handlerAssignment>\n    if (!path) {\n      this.handlers[method] = parameters;\n      this.exportHandler(method, null, parameters);\n      return;\n    }\n    </handlerAssignment>\n\n    <addChildHandler>\n    var child = this.children[path];\n    if (!child) {\n      child = this.api(path);\n    }\n    child.addHandler(method, null, parameters);\n    </addChildHandler>\n  }\n"], ["configFromStringAndArray", "\nfunction configFromStringAndArray(config) {\n    <initialSetup>\n    var tempConfig,\n        bestMoment,\n\n        scoreToBeat,\n        i,\n        currentScore;\n    </initialSetup>\n\n    <defaultInvalidConfig>\n    if (config._f.length === 0) {\n        getParsingFlags(config).invalidFormat = true;\n        config._d = new Date(NaN);\n        return;\n    }\n    </defaultInvalidConfig>\n\n    <configIteration>\n    for (i = 0; i < config._f.length; i++) {\n        <tempConfigSetup>\n        currentScore = 0;\n        tempConfig = copyConfig({}, config);\n        if (config._useUTC != null) {\n            tempConfig._useUTC = config._useUTC;\n        }\n        tempConfig._f = config._f[i];\n        configFromStringAndFormat(tempConfig);\n        </tempConfigSetup>\n\n        <validityCheck>\n        if (!isValid(tempConfig)) {\n            continue;\n        }\n        </validityCheck>\n\n        <scoreCalculation>\n        currentScore += getParsingFlags(tempConfig).charsLeftOver;\n\n        currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;\n\n        getParsingFlags(tempConfig).score = currentScore;\n        </scoreCalculation>\n\n        <bestMomentSelection>\n        if (scoreToBeat == null || currentScore < scoreToBeat) {\n            scoreToBeat = currentScore;\n            bestMoment = tempConfig;\n        }\n        </bestMomentSelection>\n    }\n    </configIteration>\n\n    <configExtension>\n    extend(config, bestMoment || tempConfig);\n    </configExtension>\n}\n"], ["stringular", "\nfunction stringular(input) {\n  <argumentExtraction>\n  var args = Array.prototype.slice.call(arguments, 1);\n  </argumentExtraction>\n\n  <inputReplacement>\n  return input.replace(/{(\\d+)}/g, function (match, number) {\n    return isUndefined(args[number]) ? match : args[number];\n  });\n  </inputReplacement>\n}\n"], ["anonymousFunction2", "\nfunction(c, record, s) {\n  var rval = false;\n\n  <inflation>\n  try {\n    var bytes = c.inflate(record.fragment.getBytes());\n    record.fragment = forge.util.createBuffer(bytes);\n    record.length = bytes.length;\n    rval = true;\n  } catch(ex) {\n    // Error handling can be considered a separate responsibility if it involves more logic\n  }\n  </inflation>\n\n  <returnResult>\n  return rval;\n  </returnResult>\n}\n"], ["setNucleotide", "\nfunction setNucleotide() {\n    <nucleotideSetting>\n    var n = arguments[0];\n    __nucleotideTo4Bit[n] = 0;\n    for (var i = 1; i < arguments.length; i++) {\n      __nucleotideTo4Bit[n] |= __nucleotideTo4Bit[arguments[i]];\n    }\n    </nucleotideSetting>\n  }\n"], ["option", "\nfunction option() {\n    <regexBuilding>\n    var ret = this.seq(\n        this.stringf('['),\n        this.manyf(c_wsp),\n        alternation,\n        this.manyf(c_wsp),\n        this.stringf(']'));\n    return new ast.Repetition(new ast.Repeat(0,1), ret[3]);\n    </regexBuilding>\n}\n"], ["_getUserDetailsFromFacebook", "\nfunction _getUserDetailsFromFacebook() {\n    <fetchUserDetails>\n    return BB\n        .bind(this)\n        .then(function() {\n            return facebook.query()\n                .get('/me?access_token=' + this.params.access_token)\n                .request();\n        })\n        .then(function(res) {\n            this.socialUserInfo = res[1];\n        });\n    </fetchUserDetails>\n}\n"], ["VirtualRepeatDirective", "\nfunction VirtualRepeatDirective($parse) {\n  <directiveDefinition>\n  return {\n    <controllerSetting>\n    controller: VirtualRepeatController,\n    </controllerSetting>\n\n    priority: 1000,\n    require: ['mdVirtualRepeat', '^^mdVirtualRepeatContainer'],\n    restrict: 'A',\n    terminal: true,\n    transclude: 'element',\n\n    <compileFunction>\n    compile: function VirtualRepeatCompile($element, $attrs) {\n      <expressionParsing>\n      var expression = $attrs.mdVirtualRepeat;\n      var match = expression.match(/^\\s*([\\s\\S]+?)\\s+in\\s+([\\s\\S]+?)\\s*$/);\n      var repeatName = match[1];\n      var repeatListExpression = $parse(match[2]);\n      var extraName = $attrs.mdExtraName && $parse($attrs.mdExtraName);\n      </expressionParsing>\n\n      <linkFunction>\n      return function VirtualRepeatLink($scope, $element, $attrs, ctrl, $transclude) {\n        ctrl[0].link_(ctrl[1], $transclude, repeatName, repeatListExpression, extraName);\n      };\n      </linkFunction>\n    }\n    </compileFunction>\n  };\n  </directiveDefinition>\n}\n"], ""]