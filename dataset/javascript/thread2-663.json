[["_convertPlainTextToDocument", "\nfunction _convertPlainTextToDocument (tx, args) {\n  let lines = args.text.split(/\\s*\\n\\s*\\n/)\n  let pasteDoc = tx.getDocument().newInstance()\n  let defaultTextType = pasteDoc.getSchema().getDefaultTextType()\n  <createContainer>\n  let container = pasteDoc.create({\n    type: '@container',\n    id: SNIPPET_ID,\n    nodes: []\n  })\n  </createContainer>\n  let node\n  if (lines.length === 1) {\n    <createSingleLineNode>\n    node = pasteDoc.create({\n      id: TEXT_SNIPPET_ID,\n      type: defaultTextType,\n      content: lines[0]\n    })\n    container.append(node.id)\n    </createSingleLineNode>\n  } else {\n    for (let i = 0; i < lines.length; i++) {\n      <createMultipleLineNodes>\n      node = pasteDoc.create({\n        id: uuid(defaultTextType),\n        type: defaultTextType,\n        content: lines[i]\n      })\n      container.append(node.id)\n      </createMultipleLineNodes>\n    }\n  }\n  return pasteDoc\n}\n"], ["performRequest", "\nfunction performRequest(uri, transactionReq, options, callback) {\n  if (typeof options === 'function') { [options, callback] = [{}, options]; }\n  <setupRequest>\n  const logger = options.logger || defaultLogger;\n  const request = options.request || defaultRequest;\n\n  const httpOptions = Object.assign({}, options.http || {});\n  httpOptions.proxy = false;\n  httpOptions.followRedirect = false;\n  httpOptions.encoding = null;\n  httpOptions.method = transactionReq.method;\n  httpOptions.uri = uri;\n  </setupRequest>\n\n  try {\n    <prepareHttpRequest>\n    httpOptions.body = getBodyAsBuffer(transactionReq.body, transactionReq.bodyEncoding);\n    httpOptions.headers = normalizeContentLengthHeader(transactionReq.headers, httpOptions.body);\n    </prepareHttpRequest>\n\n    <logAndExecuteRequest>\n    const protocol = httpOptions.uri.split(':')[0].toUpperCase();\n    logger.debug(`Performing ${protocol} request to the server under test: `\n      + `${httpOptions.method} ${httpOptions.uri}`);\n\n    request(httpOptions, (error, response, responseBody) => {\n      logger.debug(`Handling ${protocol} response from the server under test`);\n      if (error) {\n        callback(error);\n      } else {\n        callback(null, createTransactionResponse(response, responseBody));\n      }\n    });\n    </logAndExecuteRequest>\n  } catch (error) {\n    <handleRequestError>\n    process.nextTick(() => callback(error));\n    </handleRequestError>\n  }\n}\n"], ["MongoErrorAdapter", "\nfunction(error) {\n  if (error instanceof Error) return error;\n\n  <createMongoError>\n  var msg = error.err || error.errmsg || error.errMessage || error;\n  var e = MongoError.create({ message: msg, driver: true });\n  </createMongoError>\n\n  <copyErrorProperties>\n  var keys = typeof error === 'object' ? Object.keys(error) : [];\n  for (var i = 0; i < keys.length; i++) {\n    try {\n      e[keys[i]] = error[keys[i]];\n    } catch (err) {\n      \n    }\n  }\n  </copyErrorProperties>\n\n  return e;\n}\n"], ["multMod_", "\nfunction multMod_(x, y, n) {\n  var i;\n  <initializeBuffer>\n  if (s0.length!=2*x.length)\n    s0=new Array(2*x.length);\n  copyInt_(s0, 0);\n  </initializeBuffer>\n  <performMultiplication>\n  for (i=0; i<y.length; i++)\n    if (y[i])\n      linCombShift_(s0, x, y[i], i);   \n  </performMultiplication>\n  <modulusOperation>\n  mod_(s0, n);\n  </modulusOperation>\n  <copyResult>\n  copy_(x, s0);\n  </copyResult>\n}\n"], ["isGitHooks", "\nfunction isGitHooks () {\n  return co(function * () {\n    <getPPID>\n    const ppid = yield getPPID()\n    </getPPID>\n\n    <debugPPID>\n    debug(`ppid: ${ppid}`)\n    </debugPPID>\n\n    <checkHuskyRun>\n    return isRunByHusky(ppid)\n    </checkHuskyRun>\n  }).catch( function (err) {\n    <handleError>\n    debug('error: %o', err)\n    </handleError>\n    return false\n  })\n}\n"], ["fileSystem", "\nfunction fileSystem(context, settings, next) {\n  var input = context.files\n\n  <checkForFiles>\n  if (input.length === 0) {\n    next()\n  } else {\n    </checkForFiles>\n    \n    <findFiles>\n    find(\n      input,\n      {\n        cwd: settings.cwd,\n        extensions: settings.extensions,\n        silentlyIgnore: settings.silentlyIgnore,\n        ignore: new Ignore({\n          cwd: settings.cwd,\n          detectIgnore: settings.detectIgnore,\n          ignoreName: settings.ignoreName,\n          ignorePath: settings.ignorePath\n        })\n      },\n      onfound\n    )\n    </findFiles>\n  }\n\n  function onfound(error, result) {\n    var output = result.files\n\n    <sortFiles>\n    output.sort(sortAlphabetically)\n    </sortFiles>\n\n    <markFiles>\n    output.forEach(markAsGiven)\n    </markFiles>\n\n    <updateContext>\n    context.files = output\n    </updateContext>\n\n    <checkForOutputSetting>\n    if (settings.out === null || settings.out === undefined) {\n      settings.out = result.oneFileMode\n    }\n    </checkForOutputSetting>\n\n    <callNext>\n    next(error)\n    </callNext>\n  }\n\n  function markAsGiven(file) {\n    file.data.unifiedEngineGiven = true\n  }\n\n  function sortAlphabetically(left, right) {\n    return left.path < right.path ? -1 : 1\n  }\n}\n"], ["getLocation", "\nfunction getLocation(url){\n  var m = url.toLowerCase().match(reURI);\n  <parseURL>\n  var proto = m[2], domain = m[3], port = m[4] || \"\";\n  if ((proto == \"http:\" && port == \":80\") || (proto == \"https:\" && port == \":443\")) {\n    port = \"\";\n  }\n  </parseURL>\n  <constructLocation>\n  return proto + \"//\" + domain + port;\n  </constructLocation>\n}\n"], ["manageSubscription", "\nfunction(client, subscriptions, backlog, channel, callback, done_callback) {\n  <attemptToAddToBacklog>\n  if ( addToBacklog(client, backlog, unsubscribeBrowser, [client, subscriptions, backlog, channel, callback, done_callback]) ) return;\n  </attemptToAddToBacklog>\n  <checkSubscriptionExistence>\n  if (subscriptions[channel]===undefined)\n    return;\n  </checkSubscriptionExistence>\n  <removeCallbackFromChannel>\n  subscriptions[channel].splice(subscriptions[channel].indexOf(callback), 1);\n  </removeCallbackFromChannel>\n  <deleteSubscriptionIfEmptyAndUnsubscribe>\n  if (subscriptions[channel].length===0) {\n    delete subscriptions[channel];\n    client.unsubscribe(channel, {onSuccess : function() {\n      <doneCallback>\n      if (done_callback!==undefined) done_callback();\n      </doneCallback>\n    }});\n  }\n  </deleteSubscriptionIfEmptyAndUnsubscribe>\n}\n"], ["parseXML", "\nfunction (str) {\n    var xmlDoc;\n    var DOMParser = Aria.$global.DOMParser;\n    <parseUsingDOMParser>\n    if (DOMParser) {\n        var parser = new DOMParser();\n        xmlDoc = parser.parseFromString(str, \"text/xml\");\n    } else { \n    </parseUsingDOMParser>\n    <parseUsingActiveX>\n        var ActiveXObject = Aria.$global.ActiveXObject;\n        xmlDoc = new ActiveXObject(\"Microsoft.XMLDOM\");\n        xmlDoc.async = \"false\";\n        xmlDoc.loadXML(str);\n    </parseUsingActiveX>\n    }\n\n    <checkNodesAndParse>\n    if (xmlDoc.hasChildNodes()) {\n        return this.__parseXmlNode(xmlDoc);\n    } else {\n        return null;\n    }\n    </checkNodesAndParse>\n}\n"], ["getModPackages", "\nfunction (mods) {\n            var i, l = mods.length,\n                tmpMods, mod, packageInfo, type,\n                tag, charset, packageBase,\n                packageName, group, modUrl;\n            <initializeGroupsAndNormals>\n            var groups = {\n                \n            };\n            var normals = {\n                \n            };\n            </initializeGroupsAndNormals>\n            <processMods>\n            for (i = 0; i < l; ++i) {\n                mod = mods[i];\n                type = mod.getType();\n                modUrl = mod.getUrl();\n                packageInfo = mod.getPackage();\n\n                if (packageInfo) {\n                    packageBase = packageInfo.getBase();\n                    packageName = packageInfo.name;\n                    charset = packageInfo.getCharset();\n                    tag = packageInfo.getTag();\n                    group = packageInfo.getGroup();\n                } else {\n                    packageBase = mod.name;\n                }\n\n                if (packageInfo && packageInfo.isCombine() && group) {\n                    var typeGroups = groups[type] || (groups[type] = {});\n                    group = group + '-' + charset;\n                    var typeGroup = typeGroups[group] || (typeGroups[group] = {});\n                    <combineMods>\n                    var find = 0;\n                    Utils.each(typeGroup, function (tmpMods, prefix) {\n                        if (Utils.isSameOriginAs(prefix, packageBase)) {\n                            var newPrefix = getCommonPathPrefix(prefix, packageBase);\n                            tmpMods.push(mod);\n                            if (tag && tag !== tmpMods.tag) {\n                                tmpMods.tag = getHash(tmpMods.tag + tag);\n                            }\n                            delete typeGroup[prefix];\n                            typeGroup[newPrefix] = tmpMods;\n                            find = 1;\n                        }\n                    });\n                    if (!find) {\n                        tmpMods = typeGroup[packageBase] = [mod];\n                        tmpMods.charset = charset;\n                        tmpMods.tag = tag || '';\n                    }\n                    </combineMods>\n                } else {\n                    <handleNonCombinedMods>\n                    var normalTypes = normals[type] || (normals[type] = {});\n                    if (!(tmpMods = normalTypes[packageBase])) {\n                        tmpMods = normalTypes[packageBase] = [];\n                        tmpMods.charset = charset;\n                        tmpMods.tag = tag || '';\n                    } else {\n                        if (tag && tag !== tmpMods.tag) {\n                            tmpMods.tag = getHash(tmpMods.tag + tag);\n                        }\n                    }\n                    tmpMods.push(mod);\n                    </handleNonCombinedMods>\n                }\n            }\n            </processMods>\n\n            <returnCompiledGroups>\n            return {\n                groups: groups,\n                normals: normals\n            };\n            </returnCompiledGroups>\n}\n"], "```"]