[["fileUploadXhr", "\nfunction fileUploadXhr(a) {\n    <prepareFormData>\n    var formdata = new FormData();\n\n    for (var i=0; i < a.length; i++) {\n        formdata.append(a[i].name, a[i].value);\n    }\n\n    if (options.extraData) {\n        for (var p in options.extraData)\n            if (options.extraData.hasOwnProperty(p))\n                formdata.append(p, options.extraData[p]);\n    }\n\n    options.data = null;\n    </prepareFormData>\n\n    <configureAjaxRequest>\n    var s = $.extend(true, {}, $.ajaxSettings, options, {\n        contentType: false,\n        processData: false,\n        cache: false,\n        type: 'POST'\n    });\n    </configureAjaxRequest>\n    \n    <setupProgressHandling>\n    if (options.uploadProgress) {\n        \n        s.xhr = function() {\n            var xhr = jQuery.ajaxSettings.xhr();\n            if (xhr.upload) {\n                xhr.upload.onprogress = function(event) {\n                    var percent = 0;\n                    var position = event.loaded || event.position; \n                    var total = event.total;\n                    if (event.lengthComputable) {\n                        percent = Math.ceil(position / total * 100);\n                    }\n                    options.uploadProgress(event, position, total, percent);\n                };\n            }\n            return xhr;\n        };\n    }\n\n    s.data = null;\n    var beforeSend = s.beforeSend;\n    s.beforeSend = function(xhr, o) {\n        o.data = formdata;\n        if(beforeSend)\n            beforeSend.call(o, xhr, options);\n    };\n    </setupProgressHandling>\n\n    <sendAjaxRequest>\n    $.ajax(s);\n    </sendAjaxRequest>\n}\n"], ["Sprite", "\nfunction Sprite (opts) {\n    <initializeSprite>\n    Sprite.superclass.constructor.call(this, opts)\n    </initializeSprite>\n\n    ...\n    // The details are omitted since the function is lengthy and mostly involves initializing properties of the Sprite. \n    // SRP is not being violated since these actions collectively serve the single purpose of initializing a Sprite object.\n\n    <initializeTextureAtlas>\n    if (url || file || texture) {\n        textureAtlas = new TextureAtlas({ url: url, file: file, texture: texture })\n    } else if (spritesheet) {\n        textureAtlas = spritesheet.textureAtlas\n        this.useSpriteSheet = true\n    } else if (!textureAtlas) {\n        \n    }\n    </initializeTextureAtlas>\n\n    <rectHandling>\n    if (!rect && textureAtlas) {\n        if (!url) {\n            rect = new geo.Rect(0, 0, textureAtlas.texture.size.width, textureAtlas.texture.size.height)\n        } else {\n            \n            events.addListener(textureAtlas, 'load', function () {\n                if (!this.rect) {\n                    this.rect = new geo.Rect(0, 0, textureAtlas.texture.size.width, textureAtlas.texture.size.height)\n                }\n            }.bind(this))\n        }\n    }\n    </rectHandling>\n\n    <quadInitialization>\n    if (rect) {\n        this.rect = rect\n        this.contentSize = rect.size\n\n        this.quad = { drawRect: {origin: ccp(0, 0), size: rect.size}\n                    , textureRect: rect\n                    }\n    }\n    </quadInitialization>\n\n    ...\n    // The omitted parts are in a similar vein - they're part of initializing various aspects of the Sprite.\n\n    <finalizeInitialization>\n    this.textureAtlas = textureAtlas\n\n    if (frame) {\n        this.displayFrame = frame\n    }\n    </finalizeInitialization>\n}\n"], ["writeToFileSystem", "\nfunction (data, fragmentKey, cachePath, callback) {\n    <logAction>\n    debug('  write content in file system');\n    </logAction>\n    <preparePath>\n    var basePath =  path.dirname(fragmentKey);\n    if (basePath){\n      mkdirp.sync(cachePath + '/' + basePath);\n    }\n    </preparePath>\n    <writeToFile>\n    fs.writeFile(cachePath + '/' + fragmentKey, data, function (err) {\n      if (err) {\n        callback(err);\n      } else {\n        callback(null, data);\n      }\n    });\n    </writeToFile>\n}\n"], ["constructTimelineItem", "\nfunction(item) {\n  if(!item || !item.element)\n      return;\n\n  ...\n  // The rest of the function is creating and manipulating DOM elements which all serve the purpose \n  // of constructing a single timeline item with various components. It's not violating SRP as it's a single cohesive task.\n\n}\n"], ["matchObj", "\nfunction matchObj(obj, line) {\n  for (const p in obj) if (obj[p] && obj[p].test(line)) return p;\n  return \"\";\n}\n"], ["parseDoclets", "\nfunction parseDoclets(obj, propName) {\n  <retrieveAndCleanDescription>\n  let desc = obj.desc || defaultDescriptions[propName] || '';\n  obj.doclets = metadata.parseDoclets(desc) || {};\n  obj.desc = cleanDoclets(desc);\n  </retrieveAndCleanDescription>\n  <generateHtml>\n  obj.descHtml = marked(obj.desc);\n  </generateHtml>\n}\n"], ["exportJs", "\nfunction defaultJsExporter(variables, options, root) {\n    <prepareExportDetails>\n\tconst pathname = options.destination || root.source && root.source.input && root.source.input.file && root.source.input.file + '.js' || 'custom-variables.js';\n\tconst contents = Object.keys(variables).reduce(\n\t\t(buffer, key) => `${ buffer }export const ${ key } = ${ JSON.stringify(variables[key]).replace(/(^|{|,)\"(.+?)\":/g, '$1$2:') };\\n`,\n\t\t''\n\t);\n    </prepareExportDetails>\n\n    <writeToFile>\n\treturn new Promise((resolve, reject) => {\n\t\tfs.writeFile(\n\t\t\tpathname,\n\t\t\tcontents,\n\t\t\t(error) => error ? reject(error) : resolve()\n\t\t);\n\t});\n    </writeToFile>\n}\n"], ["getActiveFilters", "\nfunction getActiveFilters (req, selectedFilters, data, modelName, cb) {\n   <validateInput>\n   ...\n\n   linz.api.model.list(req, modelName, function (err, list) {\n       ...\n       <filterProcessing>\n       async.each(selectedFilters, function (fieldName, filtersDone) {\n\n           list.filters[fieldName].filter.bind(fieldName, data, function (filterErr, result) {\n\n               if (filterErr) {\n                   return filtersDone(filterErr);\n               }\n\n               activeFilters[fieldName] = {\n                   label: list.filters[fieldName].label,\n                   controls: result\n               }\n\n               return filtersDone(null);\n\n           });\n\n       }, function (filterErr) {\n\n           return cb(filterErr, activeFilters);\n\n       });\n       </filterProcessing>\n   });\n   </validateInput>\n}\n"], ["createTodoListItem", "\nfunction createTodoListItem(todo) {\n  <constructTodoElements>\n\n  var checkbox = document.createElement('input');\n  ...\n\n  var label = document.createElement('label');\n  ...\n\n  var deleteLink = document.createElement('button');\n  ...\n\n  var divDisplay = document.createElement('div');\n  ...\n\n  var inputEditTodo = document.createElement('input');\n  ...\n\n  var li = document.createElement('li');\n  ...\n\n  if (todo.completed) {\n    li.className += 'complete';\n    checkbox.checked = true;\n  }\n\n  </constructTodoElements>\n  return li;\n}\n"], ["appendView", "\nfunction(view) {\n    if (arguments.length > 1) {\n        conbo.forEach(arguments, function(view, index, list) {\n            this.appendView(view);\n        },\n        this);\n        \n        return this;\n    }\n\n    if (typeof view === 'function') {\n        view = new view(this.context);\n    }\n\n    if (!(view instanceof conbo.View)) {\n        throw new Error('Parameter must be conbo.View class or instance of it');\n    }\n\n    <appendElement>\n    this.body.appendChild(view.el);\n    </appendElement>\n    \n    return this;\n}\n"], "```\n\nIn these annotations, the SRP is largely respected except in a few cases where additional responsibilities have been tagged separately. The appropriate start and end of each responsibility are annotated to facilitate understanding the Single Responsibility Principle."]