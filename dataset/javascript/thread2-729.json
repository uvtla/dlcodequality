[["postRequestAndProcessResponse", "\nfunction(data) {\n  return this.request({\n    url: this._buildUri(this.uri),\n    method: corbel.request.method.POST,\n    data: data\n  }).\n  then(function(res) {\n    return corbel.Services.getLocationId(res);\n  });\n}\n"], ["disconnectEvents", "\nfunction _disconnect(context) {\n  forEach(this.__events__, (bindings, event) => {\n    for (let i = bindings.length - 1; i >= 0; i--) {\n      if (bindings[i] && bindings[i].context === context) {\n        _off.call(this, event, bindings[i].method, context)\n      }\n    }\n  })\n  return this\n}\n"], ["findInDatabase", "\nfunction _find(collection, query, opts) {\n  if (Tyr.logging.trace) {\n    Tyr.trace({ e: 'db', c: collection.id, m: 'find', q: query });\n  }\n  const cursor = collection.db.find(query, opts);\n  return cursor;\n}\n"], ["regularizeWeights", "\nfunction regularizeL1(weights, gradientCount, stepSize) {\n  const [gradient, count] = gradientCount;\n  for (let i = 0; i < gradient.length; i++) {\n    let grad = (gradient[i] || 0) / count;\n    weights[i] = weights[i] || 0;\n    weights[i] -= stepSize * grad + (weights[i] > 0 ? 1 : -1);\n  }\n}\n"], ["getRotationVectors", "\nfunction() {\n  return[\n    vec3.fromValues(this._rotation[0], this._rotation[4], this._rotation[8]),\n    vec3.fromValues(this._rotation[1], this._rotation[5], this._rotation[9]),\n    vec3.fromValues(this._rotation[2], this._rotation[6], this._rotation[10])\n  ];\n}\n"], ["resolvePath", "\nfunction resolveSassPath(sassPath, loadPaths, extensions) {\n  var re = new RegExp('(\\.('+extensions.join('|')+'))$', 'i');\n  var sassPathName = sassPath.replace(re, '');\n  \n  var i, j, length = loadPaths.length, scssPath, partialPath;\n  for (i = 0; i < length; i++) {\n    for (j = 0; j < extensions.length; j++) {\n      scssPath = path.normalize(loadPaths[i] + '/' + sassPathName + '.' + extensions[j]);\n      try {\n        if (fs.lstatSync(scssPath).isFile()) {\n          return scssPath;\n        }\n      } catch (e) {}\n    }\n    // Code repeats here for partial paths, annotations will avoid repetition.\n  }\n  return false;\n}\n"], ["configureFilterNode", "\nfunction(state, options) {\n  var node = this;\n  _(FilterNode.optionsSchema).each(function(optionSchema, key) {\n      // This is handling multiple responsibilities such as parsing options, and setting default values.\n  });\n}\n"], ["validateAndInitializeRequest", "\nfunction Request(url, options) {\n  if (!url) {\n    throw new Error('URL must in mandatory to initialize Request object');\n  }\n  if (!options.method) {\n    throw new Error('Cannot execute HTTP request without specifying method');\n  }\n  // Initialization of request object properties\n  this.url = url;\n  this.method = options.method;\n  this.body = options.body || {};\n  this.params = options.params || {};\n  // More initializations\n}\n"], ["createMultipleClassProxy", "\nfunction xmultipleClasses(parents) {\n  function ConstructibleProxyTarget() {}\n  ConstructibleProxyTarget.prototype = xmultipleObjects(parents.map(parent => parent.prototype));\n  const ClassForwardingProxy = xmultipleObjects(parents, ConstructibleProxyTarget);\n  return ClassForwardingProxy;\n}\n"], ["removeEventAndObject", "\nfunction (event) {\n  var object = event.target;\n  object.traverse(function (child) {\n    child.removeEventListener('remove', onObjectRemoved);\n    removeObject(child);\n  });\n}\n"], "```\nHandles removal of events and objects, which in the context of event-driven programming, is considered a single cohesive responsibility related to event cleanup."]