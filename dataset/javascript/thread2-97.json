[["argsToArray", "\nfunction argsToArray(args) {\n    if (_.isArray(args[0]))\n      return args[0];\n    else if (typeof args[0] == 'string' && args[0].indexOf(',') > -1)\n      return _.invoke(args[0].split(','), 'trim');\n    else\n      return _.toArray(args);\n}\n"], ["_globals", "\nfunction _globals (options) {\n  options.hash.scope = 'global'\n  return _identifiers(options).filter(function (identifier) {\n    if (identifier.kind === 'external') {\n      return identifier.description && identifier.description.length > 0\n    } else {\n      return true\n    }\n  })\n}\n"], ["anonymous", "\nfunction () {\n        var range = this._model.get('range');\n\n        <normalizeRange>\n        var rg = range;\n\n        if (zrUtil.isArray(rg) && rg.length === 1) {\n            rg = rg[0];\n        }\n\n        if (/^\\d{4}$/.test(rg)) {\n            range = [rg + '-01-01', rg + '-12-31'];\n        }\n\n        if (/^\\d{4}[\\/|-]\\d{1,2}$/.test(rg)) {\n\n            var start = this.getDateInfo(rg);\n            var firstDay = start.date;\n            firstDay.setMonth(firstDay.getMonth() + 1);\n\n            var end = this.getNextNDay(firstDay, -1);\n            range = [start.formatedDate, end.formatedDate];\n        }\n\n        if (/^\\d{4}[\\/|-]\\d{1,2}[\\/|-]\\d{1,2}$/.test(rg)) {\n            range = [rg, rg];\n        }\n        </normalizeRange>\n\n        <validateAndCorrectOrder>\n        var tmp = this._getRangeInfo(range);\n\n        if (tmp.start.time > tmp.end.time) {\n            range.reverse();\n        }\n        </validateAndCorrectOrder>\n\n        return range;\n    }\n"], ["Cli", "\nfunction Cli(argv) {\n  <loadModules>\n  var Cucumber = require('cucumber');\n  var Command = require('commander').Command;\n  var path = require('path');\n  </loadModules>\n\n  <collectFunction>\n  function collect(val, memo) {\n    memo.push(val);\n    return memo;\n  }\n  </collectFunction>\n\n  <getProgramFunction>\n  function getProgram() {\n    <defineProgramParameters>\n    var program = new Command(path.basename(argv[1]));\n    // ... options setup ...\n    </defineProgramParameters>\n  \n    <helpEvent>\n    program.on('--help', function () {\n      console.log('  For more details please visit https://...');\n    });\n    </helpEvent>\n\n    return program;\n  }\n  </getProgramFunction>\n\n  <getConfigurationFunction>\n  function getConfiguration() {\n    var program = getProgram();\n    program.parse(argv);\n    var profileArgs = Cucumber.Cli.ProfilesLoader.getArgs(program.profile);\n    <mergeProfileArgs>\n    if (profileArgs.length > 0) {\n      var fullArgs = argv.slice(0, 2).concat(profileArgs).concat(argv.slice(2));\n      program = getProgram();\n      program.parse(fullArgs);\n    }\n    </mergeProfileArgs>\n    var configuration = Cucumber.Cli.Configuration(program.opts(), program.args);\n    return configuration;\n  }\n  </getConfigurationFunction>\n\n  <cliExecution>\n  var self = {\n    run: function run(callback) {\n      var configuration = getConfiguration();\n      var runtime = Cucumber.Runtime(configuration);\n      var formatters = [createIpcFormatter()].concat(configuration.getFormatters());\n      formatters.forEach(function (formatter) {\n        runtime.attachListener(formatter);\n      });\n      try {\n        runtime.start(callback);\n      } catch (e) {\n        console.log(e.stack || e)\n        callback(false)\n      }\n    }\n  };\n  </cliExecution>\n\n  return self;\n}\n"], ["addInteraction", "\nfunction addInteraction() {\n  let value = typeSelect.value;\n\n  <validateInteractionType>\n  if (value !== 'None') {\n    let geometryFunction;\n    if (value === 'Square') {\n      value = 'Circle';\n      geometryFunction = createRegularPolygon(4);\n    } else if (value === 'Box') {\n      value = 'Circle';\n      geometryFunction = createBox();\n    } else if (value === 'Star') {\n      value = 'Circle';\n      geometryFunction = function(coordinates, geometry) {\n        <generateStarGeometry>\n        const center = coordinates[0];\n        const last = coordinates[1];\n        const dx = center[0] - last[0];\n        const dy = center[1] - last[1];\n        const radius = Math.sqrt(dx * dx + dy * dy);\n        const rotation = Math.atan2(dy, dx);\n        const newCoordinates = [];\n        const numPoints = 12;\n        for (let i = 0; i < numPoints; ++i) {\n          const angle = rotation + i * 2 * Math.PI / numPoints;\n          const fraction = i % 2 === 0 ? 1 : 0.5;\n          const offsetX = radius * fraction * Math.cos(angle);\n          const offsetY = radius * fraction * Math.sin(angle);\n          newCoordinates.push([center[0] + offsetX, center[1] + offsetY]);\n        }\n        newCoordinates.push(newCoordinates[0].slice());\n        if (!geometry) {\n          geometry = new Polygon([newCoordinates]);\n        } else {\n          geometry.setCoordinates([newCoordinates]);\n        }\n        </generateStarGeometry>\n        return geometry;\n      };\n    }\n    </validateInteractionType>\n\n    <addDrawInteraction>\n    draw = new Draw({\n      source: source,\n      type: value,\n      geometryFunction: geometryFunction\n    });\n    map.addInteraction(draw);\n    </addDrawInteraction>\n  }\n}\n"], ["EventStatics", "\nfunction EventStatics (msg){\n        <createJob>\n        var job =\n                { dispatcher: self\n                , evtcount: self.evtcount ++\n                , msg : msg\n                };\n        </createJob>\n\n        <enqueueJob>\n        QJhandle.push (job, QJcallback);\n        </enqueueJob>\n}\n"], ["updateListData", "\nfunction(data) {\n        this.$leftListBody.find(':checkbox').bizCheckbox('destroy');\n        this.$rightListBody.find(':checkbox').bizCheckbox('destroy');\n        this.$leftListBody.empty();\n        this.$rightListBody.empty();\n        this.$main.find('.biz-transfer-list-header :checkbox').bizCheckbox('uncheck');\n        \n        <handleNoContent>\n        if (data.length === 0) {\n            this.$leftListBody.html('<li class=\"biz-transfer-list-content-item\">' + this.options.noContent + '</li>');\n        }\n        </handleNoContent>\n\n        <addItemsToList>\n        this.addItems(data);\n        </addItemsToList>\n}\n"], ["getOwnerAndRepo", "\nfunction getOwnerAndRepo(url) {\n  <parseGitUrl>\n  let match = url.match(/^git@github\\.com:(.*)\\.git$/);\n  match = match || url.match(/^git\\+https:\\/\\/github\\.com\\/(.*)\\.git$/);\n  </parseGitUrl>\n\n  <extractRepositoryDetails>\n  const gitUrlBase = match && match[1];\n  return (gitUrlBase || url).split('/');\n  </extractRepositoryDetails>\n}\n"], ["initTbodyElOverride", "\nfunction(elTable) {\n    SDT.superclass._initTbodyEl.call(this, elTable);\n\n    <adjustTableMargin>\n    elTable.style.marginTop = (this._elTbody.offsetTop > 0) ?\n            \"-\"+this._elTbody.offsetTop+\"px\" : 0;\n    </adjustTableMargin>\n}\n"], ["fitContentToBounds", "\nfunction(bounds, anchor, immediately) {\n        <resolveAnchorPoint>\n        anchor = anchor || $.Placement.CENTER;\n        var anchorProperties = $.Placement.properties[anchor];\n        </resolveAnchorPoint>\n\n        <setupAspectRatio>\n        var aspectRatio = this.contentAspectX;\n        var xOffset = 0;\n        var yOffset = 0;\n        var displayedWidthRatio = 1;\n        var displayedHeightRatio = 1;\n        </setupAspectRatio>\n\n        <handleClipping>\n        if (this._clip) {\n            aspectRatio = this._clip.getAspectRatio();\n            displayedWidthRatio = this._clip.width / this.source.dimensions.x;\n            displayedHeightRatio = this._clip.height / this.source.dimensions.y;\n            // Offset calculations...\n        }\n        </handleClipping>\n\n        <performLayout>\n        if (bounds.getAspectRatio() > aspectRatio) {\n            // Layout for height-based scaling...\n        } else {\n            // Layout for width-based scaling...\n        }\n        </performLayout>\n}\n"], ""]