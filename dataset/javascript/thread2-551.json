[["serviceLoader", "\nfunction ServiceLoader(type, options){\n  <serviceLoaderSetup>\n  var loadCallbacks = [];\n  this.name = type;\n  this.cid = $.uniqueId('ServiceLoader');\n  this.isHydrated = false;\n  this.isComponent = true;\n  this.isModel = true;\n  this.isLazyComponent = true;\n  this.attributes = {};\n  this.consumers = [];\n  this.set = this.on = this.off = function(){\n    return 1;\n  };\n  this.get = function(path){\n    return (path) ? undefined : this;\n  };\n  </serviceLoaderSetup>\n\n  <hydrateService>\n  this.hydrate = function(service){\n    SERVICES[this.name] = service;\n    this._component = service;\n    _.each(this.consumers, function(consumer){\n      var component = consumer.component,\n          key = consumer.key;\n      if(component.attributes && component.set){ component.set(key, service); }\n      if(component.services){ component.services[key] = service; }\n      if(component.defaults){ component.defaults[key] = service; }\n    });\n    service.consumers = this.consumers;\n    \n    _.each(loadCallbacks, (cb)=>{ cb(service); });\n    delete this.loadCallbacks;\n  };\n  </hydrateService>\n\n  <serviceLoaderOnLoad>\n  this.onLoad = function(cb){\n    loadCallbacks.push(cb);\n  };\n  </serviceLoaderOnLoad>\n}\n"], ["cleanup", "\nfunction cleanup() {\n  <cleanupListeners>\n  res.removeListener('finish', makePoint);\n  res.removeListener('error', cleanup);\n  res.removeListener('close', cleanup);\n  </cleanupListeners>\n}\n"], ["parse", "\nfunction parse (argv, opts, target) {\n  <parseSetup>\n  if ('string' === typeof argv) argv = argv.split(rSplit).filter(ignore); // Split and filter the argv if it's a string.\n  if (!opts) opts = {}; // Ensure there is an opts object to work with.\n  opts[don] = true; // Mark the beginning of parsing.\n  </parseSetup>\n\n  <parseArrayFirstPass>\n  var parsed = parseArray(argv, opts); // First pass parsing of argv.\n  </parseArrayFirstPass>\n\n  <parseArraySecondPass>\n  opts[don] = false; // Mark the end of the first pass.\n  var through = parsed[don].length ? parseArray(parsed[don], opts) : null; // Second pass parsing if needed.\n  </parseArraySecondPass>\n\n  <buildTargetObject>\n  if (!target) target = {}; // Ensure there is a target object to build upon.\n  target.options = parsed; // Assign parsed options to target.\n  target.commands = parsed[din]; // Assign parsed commands to target.\n  target.input = argv; // Keep the original input for reference.\n  if (through) { // If there were 'through' items parsed in the second pass...\n    target.through = {\n      options: through,\n      commands: through[din]\n    };\n    delete through[din]; // Cleanup intermediate data.\n  }\n  delete parsed[din];\n  delete parsed[don];\n  </buildTargetObject>\n\n  return target;\n\n  <ignoreHelper>\n  function ignore (s) { // Helper function to ignore empty string values.\n    return s && '' !== s;\n  }\n  </ignoreHelper>\n}\n"], ["field", "\nfunction Field (field, name, parent) {\n  <fieldInitialization>\n  if (!(this instanceof Field)) return new Field(field, name, parent);\n\n  debug('field <%s> being built from <%s>', name, field); // Debug logging for field initialization.\n  Entry.call(this, field, name, parent); // Initialize the Entry that Field extends from.\n  this._context = parent._context;\n  this._this = parent._this;\n  </fieldInitialization>\n\n  <fieldCompilation>\n  if (typeof this._content !== 'string') { // If the content is not a string, use as is.\n    this._compiled = function () {\n      return this._content;\n    }.bind(this);\n  } else { // If the content is a string, use a template function for compilation.\n    this._compiled = _.template(this._content);\n  }\n  </fieldCompilation>\n}\n"], ["_main", "\nfunction _main() {\n  <getPathDifferences>\n  const {guides: acGuidePaths, images: acGuideImagesPaths, examples: acExamplePaths} = getPathsFromAioContent(); // Get content paths from AIO.\n  const {guides: coGuidePaths, images: coGuideImagesPaths, examples: coExamplePaths} = getPathsFromCodeowners(); // Get content paths from codeowners.\n\n  const guidesDiff = arrayDiff(acGuidePaths, coGuidePaths); // Compute differences between guide paths.\n  const imagesDiff = arrayDiff(acGuideImagesPaths, coGuideImagesPaths); // Compute differences between image paths.\n  const examplesDiff = arrayDiff(acExamplePaths, coExamplePaths); // Compute differences between example paths.\n  const hasDiff = !!(guidesDiff.diffCount || imagesDiff.diffCount || examplesDiff.diffCount); // Determine if there are any differences.\n  </getPathDifferences>\n\n  <reportAndExit>\n  if (hasDiff) {\n    const expectedGuidesSrc = path.relative(PROJECT_ROOT_DIR, AIO_GUIDES_DIR); // Get the expected source paths for guides.\n    const expectedImagesSrc = path.relative(PROJECT_ROOT_DIR, AIO_GUIDE_IMAGES_DIR); // Get the expected source paths for images.\n    const expectedExamplesSrc = path.relative(PROJECT_ROOT_DIR, AIO_GUIDE_EXAMPLES_DIR); // Get the expected source paths for examples.\n    const actualSrc = path.relative(PROJECT_ROOT_DIR, CODEOWNERS_PATH); // Get the actual source path.\n\n    reportDiff(guidesDiff, expectedGuidesSrc, actualSrc); // Report differences for guides.\n    reportDiff(imagesDiff, expectedImagesSrc, actualSrc); // Report differences for images.\n    reportDiff(examplesDiff, expectedExamplesSrc, actualSrc); // Report differences for examples.\n  }\n\n  process.exit(hasDiff ? 1 : 0); // Exit the process based on the presence of differences.\n  </reportAndExit>\n}\n"], ["groupByProperty", "\nfunction groupByProperty(objects) {\n  const groupedObj = objects.reduce((accumulator, obj) => {\n      const prop = Object.keys(obj)[0]; // Determine the property to group by.\n\n      accumulator[prop] = accumulator[prop] ? accumulator[prop].concat(obj) : [obj]; // Group objects by that property.\n      return accumulator;\n  }, {});\n\n  return Object.keys(groupedObj).map(prop => groupedObj[prop]); // Transform the grouped object into the desired array format.\n}\n"], ["parseBrtCellBool", "\nfunction parse_BrtCellBool(data) {\n  var cell = parse_XLSBCell(data); // Parse cell information from data.\n  var fBool = data.read_shift(1); // Read a boolean value from data.\n  return [cell, fBool, 'b']; // Return the parsed data along with type identification.\n}\n"], ["encodeSample", "\nfunction encodeSample(sample) {\n  \n  <compandingSetup>\n  let compandedValue; \n  sample = (sample ==-32768) ? -32767 : sample; // Prevent wrap-around for the lowest value.\n  \n  let sign = ((~sample) >> 8) & 0x80; // Extract the sign bit.\n  if (!sign) {\n    sample = sample * -1; // Flip the sample if it's positive.\n  }\n  if (sample > 32635) {\n    sample = 32635; // Clamp the sample to a maximum value.\n  }\n  </compandingSetup>\n\n  <compandingCalculation>\n  if (sample >= 256)  { // If the sample requires companding...\n    \n    let exponent = LOG_TABLE[(sample >> 8) & 0x7F]; // Look up the exponent from the logarithm table.\n    \n    let mantissa = (sample >> (exponent + 3) ) & 0x0F; // Calculate the mantissa.\n    compandedValue = ((exponent << 4) | mantissa); // Combine exponent and mantissa for the companded value.\n  } else {\n    compandedValue = sample >> 4; // Use a simpler calculation for smaller samples.\n  } \n  </compandingCalculation>\n  \n  return compandedValue ^ (sign ^ 0x55); // Return the final encoded value after XOR with the sign bit.\n}\n"], ["destroy", "\nfunction destroy() {\n  <updateParallaxesList>\n  Parallax._parallaxes.splice(Parallax._parallaxes.indexOf(this), 1); // Remove this Parallax instance from the global list.\n  </updateParallaxesList>\n  \n  <resetStyles>\n  this.$img[0].style.transform = ''; // Reset any transformations applied to the image element.\n  </resetStyles>\n  \n  <removeEventHandlers>\n  this._removeEventHandlers(); // Remove event handlers associated with this Parallax instance.\n  </removeEventHandlers>\n\n  <clearPluginInstance>\n  this.$el[0].M_Parallax = undefined; // Clear the reference to this Parallax instance from the element.\n  </clearPluginInstance>\n}\n"], ["get", "\nfunction get(connections, params, cb) {\n  <validateParams>\n  var failed = validate(params).has(CONSTANTS.DATA_TARGET_ID); // Validate that the required data target ID is present in params.\n\n  if (failed) {\n    return cb(buildErrorResponse({error: new Error(\"An ID Parameter Is Required To Get A Data Target\"), code: ERROR_CODES.FH_FORMS_INVALID_PARAMETERS})); // Return an error if validation fails.\n  }\n\n  if (!misc.checkId(params._id)) {\n    return cb(buildErrorResponse({error: new Error(\"Invalid ID Paramter\"), code: ERROR_CODES.FH_FORMS_INVALID_PARAMETERS})); // Check and return an error if _id is invalid.\n  }\n  </validateParams>\n\n  <findAndCheckForms>\n  async.waterfall([ // Begin an asynchronous waterfall to find data targets and check forms.\n\n    <findDataTargets>\n    function findDataTargets(cb) {\n      var query = {};\n      \n      query[CONSTANTS.DATA_TARGET_ID] = params._id; // Construct the query to find the data target.\n\n      lookUpDataTargets(connections, {\n        query: query,\n        lean: true\n      }, function(err, dataTargets) {\n        if (err) { // If there's an error during lookup...\n          return cb(buildErrorResponse({\n            error: err,\n            userDetail: \"Unexpected Error When Searching For A Data Target\",\n            code: ERROR_CODES.FH_FORMS_UNEXPECTED_ERROR\n          }));\n        }\n\n        if (dataTargets.length !== 1) { // If the expected data target was not found or too many were found...\n          return cb(buildErrorResponse({\n            error: new Error(\"Data Target Not Found\"),\n            systemDetail: \"Requested ID: \"  + params[CONSTANTS.DATA_TARGET_ID],\n            code: ERROR_CODES.FH_FORMS_NOT_FOUND\n          }));\n        }\n\n        return cb(undefined, dataTargets[0]); // Pass the found data target to the next function in the waterfall.\n      });\n    },\n    </findDataTargets>\n\n    <checkFormsUsingDataTarget>\n    function checkForms(dataTargetJSON, cb) {\n      checkFormsUsingDataTarget(connections, dataTargetJSON, cb); // Check which forms are using the found data target.\n    }\n    </checkFormsUsingDataTarget>\n\n  ], cb);\n  </findAndCheckForms>\n}\n"], ""]