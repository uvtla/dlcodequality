[["execHttp", "\nfunction execHttp(options, callback) {\n\n  <configureProxy>\n  if (proxyList) {\n    options.proxy = proxyList.getProxy().getUrl();\n  }\n  </configureProxy>\n\n  <logHttpRequest>\n  log.debug({\"url\" : options.url, \"step\" : \"queue-requester.execHttp\", \"message\" : \"Execute the request\"});\n  </logHttpRequest>\n\n  <performHttpRequest>\n  request.get(options, function(error, result) {\n    log.debug({\"url\" : options.url, \"step\" : \"queue-requester.execHttp\", \"message\" : \"Execute the request done\"});\n\n    \n    \n    <handleHttpResponse>\n    if (result.statusCode && result.statusCode >= 400 && result.statusCode <= 499 && result.retry400) {\n      error = new Error(\"40* Error\");\n      error.code = result.statusCode;\n    }\n    </handleHttpResponse>\n\n    <processHttpError>\n    if (error) {\n      onRequestError(error, result, function(error){\n        process.nextTick(function() {callback(error);});\n      });\n    }\n    </processHttpError>\n    <processSuccessResponse>\n    else {\n      onCrawl(null, result, function(error){\n        process.nextTick(function() {callback(error);});\n      });\n    }\n    </processSuccessResponse>\n\n  });\n  </performHttpRequest>\n\n\n}\n"], ["resolveBase", "\nfunction resolveBase(app) {\n  <defineResolutionPaths>\n  const paths = [\n    { name: 'base', path: path.resolve(cwd, 'node_modules/base') },\n    { name: 'base-app', path: path.resolve(cwd, 'node_modules/base-app') },\n    { name: 'assemble-core', path: path.resolve(cwd, 'node_modules/assemble-core') },\n    { name: 'assemble', path: path.resolve(cwd, 'node_modules/assemble') },\n    { name: 'generate', path: path.resolve(cwd, 'node_modules/generate') },\n    { name: 'update', path: path.resolve(cwd, 'node_modules/update') },\n    { name: 'verb', path: path.resolve(cwd, 'node_modules/verb') },\n    { name: 'core', path: path.resolve(__dirname, '..') }\n  ];\n  </defineResolutionPaths>\n\n  <lookupAndResolveApp>\n  for (const file of paths) {\n    if (opts.app && file.name === opts.app && (app = resolveApp(file))) {\n      return app;\n    }\n  }\n  </lookupAndResolveApp>\n\n  <resolveOrFallback>\n  if (opts.app) {\n    app = resolveApp({\n      name: opts.app,\n      path: path.resolve(cwd, 'node_modules', opts.app)\n    });\n  }\n  </resolveOrFallback>\n\n  return app;\n}\n"], ["checkVariable", "\nfunction checkVariable(i) {\n  <variableChecking>\n  const start = i;\n  \n  if (i >= tokensLength) return 0;\n\n  if (tokens[i].type === TokenType.DollarSign) i++;\n  else return 0;\n\n  <validateIdentifier>\n  let l;\n  if (l = checkIdent(i)) i += l;\n  else return 0;\n  </validateIdentifier>\n\n  return i - start;\n  </variableChecking>\n}\n"], ["rgbToRgba", "\nfunction rgbToRgba(rgbValue) {\n  <convertToRgba>\n  var rgb = /rgb\\((\\d+,\\s*[\\d]+,\\s*[\\d]+)\\)/g.exec(rgbValue);\n  return rgb ? (\"rgba(\" + (rgb[1]) + \",1)\") : rgbValue;\n  </convertToRgba>\n}\n"], ["linear_regression", "\nfunction linear_regression() {\n  var linreg = {},\n      data = [];\n\n  <setData>\n  linreg.data = function(x) {\n      if (!arguments.length) return data;\n      data = x.slice();\n      return linreg;\n  };\n  </setData>\n\n  <calculateSlopeAndIntercept>\n  linreg.mb = function() {\n      var m, b;\n\n      \n      \n      <determineDataLength>\n      var data_length = data.length;\n      </determineDataLength>\n\n      \n      \n      <handleSingleDataPoint>\n      if (data_length === 1) {\n          m = 0;\n          b = data[0][1];\n      }\n      </handleSingleDataPoint> \n      <computeLinearCoefficients>\n      else {\n          \n          \n          var sum_x = 0, sum_y = 0,\n              sum_xx = 0, sum_xy = 0;\n\n          \n          \n          var point, x, y;\n\n          \n          \n          \n          \n          \n          \n          for (var i = 0; i < data_length; i++) {\n              point = data[i];\n              x = point[0];\n              y = point[1];\n\n              sum_x += x;\n              sum_y += y;\n\n              sum_xx += x * x;\n              sum_xy += x * y;\n          }\n\n          \n          m = ((data_length * sum_xy) - (sum_x * sum_y)) /\n              ((data_length * sum_xx) - (sum_x * sum_x));\n\n          \n          b = (sum_y / data_length) - ((m * sum_x) / data_length);\n      }\n      </computeLinearCoefficients>\n\n      \n      return { m: m, b: b };\n  };\n  </calculateSlopeAndIntercept>\n\n  <getSlope>\n  linreg.m = function() {\n      return linreg.mb().m;\n  };\n  </getSlope>\n\n  <getIntercept>\n  linreg.b = function() {\n      return linreg.mb().b;\n  };\n  </getIntercept>\n\n  <generateLineFunction>\n  linreg.line = function() {\n\n      \n      var mb = linreg.mb(),\n          m = mb.m,\n          b = mb.b;\n\n      \n      \n      \n      return function(x) {\n          return b + (m * x);\n      };\n  };\n  </generateLineFunction>\n\n  return linreg;\n}\n"], ["ampmStrings", "\nfunction() {\n  <initializeVariables>\n  var ampmL = this.options.template.indexOf('a') !== -1,\n  ampmU = this.options.template.indexOf('A') !== -1,\n  </initializeVariables>            \n  <computeItemsArray>\n  items = [\n  ['am', ampmL ? 'am' : 'AM'],\n  ['pm', ampmL ? 'pm' : 'PM']\n  ];\n  </computeItemsArray>\n  return items;\n}\n"], ["circleReportPath", "\nfunction circleReportPath () {\n  <environmentValidation>\n\tconst CIRCLE_JOB = process.env.CIRCLE_JOB;\n\tconst CIRCLE_WORKING_DIRECTORY = process.env.CIRCLE_WORKING_DIRECTORY;\n\tif (!(ci.CIRCLE && CIRCLE_JOB && CIRCLE_WORKING_DIRECTORY)) {\n\t\treturn;\n\t}\n  </environmentValidation>\n\n  <resolveCwd>\n\tconst cwd = resolveHomePath(CIRCLE_WORKING_DIRECTORY);\n  </resolveCwd>\n  \n  <readConfiguration>\n\tlet config = path.join(cwd, '.circleci/config.yml');\n\tconfig = fs.readFileSync(config, 'utf-8');\n\tconfig = yaml.safeLoad(config);\n  </readConfiguration>\n\n  <aggregateTestResultsPaths>\n\tconfig = config.jobs[CIRCLE_JOB].steps.reduce((results, step) => {\n\t\tstep = step.store_test_results;\n\t\tif (step) {\n\t\t\tstep = step.paths || step.path;\n\t\t\tif (step) {\n\t\t\t\tresults = results.concat(step);\n\t\t\t}\n\t\t}\n\t\treturn results;\n\t}, []);\n  </aggregateTestResultsPaths>\n\n  <selectTestResultPath>\n\tconfig = config.find(path => !/\\w+\\.\\w+$/.test(path)) || config[0];\n  </selectTestResultPath>\n\n  <resolvePath>\n\tif (config) {\n\t\treturn path.resolve(cwd, resolveHomePath(config));\n\t}\n  </resolvePath>\n}\n"], ["processLess", "\nfunction processLess() {\n    let index = 0;\n    while (index < lessFilePool.length) {\n      (function (index) {\n        <processLessFiles>\n        if (lessFilePool[index].indexOf('.less') != -1) {\n          <readLessFile>\n          fs.readFile(lessFilePool[index], function (e, data) {\n              if (data) {\n                  <renderLess>\n                  less.render(data.toString(), {\n                      filename: lessFilePool[index]\n                  }, function (e, output) {\n                      if (e) {\n                          console.log(e);\n                      } else {\n                          <processCssAfterLess>\n                          cssImage(output.css, lessFilePool[index]).then(res => {\n                              saveToCss(res);\n                              lessFilePool[index] = '';\n                              doneOne();\n                          });\n                          </processCssAfterLess>\n                      }\n                  })\n                  </renderLess>\n              }\n          });\n          </readLessFile>\n        }\n        </processLessFiles>\n        \n        <processSassFiles>\n        if (lessFilePool[index].indexOf('.scss') != -1) {\n          <renderScss>\n          scss.render({\n              file: lessFilePool[index]\n          }, function (e, output) {\n              if (e) {\n                  console.log(e);\n              } else {\n                  <processCssAfterScss>\n                  cssImage(output.css, lessFilePool[index]).then(res => {\n                      saveToCss(res);\n                      lessFilePool[index] = '';\n                      doneOne();\n                  });\n                  </processCssAfterScss>\n              }\n          });\n          </renderScss>\n        }\n        </processSassFiles>\n\n        <processCssFiles>\n        if (lessFilePool[index].indexOf('.css') != -1) {\n          <readCssFile>\n          fs.readFile(lessFilePool[index], function (e, data) {\n              if (e) {\n                  console.log(e)\n              } else {\n                  <processCss>\n                  cssImage(data.toString(), lessFilePool[index]).then(res => {\n                      saveToCss(res);\n                      lessFilePool[index] = '';\n                      doneOne();\n                  });\n                  </processCss>\n              }\n          });\n          </readCssFile>\n        }\n        </processCssFiles>\n\n      })(index);\n      index += 1\n    }\n}\n"], ["sendSmsFunction", "\nfunction(to,tempId,params,callback){\n  <generateTimeStamp>\n  var timeStamp = index.createTimeStamp(cfg.timeFmt);\n  </generateTimeStamp>\n\n  <createSignature>\n  var sigParameter = index.hashMD5(cfg.accountSid+cfg.accountToken+timeStamp).toUpperCase();\n  </createSignature>\n\n  <formatUrl>\n  var url = util.format('/%s/Accounts/%s/%s/%s?sig=%s', cfg.softVersion, cfg.accountSid, cfg.func, cfg.funcdes, sigParameter);\n  </formatUrl>\n\n  <encodeAuthentication>\n  var authBuff = new Buffer(cfg.accountSid+':'+timeStamp);\n  var authcode = authBuff.toString('base64');\n  </encodeAuthentication>\n\n  <defineHeaders>\n  var headers = {\n    'Accept':'application/json',\n    'Content-Type':'application/json;charset=utf-8',\n    'Authorization':authcode,\n  };\n  </defineHeaders>\n\n  <generateVerificationCode>\n  var code = smsCodeGen();\n  </generateVerificationCode>\n\n  <prepareRequestBody>\n  var body = {\n    to:to,\n    templateId:tempId.toString(),\n    appId:cfg.appId,\n    datas:params,\n  };\n  </prepareRequestBody>\n\n  <configurePostOptions>\n  var postOptions = {\n    method: 'POST',\n    baseUrl:cfg.serverIP+':'+cfg.serverPort,\n    url: url,\n    json:true,\n    body:body,\n    headers:headers,\n  };\n  </configurePostOptions>\n\n  <sendRequest>\n  request(postOptions, function(err,res,body){\n    err = getSmsInfo(body);\n    callback(err,body);\n  });\n  </sendRequest>\n}\n"], ["anomaly", "\nfunction anomaly() {\n  <retrieveId>\n  var id = this instanceof events.EventEmitter && this.id ? String(this.id) : '' \n  </retrieveId>\n\n  <collectArguments>\n  var body = getBody(id, Array.prototype.slice.call(arguments))\n  </collectArguments>\n\n  <logEvent>\n  log(id, body)\n  </logEvent>\n\n  <conditionalEmailAction>\n  if (!isShutdown && isEmailOn() && emailer.hasSendMail()) enqueueEmail(body)\n  </conditionalEmailAction>\n}\n"], "```"]