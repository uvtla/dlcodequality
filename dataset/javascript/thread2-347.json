[["migrate", "\nfunction migrate() {\n  var multi = rclient.multi()\n\n  \n  <redisCommands>\n  multi.get('version')\n  multi.get('anvil:connect:version')\n  multi.dbsize()\n  </redisCommands>\n\n  <executionAndErrorHandling>\n  multi.exec(function (err, results) {\n    if (err) {\n      console.log(Array.isArray(err) ? err[0].message : err.message)\n      process.exit(1)\n    }\n  </executionAndErrorHandling>\n\n  <versionAndDatabaseSizeCheck>\n    var version = results[1][1] || results[0][1]\n    var dbsize = results[2][1]\n\n    \n    if (!version && dbsize > 0) {\n      if (process.argv.indexOf('--no-db-check') === -1) {\n        console.log(\n          \"\\nRedis already contains data, but it doesn't seem to be an \" +\n          'Anvil Connect database.\\nIf you are SURE it is, start the server ' +\n          'with --no-db-check to skip this check.\\n'\n        )\n        return process.exit(1)\n      }\n    }\n  </versionAndDatabaseSizeCheck>\n\n  <migrationInitiation>\n    var migrations = [\n      \n      require('../migrations/baseline')()\n    ].concat(\n      \n      require('../migrations')(version)\n    )\n  </migrationInitiation>\n\n  <migrationExecution>\n    async.parallel(migrations, function (err, results) {\n      if (err) {\n        console.log('Unable to initialize Redis database.')\n        console.log(err.message)\n        return process.exit(1)\n      }\n\n      updateVersion(function (err) {\n        if (err) {\n          console.log('Unable to initialize Redis database.')\n          console.log(err.message)\n          return process.exit(1)\n        }\n\n        console.log('Successfully initialized Redis database.')\n      })\n    })\n  </migrationExecution>\n  })\n}\n"], ["UMLGeneralizationView", "\nfunction UMLGeneralizationView() {\n  UMLGeneralEdgeView.apply(this, arguments);\n  this.tailEndStyle = Core.ES_FLAT;\n  this.headEndStyle = Core.ES_TRIANGLE;\n  this.lineMode = Core.LM_SOLID;\n}\n"], ["defineProperty", "\nfunction defineProperty(target, property, value, options) {\n  Object.defineProperty(target, property, {\n    value,\n    writable: (options && options.writable) !== false,\n    configurable: (options && options.configurable) !== false,\n    enumerable: options && options.enumerable\n  });\n  return target;\n}\n"], ["checkRegex", "\nfunction checkRegex(_regex, _config) {\n  let pattern;\n  let config;\n\n  <handleArguments>\n  try {\n    [pattern, config] = handleArgs(_regex, _config);\n  } catch (e) {\n    return Promise.reject(RESPONSE_INVALID);\n  }\n  log(`Input OK. pattern /${pattern}/ config ${JSON.stringify(config)}`);\n  </handleArguments>\n\n  <requestInitiation>\n  let postObject = generatePostObject(pattern);\n  let postBuffer = JSON.stringify(postObject);\n  let postHeaders = generatePostHeaders(config, Buffer.byteLength(postBuffer));\n  </requestInitiation>\n\n  <promiseResult>\n  function promiseResult(options, data) {\n    log(`promiseResult: data ${data}`);\n    return new Promise((resolve, reject) => {\n      <checkCache>\n      const cacheHit = checkCache(config, pattern);\n      if (cacheHit !== RESPONSE_UNKNOWN) {\n        log(`Cache hit: ${cacheHit}`);\n        return resolve(cacheHit);\n      }\n      </checkCache>\n\n      <sendRequest>\n      const req = https.request(options, (res) => {\n        res.setEncoding('utf8');\n\n        let response = '';\n        res.on('data', (chunk) => {\n          log(`Got data`);\n          response += chunk;\n        });\n\n        res.on('end', () => {\n          log(`end: I got ${JSON.stringify(response)}`);\n\n          const result = serverResponseToRESPONSE(response);\n          log(`end: result ${result}`);\n          updateCache(config, postObject.pattern, result);\n\n          if (result === RESPONSE_INVALID) {\n            return reject(result);\n          } else {\n            return resolve(result);\n          }\n        });\n      });\n      </sendRequest>\n\n      <errorHandling>\n      req.on('error', (e) => {\n        log(`Error: ${e}`);\n        return reject(RESPONSE_INVALID);\n      });\n      </errorHandling>\n\n      <writeData>\n      log(`Writing to req:\\n${data}`);\n      req.write(data);\n      req.end();\n      </writeData>\n    });\n  }\n  </promiseResult>\n\n  <returnPromise>\n  return promiseResult(postHeaders, postBuffer);\n  </returnPromise>\n}\n"], ["copyingOperation", "\nfunction (src, dst, callback) {\n  fs.exists(dst, function (exists) {\n    \n    <handleExistence>\n    if (exists) {\n      \n      callback(src, dst);\n    }\n    </handleExistence>\n\n    \n    <handleNonExistence>\n    else {\n      fs.mkdir(dst, function () {\n        callback(src, dst);\n      });\n    }\n    </handleNonExistence>\n  });\n}\n"], ["DeviceFirmwareBundle", "\nfunction DeviceFirmwareBundle() {\n  var firmwareImageInformation = null;\n  var firmwareImage = null;\n  var deviceImage = null;\n  var device = null;\n  var curatedDevice = null;\n\n  <deviceStateInitialization>\n  var initialDeviceState = {};\n\n  var version = null;\n  var serial = null;\n  var connectionType = null;\n  var deviceType = null;\n  var deviceTypeString = null;\n  </deviceStateInitialization>\n\n  <progressTracking>\n  var progressListener = null;\n\n  this.setProgressListener = function (newListener) {\n    progressListener = newListener;\n  };\n  this.getProgressListener = function () {\n    return progressListener;\n  };\n  this.updateProgressScaled = function (value) {\n    if (shouldUpdateProgressBar) {\n      var scaledValue = curScaling * value + curOffset;\n      progressListener.updatePercentage(scaledValue, nop);\n    }\n  };\n  </progressTracking>\n\n  <gettersAndSetters>\n  \n  this.getFirmwareImage = function () {\n    return firmwareImage;\n  };\n\n  \n  this.setFirmwareImage = function (newFirmwareImage) {\n    firmwareImage = newFirmwareImage;\n  };\n\n  \n  this.getFirmwareImageInformation = function () {\n    return firmwareImageInformation;\n  };\n  </gettersAndSetters>\n\n  <additionalMethods>\n  function getUpgradeTargetFlashInfo() {\n    // ...\n  }\n  this.getUpgradeTargetFlashInfo = getUpgradeTargetFlashInfo;\n\n  function isLoadingRecoveryFW() {\n    // ...\n  }\n  this.isLoadingRecoveryFW = isLoadingRecoveryFW;\n\n  this.setConnectionType = function (newConnectionType) {\n    // ...\n  };\n  this.setDeviceType = function (newDeviceType) {\n    // ...\n  };\n  </additionalMethods>\n\n  <setters>\n  \n  this.setFirmwareImageInformation = function (newFirmwareImageInformation) {\n    firmwareImageInformation = newFirmwareImageInformation;\n  };\n\n  \n  this.setDevice = function (newDevice) {\n    device = newDevice;\n  };\n\n  \n  this.setCuratedDevice = function (newCuratedDevice) {\n    curatedDevice = newCuratedDevice;\n  };\n\n  \n  this.getDevice = function () {\n    return device;\n  };\n\n  \n  this.getCuratedDevice = function () {\n    return curatedDevice;\n  };\n\n  \n  this.getFirmwareVersion = function () {\n    return version;\n  };\n\n  \n  this.setFirmwareVersion = function (newVersion) {\n    version = newVersion;\n  };\n\n  \n  this.setSerialNumber = function (newSerial) {\n    serial = newSerial;\n  };\n\n  \n  this.getSerialNumber = function () {\n    return serial;\n  };\n\n  this.getConnectionType = function () {\n    return connectionType;\n  };\n\n  this.getDeviceType = function () {\n    return deviceType;\n  };\n  this.getDeviceTypeString = function () {\n    return deviceTypeString;\n  };\n  this.deviceHasWiFi = function () {\n    var hasWiFi = false;\n    if (deviceType == driver_const.LJM_DT_T7) {\n      hasWiFi = true;\n    }\n    return hasWiFi;\n  };\n  </setters>\n\n  <interpretationAndState>\n  function interpretData(activeFW, primaryFW, recoveryFW) {\n    // ...\n  }\n  \n  this.getInitialDeviceState = function () {\n    return initialDeviceState;\n  };\n  this.setInitialDeviceState = function (activeFW, primaryFW, recoveryFW) {\n    initialDeviceState = interpretData(activeFW, primaryFW, recoveryFW);\n    if (DEBUG_FIRMWARE_UPGRADE_PROCESS) {\n      console.log('Initial Device State', initialDeviceState);\n    }\n  };\n  this.performDeviceReboot = function () {\n    // ...\n  };\n  this.verifyLoadedFirmwareVersion = function () {\n    // ...\n  };\n  </interpretationAndState>\n\n  <tempDataStore>\n  var tempDataStore = {};\n  this.clearTempDataStore = function () {\n    tempDataStore = {};\n  };\n  this.addTempDataStore = function (key, value) {\n    tempDataStore[key] = value;\n  };\n  this.getTempDataStore = function () {\n    return tempDataStore;\n  };\n  </tempDataStore>\n}\n"], ["tileCacheHandling", "\nfunction(evt) {\n  var tile = evt.object;\n  var img = this.tileCache[tile.url];\n  if (img) {\n    <disassociateImg>\n    if (img.parentNode &&\n            OpenLayers.Element.hasClass(img.parentNode, 'olBackBuffer')) {\n        img.parentNode.removeChild(img);\n        img.id = null;\n    }\n    </disassociateImg>\n    \n    <associateTile>\n    if (!img.parentNode) {\n        img.style.visibility = 'hidden';\n        img.style.opacity = 0;\n        tile.setImage(img);\n        \n        <tileCacheIndexHandling>\n        OpenLayers.Util.removeItem(this.tileCacheIndex, tile.url);\n        this.tileCacheIndex.push(tile.url);\n        </tileCacheIndexHandling>\n    }\n    </associateTile>\n  }\n}\n"], ["handleConfigObject", "\nfunction handleConfigObject(oCfg, mHandlers) {\n\n  <processConfig>\n  function processConfig(key, value) {\n    var handler = mHandlers[key];\n    if (typeof handler === 'function') {\n      if (handler.length === 1) {\n        handler(value);\n      } else if (value != null) {\n        forEach(value, handler);\n      }\n    } else {\n      log.warning(\"configuration option \" + key + \" not supported (ignored)\");\n    }\n  }\n  </processConfig>\n\n  \n  <processBaseUrl>\n  if (oCfg.baseUrl) {\n    processConfig(\"baseUrl\", oCfg.baseUrl);\n  }\n  </processBaseUrl>\n\n  <processOtherOptions>\n  forEach(oCfg, function (key, value) {\n    \n    if (key !== \"baseUrl\") {\n      processConfig(key, value);\n    }\n  });\n  </processOtherOptions>\n}\n"], ["processStatements", "\nfunction (out, statement) {\n  var statname = statement.name;\n  if (statname.charAt(0) == '@') {\n      statname = '@';\n  }\n\n  <statementProcessing>\n  var handler = this.STATEMENTS[statname];\n  if (handler == null) {\n      out.logError(statement, this.UNKNOWN_STATEMENT, [statname]);\n  } else if (handler.container === true && statement.content === undefined) {\n      out.logError(statement, this.EXPECTED_CONTAINER, [statname]);\n  } else if (handler.container === false && statement.content !== undefined) {\n      out.logError(statement, this.UNEXPECTED_CONTAINER, [statname]);\n  } else if (handler.inMacro !== undefined && out.isOutputReady() !== handler.inMacro) {\n      if (handler.inMacro) {\n          out.logError(statement, ariaTemplatesStatements.SHOULD_BE_IN_MACRO, [statname]);\n      } else {\n          out.logError(statement, this.SHOULD_BE_OUT_OF_MACRO, [statname]);\n      }\n  } else {\n      if (handler.paramRegexp) {\n          <paramRegexpCheck>\n          var res = handler.paramRegexp.exec(statement.paramBlock);\n          if (res == null) {\n              out.logError(statement, this.INVALID_STATEMENT_SYNTAX, [statname, handler.paramRegexp]);\n          } else {\n              if (this._isDebug) {\n                  out.trackLine(statement.lineNumber);\n              }\n              handler.process(out, statement, res);\n          }\n          </paramRegexpCheck>\n      } else {\n          if (this._isDebug) {\n              out.trackLine(statement.lineNumber);\n          }\n          handler.process(out, statement, this);\n      }\n  }\n  </statementProcessing>\n}\n"], ["expandParamOptions", "\nfunction expandParamOptions(options) {\n  if (!options) { return {}; }\n\n  <paramProcessing>\n  if (!Ember.isArray(options)) {\n    options = [options];\n  }\n\n  let params = {};\n  let option, i, key;\n\n  for (i = 0; i < options.length; i++) {\n    option = options[i];\n    if (typeof option === \"object\") {\n      for (key in option) {\n        params[key] = option[key];\n      }\n    } else {\n      params[option] = option;\n    }\n  }\n  </paramProcessing>\n\n  <paramReturn>\n  return params;\n  </paramReturn>\n}\n"], "```"]