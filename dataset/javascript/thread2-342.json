[["createBroker", "\nfunction createBroker (ascoltatore, moscaOpts) {\n  <initializeBrokerSettings>\n  const moscaSettings = {\n    \n    backend: ascoltatore,\n    persistence: {\n      factory: mosca.persistence.Redis\n    }\n  }\n\n  moscaOpts = Object.assign({}, moscaSettings, moscaOpts)\n  const server = new mosca.Server(moscaOpts)\n  server.on('ready', setup)\n  </initializeBrokerSettings>\n\n  <handlePublishedEvents>\n  server.on('published', function (packet, client) {\n    const presence = packet.topic.match(/^\\$SYS\\/.*\\/(new|disconnect)\\/clients$/)\n    if (presence) {\n      const clientId = packet.payload\n      const type = presence[1] === 'new' ? 'connected' : 'disconnected'\n      server.publish({\n        topic: `$aws/events/presence/${type}/${clientId}`,\n        payload: JSON.stringify(createAWSLifecycleEvent({\n          type,\n          clientId\n        }))\n      })\n    }\n\n    const subscription = packet.topic.match(/^\\$SYS\\/.*\\/new\\/(subscribes|unsubscribes)$/)\n    if (subscription) {\n      const type = subscription[1] === 'subscribes' ? 'subscribed' : 'unsubscribed'\n      const { clientId, topic } = JSON.parse(packet.payload)\n      server.publish({\n        topic: `$aws/events/subscriptions/${type}/${clientId}`,\n        payload: JSON.stringify(createAWSLifecycleEvent({\n          type,\n          clientId,\n          topics: [topic]\n        }))\n      })\n    }\n  })\n  </handlePublishedEvents>\n\n  return server\n}\n"], ["create", "\nfunction create (id, spec) {\n  <validateAndParseEntity>\n  validateModifiers(id, spec, ['select'])\n  const entity = {}\n  entity.spec = spec\n  entity.select = parseSwitch(spec)\n  </validateAndParseEntity>\n  return entity\n}\n"], ["buildError", "\nfunction buildError(k, message) {\n  <accumulateErrorMessages>\n  if (!Array.isArray(errors[k])) errors[k] = [];\n  errors[k].push(message);\n  </accumulateErrorMessages>\n}\n"], ["Q", "\nfunction Q(redisClient, key) {\n  <initializeQueue>\n  if (!(this instanceof Q)) {\n    return new Q(redisClient, key);\n  }\n  this._redis = redisClient;\n  this._key = key;\n  </initializeQueue>\n}\n"], ["addPathGuides", "\nfunction addPathGuides($canvas, parent) {\n  <drawGuidesForPaths>\n  var handles = parent._handles,\n    prevHandle, nextHandle, otherHandle,\n    handle, h,\n    guide, guideProps;\n  guideProps = $.extend({}, parent.guide, {\n    layer: true,\n    draggable: false,\n    type: 'line'\n  });\n  if (parent._method === $.fn.drawQuadratic) {\n    $canvas.addLayer(guideProps);\n    parent._guide = $canvas.getLayer(-1);\n    $canvas.moveLayer(parent._guide, -handles.length - 1);\n  } else if (parent._method === $.fn.drawBezier) {\n    parent._guides = [];\n    for (h = 0; h < handles.length; h += 1) {\n      handle = handles[h];\n      nextHandle = handles[h + 1];\n      prevHandle = handles[h - 1];\n      otherHandle = null;\n      if (nextHandle !== undefined) {\n        if (handle._xProp.indexOf('x') === 0 && nextHandle._xProp.indexOf('cx') === 0) {\n          otherHandle = nextHandle;\n        }\n      } else if (prevHandle !== undefined) {\n        if (prevHandle._xProp.indexOf('cx') === 0 && handle._xProp.indexOf('x') === 0) {\n          otherHandle = prevHandle;\n        }\n      }\n      if (otherHandle !== null) {\n        $canvas.addLayer(guideProps);\n        guide = $canvas.getLayer(-1);\n        guide._handles = [handle, otherHandle];\n        parent._guides.push(guide);\n        $canvas.moveLayer(guide, -handles.length - 1);\n      }\n    }\n  }\n  updatePathGuides(parent);\n  </drawGuidesForPaths>\n}\n"], ["initializeCalendarEvents", "\nfunction () {\n\n  var oCalendarTBody = Dom.get(calendarId).tBodies[0],\n    aElements = oCalendarTBody.getElementsByTagName(\"a\"),\n    oAnchor;\n\n  if (aElements.length > 0) {\n  \n    <findAnchorElement>\n    Dom.batch(aElements, function (element) {\n      if (Dom.hasClass(element.parentNode, \"today\")) {\n        oAnchor = element;\n      }\n    });\n    \n    if (!oAnchor) {\n      oAnchor = aElements[0];\n    }\n    </findAnchorElement>\n\n    <setFocusOnAnchor>\n    lang.later(0, oAnchor, function () {\n      try {\n        oAnchor.focus();\n      }\n      catch(e) {}\n    });\n    </setFocusOnAnchor>\n  \n  }\n  \n}\n"], ["fixHttpMethod", "\nfunction fixHttpMethod (fn, name) {\n  <updateHttpVerb>\n  if (fn.http && fn.http.verb && fn.http.verb.toLowerCase() === 'put') {\n    fn.http.verb = 'patch'\n  }\n  </updateHttpVerb>\n}\n"], ["read", "\nfunction read(src, basedir, callback){\n  <readPageContent>\n  var page = new Page(src, basedir)\n  page.read(callback)\n  </readPageContent>\n}\n"], ["getSubstitution", "\nfunction getSubstitution(matched, str, position, captures, namedCaptures, replacement) {\n  <handleReplacementSubstitutions>\n  var tailPos = position + matched.length;\n  var m = captures.length;\n  var symbols = SUBSTITUTION_SYMBOLS_NO_NAMED;\n  if (namedCaptures !== undefined) {\n    namedCaptures = toObject(namedCaptures);\n    symbols = SUBSTITUTION_SYMBOLS;\n  }\n  return $replace.call(replacement, symbols, function (match, ch) {\n    var capture;\n    switch (ch.charAt(0)) {\n      case '$': return '$';\n      case '&': return matched;\n      case '`': return str.slice(0, position);\n      case \"'\": return str.slice(tailPos);\n      case '<':\n        capture = namedCaptures[ch.slice(1, -1)];\n        break;\n      default: \n        var n = +ch;\n        if (n === 0) return match;\n        if (n > m) {\n          var f = floor(n / 10);\n          if (f === 0) return match;\n          if (f <= m) return captures[f - 1] === undefined ? ch.charAt(1) : captures[f - 1] + ch.charAt(1);\n          return match;\n        }\n        capture = captures[n - 1];\n    }\n    return capture === undefined ? '' : capture;\n  });\n  </handleReplacementSubstitutions>\n}\n"], ["handleMouseMove", "\nfunction (event) {\n  <lockPointerAndCalculateMovement>\n  if (!this.data.enabled || (!this.mouseDown && !this.pointerLocked)) { return; }\n  if (this.pointerLocked) {\n    movementX = event.movementX || event.mozMovementX || 0;\n    movementY = event.movementY || event.mozMovementY || 0;\n  } else {\n    movementX = event.screenX - previousMouseEvent.screenX;\n    movementY = event.screenY - previousMouseEvent.screenY;\n  }\n  </lockPointerAndCalculateMovement>\n\n  <updateCameraRotation>\n  this.previousMouseEvent = event;\n  direction = this.data.reverseMouseDrag ? 1 : -1;\n  yawObject.rotation.y += movementX * 0.002 * direction;\n  pitchObject.rotation.x += movementY * 0.002 * direction;\n  pitchObject.rotation.x = Math.max(-PI_2, Math.min(PI_2, pitchObject.rotation.x));\n  </updateCameraRotation>\n}\n"], "```"]