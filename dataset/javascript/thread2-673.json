[["tryPlugin", "\nfunction tryPlugin(mId, space) {\n  <parseModuleId>\n  const parsed = parse(mId); // parse the module id\n  const pluginId = parsed.prefix.slice(0, -1); \n  </parseModuleId>\n  \n  <handleNonTextPluginLoading>\n  if (pluginId) {\n    if (pluginId !== 'text' && pluginId !== 'raw') {\n      return new Promise((resolve, reject) => {\n        const req = (deps, callback, errback) => {\n          const errback2 = e => {\n            if (errback) {\n              try {\n                errback(e);\n              } catch (err) { }\n            }\n            reject(e);\n          };\n          return requirejs(deps, callback, errback2);\n        };\n        try {\n          const onload = loaded => {\n            space.define(mId, [], () => loaded);\n            resolve(space.req(mId));\n          };\n          onload.error = err => reject(err);\n          requirejs([pluginId], plugin => {\n            plugin.load(parsed.bareId, req, onload, {});\n          });\n        } catch (err) {\n          reject(err);\n        }\n      });\n    }\n  }\n  </handleNonTextPluginLoading>\n  \n  <handleExtensionPluginLoading>\n  else if (parsed.ext && parsed.ext !== '.js') {\n    const extPluginName = 'ext:' + parsed.ext.slice(1);\n    if (userSpace.has(extPluginName) || packageSpace.has(extPluginName)) {\n      return new Promise((resolve, reject) => {\n        const req = (deps, callback, errback) => {\n          const errback2 = e => {\n            if (errback) {\n              try {\n                errback(e);\n              } catch (err) { }\n            }\n            reject(e);\n          };\n          return requirejs(deps, callback, errback2);\n        };\n        try {\n          const onload = loaded => {\n            space.define(mId, [], () => loaded);\n            resolve(space.req(mId));\n          };\n          onload.error = err => reject(err);\n          requirejs([extPluginName], plugin => {\n            plugin.load(parsed.cleanId, req, onload, {});\n          });\n        } catch (err) {\n          reject(err);\n        }\n      });\n    }\n    return new Promise(resolve => {\n      space.define(parsed.cleanId,['text!' + parsed.cleanId], m => m);\n      resolve(space.req(mId));\n    });\n  }\n  </handleExtensionPluginLoading>\n}\n"], ["setTextareaAccessibility", "\nfunction (disable) {\n  var t = this,\n      prefix = t.o.prefix;\n  \n  t.disabled = disable;\n  \n  if (disable) {\n    t.$ta.attr('disabled', true);\n  } else {\n    t.$ta.removeAttr('disabled');\n  }\n  t.$box.toggleClass(prefix + 'disabled', disable);\n  t.$ed.attr('contenteditable', !disable);\n}\n"], ["pubsubDeleteNode", "\nfunction(node, call_back) {\n  var that = this._connection;\n  var iqid = that.getUniqueId(\"pubsubdeletenode\");\n  \n  <generateIQ>\n  var iq = $iq({from:this.jid, to:this.service, type:'set', id:iqid})\n    .c('pubsub', {xmlns:Strophe.NS.PUBSUB_OWNER})\n    .c('delete', {node:node});\n  </generateIQ>\n\n  <setupCallback>\n  that.addHandler(call_back, null, 'iq', null, iqid, null);\n  </setupCallback>\n  \n  <sendIQ>\n  that.send(iq.tree());\n  </sendIQ>\n\n  return iqid;\n}\n"], ["processSourceFile", "\nfunction processSourceFile(work_directory, file_path) {\n  <pathSetup>\n  var path = create('fs.path', work_directory).combine(file_path),\n      source = create('fs.filereader(utf8)', path).readSync();\n  </pathSetup>\n\n  <replaceIncludes>\n  var result = source.replace(/\\/\\*#include \\S+\\*\\\n  var include_file_path = /\\/\\*#include (\\S+)\\*\\\n  \n  watch_list.push(include_file_path);\n  \n  return processSourceFile(path.getParentPath().path, include_file_path);\n  });\n  </replaceIncludes>\n\n  return result;\n}\n"], ["getOPF", "\nfunction getOPF(document) {\n  <getAndReplaceContent>\n  var content = structuralFiles.getOPF(document);\n  return replacements(document, replacements(document, content));\n  </getAndReplaceContent>\n}\n"], ["initializePlugin", "\nfunction plugin(Vue) {\n  <checkAlreadyInstalled>\n  if (plugin.installed) {\n    return;\n  }\n  </checkAlreadyInstalled>\n\n  <setupUtilities>\n  Util(Vue);\n  </setupUtilities>\n\n  <attachProperties>\n  Vue.url = Url;\n  Vue.http = Http;\n  Vue.resource = Resource;\n  Vue.Promise = PromiseObj;\n  \n  Object.defineProperties(Vue.prototype, {\n    $url: {\n      get: function get() {\n        return options(Vue.url, this, this.$options.url);\n      }\n    },\n    $http: {\n      get: function get() {\n        return options(Vue.http, this, this.$options.http);\n      }\n    },\n    $resource: {\n      get: function get() {\n        return Vue.resource.bind(this);\n      }\n    },\n    $promise: {\n      get: function get() {\n        var this$1 = this;\n        return function (executor) { return new Vue.Promise(executor, this$1); };\n      }\n    }\n  });\n  </attachProperties>\n}\n"], ["createFunctionStruct", "\nfunction func(schema, defaults, options) {\n  <validateSchema>\n  if (kindOf(schema) !== 'function') {\n    <schemaErrorHandling>\n    if (process.env.NODE_ENV !== 'production') {\n      throw new Error(\n        `Function structs must be defined as a function, but you passed: ${schema}`\n      )\n    } else {\n      throw new Error(`Invalid schema: ${schema}`)\n    }\n    </schemaErrorHandling>\n  }\n  </validateSchema>\n\n  <setupValidationFunction>\n  const name = 'function'\n  const type = '<function>'\n  const validate = (value = resolveDefaults(defaults), data) => {\n    const result = schema(value, data)\n    let failure = { path: [], reason: null }\n    let isValid\n    \n    <handleValidationResult>\n    switch (kindOf(result)) {\n      case 'boolean': {\n        isValid = result\n        break\n      }\n      case 'string': {\n        isValid = false\n        failure.reason = result\n        break\n      }\n      case 'object': {\n        isValid = false\n        failure = { ...failure, ...result }\n        break\n      }\n      default: {\n        <resultErrorHandling>\n        if (process.env.NODE_ENV !== 'production') {\n          throw new Error(\n            `Validator functions must return a boolean, an error reason string or an error reason object, but you passed: ${schema}`\n          )\n        } else {\n          throw new Error(`Invalid result: ${result}`)\n        }\n        </resultErrorHandling>\n      }\n    }\n    </handleValidationResult>\n\n    return isValid\n      ? [undefined, value]\n      : [{ type, value, data: value, ...failure }]\n  }\n  </setupValidationFunction>\n\n  <createStructInstance>\n  return new Kind(name, type, validate)\n  </createStructInstance>\n}\n"], ["resetParserState", "\nfunction reset(html) {\n  this.html = html || this.html;\n  this.root = new VNode('div');\n  this.node = this.root; \n  this.path = []; \n  this.blocks = []; \n}\n"], ["expandAbbreviation", "\nfunction(abbr, syntax, profile, contextNode) {\n\treturn parser.expand(abbr, {\n\t\tsyntax: syntax,\n\t\tprofile: profile,\n\t\tcontextNode: contextNode\n\t});\n}\n"], ["adjustDateRange", "\nfunction(date, inst) {\n\tvar minDate = inst.get('minDate');\n\tvar maxDate = inst.get('maxDate');\n\t<minDateAdjustment>\n\tdate = (minDate && date.compareTo(minDate) === -1 ? minDate.newDate() : date);\n\t</minDateAdjustment>\n\t<maxDateAdjustment>\n\tdate = (maxDate && date.compareTo(maxDate) === +1 ? maxDate.newDate() : date);\n\t</maxDateAdjustment>\n\treturn date;\n}\n"], "```\n\nPlease note that these annotations identify cohesive blocks of code that represent a specific responsibility. Responsibilities are marked according to their logic and purpose, not merely on syntactical lines."]