[["match", "\nfunction match(source, cases, isExec) {\n  <throwErr_check>\n  if (!isObj(cases)) throwErr('obj'); </throwErr_check>\n  <isExec_default>\n  if (isUdf(isExec)) isExec = true; </isExec_default>\n  var symbol = '__@fnMatch__';\n  <determine_symbol>\n  if (has(cases, source)) {\n    symbol = source;\n  } else if (has(cases, 'default')) {\n    symbol = 'default';\n  } </determine_symbol>\n  <resolve_matched>\n  var matched = cases[symbol];\n  if (matched === '@next') {\n    var ks = keys(cases), i = ks.indexOf(symbol) - 1;\n    while (++i < ks.length) if (cases[ks[i]] !== '@next') { matched = cases[ks[i]]; break; }\n  } </resolve_matched>\n  <execute_or_return>\n  if (isExec && isFun(matched)) {\n    return len(matched) ? matched(source) : matched();\n  } else {\n    return matched === '@next' ? UDF : matched;\n  } </execute_or_return>\n}\n"], ["getErrorReportURL", "\nfunction getErrorReportURL(projectId, key) {\n  var url = [API, projectId, 'events:report'].join('/');\n  <append_key_param>\n  if (isString(key)) {\n    url += '?key=' + key;\n  } </append_key_param>\n  return url;\n}\n"], ["pursue", "\nfunction pursue(targetBoid) {\n  <calculate_predicted_target>\n  const lookAheadTime = position.distanceSq(targetBoid.position) / maxSpeedSq;\n\n  const scaledVelocity = targetBoid.velocity.clone().scaleBy(lookAheadTime);\n  const predictedTarget = targetBoid.position.clone().add(scaledVelocity);\n\n  seek(predictedTarget);\n\n  scaledVelocity.dispose();\n  predictedTarget.dispose();\n  </calculate_predicted_target>\n\n  return boid;\n}\n"], ["injectNumbers", "\nfunction injectNumbers (funcs, task) {\n  <inject>\n  function inject (taskKey) {\n    var taskName = task[taskKey]\n\n    var num = parseFloat(taskName)\n\n    if (!isNaN(num)) {\n      funcs[taskName] = function () { return num }\n    }\n  } </inject>\n\n  <loop_through_tasks>\n  Object.keys(task)\n    .forEach(inject)\n  </loop_through_tasks>\n}\n"], ["clean", "\nfunction clean(obj) {\n  <remove_null_properties>\n  for (var prop in obj) if (obj[prop] == null) delete obj[prop]; </remove_null_properties>\n  return obj;\n}\n"], ["anonymous_event_function", "\nfunction(event_type) {\n  <setup>\n\tvar rest_args = arguments.length > 1 ? rest(arguments) : root,\n\t\t\n\t\tevent = new CJSEvent(false, false, function(transition) {\n\t\t\tvar targets = [],\n\t\t\t\t<timeout_management>\n\t\t\t\ttimeout_id = false,\n\t\t\t\tevent_type_val = [],\n\t\t\t\tlistener = bind(this._fire, this),\n\t\t\t\tfsm = transition.getFSM(),\n\t\t\t\tfrom = transition.getFrom(),\n\t\t\t\tstate_selector = new StateSelector(from),\n\t\t\t\tfrom_state_selector = new TransitionSelector(true, state_selector, new AnyStateSelector()),\n\t\t\t\ton_listener = function() {\n\t\t\t\t\t<timeout_set_up>\n\t\t\t\t\teach(event_type_val, function(event_type) {\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(event_type === timeout_event_type) {\n\t\t\t\t\t\t\n\t\t\t\t\t\t\tif(timeout_id) {\n\t\t\t\t\t\t\t\tcTO(timeout_id);\n\t\t\t\t\t\t\t\ttimeout_id = false;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tvar delay = cjs.get(rest_args[0]);\n\t\t\t\t\t\t\tif(!isNumber(delay) || delay < 0) {\n\t\t\t\t\t\t\t\tdelay = 0;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\ttimeout_id = sTO(listener, delay);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t<event_listening>\n\t\t\t\t\t\t\teach(targets, function(target) {\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\taEL(target, event_type, listener);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t</event_listening>\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\t</timeout_set_up>\n\t\t\t\t},\n\t\t\t\toff_listener = function() {\n\t\t\t\t\teach(event_type_val, function(event_type) {\n\t\t\t\t\t\teach(targets, function(target) {\n\t\t\t\t\t\t\tif(event_type === timeout_event_type) {\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tif(timeout_id) {\n\t\t\t\t\t\t\t\t\tcTO(timeout_id);\n\t\t\t\t\t\t\t\t\ttimeout_id = false;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t<remove_event_listener>\n\t\t\t\t\t\t\t\trEL(target, event_type, listener);\n\t\t\t\t\t\t\t\t</remove_event_listener>\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\t\t\t\t},\n\t\t\t\tlive_fn = cjs.liven(function() {\n\t\t\t\t\t<live_functionality>\n\t\t\t\t\toff_listener();\n\n\t\t\t\t\tevent_type_val = split_and_trim(cjs.get(event_type));\n\t\t\t\t\t\n\t\t\t\t\ttargets = flatten(map(filter(get_dom_array(rest_args), isElementOrWindow), getDOMChildren , true));\n\n\t\t\t\t\tfsm\t.on(state_selector, on_listener)\n\t\t\t\t\t\t.on(from_state_selector, off_listener);\n\n\t\t\t\t\tif(fsm.is(from)) {\n\t\t\t\t\t\t\n\t\t\t\t\t\ton_listener();\n\t\t\t\t\t}\n\t\t\t\t\t</live_functionality>\n\t\t\t\t});\n\t\t\treturn live_fn;\n\t\t});\n\t\treturn event;\n\t</setup>\n}\n"], ["main", "\nfunction main (options, done) {\n  <input_assertions>\n  const token = options.token\n  const filename = options.filename\n\n  assert.equal(typeof token, 'string', 'markdown-to-medium: token should be a string')\n  </input_assertions>\n\n  <medium_setup>\n  const client = new medium.MediumClient({\n    clientId: token,\n    clientSecret: token\n  })\n\n  client.setAccessToken(token)\n  </medium_setup>\n\n  var src\n\n  <read_file>\n  try {\n    src = fs.readFileSync(filename, 'utf8')\n  } catch (e) {\n    throw new Error('Could not read file ' + filename)\n  }\n  </read_file>\n\n  <prepare_content>\n  const matter = frontMatter(src)\n  let title = options.title || matter.attributes.title\n  const tags = (options.tags && options.tags.split(',')) || matter.attributes.tags\n  const publication = options.publication || matter.attributes.publication\n  const canonicalUrl = options.canonicalUrl || matter.attributes.canonicalUrl || ''\n  const license = checkLicense(options.license || matter.attributes.license)\n\n  var content = `\n  # ${title}\n\n  ${matter.body}\n\n  `\n\n  if (!title && getTitle(src)) {\n    title = getTitle(src).text\n    content = matter.body\n  }\n\n  if (canonicalUrl.length) {\n    content += `\n*Cross-posted from [${canonicalUrl}](${canonicalUrl}).*\n    `\n  }\n  </prepare_content>\n\n  <user_authentication_and_post>\n  client.getUser((err, user) => {\n    <handle_errors>\n    if (err) {\n      throw new Error(err)\n    } </handle_errors>\n\n    console.log(`Authenticated as ${user.username}`.blue)\n\n    const options = {\n      userId: user.id,\n      title,\n      tags,\n      content,\n      canonicalUrl,\n      license,\n      contentFormat: 'markdown',\n      publishStatus: 'draft'\n    }\n\n    const successMsg = `Draft post \"${title}\" published to Medium.com`.green\n\n    <publish_to_publication>\n    if (publication) {\n      client.getPublicationsForUser({userId: user.id}, (err, publications) => {\n        if (err) {\n          throw new Error(err)\n        }\n        const myPub = publications.filter((val) => { return val.name === publication })\n        if (myPub.length === 0) {\n          throw new Error('No publication by that name!')\n        }\n        client.createPostInPublication(Object.assign(options, {publicationId: myPub[0].id}), (err, post) => {\n          if (err) {\n            throw new Error(err)\n          }\n          console.log(successMsg)\n          open(post.url)\n        })\n      })\n    </publish_to_publication>\n    <publish_to_user>\n    else {\n      client.createPost(options, (err, post) => {\n        if (err) {\n          throw new Error(err)\n        }\n        console.log(successMsg)\n        open(post.url)\n      })\n    }\n    </publish_to_user>\n  })\n  </user_authentication_and_post>\n}\n"], ["generateQuestions", "\nfunction generateQuestions(config = {}, questions = {}) {\n  const questionKeys = Object.keys(questions)\n\n  <return_all_questions>\n  if (!config) {\n    return questionKeys.map(question => questions[question])\n  }\n  </return_all_questions>\n\n  <generate_custom_questions>\n  if (config.type === 'custom') {\n    return generateQuestionsCustom(config, questions)\n  }\n  </generate_custom_questions>\n  \n  <filter_and_return_questions>\n  const filteredQuestions = []\n  questionKeys.forEach((question) => {\n    if (!(question in config)) {\n      filteredQuestions.push(questions[question])\n    }\n  })\n\n  return filteredQuestions\n  </filter_and_return_questions>\n}\n"], ["normalizeText", "\nfunction normalizeText(text, start, end, removeTrailingSemiColons) {\n  var trimmedText;\n\n  <trim_left>\n  trimmedText = _.trimLeft(text);\n\n  if (trimmedText.length < text.length) {\n    start += (text.length - trimmedText.length);\n  }\n\n  text = trimmedText;\n  </trim_left>\n  \n  <trim_right>\n  trimmedText = _.trimRight(text);\n\n  if (trimmedText.length < text.length) {\n    end -= (text.length - trimmedText.length);\n  }\n\n  text = trimmedText;\n  </trim_right>\n  \n  <remove_semicolons>\n  if (removeTrailingSemiColons) {\n    trimmedText = _.trimRight(text, ';');\n\n    if (trimmedText.length < text.length) {\n      end -= (text.length - trimmedText.length);\n    }\n  }\n  </remove_semicolons>\n\n  return {\n    text: trimmedText,\n    start: start,\n    end: end\n  };\n}\n"], ["f_teklif_onay_durum_idsi", "\nfunction f_teklif_onay_durum_idsi(_olay) {\n  <determine_teklif_type>\n  var tipi = \"\";\n  switch (_olay) {\n    case schema.SABIT.OLAY.TEKLIF_KAZANDI:\n    {\n      tipi = schema.SABIT.ONAY_DURUM.teklif.KAZANDI;\n    }\n      break;\n    case schema.SABIT.OLAY.TEKLIF_IHALEDEN_ATILDI:\n    {\n      tipi = schema.SABIT.ONAY_DURUM.teklif.IHALEDEN_ATILDI;\n    }\n      break;\n    case schema.SABIT.OLAY.TEKLIF_REDDEDILDI:\n    {\n      tipi = schema.SABIT.ONAY_DURUM.teklif.REDDEDILDI;\n    }\n      break;\n    default:\n      throw \"Gelen olaya uygun teklif onay durumu bulunamad\u0131!\";\n      break;\n  }\n  </determine_teklif_type>\n  return tipi;\n}\n"], "```"]