[["getStat", "\nfunction getStat(type, name, granCode, fromDate, toDate, callback) {\n  <checkGranCode>\n  if(!granCode) throw new Error('granCode is required');\n  </checkGranCode>\n\n  <assignToDateIfCallbackIsFunction>\n  if(!callback && typeof toDate == 'function') {\n    callback = toDate;\n    toDate = Date.now();\n  }\n  </assignToDateIfCallbackIsFunction>\n\n  <getGranularity>\n  var gran = granMap[granCode] || util.getUnitDesc(granCode);\n  if(!gran) throw new Error('Granularity is not defined ' + granCode);\n  </getGranularity>\n\n  <convertDatesToTimestamps>\n  if(fromDate instanceof Date) fromDate = fromDate.getTime();\n  if(toDate instanceof Date) toDate = toDate.getTime();\n  </convertDatesToTimestamps>\n\n  <setDefaultDates>\n  toDate = toDate || Date.now()\n  fromDate = fromDate || (toDate - util.getTimePeriod(gran, points));\n  </setDefaultDates>\n\n  <prepareRedisQuery>\n  var unitPeriod = gran[0];\n  var multi = redis.multi();\n  var _points = [];\n  for(var d = fromDate; d <= toDate; d += unitPeriod) {\n    var key = getGranKey(name, gran, d);\n    _points.push(util.getKeyTime(gran, d));\n    multi.hget(key, type);\n  }\n  </prepareRedisQuery>\n\n  <executeRedisQuery>\n  multi.exec(function(err, results) {\n    if(err) return callback(err);\n    var merged = [];\n    for (var i = 0, l = _points.length, p; i < l; i ++) {\n      p = _points[i];\n      merged[i] = [p, Number(results[i])];\n    }\n    callback(null, {\n        step: unitPeriod\n        , unitType: gran[3]\n        , data: merged\n    });\n  });\n  </executeRedisQuery>\n}\n"], ["copyToClipBoard", "\nfunction copyToClipBoard(content) {\n  <copyContentToClipboardBasedOnOS>\n  switch (process.platform) {\n  case 'darwin':\n    var child = spawn('pbcopy', []);\n    child.stdin.end(new Buffer(content, 'utf8'));\n    return true;\n  default:\n    return false;\n  }\n  </copyContentToClipboardBasedOnOS>\n}\n"], ["unnamedFunction1", "\nfunction (route) {\n  <compileHostAndPathPatterns>\n  var staticPrefix = null;\n  var hostVariables = [];\n  var pathVariables = [];\n  var variables = [];\n  var tokens = [];\n  var regex = null;\n  var hostRegex = null;\n  var hostTokens = [];\n  var host;\n\n  <compileHostPattern>\n  if ('' !== (host = route.domain())) {\n      var result = compilePattern(route, host, true);\n      hostVariables = result['variables'];\n      variables = variables.concat(hostVariables);\n      hostTokens = result['tokens'];\n      hostRegex = result['regex'];\n  }\n  </compileHostPattern>\n\n  <compilePathPattern>\n  var path = route.getPath();\n  result = compilePattern(route, path, false);\n  staticPrefix = result['staticPrefix'];\n  pathVariables = result['variables'];\n  variables = variables.concat(pathVariables);\n  tokens = result['tokens'];\n  regex = result['regex'];\n  </compilePathPattern>\n\n  <returnCompiledRoute>\n  return new CompiledRoute(\n      staticPrefix,\n      regex,\n      tokens,\n      pathVariables,\n      hostRegex,\n      hostTokens,\n      hostVariables,\n      _.uniq(variables)\n  );\n  </returnCompiledRoute>\n  </compileHostAndPathPatterns>\n}\n"], ["unnamedFunction2", "\nfunction (chart, userOptions) {\n  <setupAxisConfiguration>\n  var isXAxis = userOptions.isX,\n    axis = this;\n  axis.horiz = chart.inverted ? !isXAxis : isXAxis;\n  axis.isXAxis = isXAxis;\n  axis.coll = isXAxis ? 'xAxis' : 'yAxis';\n  axis.opposite = userOptions.opposite;\n  axis.side = userOptions.side || (axis.horiz ? (axis.opposite ? 0 : 2) : (axis.opposite ? 1 : 3));\n  \n  axis.setOptions(userOptions);\n  </setupAxisConfiguration>\n\n  <assignVariousOptions>\n  var options = this.options,\n    type = options.type,\n    isDatetimeAxis = type === 'datetime';\n  axis.userOptions = userOptions;\n  axis.minPixelPadding = 0;\n  axis.chart = chart;\n  axis.reversed = options.reversed;\n  axis.zoomEnabled = options.zoomEnabled !== false;\n  axis.categories = options.categories || type === 'category';\n  axis.names = [];\n  axis.isLog = type === 'logarithmic';\n  axis.isDatetimeAxis = isDatetimeAxis;\n  axis.isLinked = defined(options.linkedTo);\n  axis.tickmarkOffset = (axis.categories && options.tickmarkPlacement === 'between' && pick(options.tickInterval, 1) === 1) ? 0.5 : 0;\n  axis.ticks = {};\n  axis.labelEdge = [];\n  axis.minorTicks = {};\n  axis.plotLinesAndBands = [];\n  axis.alternateBands = {};\n  axis.len = 0;\n  axis.minRange = axis.userMinRange = options.minRange || options.maxZoom;\n  axis.range = options.range;\n  axis.offset = options.offset || 0;\n  axis.stacks = {};\n  axis.oldStacks = {};\n  axis.max = null;\n  axis.min = null;\n  axis.crosshair = pick(options.crosshair, splat(chart.options.tooltip.crosshairs)[isXAxis ? 0 : 1], false);\n  </assignVariousOptions>\n\n  <processEventsAndFinalSetup>\n  var eventType,\n    events = axis.options.events;\n  if (inArray(axis, chart.axes) === -1) {\n    if (isXAxis && !this.isColorAxis) {\n      chart.axes.splice(chart.xAxis.length, 0, axis);\n    } else {\n      chart.axes.push(axis);\n    }\n    chart[axis.coll].push(axis);\n  }\n  axis.series = axis.series || [];\n  if (chart.inverted && isXAxis && axis.reversed === UNDEFINED) {\n    axis.reversed = true;\n  }\n  axis.removePlotBand = axis.removePlotBandOrLine;\n  axis.removePlotLine = axis.removePlotBandOrLine;\n  for (eventType in events) {\n    addEvent(axis, eventType, events[eventType]);\n  }\n  if (axis.isLog) {\n    axis.val2lin = log2lin;\n    axis.lin2val = lin2log;\n  }\n  </processEventsAndFinalSetup>\n}\n"], ["startNode", "\nfunction startNode(node) {\n  <initializeNavigationNode>\n  var navNode = emptyNavigationBarNode(node);\n  pushChild(parent, navNode);\n  </initializeNavigationNode>\n\n  <updateParentsStack>\n  parentsStack.push(parent);\n  parent = navNode;\n  </updateParentsStack>\n}\n"], ["resolveUse", "\nfunction resolveUse (appendList, increment, options, resolver) {\n  <resolveUseClosure>\n  return function resolveUseClosure (value) {\n    <earlyReturnIfSettled>\n    if (resolver.settled && !options.updateAfterSettlement) {\n      return;\n    }\n    </earlyReturnIfSettled>\n\n    <updateResolverAndPromise>\n    var promise = resolver.promise;\n    resolver[appendList].push(value);\n    promise[increment] += 1;\n    promise.pending -= 1;\n    </updateResolverAndPromise>\n\n    <resumeSubscriptionIfApplicable>\n    if (resolver.i >= 0) {\n      var resume = resolver.resume;\n      resumeSubscriptionDispatcher(\n        resume.topic, resume.data, options, resume.subscriptions,\n        resolver, resume.fulfill, resume.reject\n      );\n      return;\n    }\n    </resumeSubscriptionIfApplicable>\n\n    <evaluateLatchForResolver>\n    evaluateLatch(resolver, options);\n    </evaluateLatchForResolver>\n  };\n  </resolveUseClosure>\n}\n"], ["finalizeRequest", "\nfunction(request, callback, response_middlewares) {\n  <executeRequestAndCallMiddlewares>\n  var that = this;\n  request.finalize(function(err, res) {\n    if (err) callback(err, null);\n    else that._callResponseMiddlewares(response_middlewares, res, callback);\n  });\n  </executeRequestAndCallMiddlewares>\n}\n"], ["makeInstance", "\nfunction makeInstance(constructor, constructorOpt, args) {\n  <defineInstantiationProcedure>\n  function F() {\n    return constructor.apply(this, args);\n  }\n  F.prototype = constructor.prototype;\n  </defineInstantiationProcedure>\n\n  <instantiateAndCaptureStackTrace>\n  var errInstance = new F();\n  Error.captureStackTrace(errInstance, constructorOpt);\n  </instantiateAndCaptureStackTrace>\n\n  <returnInstance>\n  return errInstance;\n  </returnInstance>\n}\n"], ["_sha1", "\nfunction _sha1() {\n  <createAndDigestSha1>\n  var sha = forge.md.sha1.create();\n  var num = arguments.length;\n  for (var i = 0; i < num; ++i) {\n    sha.update(arguments[i]);\n  }\n  return sha.digest();\n  </createAndDigestSha1>\n}\n"], ["unnamedFunction3", "\nfunction (opts) {\n  <initializeProperties>\n  this.options = opts || {};\n  this.pattern = null;\n  this.middleware = {};\n  this.includes = {};\n  this.excludes = {};\n  this.files = [];\n  this.fns = [];\n  </initializeProperties>\n\n  <attachHelpers>\n  options(this);\n  iterators(this);\n  symlinks(this);\n  readers(this);\n  </attachHelpers>\n}\n"], "```"]