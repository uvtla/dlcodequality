[["queryWorksheet", "\nasync function queryWorksheet(workSheetInfo, query, options) {\n    <createIdentifierKey>\n    var key = util.createIdentifier(\n        workSheetInfo.worksheetId,\n        JSON.stringify(query)\n    );\n    </createIdentifierKey>\n\n    <prepareOptions>\n    options = options || {};\n    options.query = query;\n    </prepareOptions>\n\n    <fetchData>\n    return await fetchData(\n        key,\n        api.converter.queryResponse,\n        () => {\n            <extendWithQueryRequest>\n            let payload = util._extend(\n                workSheetInfo,\n                api.converter.queryRequest(options)\n            );\n            </extendWithQueryRequest>\n\n            <executeRequest>\n            return executeRequest('query_worksheet', payload);\n            </executeRequest>\n        });\n}\n</fetchData>\n"], ["parse_uri", "\nfunction parse_uri(uri = document.location) {\n    <initializeOptions>\n    const options = {\n        strictMode: false,\n        key: [\n            \"source\",   \n            \"protocol\",\n            \"authority\", \n            \"userInfo\", \n            \"user\",\n            \"password\",\n            \"host\",\n            \"port\",\n            \"relative\", \n            \"path\",\n            \"directory\",\n            \"file\",\n            \"query\",\n            \"anchor\"\n        ],\n        query: {\n            name: \"parameters\",\n            parser: /(?:^|&)([^&=]*)=?([^&]*)/g\n        },\n        parser: {\n            strict: /^(?:([^:\\/?#]+):)?(?:\\/\\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\\/?#]*)(?::(\\d*))?))?((((?:[^?#\\/]*\\/)*)([^?#]*))(?:\\?([^#]*))?(?:#(.*))?)/,\n            loose:  /^(?:(?![^:@]+:[^:@\\/]*@)([^:\\/?#.]+):)?(?:\\/\\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\\/?#]*)(?::(\\d*))?)(((\\/(?:[^?#](?![^?#\\/]*\\.[^?#\\/.]+(?:[?#]|$)))*\\/?)?([^?#\\/]*))(?:\\?([^#]*))?(?:#(.*))?)/\n        }\n    }\n    </initializeOptions>\n\n    <uriMatchParsing>\n    var matches = options.parser[options.strictMode ? \"strict\" : \"loose\"].exec(uri)\n    </uriMatchParsing>\n\n    <buildResult>\n    const result = {}\n    let i = 14\n    while (i--) {\n        result[options.key[i]] = matches[i] || \"\"\n    }\n    </buildResult>\n\n    <parseQueryParameters>\n    result[options.query.name] = {}\n    result[options.key[12]].replace(options.query.parser, function ($0, $1, $2) {\n        if ($1) {\n            result[options.query.name][$1] = $2\n        }\n    })\n    </parseQueryParameters>\n\n    return result\n}\n"], ["demuxSsa", "\nfunction demuxSsa (params, cb) {\n  <assertParamTypes>\n  assert.equal(typeof params, 'object')\n  assert.equal(typeof params._ssa, 'object')\n  assert.equal(typeof cb, 'function')\n  </assertParamTypes>\n\n  <unpackAndCallbackExecution>\n  const req = params._ssa.req\n  const res = params._ssa.res\n  const nw = xtend(params)\n  delete nw._ssa\n  </unpackAndCallbackExecution>\n\n  <executeCallback>\n  cb(req, res, nw)\n  </executeCallback>\n}\n"], ["hamming", "\nfunction hamming( a, b, clbk ) {\n    <validateInputs>\n    var aType = isString( a ),\n        bType = isString( b ),\n        len,\n        d, i;\n    if ( !isArray( a ) && !aType ) {\n        throw new TypeError( 'hamming()::invalid input argument. Sequence must be either an array or a string. Value: `' + a + '`.' );\n    }\n    if ( !isArray( b ) && !bType ) {\n        throw new TypeError( 'hamming()::invalid input argument. Sequence must be either an array or a string. Value: `' + b + '`.' );\n    }\n    if ( aType !== bType ) {\n        throw new TypeError( 'hamming()::invalid input arguments. Sequences must be the same type; i.e., both strings or both arrays.' );\n    }\n    if ( arguments.length > 2 ) {\n        if ( !isFunction( clbk ) ) {\n            throw new TypeError( 'hamming()::invalid input argument. Accessor must be a function. Value: `' + clbk + '`.' );\n        }\n    }\n    len = a.length;\n    if ( len !== b.length ) {\n        throw new Error( 'hamming()::invalid input arguments. Sequences must be the same length.' );\n    }\n    </validateInputs>\n\n    <calculateHammingDistance>\n    d = 0;\n    if ( clbk ) {\n        for ( i = 0; i < len; i++ ) {\n            if ( clbk( a[i], i, 0 ) !== clbk( b[i], i, 1 ) ) {\n                d += 1;\n            }\n        }\n    } else {\n        for ( i = 0; i < len; i++ ) {\n            if ( a[ i ] !== b[ i ] ) {\n                d += 1;\n            }\n        }\n    }\n    </calculateHammingDistance>\n\n    return d;\n}\n"], ["includesAtLoader", "\nfunction includesAtLoader(graph) {\n  var found = false;\n\n  <defineHelper>\n  var isAtLoader = function(name) {\n    return name === \"@loader\";\n  };\n  </defineHelper>\n\n  <iterateOverGraphNodes>\n  keys(graph).forEach(function(name) {\n    <excludeNodeFromBuild>\n    var node = graph[name];\n    if (isPluginExcludedFromBuild(node)) {\n      return;\n    }\n    </excludeNodeFromBuild>\n\n    <checkAtLoader>\n    if (isAtLoader(name)) {\n      return (found = true);\n    }\n    </checkAtLoader>\n\n    <checkDependenciesForAtLoader>\n    defaultTo(node.dependencies, []).forEach(function(depName) {\n      if (isAtLoader(depName)) {\n        return (found = true);\n      }\n    });\n    </checkDependenciesForAtLoader>\n  });\n  </iterateOverGraphNodes>\n\n  return found;\n}\n"], ["BaseCoverArt", "\nfunction BaseCoverArt(options) {\n  <setDefaultOptions>\n  options = options || {};\n  </setDefaultOptions>\n\n  <initializeProperties>\n  this.userAgent = options.userAgent || _userAgent;\n  this.host = _host;\n  this.basePath = _path;\n  this.http = _http;\n  </initializeProperties>\n}\n"], ["directives", "\nfunction directives() {\n  var i, p, pn;\n\n  <directiveLoop>\n  for (;;) {\n    <checkForString>\n    if (state.tokens.next.id === \"(string)\") {\n      <peekNextToken>\n      p = peek(0);\n      if (p.id === \"(endline)\") {\n        i = 1;\n        <skipEndLines>\n        do {\n          pn = peek(i);\n          i = i + 1;\n        } while (pn.id === \"(endline)\");\n        </skipEndLines>\n\n        <checkForMissingSemicolon>\n        if (pn.id !== \";\") {\n          <breakIfNotSpecificTokens>\n          if (pn.id !== \"(string)\" && pn.id !== \"(number)\" &&\n              pn.id !== \"(regexp)\" && pn.identifier !== true &&\n              pn.id !== \"}\") {\n            break;\n          }\n          </breakIfNotSpecificTokens>\n          <warnForMissingSemicolon>\n          warning(\"W033\", state.tokens.next);\n          </warnForMissingSemicolon>\n        } else {\n          p = pn;\n        }\n      </peekNextToken>\n      </checkForString>\n      <checkForEndOrMissingSemicolon>\n      else if (p.id === \"}\") {\n        <warnForMissingSemicolonInBlock>\n        warning(\"W033\", p);\n        </warnForMissingSemicolonInBlock>\n      } else if (p.id !== \";\") {\n        break;\n      }\n      </checkForEndOrMissingSemicolon>\n\n      <advanceAndUpdateDirective>\n      advance();\n      if (state.directive[state.tokens.curr.value]) {\n        <warnForExistingDirective>\n        warning(\"W034\", state.tokens.curr, state.tokens.curr.value);\n        </warnForExistingDirective>\n      }\n      if (state.tokens.curr.value === \"use strict\") {\n        <setStrictMode>\n        if (!state.option[\"(explicitNewcap)\"])\n          state.option.newcap = true;\n        state.option.undef = true;\n        </setStrictMode>\n      }\n      state.directive[state.tokens.curr.value] = true;\n      if (p.id === \";\") {\n        <advanceToNextToken>\n        advance(\";\");\n        </advanceToNextToken>\n      }\n      continue;\n      </advanceAndUpdateDirective>\n    }\n    break;\n  }\n  </directiveLoop>\n}\n"], ["parseConsecutiveLists", "\nfunction parseConsecutiveLists(list, listType, trimTrailing) {\n  <initializeRegex>\n  var olRgx = (options.disableForced4SpacesIndentedSublists) ? /^ ?\\d+\\.[ \\t]/gm : /^ {0,3}\\d+\\.[ \\t]/gm,\n      ulRgx = (options.disableForced4SpacesIndentedSublists) ? /^ ?[*+-][ \\t]/gm : /^ {0,3}[*+-][ \\t]/gm,\n      counterRxg = (listType === 'ul') ? olRgx : ulRgx,\n      result = '';\n  </initializeRegex>\n\n  <parseLists>\n  if (list.search(counterRxg) !== -1) {\n    <recursiveParsing>\n    (function parseCL(txt) {\n      var pos = txt.search(counterRxg);\n      if (pos !== -1) {\n        <appendParsedList>\n        result += '\\n<' + listType + '>\\n' + processListItems(txt.slice(0, pos), !!trimTrailing) + '</' + listType + '>\\n';\n        </appendParsedList>\n        <switchListType>\n        listType = (listType === 'ul') ? 'ol' : 'ul';\n        counterRxg = (listType === 'ul') ? olRgx : ulRgx;\n        </switchListType>\n        <continueParsing>\n        parseCL(txt.slice(pos));\n        </continueParsing>\n      } else {\n        <finalizeParsing>\n        result += '\\n<' + listType + '>\\n' + processListItems(txt, !!trimTrailing) + '</' + listType + '>\\n';\n        </finalizeParsing>\n      }\n    })(list);\n    </recursiveParsing>\n  } else {\n    <singleListParsing>\n    result = '\\n<' + listType + '>\\n' + processListItems(list, !!trimTrailing) + '</' + listType + '>\\n';\n    </singleListParsing>\n  }\n  </parseLists>\n\n  return result;\n}\n"], ["functionWithNoName", "\nfunction(from, to){\n    <initializeRangeAndCellNodes>\n    var range = [], cellNodes = this._cellNodes, n = cellNodes.length;\n    if (n === 0) {\n      return range;\n    }\n    </initializeRangeAndCellNodes>\n\n    var cellNode, ordinal;\n\n    <setToIndex>\n    if (_isUnd(to) || to === -1) {\n      to = this._getCellOrdinal(cellNodes[n-1]);\n    }\n    </setToIndex>\n    <setFromIndex>\n    if (_isUnd(from) || from === -1) {\n      from = this._getCellOrdinal(cellNodes[0]);\n    }\n    </setFromIndex>\n\n    <findToIndex>\n    var toIndex = Math.min(to, n - 1);\n    while (toIndex >= 0) {\n      cellNode = cellNodes[toIndex];\n      ordinal = this._getCellOrdinal(cellNode);\n      if (ordinal <= to) {\n        break;\n      }\n      toIndex -= 1;\n    }\n    if (toIndex === -1) {\n      return range;\n    }\n    </findToIndex>\n\n    <validateFromLessThanOrdinal>\n    if (ordinal < from) {\n      return range;\n    }\n    </validateFromLessThanOrdinal>\n\n    <findFromIndex>\n    var fromIndex = Math.min(toIndex, from);\n    while (fromIndex >= 0) {\n      cellNode = cellNodes[fromIndex];\n      ordinal = this._getCellOrdinal(cellNode);\n      if (ordinal <= from) {\n        if (ordinal < from) {\n          fromIndex += 1;\n        }\n        break;\n      }\n      fromIndex -= 1;\n    }\n    if (fromIndex === -1) {\n      fromIndex = 0;\n    }\n    </findFromIndex>\n\n    <createRange>\n    var index;\n    for (index = fromIndex; index <= toIndex; index++) {\n      cellNode = cellNodes[index];\n      range.push(this._readCell(cellNode, {}));\n    }\n    </createRange>\n\n    return range;\n}\n"], ["saveContentToEntitlementsFile", "\nfunction saveContentToEntitlementsFile(content) {\n  <convertToPlist>\n  var plistContent = plist.build(content);\n  </convertToPlist>\n  <getFilePath>\n  var filePath = pathToEntitlementsFile();\n  </getFilePath>\n\n  <createDirectoryPath>\n  mkpath.sync(path.dirname(filePath));\n  </createDirectoryPath>\n\n  <writeToFile>\n  fs.writeFileSync(filePath, plistContent, 'utf8');\n  </writeToFile>\n}\n"], "```"]