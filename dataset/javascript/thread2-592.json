[["generateGeometryFromNode", "\nfunction ( geoNode, skeleton, morphTarget, preTransform ) {\n\n            var geo = new THREE.BufferGeometry();\n            <setName>\n            if ( geoNode.attrName ) geo.name = geoNode.attrName;\n            </setName>\n\n            <parseGeoNodeAndGenerateBuffers>\n            var geoInfo = this.parseGeoNode( geoNode, skeleton );\n            var buffers = this.genBuffers( geoInfo );\n            </parseGeoNodeAndGenerateBuffers>\n\n            <createAndApplyPosition>\n            var positionAttribute = new THREE.Float32BufferAttribute( buffers.vertex, 3 );\n            preTransform.applyToBufferAttribute( positionAttribute );\n            geo.addAttribute( 'position', positionAttribute );\n            </createAndApplyPosition>\n\n            <addColorAttribute>\n            if ( buffers.colors.length > 0 ) {\n                geo.addAttribute( 'color', new THREE.Float32BufferAttribute( buffers.colors, 3 ) );\n            }\n            </addColorAttribute>\n\n            <handleSkeleton>\n            if ( skeleton ) {\n                geo.addAttribute( 'skinIndex', new THREE.Uint16BufferAttribute( buffers.weightsIndices, 4 ) );\n\n                geo.addAttribute( 'skinWeight', new THREE.Float32BufferAttribute( buffers.vertexWeights, 4 ) );\n                geo.FBX_Deformer = skeleton;\n            }\n            </handleSkeleton>\n\n            <addNormalAttribute>\n            if ( buffers.normal.length > 0 ) {\n                var normalAttribute = new THREE.Float32BufferAttribute( buffers.normal, 3 );\n                var normalMatrix = new THREE.Matrix3().getNormalMatrix( preTransform );\n                normalMatrix.applyToBufferAttribute( normalAttribute );\n                geo.addAttribute( 'normal', normalAttribute );\n            }\n            </addNormalAttribute>\n\n            <addUVAttributes>\n            buffers.uvs.forEach( function ( uvBuffer, i ) {\n                var name = 'uv' + ( i + 1 ).toString();\n                if ( i === 0 ) {\n                    name = 'uv';\n                }\n                geo.addAttribute( name, new THREE.Float32BufferAttribute( buffers.uvs[ i ], 2 ) );\n            } );\n            </addUVAttributes>\n\n            <addGroupsBasedOnMaterialIndex>\n            if ( geoInfo.material && geoInfo.material.mappingType !== 'AllSame' ) {\n                var prevMaterialIndex = buffers.materialIndex[ 0 ];\n                var startIndex = 0;\n                buffers.materialIndex.forEach( function ( currentIndex, i ) {\n                    if ( currentIndex !== prevMaterialIndex ) {\n                        geo.addGroup( startIndex, i - startIndex, prevMaterialIndex );\n                        prevMaterialIndex = currentIndex;\n                        startIndex = i;\n                    }\n                } );\n                </addGroupsBasedOnMaterialIndexFinalSteps>\n                if ( geo.groups.length > 0 ) {\n                    var lastGroup = geo.groups[ geo.groups.length - 1 ];\n                    var lastIndex = lastGroup.start + lastGroup.count;\n                    if ( lastIndex !== buffers.materialIndex.length ) {\n                        geo.addGroup( lastIndex, buffers.materialIndex.length - lastIndex, prevMaterialIndex );\n                    }\n                }\n                if ( geo.groups.length === 0 ) {\n                    geo.addGroup( 0, buffers.materialIndex.length, buffers.materialIndex[ 0 ] );\n                }\n                </addGroupsBasedOnMaterialIndexFinalSteps>\n            }\n            </addGroupsBasedOnMaterialIndex>\n\n            <addMorphTargets>\n            this.addMorphTargets( geo, geoNode, morphTarget, preTransform );\n            </addMorphTargets>\n\n            return geo;\n}\n"], ["parseWallets", "\nfunction parseWallets(br) {\n  const count = br.readU32();\n  const wids = new Set();\n\n  <parseWalletIDs>\n  for (let i = 0; i < count; i++)\n    wids.add(br.readU32());\n  </parseWalletIDs>\n\n  return wids;\n}\n"], ["morganLoggerSetup", "\nfunction morgan (format, options) {\n  <formatHandling>\n  var fmt = format\n  var opts = options || {}\n  if (format && typeof format === 'object') {\n    opts = format\n    fmt = opts.format || 'default'\n    deprecate('morgan(options): use morgan(' + (typeof fmt === 'string' ? JSON.stringify(fmt) : 'format') + ', options) instead')\n  }\n  if (fmt === undefined) {\n    deprecate('undefined format: specify a format')\n  }\n  </formatHandling>\n\n  <optionsSetup>\n  var immediate = opts.immediate\n  var skip = opts.skip || false\n  var formatLine = typeof fmt !== 'function'\n    ? getFormatFunction(fmt)\n    : fmt\n  var buffer = opts.buffer\n  var stream = opts.stream || process.stdout\n  </optionsSetup>\n\n  <bufferStreamSetup>\n  if (buffer) {\n    deprecate('buffer option')\n    var interval = typeof buffer !== 'number'\n      ? DEFAULT_BUFFER_DURATION\n      : buffer\n    stream = createBufferStream(stream, interval)\n  }\n  </bufferStreamSetup>\n\n  return <createLoggerMiddleware>\n  function logger (req, res, next) {\n    <initializeRequestResponse>\n    req._startAt = undefined\n    req._startTime = undefined\n    req._remoteAddress = getip(req)\n    res._startAt = undefined\n    res._startTime = undefined\n    </initializeRequestResponse>\n\n    <recordStartTime>\n    recordStartTime.call(req)\n    </recordStartTime>\n\n    function <logRequestFunction>logRequest () {\n      if (skip !== false && skip(req, res)) {\n        debug('skip request')\n        return\n      }\n      var line = formatLine(morgan, req, res)\n      if (line == null) {\n        debug('skip line')\n        return\n      }\n      debug('log request')\n      stream.write(line + '\\n')\n    };\n    </logRequestFunction>\n\n    <handleImmediateLogging>\n    if (immediate) {\n      logRequest()\n    } else {\n      onHeaders(res, recordStartTime)\n      onFinished(res, logRequest)\n    }\n    </handleImmediateLogging>\n\n    next()\n  }\n  </createLoggerMiddleware>\n}\n"], ["skipIndex", "\nfunction skipIndex() {\n\t\t<trimArrayTypeIndicator>\n\t\tif( childType && childType.indexOf('[]') === childType.length-2 ) {\n\t\t\tchildType = childType.substring(0, childType.length-2);\n\t\t}\n\t\t</trimArrayTypeIndicator>\n}\n"], ["createHash", "\nfunction hashMany(obj) {\n    <initialHashCalculation>\n    var h = hash(obj, false);\n    </initialHashCalculation>\n\n    <combineHashArguments>\n    if (arguments.length > 1) {\n        var len = arguments.length,\n            i = 0;\n        while (i < len) {\n            h = combineHash(h, hash(arguments[i++], false));\n        }\n    }\n    </combineHashArguments>\n\n    return h;\n}\n"], ["buildChildrenItems", "\nfunction buildChildren(reflection, parent) {\n                    <sortModules>\n                    var modules = reflection.getChildrenByKind(td.models.ReflectionKind.SomeModule);\n                    modules.sort(function (a, b) {\n                        return a.getFullName() < b.getFullName() ? -1 : 1;\n                    });\n                    </sortModules>\n                    <iterateAndBuild>\n                    modules.forEach(function (reflection) {\n                        var item = output.NavigationItem.create(reflection, parent);\n                        includeDedicatedUrls(reflection, item);\n                        buildChildren(reflection, item);\n                    });\n                    </iterateAndBuild>\n}\n"], ["routeBinding", "\nfunction bind(method, path, controller, action) {\n    <lookupControllerHandler>\n    let handler = controllerRegistry[controller] && controllerRegistry[controller][action]\n    if (!handler) {\n      console.warn(`can't bind route ${ path } to unknown action ${ controller }.${ action }`)\n      return\n    }\n    </lookupControllerHandler>\n\n    <getAndApplyPolicy>\n    const policyName = LocalUtil.getPolicyName(policy, controller, action)\n    let currentPolicy\n    if (policyName) currentPolicy = policyRegistry[policyName]\n    if (currentPolicy) {\n      router[method](path, currentPolicy, handler)\n    } else {\n      router[method](path, handler)\n    }\n    </getAndApplyPolicy>\n}\n"], ["calculateSRPClientS", "\nfunction client_getS(params, k_num, x_num, a_num, B_num, u_num) {\n  <assertions>\n  assertIsBigInteger(k_num);\n  assertIsBigInteger(x_num);\n  assertIsBigInteger(a_num);\n  assertIsBigInteger(B_num);\n  assertIsBigInteger(u_num);\n  if((zero.compareTo(B_num) > 0) && (N.compareTo(B_num) < 0))\n    throw new Error(\"invalid server-supplied 'B', must be 1..N-1\");\n  </assertions>\n  <calculateSecret>\n  var S_num = B_num.subtract(k_num.multiply(params.g.modPow(x_num, params.N))).modPow(a_num.add(u_num.multiply(x_num)), params.N).mod(params.N);\n  </calculateSecret>\n\n  return <padSecret>\n  padToN(S_num, params);\n  </padSecret>\n}\n"], ["logMessage", "\nfunction log(msg) {\n  <writeTime>\n  process.stdout.write(time + ' ');\n  </writeTime>\n  <logColoredMessage>\n  console.log(colors.log(msg));\n  </logColoredMessage>\n}\n"], ["createGroupByBehavior", "\nfunction(behavior) {\n    return <createGroupByFunction>\n    function(obj, iteratee, context) {\n      var result = {};\n      iteratee = _.iteratee(iteratee, context);\n      <applyBehaviorToEach>\n      _.each(obj, function(value, index) {\n        var key = iteratee(value, index, obj);\n        behavior(result, value, key);\n      });\n      </applyBehaviorToEach>\n      return result;\n    };\n    </createGroupByFunction>\n  }\n"], "```"]