[["f_todo_secildi", "\nfunction f_todo_secildi(_uyari) { \n  <logging_activity>\n  l.info(\"f_todo_secildi\");\n  </logging_activity>\n\n  <create_user_ids>\n  var kullanici_idleri = f_uye_id_array(_uyari);\n  </create_user_ids>\n\n  <map_and_process>\n  return _uyari.RENDER.Sonuc.Data.map(function (_elm) {\n    <generate_details>\n    var detay = f_detay_olustur(schema.SABIT.UYARI.TODO, _uyari, _elm);\n    </generate_details>\n    \n    <add_and_process_alert_result>\n    return f_uyari_sonucu_ekle(detay)\n      .then(function (_id) {\n        <require_database_task>\n        var db_gorev = require('./db_gorev');\n        </require_database_task>\n        \n        <map_and_add_task>\n        return kullanici_idleri.mapX(null, db_gorev.f_db_gorev_ekle, _id).allX();\n        </map_and_add_task>\n      });\n    </add_and_process_alert_result>\n  }).allX();\n  </map_and_process>\n}\n"], ["prependTo", "\nfunction prependTo(newNode, parentNode, siblingNode) {\n  parentNode.insertBefore(newNode, siblingNode || parentNode.firstChild);\n}\n"], ["generateUniqueKey", "\nfunction generateUniqueKey(index, initialKey) {\n  <initialize_key_and_counter>\n  var currentCandidate = initialKey;\n  var counter = 0;\n  </initialize_key_and_counter>\n\n  <key_conflict_resolution>\n  while (index[currentCandidate]) {\n    var numberAtEndOfKeyMatches = currentCandidate.match(NUMBER_AT_END_OF_KEY_REGEX);\n    if (numberAtEndOfKeyMatches !== null) {\n      var nextNumber = parseInt(numberAtEndOfKeyMatches[1], 10) + 1;\n      currentCandidate = currentCandidate.replace(NUMBER_AT_END_OF_KEY_REGEX, \"(\" + nextNumber + \")\");\n    } else {\n      currentCandidate += \" (1)\";\n    }\n    \n    counter++;\n    if (counter >= 100000) {\n      throw new DeveloperError(\"Was not able to find a unique key for \" + initialKey + \" after 100000 iterations.\" +\n      \" This is probably because the regex for matching keys was somehow unable to work for that key.\");\n    }\n  }\n  </key_conflict_resolution>\n\n  return currentCandidate;\n}\n"], ["AsyncSlice", "\nfunction AsyncSlice(category, title, colorId, start, args, duration, opt_isTopLevel, opt_cpuStart, opt_cpuDuration,\n                      opt_argsStripped) {\n    tr.model.TimedEvent.call(this, start);\n\n    <initialization>\n    this.category = category || '';\n    this.originalTitle = title;\n    this.title = title;\n    this.colorId = colorId;\n    this.args = args;\n    this.startStackFrame = undefined;\n    this.endStackFrame = undefined;\n    this.didNotFinish = false;\n    this.important = false;\n    this.subSlices = [];\n    this.parentContainer = undefined;\n\n    this.id = undefined;\n    this.startThread = undefined;\n    this.endThread = undefined;\n    this.cpuStart = undefined;\n    this.cpuDuration = undefined;\n    this.argsStripped = false;\n\n    this.startStackFrame = undefined;\n    this.endStackFrame = undefined;\n\n    this.duration = duration;\n    this.isTopLevel = (opt_isTopLevel === true);\n    </initialization>\n\n    <optional_parameters>\n    if (opt_cpuStart !== undefined) this.cpuStart = opt_cpuStart;\n    if (opt_cpuDuration !== undefined) this.cpuDuration = opt_cpuDuration;\n    if (opt_argsStripped !== undefined) this.argsStripped = opt_argsStripped;\n    </optional_parameters>\n}\n"], ["_toBuffer", "\nfunction _toBuffer(buffer) {\n    <buffer_initialization>\n    var _buffer, nums;\n\n    if (Buffer.isBuffer(buffer)) {\n        _buffer = new Buffer(buffer.length);\n        buffer.copy(_buffer);\n    } else if (Array.isArray(buffer)) {\n        _buffer = new Buffer(buffer);\n    } else if (typeof buffer === 'string') {\n        nums = buffer.replace(/^0x/i, '').match(/.{1,2}(?=(..)+(?!.))|..?$/g);\n        _buffer = new Buffer(nums.length);\n\n        _buffer.fill(0);\n\n        <parse_and_write_nums_to_buffer>\n        for (var i = nums.length - 1; i >= 0; i--) {\n            _buffer.writeUInt8(parseInt(nums[i], 16), i);\n        }\n        </parse_and_write_nums_to_buffer>\n    }\n    </buffer_initialization>\n\n    return _buffer;\n}\n"], ["splitValue", "\nfunction splitValue(value, separator) {\n    <prepare_regexp>\n    var separatorRegexp = new RegExp(separator);\n    var escapedSeparatorRegexp = new RegExp('\\\\\\\\' + separator, 'g');\n    </prepare_regexp>\n\n    <escape_and_split>\n    value = value.replace(escapedSeparatorRegexp, '\u03a9\u03a9\u03a9');\n    if (value.match(separatorRegexp)) {\n        value = value.split(separator);\n\n        <un_escape_split_values>\n        value = value.map(function (item) {\n            return item.replace(/\u03a9\u03a9\u03a9/g, separator);\n        });\n        </un_escape_split_values>\n    } else {\n        value = value.replace(/\u03a9\u03a9\u03a9/g, separator);\n    }\n    </escape_and_split>\n    \n    return value;\n}\n"], ["unnamed_location_handler", "\nfunction() {\n  <initialization_and_checks>\n  var location = this.options.location, latLng;\n  if (!location) { return; }\n  </initialization_and_checks>\n\n  <location_processing>\n  if (typeof location == 'string') {\n    this.find(location);\n    return;\n  }\n  if (location instanceof Array) {\n    latLng = new google.maps.LatLng(location[0], location[1]);\n  }\n  if (location instanceof google.maps.LatLng){\n    latLng = location;\n  }\n  </location_processing>\n\n  <update_map_and_marker>\n  if (latLng){\n    if (this.map){ this.map.setCenter(latLng); }\n    if (this.marker){ this.marker.setPosition(latLng); }\n  }\n  </update_map_and_marker>\n}\n"], ["CompositeDisposable", "\nfunction CompositeDisposable () {\n  <argument_handling>\n  var args = [], i, len;\n  if (Array.isArray(arguments[0])) {\n    args = arguments[0];\n    len = args.length;\n  } else {\n    len = arguments.length;\n    args = new Array(len);\n    for(i = 0; i < len; i++) { args[i] = arguments[i]; }\n  }\n  this._disposables = args;\n  </argument_handling>\n  \n  <properties_initialization>\n  this.isDisposed = false;\n  this.length = args.length;\n  </properties_initialization>\n}\n"], ["computeFactorial", "\nfunction computeFactorial(number) {\n    <validate_and_prepare_number>\n    number = Number(number);\n    if (!(_regex.regex.positiveInteger.test(String(number)) || number === 0)) {\n        throw new Error(\"number should be 0 or positiveNumber but got \" + number);\n    }\n    if (number === 0) {\n        return 1;\n    }\n    </validate_and_prepare_number>\n\n    <calculate_factorial>\n    var result = 1;\n    for (var i = 2; i <= number; i++) {\n        result *= i;\n    }\n    </calculate_factorial>\n\n    return result;\n}\n"], ["reset_deprecated_application_instance", "\nfunction () {\n  <assert_globals_mode>\n  _emberMetalDebug.assert('Calling reset() on instances of `Ember.Application` is not supported when globals mode is disabled; call `visit()` to create new `Ember.ApplicationInstance`s and dispose them via their `destroy()` method instead.', this._globalsMode && this.autoboot);\n  </assert_globals_mode>\n\n  <initialize_and_destroy>\n  var instance = this.__deprecatedInstance__;\n  this._readinessDeferrals = 1;\n  this._bootPromise = null;\n  this._bootResolver = null;\n  this._booted = false;\n\n  \n  <handle_reset>\n  function handleReset() {\n    _emberMetalRun_loop.default(instance, 'destroy');\n    this._buildDeprecatedInstance();\n    _emberMetalRun_loop.default.schedule('actions', this, '_bootSync');\n  }\n  </handle_reset>\n\n  <join_run_loop>\n  _emberMetalRun_loop.default.join(this, handleReset);\n  </join_run_loop>\n}\n"], "```\n\nMost of the functions above are compliant with the Single Responsibility Principle, except for a few which are annotated with multiple responsibilities within the enclosing function. Tags are placed around blocks of code that represent different responsibilities, which involve more than just a single line or simple instruction."]