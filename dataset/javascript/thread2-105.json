[["activateControlFeature", "\nfunction() {\n    <checkActivation>\n    var activated = false;\n    if(OpenLayers.Control.prototype.activate.apply(this, arguments)) {</checkActivation>\n        <activateDrag>\n        this.dragControl.activate();</activateDrag>\n        <addMainFeature>\n        this.layer.addFeatures([this.box]);</addMainFeature>\n        <handleRotation>\n        this.rotate && this.layer.addFeatures(this.rotationHandles);</handleRotation>\n        <addHandles>\n        this.layer.addFeatures(this.handles);</addHandles>        \n        <setActivated>\n        activated = true;</setActivated>\n    }\n    <returnState>\n    return activated;</returnState>\n}\n"], ["decodeAMF3UI29", "\nfunction amf3decUI29(buf) {\n    <decodeValue>\n    var val = 0;\n    var len = 1;\n    var b;\n\n    do {\n        b = buf.readUInt8(len++);\n        val = (val << 7) + (b & 0x7F);\n    } while (len < 5 || b > 0x7F);\n\n    if (len == 5) val = val | b; </decodeValue>\n\n    <returnValue>\n    return { len: len, value: val }</returnValue>\n}\n"], ["initAudio", "\nfunction ( source ) {\n    <setDefaultValues>\n    var _this = this;\n    this.path = source ? source.src : this.path;\n\n    this.isLoaded = false;\n    this.progress = 0;</setDefaultValues>\n\n    <soundManagerLoading>\n    !window.soundManager && !smLoading && loadSM.call( this );</soundManagerLoading>\n\n    <createSoundObject>\n    if ( window.soundManager ) {\n        this.audio = soundManager.createSound({\n            id       : 'dancer' + Math.random() + '',\n            url      : this.path,\n            stream   : true,\n            autoPlay : false,\n            autoLoad : true,\n            whileplaying : function () {\n                _this.update();\n            },\n            whileloading : function () {\n                _this.progress = this.bytesLoaded / this.bytesTotal;\n            },\n            onload   : function () {\n                <onloadSetup>\n                _this.fft = new FFT( SAMPLE_SIZE, SAMPLE_RATE );\n                _this.signal = new Float32Array( SAMPLE_SIZE );\n                _this.waveform = new Float32Array( SAMPLE_SIZE );\n                _this.isLoaded = true;\n                _this.progress = 1;\n                _this.dancer.trigger( 'loaded' );</onloadSetup>\n            }\n        });\n        this.dancer.audio = this.audio;\n    }</createSoundObject>\n\n    <returnAudioObject>\n    return this.audio;</returnAudioObject>\n}\n"], ["formatLog", "\nfunction format( type, args ) {\n  <prepareLogMessage>\n  var now = new Date().toISOString(),\n    tmpl = '[%s] %s: %s\\n',\n    msg;\n\n  msg = args[ 0 ] instanceof Error ? args[ 0 ].stack :\n    util.format.apply( util, args );</prepareLogMessage>\n\n  <returnFormattedMessage>\n  return util.format( tmpl, now, type, msg );</returnFormattedMessage>\n}\n"], ["setupBanner", "\nfunction setBanner() {\n    <checkPluginReleaseMode>\n    if (grunt.config.get('app_plugins_mode_release')) {</checkPluginReleaseMode>\n        <gatherModuleInfo>\n        var moduleName = grunt.config.get('app_plugins_work_script_name') + '.js';\n        var version = grunt.config.get('app_plugins_work_version');\n        var src = path.join(\n            grunt.config.get('app_plugins_root_dir'),\n            grunt.config.get('app_plugins_work_id'),\n            grunt.config.get('plugins_www'),\n            grunt.config.get('app_plugins_work_script_name') + '.js'\n        );\n\n        var info = {\n            src: src,\n            moduleName: moduleName,\n            version: version,\n        };</gatherModuleInfo>\n\n        <configureBanner>\n        grunt.config.set('banner_info', info);\n        grunt.task.run('banner_setup');</configureBanner>\n    }\n}\n"], ["loadClusterServer", "\nfunction () {\n    <generateQuery>\n    var guid = generateGuid();\n\n    var queryString = 'guid=' + generateGuid();\n\n    queryString = ortc.appKey ? queryString + '&appkey=' + ortc.appKey : queryString;</generateQuery>\n\n    <loadClusterScript>\n    loadClusterServerScript(clusterUrl + '/?' + queryString, guid, function (clusterServerResolved, scriptGuid) {\n        if (clusterServerResolved) {\n            <setupConnection>\n            url = SOCKET_SERVER;\n            sockjs = createSocketConnection(ortc.getUrl());</setupConnection>\n        }\n\n        <clearScripts>\n        try {\n            clearScripts(scriptGuid);\n        } catch (loadError) { }</clearScripts>\n    });</loadClusterScript>\n}\n"], ["initTranslateHandling", "\nfunction initTranslate(props) {\n    <initTranslateSetup>\n    const element = props.element,\n      elementStyle = props.elementStyle,\n      curPosition = getBBox(element),\n      RESTORE_PROPS = ['display', 'marginTop', 'marginBottom', 'width', 'height'];\n    RESTORE_PROPS.unshift(cssPropTransform);\n\n    const orgTransitionProperty = elementStyle[cssPropTransitionProperty];\n    elementStyle[cssPropTransitionProperty] = 'none';\n    const fixPosition = getBBox(element);</initTranslateSetup>\n\n    <handleOriginalStyle>\n    if (!props.orgStyle) {\n        props.orgStyle = RESTORE_PROPS.reduce((orgStyle, prop) => {\n            orgStyle[prop] = elementStyle[prop] || '';\n            return orgStyle;\n        }, {});\n        props.lastStyle = {};\n    } else {\n        RESTORE_PROPS.forEach(prop => {\n            if (props.lastStyle[prop] == null || elementStyle[prop] === props.lastStyle[prop]) {\n                elementStyle[prop] = props.orgStyle[prop];\n            }\n        });\n    }</handleOriginalStyle>\n\n    <adjustDisplayInline>\n    const orgSize = getBBox(element),\n      cmpStyle = window.getComputedStyle(element, '');\n\n    if (cmpStyle.display === 'inline') {\n        elementStyle.display = 'inline-block';\n        ['Top', 'Bottom'].forEach(dirProp => {\n            const padding = parseFloat(cmpStyle[`padding${dirProp}`]);\n            elementStyle[`margin${dirProp}`] = padding ? `-${padding}px` : '0';\n        });\n    }</adjustDisplayInline>\n\n    <translateElement>\n    elementStyle[cssPropTransform] = 'translate(0, 0)';\n    let newBBox = getBBox(element);\n    const offset = props.htmlOffset =\n      {left: newBBox.left ? -newBBox.left : 0, top: newBBox.top ? -newBBox.top : 0};\n\n    elementStyle[cssPropTransform] =\n      `translate(${curPosition.left + offset.left}px, ${curPosition.top + offset.top}px)`;</translateElement>\n\n    <handleSizeAdjustment>\n    ['width', 'height'].forEach(prop => {\n        if (newBBox[prop] !== orgSize[prop]) {\n            elementStyle[prop] = orgSize[prop] + 'px';\n            newBBox = getBBox(element);\n            if (newBBox[prop] !== orgSize[prop]) {\n                elementStyle[prop] = orgSize[prop] - (newBBox[prop] - orgSize[prop]) + 'px';\n            }\n        }\n        props.lastStyle[prop] = elementStyle[prop];\n    });</handleSizeAdjustment>\n\n    <restoreTransition>\n    element.offsetWidth;\n    elementStyle[cssPropTransitionProperty] = orgTransitionProperty;\n    if (fixPosition.left !== curPosition.left || fixPosition.top !== curPosition.top) {\n        elementStyle[cssPropTransform] =\n        `translate(${fixPosition.left + offset.left}px, ${fixPosition.top + offset.top}px)`;\n    }</restoreTransition>\n\n    <returnFixedPosition>\n    return fixPosition;</returnFixedPosition>\n}\n"], ["createXMLPath", "\nfunction createPath(root, item) {\n    <generatePath>\n    var paths = item.parent.split('/'),\n        dir, prevEl, el;\n\n    if (paths && paths.length) {\n        paths.forEach(function (path, index) {\n            dir = paths.slice(0, index + 1).join('/');\n            el = root.find(dir);\n\n            if (!el) {\n                el = et.SubElement(prevEl ? prevEl : root, path, {});\n            }\n\n            prevEl = el;\n        });\n    }</generatePath>\n\n    <returnElement>\n    return root.find(item.parent || root.find('*/' + item.parent));</returnElement>\n}\n"], ["increaseVersion", "\nfunction incPnodeVersion (pnode) {\n    <updatePnodeProperties>\n    pnode._version = pnode._version ? pnode._version + 1 : 1\n    pnode._mtxid = ptree.txid\n    pnode._mtime = new Date\n    if (!pnode._ctxid) pnode._ctxid = pnode._mtxid\n    if (!pnode._ctime) pnode._ctime = pnode._mtime</updatePnodeProperties>\n    <returnUpdatedNode>\n    return pnode</returnUpdatedNode>\n}\n"], ["processCSS", "\nfunction(pathname, css, req, next) {\n    <writeCssToFile>\n    if (!self.options.bless) {\n        fs.writeFileSync(pathname, css);\n        return next();\n    }</writeCssToFile>\n    <splitWithBless>\n    self.splitWithBless(pathname, css);\n    return next();</splitWithBless>\n}\n"], "```\nSome of the functions above may appear to handle multiple responsibilities, but context is needed to verify whether they truly involve SRP violations. For instance, initializing values or preparing to return an object might be part of a function's central responsibility if the context indicates these actions to be intrinsic to the process being performed. However, actions like logging, managing external resources, or have distinctly separate concepts (e.g., operating on a database and sending emails) typically indicate SRP violations."]