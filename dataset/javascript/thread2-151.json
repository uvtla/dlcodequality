[["hasGreenkeeper", "\nfunction hasGreenkeeper (options) {\n  const config = options.data.root.config\n  <showBadgeDetermination>\n  const showBadge = !!(config && config.badges && config.badges.greenkeeper) \n  if (showBadge && !githubRepo(options)) {\n    throw new Error('Greenkeeper badge should be enabled, but no github-repo was found.')\n  }\n  </showBadgeDetermination>\n  return showBadge\n}\n"], ["calculatePosition", "\nfunction (config) {\n  var nbChoices, position = -1;\n  nbChoices = this.choicesList.length;\n\n  if (lang.isNumber(config.position) && config.position >= 0 && config.position < nbChoices) {\n    position = parseInt(config.position, 10);\n  } else if (!lang.isUndefined(config.value)) {\n    position = inputEx.indexOf(config.value, this.choicesList, function (value, opt) {\n      return opt.value === value;\n    });\n  } else if (lang.isString(config.label)) {\n    position = inputEx.indexOf(config.label, this.choicesList, function (label, opt) {\n      return opt.label === label;\n    });\n  }\n  return position;\n}\n"], ["loadEndpoints", "\nfunction loadEndpoints(endpoints, options, auth) {\n\tif (Array.isArray(endpoints)) {\n\t\tendpoints.forEach(function(endpoint) {\n\t\t\t<authenticationFilter>\n      if (auth !== Boolean(endpoint.authenticated)) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t</authenticationFilter>\n      <conditionalLoading>\n      const conditional = endpoint.hasOwnProperty(\"ifProp\");\n\t\t\tif (conditional && options.configParams.get(endpoint.ifProp) || !conditional) {\n\t\t\t\ttryLoadRouter(endpoint, options);\n\t\t\t}\n      </conditionalLoading>\n\t\t});\n\t}\n}\n"], ["writeParamsForRequestHeaders", "\nfunction writeParamsForRequestHeaders(entry, out, consumedParams) {\n  <validateParams>\n    const params = entry.params;\n    if (!(typeof params.line === 'string') ||\n        !(params.headers instanceof Array)) {\n      return;\n    }\n  </validateParams>\n  <writeHeaderLines>\n    const lineWithoutCRLF = params.line.replace(/\\r\\n$/g, '');\n    out.writeArrowIndentedLines([lineWithoutCRLF].concat(params.headers));\n  </writeHeaderLines>\n  <markConsumedParams>\n    consumedParams.line = true;\n    consumedParams.headers = true;\n  </markConsumedParams>\n}\n"], ["checkForDynamicPage", "\nfunction _checkForDynamicPage(uri, { _dynamic }) {\n  if (!_dynamic || typeof _dynamic !== 'boolean') {\n    return bluebird.reject(new Error('Page is not dynamic and requires a url'));\n  }\n  return bluebird.resolve(_dynamic);\n}\n"], ["buildSegmentList", "\nfunction() {\n    var node\n      , segs = []\n      , star;\n\n    star = this.accept('*');\n    if (star) segs.push(new nodes.Literal('*'));\n\n    while (true) {\n      <handleInterpolation>\n      if (this.accept('{')) {\n        this.state.push('interpolation');\n        segs.push(this.expression());\n        this.expect('}');\n        this.state.pop();\n      }\n      </handleInterpolation>\n      <handleDashesAndIdents>\n      else if (node = this.accept('-')){\n        segs.push(new nodes.Literal('-'));\n      } else if (node = this.accept('ident')){\n        segs.push(node.val);\n      }\n      </handleDashesAndIdents>\n      else {\n        break;\n      }\n    }\n    if (!segs.length) this.expect('ident');\n    return segs;\n}\n"], ["normalizeRoute", "\nfunction normalize(route) {\n  const normalized = { ...route };\n  <validateRoutePath>\n  if (is.not.array(normalized.path) && is.not.string(normalized.path)) {\n    throw new Error(\"The route's path must be a String or [String]\");\n  }\n  </validateRoutePath>\n  <normalizeMethod>\n  if (is.array(normalized.method)) {\n    for (let method of normalized.method) {\n      method = clean(method);\n    }\n  }\n  if (is.string(normalized.method)) {\n    normalized.method = clean(normalized.method);\n  }\n  </normalizeMethod>\n  return normalized;\n}\n"], ["parseCloudFunction", "\nfunction(name, data, options) {\n  options = options || {};\n\n  <makeRequest>\n  var request = Parse._request({\n    route: \"functions\",\n    className: name,\n    method: 'POST',\n    useMasterKey: options.useMasterKey,\n    data: Parse._encode(data, null, true)\n  });\n  </makeRequest>\n  <handleResponse>\n  return request.then(function(resp) {\n    return Parse._decode(null, resp).result;\n  })._thenRunCallbacks(options);\n  </handleResponse>\n}\n"], ["splitStyleProperty", "\nfunction splitStyleProperty(property) {\n  var token = /((?:[^\"']|\".*?\"|'.*?')*?)([(,)]|$)/g;\n  <recursiveSplit>\n  var recurse = function () {\n      var array = [];\n      for (;;) {\n          var result = token.exec(property);\n          if (result[2] === \"(\") {\n              var str = result[1].trim() + \"(\" + recurse().join(\",\") + \")\";\n              result = token.exec(property);\n              str += result[1];\n              array.push(str);\n          } else {\n              array.push(result[1].trim());\n          }\n          if (result[2] !== \",\") {\n              return array;\n          }\n      }\n  };\n  </recursiveSplit>\n  return (recurse());\n}\n"], ["mapHitDetection", "\nfunction(evt) {\n  if (evt instanceof MapBrowserEvent && !evt.dragging) {\n    <pixelDetermination>\n    const pixel = map.getEventPixel(evt.originalEvent);\n    </pixelDetermination>\n    <layerQuerying>\n    const queryable = function(layer) {\n      const visible = layer.get('visible');\n      const sourceids = layer.get('querySourceIds');\n      return visible && !!sourceids;\n    };\n    </layerQuerying>\n    <hitDetection>\n    const hit = map.forEachLayerAtPixel(pixel, () => true, undefined, queryable);\n    </hitDetection>\n    <cursorUpdate>\n    map.getTargetElement().style.cursor = hit ? 'pointer' : '';\n    </cursorUpdate>\n  }\n}\n"], "```"]