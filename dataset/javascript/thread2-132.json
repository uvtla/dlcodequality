[["inner", "\nfunction inner(A, B) {\n    <validateInput>\n    if (A.shape.length !== 1) {\n        throw new Error('A is not a 1D array');\n    }\n    if (B.shape.length !== 1) {\n        throw new Error('B is not a 1D array');\n    }\n    if (A.data.length > B.data.length) {\n        throw new Error(\"A.data.length should be <= B.data.length\");\n    }\n    </validateInput>\n    var dot = 0.0;\n    for (var i = 0; i < A.data.length; i++) {\n        dot += A.data[i] * B.data[i];\n    }\n    return dot;\n}\n"], ["anonymous", "\nfunction () {\n    this._paused = false;\n    <initializeQueue>\n    this.queue = [];\n    </initializeQueue>\n    this.onTimeout = function () {\n        <checkPaused>\n        if (this._paused)\n            return;\n        </checkPaused>\n        <processQueue>\n        if (this.queue.length == 0) {\n            <showApplication>\n            var app = atomApplication._element;\n            if (app.style.visibility == \"hidden\" || $(app).css(\"visibility\") == \"hidden\") {\n                app.style.visibility = \"visible\";\n\n                app.atomControl.updateUI();\n            }\n            </showApplication>\n            return;\n        }\n        var item = this.queue.shift();\n        \n        item();\n        </processQueue>\n\n        <setNextTimeout>\n        window.setTimeout(this._onTimeout, 1);\n        </setNextTimeout>\n    };\n\n    <setupOnTimeout>\n    var _this = this;\n    this._onTimeout = function () {\n        _this.onTimeout();\n    };\n    </setupOnTimeout>\n}\n"], ["forEach", "\nfunction forEach(stream, onData, onEnd) {\n\n  <applyBufferToStream>\n  forEachObj(stream, function (chunk) {\n    onData(new Buffer(chunk));\n  }, onEnd);\n  </applyBufferToStream>\n}\n"], ["anonymous", "\nfunction(url, opts) {\n    var that = this;\n    var buf_pos = 0;\n    <orscFunction>\n    var orsc = function (xhr, e, abort_reason) {\n        <processReadyState>\n        if (xhr.readyState === 3 || xhr.readyState === 4) {\n            <handleResponse>\n            try {\n                var responseText = xhr.responseText;\n                var status = xhr.status;\n            } catch (x) {}\n            if (responseText && status === 200) {\n                var msgs = [];\n                while (1) {\n                    var buf = responseText.slice(buf_pos);\n                    var p = buf.indexOf('\\n');\n                    if (p === -1) break;\n                    buf_pos += p+1;\n                    var msg = buf.slice(0, p);\n                    that.dispatchEvent(\n                        new SimpleEvent('message', {\n                                            data: msg,\n                                            readystate: xhr.readyState,\n                                            responsetext: responseText\n                                        }));\n                }\n            }\n            </handleResponse>\n        }\n        </processReadyState>\n        <handleRequestCompletion>\n        if (xhr.readyState === 4 || abort_reason) {\n            var reason = abort_reason ? 'user' :\n                (xhr.status === 200 ? 'network' : 'permanent');\n            that.xhr_close = null;\n            that.dispatchEvent(new SimpleEvent('close', {reason: reason}));\n        }\n        </handleRequestCompletion>\n    };\n    </orscFunction>\n    <createXhrRequest>\n    var createXhr = (opts.cors && _window.XDomainRequest) ?\n                                    utils.createXDR : utils.createXHR;\n    that.xhr_close = createXhr('POST', url, null, orsc);\n    </createXhrRequest>\n}\n"], ["parsePrimaryKey", "\nfunction parsePrimaryKey(attrPathList, context) {\n    return attrPathList.split(',').map(attrPath => parseAttributePath(attrPath, context));\n}\n"], ["anonymous", "\nfunction (nodeA, nodeB) {\n    <compareTagNames>\n    if (nodeA.tagName != nodeB.tagName) {\n        return false;\n    }\n    </compareTagNames>\n    <compareAttributes>\n    var thisAttrs = nodeA.attributes,\n        otherAttrs = nodeB.attributes;\n    if (!ie && thisAttrs.length != otherAttrs.length) {\n        return false;\n    }\n    var attrA, attrB, al = 0, bl = 0;\n    for (var i = 0; attrA = thisAttrs[i++];) {\n        if (attrA.nodeName == 'style') {\n            if (attrA.specified) {\n                al++;\n            }\n            if (domUtils.isSameStyle(nodeA, nodeB)) {\n                continue;\n            } else {\n                return false;\n            }\n        }\n        if (ie) {\n            if (attrA.specified) {\n                al++;\n                attrB = otherAttrs.getNamedItem(attrA.nodeName);\n            } else {\n                continue;\n            }\n        } else {\n            attrB = nodeB.attributes[attrA.nodeName];\n        }\n        if (!attrB.specified || attrA.nodeValue != attrB.nodeValue) {\n            return false;\n        }\n    }\n    \n    if (ie) {\n        for (i = 0; attrB = otherAttrs[i++];) {\n            if (attrB.specified) {\n                bl++;\n            }\n        }\n        if (al != bl) {\n            return false;\n        }\n    }\n    </compareAttributes>\n    return true;\n}\n"], ["localStorageTest", "\nfunction () {\n    return !!storage && function() {\n        <testStorage>\n        var success = true\n        var value = Math.random()\n        try {\n            storage.setItem(value, value)\n        } catch (e) {\n            success = false\n        }\n        </testStorage>\n        <removeTestItem>\n        storage.removeItem(value)\n        </removeTestItem>\n        return success\n    }()\n}\n"], ["debugTreeSelection", "\nfunction () {\n    var oModel = this._oDialog.getModel(\"view\"),\n        <getTreeData>\n        oTreeData = oModel.getProperty(\"/DebugModules\")[0];\n        </getTreeData>\n\n    <updateTreeData>\n    this._treeHelper.recursiveSelect(oTreeData, false);\n    this._updateTreeInfos();\n    </updateTreeData>\n}\n"], ["getCall", "\nfunction getCall() {\n    var result = _.trim(_.get(/\\*\\/\\s*(?:function\\s+)?([^\\s(]+)\\s*\\(/.exec(this.entry), 1));\n    if (!result) {\n        result = _.trim(_.get(/\\*\\/\\s*(.*?)[:=,]/.exec(this.entry), 1));\n        result = /['\"]$/.test(result)\n            ? _.trim(result, '\"\\'')\n            : result.split('.').pop().split(/^(?:const|let|var) /).pop();\n    }\n    var name = getValue(this, 'name') || result;\n    <isFunctionCheck>\n    if (!this.isFunction()) {\n        return name;\n    }\n    </isFunctionCheck>\n    var params = this.getParams();\n    result = _.castArray(result);\n\n    <combineParams>\n    _.each(params, function(param) {\n        var paramValue = param[1],\n            parentParam = _.get(/\\w+(?=\\.[\\w.]+)/.exec(paramValue), 0);\n\n        var parentIndex = parentParam == null ? -1 : _.findIndex(params, function(param) {\n        return _.trim(param[1], '[]').split(/\\s*=/)[0] == parentParam;\n        });\n\n        if (_.get(params[parentIndex], 0) != 'Object') {\n            result.push(paramValue);\n        }\n    });\n    </combineParams>\n\n    return name + '(' + result.slice(1).join(', ') + ')';\n}\n"], ["compileVueToRn", "\nfunction compileVueToRn(resource) {\n    const code = resource.toString();\n    const cparsed = compiler.parseComponent(code, { pad: 'line' });\n\n    <initializeOutput>\n    let output = '';\n    let mappings = '';\n    </initializeOutput>\n\n    <generateImports>\n    output += `import ${constants.VUE}, { observer as ${\n        constants.OBSERVER\n        } } from 'vue-native-core'`;\n    output += '\\n';\n\n    output += `import ${constants.REACT_NATIVE} from 'react-native'`;\n    output += '\\n';\n\n    output += `import ${constants.PROP_TYPE} from 'prop-types'`;\n    output += '\\n';\n\n    output += `import { buildNativeComponent as ${\n        constants.BUILD_COMPONENT\n        } } from 'vue-native-helper'`;\n    output += '\\n';\n    </generateImports>\n\n    <prepareTemplate>\n    const template = cparsed.template;\n    let templateStartIndex = code.indexOf(\"<\");\n    let tempStringBeforeStart = code.substring(0, templateStartIndex);\n    let templateLineNumber = tempStringBeforeStart.split(splitRE).length - 1;\n    let nodes = [];\n    const templateFragments = parse5.parseFragment(cparsed.template.content, { sourceCodeLocationInfo: true });\n    if (templateFragments.childNodes) {\n        traverse(templateFragments, nodes);\n    }\n    let templateParsed = DEFAULT_OUTPUT.template;\n    if (template) {\n        const templateContent = template.content.replace(/\\/\\/\\n/g, '').trim();\n        if (templateContent) {\n            templateParsed = parseTemplate(templateContent);\n        }\n    }\n    output += templateParsed.import;\n    output += '\\n';\n    </prepareTemplate>\n\n    <prepareScript>\n    const script = cparsed.script;\n    let scriptParsed = DEFAULT_OUTPUT.script;\n    if (script) {\n        const scriptContent = script.content.replace(/\\/\\/\\n/g, '').trim();\n        scriptParsed = parseScript(scriptContent);\n        mappings = generateSourceMap(code);\n    }\n    </prepareScript>\n\n    <generateMappings>\n    if (mappings) {\n        var beforeLines = output.split(splitRE).length;\n        var scriptLine = code.slice(0, cparsed.script.start).split(splitRE).length + 1;\n        var exportDefaultIndex = code.indexOf('export default');\n        var tempString = code.substring(0, exportDefaultIndex);\n        var exportDefaultLineNumber = tempString.split('\\n').length;\n    }\n    </generateMappings>\n\n    <appendScriptToOutput>\n    output += scriptParsed;\n    output += '\\n\\n';\n    var endLines = output.split(splitRE).length - 1;\n    for (; scriptLine < endLines; scriptLine++) {\n        if (scriptLine !== exportDefaultLineNumber) {\n            mappings.addMapping({\n                source: mappings._hashedFilename,\n                generated: {\n                    line: beforeLines,\n                    column: 0\n                },\n                original: {\n                    line: scriptLine,\n                    column: 0\n                }\n            });\n        }\n        beforeLines++;\n    }\n    </appendScriptToOutput>\n\n    <prepareRender>\n    let beautifiedRender = beautify(addvm(templateParsed.render, { indent_size: 2 }));\n    output += beautifiedRender;\n    output += '\\n\\n';\n    let renderEndLine = beautifiedRender.split(splitRE).length - 1;\n    </prepareRender>\n\n    <mapTemplateToJsx>\n    var reactVueElementRegex = /__react__vue__createElement/;\n    let foundLines = lineNumber(beautifiedRender, reactVueElementRegex);\n    if (mappings) {\n        foundLines.forEach((line, index) => {\n            let renderJsLine = endLines + line.number;\n            if (foundLines[index + 1]) {\n                for (let i = line.number; i < foundLines[index + 1].number; i++) {\n                    if (nodes[index]) {\n                        mappings.addMapping({\n                            source: mappings._hashedFilename,\n                            generated: {\n                                line: renderJsLine++,\n                                column: 0\n                            },\n                            original: {\n                                line: nodes[index].startTag.startLine + templateLineNumber,\n                                column: 0\n                            }\n                        });\n                    }\n                }\n            } else if (nodes[index] && nodes[index].startTag) {\n                for (let i = line.number; i < renderEndLine; i++) {\n                    mappings.addMapping({\n                        source: mappings._hashedFilename,\n                        generated: {\n                            line: renderJsLine++,\n                            column: 0\n                        },\n                        original: {\n                            line: nodes[index].startTag.startLine + templateLineNumber,\n                            column: 0\n                        }\n                    });\n                }\n            }\n        });\n    }\n    </mapTemplateToJsx>\n\n    <prepareStyles>\n    const styles = cparsed.styles;\n    let cssParsed = {};\n    styles.forEach(function (v) {\n        const cssAst = cssParse(v.content);\n        cssParsed = Object.assign({}, cssParsed, parseCss(cssAst));\n    });\n    output += `const ${constants.CSS} = ${JSON.stringify(cssParsed)}`;\n    output += '\\n\\n';\n    </prepareStyles>\n\n    <buildComponent>\n    output += `const ${constants.COMPONENT_BUILDED} = ${\n        constants.BUILD_COMPONENT\n        }(${constants.TEMPLATE_RENDER}, ${constants.SCRIPT_OPTIONS}, {Component: ${\n        constants.COMPONENT\n        }, PropTypes: ${constants.PROP_TYPE}, Vue: ${constants.VUE}, ReactNative: ${\n        constants.REACT_NATIVE\n        }, css: ${constants.CSS}})`;\n    output += '\\n\\n';\n    </buildComponent>\n\n    <exportObserver>\n    output += `export default ${constants.OBSERVER}(${\n        constants.COMPONENT_BUILDED\n        })`;\n    </exportObserver>\n\n    return { output, mappings: mappings ? mappings.toJSON() : null };\n}\n"], ""]