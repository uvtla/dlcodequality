[["curveEditorInteraction", "\nfunction _curveMouseMove(e) {\n        var self = e.target,\n            bezierEditor = self.bezierEditor,\n            curveBoundingBox = <getCurveBoundingBox>bezierEditor._getCurveBoundingBox()</getCurveBoundingBox>,\n            left   = curveBoundingBox.left,\n            top    = curveBoundingBox.top,\n            x = e.pageX - left,\n            y = e.pageY - top - HEIGHT_ABOVE;\n\n        <updateTimeProgression>updateTimeProgression(self, x, y);</updateTimeProgression>\n\n        if (bezierEditor.dragElement) {\n            if (e.pageX === 0 && e.pageY === 0) {\n                return;\n            }\n\n            <handlePointMove>handlePointMove(e, x, y);</handlePointMove>\n        }\n    }\n"], ["getIndexFromList", "\nfunction getIndex(objects, obj) {\n\n            var i;\n            for (i = 0; i < objects.length; i++) {\n                if (objects[i] === obj) {\n                    return i;\n                }\n            }\n\n            return -1;\n        }\n"], ["overrideWriteMethod", "\nfunction wrapWrite(std, print) {\n  <setCachedData>process[std].write = function (data) {\n    cachedData[std].push(data);</setCachedData>\n\n    <conditionallyPrint>if (print)\n      originalWrites[std].apply(process[std], arguments);</conditionallyPrint>\n  };\n}\n"], ["eventUnsubscriberDecorator", "\nfunction Off(event, method) {\n      return function (target, key, descriptor) {\n          key = <hyphenateEventKey>hyphenate(key);</hyphenateEventKey>\n          var original = descriptor.value;\n          descriptor.value = function offer() {\n              var args = [];\n              for (var _i = 0; _i < arguments.length; _i++) {\n                  args[_i] = arguments[_i];\n              }\n              <invokeOriginalMethod>if (original.apply(this, args) !== false) {</invokeOriginalMethod>\n                  <unsubscribeEvents>if (method) {\n                      if (typeof this[method] === 'function') {\n                          this.$off(event || key, this[method]);\n                      }\n                      else {\n                          throw new TypeError('must be a method name');\n                      }\n                  }\n                  else if (event) {\n                      this.$off(event || key);\n                  }\n                  else {\n                      this.$off();\n                  }</unsubscribeEvents>\n              }\n          };\n      };\n  }\n"], ["getCsrfSecret", "\nfunction getSecret (req, sessionKey, cookie) {\n  \n  var bag = getSecretBag(req, sessionKey, cookie)\n  var key = cookie ? cookie.key : 'csrfSecret'\n\n  <throwErrorOnMisconfiguration>if (!bag) {\n    throw new Error('misconfigured csrf')\n  }</throwErrorOnMisconfiguration>\n\n  \n  return bag[key]\n}\n"], ["combineAsyncChangesets", "\nfunction combineChangesets (changesets) {\n  const actions = changesets.map((changeset) => changeset.apply)\n\n  const combinedAction = function () {\n    const args = arguments\n\n    return actions.reduce((promise, action) => (\n      promise.then(() => action.apply(null, args))\n    ), <initialPromise>Promise.resolve())</initialPromise>\n  }\n\n  return createChangeset(combinedAction)\n}\n"], ["controllerActions", "\nfunction ExampleCtrl($scope, $timeout) {\n    var pomo_nonsense = 'The fallacy of disciplinary boundaries thematizes the figuralization of civil society.',\n      regex = /(of\\s.+\\sboundaries|eht)/;\n\n    <resetData>$scope.reset = function reset() {\n      delete $scope.data.pomo_nonsense;\n      $timeout(function () {\n        $scope.data.pomo_nonsense = pomo_nonsense;\n      });\n    };</resetData>\n\n    <reverseNonsense>$scope.reverse = function reverse() {\n      var arr = Array.prototype.slice.call($scope.data.pomo_nonsense);\n      arr.reverse();\n      $scope.data.pomo_nonsense = arr.join('');\n    };</reverseNonsense>\n\n    <initializeScopeData>$scope.data = {\n      regex: regex,\n      pomo_nonsense: pomo_nonsense\n    };</initializeScopeData>\n  }\n"], ["snowplowTrackerInitialization", "\nfunction tracker(emitters, namespace, appId, encodeBase64) {\n\tif (!(emitters instanceof Array)) {\n\t\temitters = [emitters];\n\t}\n\tencodeBase64 = encodeBase64 !== false;\n\tvar trackerCore = core(encodeBase64, sendPayload);\n\n\t<setTrackerProperties>trackerCore.setPlatform('srv'); \n\ttrackerCore.setTrackerVersion('node-' + version);\n\ttrackerCore.setTrackerNamespace(namespace);\n\ttrackerCore.setAppId(appId);</setTrackerProperties>\n\n\t\n\t<sendPayloadToEmitters>function sendPayload(payload) {\n\t\tvar builtPayload = payload.build();\n\t\tfor (var i=0; i<emitters.length; i++) {\n\t\t\temitters[i].input(builtPayload);\n\t\t}\n\t}</sendPayloadToEmitters>\n\n\tvar trackEcommerceTransaction = trackerCore.trackEcommerceTransaction;\n\n\t\n\t<trackEcommerceTransactionItems>trackerCore.trackEcommerceTransaction = function (orderId, affiliation, total, tax, shipping, city, state, country, currency, items, context, tstamp) {\n\t\ttrackEcommerceTransaction(\n\t\t\torderId,\n\t\t\taffiliation,\n\t\t\ttotal,\n\t\t\ttax,\n\t\t\tshipping,\n\t\t\tcity,\n\t\t\tstate,\n\t\t\tcountry,\n\t\t\tcurrency,\n\t\t\tcontext,\n\t\t\ttstamp\n\t\t);\n\n\t\tif (items) {\n\t\t\tfor (var i=0; i<items.length; i++) {\n\t\t\t\tvar item = items[i];\n\t\t\t\ttrackerCore.trackEcommerceTransactionItem(\n\t\t\t\t\torderId,\n\t\t\t\t\titem.sku,\n\t\t\t\t\titem.name,\n\t\t\t\t\titem.category,\n\t\t\t\t\titem.price,\n\t\t\t\t\titem.quantity,\n\t\t\t\t\tcurrency,\n\t\t\t\t\titem.context,\n\t\t\t\t\ttstamp\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t};</trackEcommerceTransactionItems>\n\n\treturn trackerCore;\n}\n"], ["loadAndSetSSLFiles", "\nfunction handleSSLProperties (config) {\n  const sslFiles = ['sslKey', 'sslCert', 'sslDHParams']\n  let key\n  let resolvedFilePath\n  let filePath\n  <iterateAndProcessSSLFiles>for (let i = 0; i < sslFiles.length; i++) {\n    key = sslFiles[i]\n    filePath = config[key]\n    if (!filePath) {\n      continue\n    }\n    resolvedFilePath = fileUtils.lookupConfRequirePath(filePath)\n    try {\n      config[key] = fs.readFileSync(resolvedFilePath, 'utf8')\n    } catch (e) {\n      throw new Error(`The file path \"${resolvedFilePath}\" provided by \"${key}\" does not exist.`)\n    }\n  }</iterateAndProcessSSLFiles>\n}\n"], ["mapToObjectAdicionalInfo", "\nfunction AdicionalInfo(obj) {\n    this.date_expedition = <formatDateExpedition>moment.tz(obj.DataExpedicao, \"YYYY-MM-DD\", zone).format()</formatDateExpedition>\n    this.service_type = obj.desc_tipo_servico\n    this.sub_status = <trimSubStatus>obj.Desc_SubStatus.trim()</trimSubStatus>\n    this.updated = <formatUpdatedDate>moment.tz(obj.data_status, \"YYYY-MM-DD HH:mm\", zone).format()</formatUpdatedDate>\n    this.status = obj.Desc_Status\n    this.name = obj.nome\n    this.distributor = obj.Distribuidor\n    this.phone1 = obj.Phone1\n    this.phone2 = <trimPhone2>obj.Phone2.trim()</trimPhone2>\n    this.notes = obj.Notes\n    this.trackerWebsite = <getTrackerLink>adicional.getLink(null)</getTrackerLink>\n}\n"], ""]