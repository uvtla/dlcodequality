[["mergeArrays", "\nfunction mergeArrays(array1, array2) {\n  return array2.length >= array1.length ? [...array2] : [...array2, ...array1.slice(array2.length)];\n}\n"], ["thisFunctionConstructor", "\nfunction (Constructor) {\n        <updateFunction>\n        var update = function (input) {\n            var len = input.length;\n            var offset = 0;\n            while (len > 0) {\n                var copyLen = this.blockLen - this.inLen;\n                if (copyLen > len) {\n                    copyLen = len;\n                }\n                var tmpInput = input.subarray(offset, offset + copyLen);\n                this.inbuf.set(tmpInput, this.inLen);\n                offset += copyLen;\n                len -= copyLen;\n                this.inLen += copyLen;\n                <processBlock>\n                if (this.inLen === this.blockLen) {\n                    this.processBlock(this.inbuf);\n                    this.inLen = 0;\n                }\n\t\t</processBlock>\n            }\n        };\n        </updateFunction>\n\n        <finalizeFunction>\n        var finalize = function () {\n            var padding = this.doPadding();\n            this.update(padding);\n            var result = this.getDigest();\n            this.reset();\n            return result;\n        };\n        </finalizeFunction>\n\n        <engineFunction>\n        var engine = (function () {\n            if (!Constructor) {\n                throw \"Unsupported algorithm: \" + Constructor.toString();\n            }\n            Constructor.prototype.update = update;\n            Constructor.prototype.finalize = finalize;\n            var engine = new Constructor();\n            engine.inbuf = new Uint8Array(new ArrayBuffer(engine.blockLen));\n            engine.reset();\n            return engine;\n        }());\n        </engineFunction>\n\n        return {\n            update: function (input) {\n                engine.update(convertToUint8Array(input));\n            },\n\n            finalize: function () {\n                return engine.finalize();\n            },\n\n            digest: function (input) {\n                engine.update(convertToUint8Array(input));\n                return engine.finalize();\n            },\n\n            reset: function () {\n                engine.reset();\n            },\n\n            digestLength: function () {\n                return engine.digestLen;\n            }\n        };\n}\n"], ["shadingFunction", "\nfunction ( renderer, scene, camera, geometry, material, group ) {\n\tif ( material.isGLTFSpecularGlossinessMaterial !== true ) {\n\t\treturn;\n\t}\n\n\t<uniformSetup>\n\tvar uniforms = material.uniforms;\n\tvar defines = material.defines;\n\tuniforms.opacity.value = material.opacity;\n\tuniforms.diffuse.value.copy( material.color );\n\tuniforms.emissive.value.copy( material.emissive ).multiplyScalar( material.emissiveIntensity );\n\tuniforms.map.value = material.map;\n\tuniforms.specularMap.value = material.specularMap;\n\tuniforms.alphaMap.value = material.alphaMap;\n\tuniforms.lightMap.value = material.lightMap;\n\tuniforms.lightMapIntensity.value = material.lightMapIntensity;\n\tuniforms.aoMap.value = material.aoMap;\n\tuniforms.aoMapIntensity.value = material.aoMapIntensity;\n\t</uniformSetup>\n\n\t<uvScaleMapSetup>\n\tvar uvScaleMap;\n\tif ( material.map ) {\n\t\tuvScaleMap = material.map;\n\t} else if ( material.specularMap ) {\n\t\tuvScaleMap = material.specularMap;\n\t} else if ( material.displacementMap ) {\n\t\tuvScaleMap = material.displacementMap;\n\t} else if ( material.normalMap ) {\n\t\tuvScaleMap = material.normalMap;\n\t} else if ( material.bumpMap ) {\n\t\tuvScaleMap = material.bumpMap;\n\t} else if ( material.glossinessMap ) {\n\t\tuvScaleMap = material.glossinessMap;\n\t} else if ( material.alphaMap ) {\n\t\tuvScaleMap = material.alphaMap;\n\t} else if ( material.emissiveMap ) {\n\t\tuvScaleMap = material.emissiveMap;\n\t}\n\t</uvScaleMapSetup>\n\n\t<uvScaleMapUpdate>\n\tif ( uvScaleMap !== undefined ) {\n\t\tif ( uvScaleMap.isWebGLRenderTarget ) {\n\t\t\tuvScaleMap = uvScaleMap.texture;\n\t\t}\n\t\tif ( uvScaleMap.matrixAutoUpdate === true ) {\n\t\t\tuvScaleMap.updateMatrix();\n\t\t}\n\t\tuniforms.uvTransform.value.copy( uvScaleMap.matrix );\n\t}\n\t</uvScaleMapUpdate>\n\n\t<remainingUniformsSetup>\n\tuniforms.envMap.value = material.envMap;\n\tuniforms.envMapIntensity.value = material.envMapIntensity;\n\tuniforms.flipEnvMap.value = ( material.envMap && material.envMap.isCubeTexture ) ? - 1 : 1;\n\tuniforms.refractionRatio.value = material.refractionRatio;\n\tuniforms.specular.value.copy( material.specular );\n\tuniforms.glossiness.value = material.glossiness;\n\tuniforms.glossinessMap.value = material.glossinessMap;\n\tuniforms.emissiveMap.value = material.emissiveMap;\n\tuniforms.bumpMap.value = material.bumpMap;\n\tuniforms.normalMap.value = material.normalMap;\n\tuniforms.displacementMap.value = material.displacementMap;\n\tuniforms.displacementScale.value = material.displacementScale;\n\tuniforms.displacementBias.value = material.displacementBias;\n\t</remainingUniformsSetup>\n\n\t<glossinessMapDefinesSetup>\n\tif ( uniforms.glossinessMap.value !== null && defines.USE_GLOSSINESSMAP === undefined ) {\n\t\tdefines.USE_GLOSSINESSMAP = '';\n\t\tdefines.USE_ROUGHNESSMAP = '';\n\t}\n\tif ( uniforms.glossinessMap.value === null && defines.USE_GLOSSINESSMAP !== undefined ) {\n\t\tdelete defines.USE_GLOSSINESSMAP;\n\t\tdelete defines.USE_ROUGHNESSMAP;\n\t}\n\t</glossinessMapDefinesSetup>\n\n}\n"], ["PaymentConstructor", "\nfunction Payment() {\n    this.total = null;\n    this.subtotal = null;\n    this.formattedTotal = null;\n    this.formattedSubtotal = null;\n    this.currency = null;\n    <couponSetup>\n    this.coupon = Object.create(Coupon.prototype);\n    </couponSetup>\n    <taxSetup>\n    this.tax = Object.create(Tax.prototype);\n    </taxSetup>\n    <shippingSetup>\n    this.shipping = Object.create(Shipping.prototype);\n    </shippingSetup>\n}\n"], ["VerticalLStrategyConstructor", "\nfunction VerticalLStrategy(connector)\n{\n\tthis.connector = connector;\n\tthis.startSegment;\n\tthis.endSegment;\n\tthis.strategyName = \"vertical_L\";\n\t<isApplicableMethod>\n\tthis.isApplicable = function()\n\t{\n\t\tvar sourceMiddle = Math.floor(this.connector.source.left() + this.connector.source.width() / 2);\n\t\tvar dl = this.connector.destination.left();\n\t\tvar dw = this.connector.destination.width();\n\t\tvar st = this.connector.source.top();\n\t\tvar sh = this.connector.source.height();\n\t\tvar destMiddle = Math.floor(this.connector.destination.top() + this.connector.destination.height() / 2);\n\n\t\tif(sourceMiddle > dl && sourceMiddle < dl + dw)\n\t\t\treturn false;\n\t\tif(destMiddle > st && destMiddle < st + sh)\n\t\t\treturn false;\n\t\treturn true;\n\t}\n\t</isApplicableMethod>\n\t\n\t<getMiddleSegmentMethod>\n\tthis.getMiddleSegment = function() {\n\t\tif(this.startSegment.length > this.endSegment.length)\n\t\t\treturn this.startSegment;\n\t\treturn this.endSegment;\n\t}\n\t</getMiddleSegmentMethod>\n\t\n\t<paintMethod>\n\tthis.paint = function() {\n\t\tthis.startSegment = this.connector.createSegment();\n\t\tthis.endSegment = this.connector.createSegment();\n\t\tvar destMiddleY = Math.floor(this.connector.destination.top() + this.connector.destination.height() / 2);\n\t\tvar dl = this.connector.destination.left();\n\t\tvar dw = this.connector.destination.width();\n\t\tvar st = this.connector.source.top();\n\t\tvar sh = this.connector.source.height();\n\t\tthis.startSegment.startX = Math.floor(this.connector.source.left() + this.connector.source.width() / 2);\n\t\t\n\t\tif(Math.abs(destMiddleY - st) < Math.abs(destMiddleY - (st + sh))) {\n\t\t\tthis.startSegment.orientation = (destMiddleY < st) ? UP : DOWN;\n\t\t\tthis.startSegment.startY = st;\n\t\t} else {\n\t\t\tthis.startSegment.orientation = (destMiddleY > (st + sh)) ? DOWN : UP;\n\t\t\tthis.startSegment.startY = st + sh;\n\t\t}\n\t\tthis.startSegment.length = Math.abs(destMiddleY - this.startSegment.startY);\n\t\t\n\t\tif(Math.abs(this.startSegment.startX - dl) < Math.abs(this.startSegment.startX - (dl + dw)))\n\t\t{\n\t\t\tthis.endSegment.orientation = (this.startSegment.startX < dl) ? RIGHT : LEFT;\n\t\t\tthis.endSegment.length = Math.abs(this.startSegment.startX - dl);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.endSegment.orientation = (this.startSegment.startX > dl + dw) ? LEFT : RIGHT;\n\t\t\tthis.endSegment.length = Math.abs(this.startSegment.startX - (dl + dw));\n\t\t}\n\t}\n\t</paintMethod>\n}\n"], ["replaceFunction", "\nfunction replace(match, text) {\n        var rng = rangeFromMatch(match);\n        <deleteRangeContents>\n        rng.deleteContents();\n        </deleteRangeContents>\n        <insertTextNode>\n        if (text.length > 0) {\n          rng.insertNode(editor.dom.doc.createTextNode(text));\n        }\n        </insertTextNode>\n        return rng;\n      }\n"], ["decodeOperandFunction", "\nfunction decode_operand(di, machine_code, offset=0) {\n  const addressing_mode = di.addressing_mode;\n  let consumed = 0;\n  let value;\n\n  <switchAddressingMode>\n  switch(di.addressing_mode) {\n    case ADDR_MODE.INDIRECT_INDEXED_Y:\n    case ADDR_MODE.INDEXED_X_INDIRECT:\n    case ADDR_MODE.ABSOLUTE:\n    case ADDR_MODE.ABSOLUTE_X:\n    case ADDR_MODE.ABSOLUTE_Y:\n    case ADDR_MODE.INDIRECT:\n      value = machine_code[offset + 1];\n      value += T_TO_TRITS_PER_TRYTE * machine_code[offset + 2];\n      consumed = 2;\n      break;\n    case ADDR_MODE.ACCUMULATOR:\n      consumed = 0;\n      break;\n    case ADDR_MODE.IMMEDIATE:\n      value = machine_code[offset + 1];\n      consumed = 1;\n      break;\n  }\n  </switchAddressingMode>\n\n  return {addressing_mode, value, consumed};\n}\n"], ["promiseErrorHandling", "\nfunction(results) {\n      return results.reduce(function(memo, result) {\n        <handlePromiseError>\n        if (!v.isPromise(result.error)) {\n          return memo;\n        }\n        return memo.then(function() {\n          return result.error.then(function(error) {\n            result.error = error || null;\n          });\n        });\n        </handlePromiseError>\n      }, new v.Promise(function(r) { r(); })); \n}\n"], ["loadLanguage", "\nfunction( languageCode, defaultLanguage, callback ) {\n\t<languageDetection>\n\tif ( !languageCode || !CKEDITOR.lang.languages[ languageCode ] )\n\t\tlanguageCode = this.detect( defaultLanguage, languageCode );\n\t</languageDetection>\n\t<languageLoading>\n\tif ( !this[ languageCode ] ) {\n\t\tCKEDITOR.scriptLoader.load( CKEDITOR.getUrl('_source/' + 'lang/' + languageCode + '.js' ), function() {\n\t\t\tcallback( languageCode, this[ languageCode ] );\n\t\t}, this );\n\t}\n\telse\n\t\tcallback( languageCode, this[ languageCode ] );\n\t</languageLoading>\n}\n"], ["testControlRendering", "\nfunction(aControls, aControlsToTest, aExcludedControls, bIncludeNonRenderable, bIncludeNonInstantiable, fnCallback) {\n\t\treturn new Promise(function(resolve, reject){\n\t\t\tvar iControlCountInLib = 0;\n\t\t\t<loopTest>\n\t\t\tvar loop = function(i) {\n\t\t\t\tif (i < aControls.length) {\n\t\t\t\t\tvar sControlName = aControls[i];\n\t\t\t\t\thandleControl(sControlName, aControlsToTest, aExcludedControls, bIncludeNonRenderable, bIncludeNonInstantiable, fnCallback).then(function(bCountThisControl){\n\t\t\t\t\t\tif (bCountThisControl) {\n\t\t\t\t\t\t\tiControlCountInLib++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tloop(i + 1);\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tresolve(iControlCountInLib);\n\t\t\t\t}\n\t\t\t};\n\t\t\t</loopTest>\n\t\t\tloop(0);\n\t\t});\n\t}\n"], "```"]