[["SetGarbage", "\nfunction SetGarbage (proxy, timeout) {\n\n    <debugLogging>\n    proxy.Debug (4, \"SetGarbage timeout=%d\", timeout);\n    </debugLogging>\n    \n    <schedulingNextGarbageCollection>\n    setTimeout (function(){SetGarbage (proxy, timeout);}, timeout*500);\n    </schedulingNextGarbageCollection>\n    \n    <calculateGarbageThreshold>\n    var lastshow = new Date().getTime() - (timeout *1000);\n    </calculateGarbageThreshold>\n    \n    <removeOldVessels>\n    for (var mmsi in proxy.vessels) {\n        var vessel = proxy.vessels[mmsi];\n        if (vessel.lastshow < lastshow) {\n            <debugLoggingVesselRemoval>\n            proxy.Debug (5, \"Removed Vessel mmsi=%s\", mmsi);\n            </debugLoggingVesselRemoval>\n            delete proxy.vessels [mmsi];\n        }\n    }\n    </removeOldVessels>\n      \n}\n"], ["updateShadowCamera", "\nfunction updateShadowCamera( camera, light ) {\n\n\t<shadowCameraSetup>\n\t\tvar shadowCamera = light.shadowCamera,\n\t\t\tpointsFrustum = light.pointsFrustum,\n\t\t\tpointsWorld = light.pointsWorld;\n\t</shadowCameraSetup>\n\n\t<calculateBoundingBox>\n\t\t_min.set( Infinity, Infinity, Infinity );\n\t\t_max.set( -Infinity, -Infinity, -Infinity );\n\n\t\tfor ( var i = 0; i < 8; i ++ ) {\n\n\t\t\tvar p = pointsWorld[ i ];\n\n\t\t\tp.copy( pointsFrustum[ i ] );\n\t\t\tTHREE.ShadowMapPlugin.__projector.unprojectVector( p, camera );\n\n\t\t\tp.applyMatrix4( shadowCamera.matrixWorldInverse );\n\n\t\t\tif ( p.x < _min.x ) _min.x = p.x;\n\t\t\tif ( p.x > _max.x ) _max.x = p.x;\n\n\t\t\tif ( p.y < _min.y ) _min.y = p.y;\n\t\t\tif ( p.y > _max.y ) _max.y = p.y;\n\n\t\t\tif ( p.z < _min.z ) _min.z = p.z;\n\t\t\tif ( p.z > _max.z ) _max.z = p.z;\n\n\t\t}\n\t</calculateBoundingBox>\n\n\t<updateShadowCameraProperties>\n\t\tshadowCamera.left = _min.x;\n\t\tshadowCamera.right = _max.x;\n\t\tshadowCamera.top = _max.y;\n\t\tshadowCamera.bottom = _min.y;\t\n\t</updateShadowCameraProperties>\n\n\t<updateProjectionMatrix>\n\t\tshadowCamera.updateProjectionMatrix();\n    </updateProjectionMatrix> \n\n}\n"], ["submitFormData", "\nfunction submitFormData(params, cb) {\n  <prepareRequestParameters>\n  var resourcePath = config.addURIParams(\"/appforms/forms/:id/submitFormData\", params);\n  var method = \"POST\";\n  var data = params.submission;\n\n  params.resourcePath = resourcePath;\n  params.method = method;\n  params.data = data;\n  </prepareRequestParameters>\n\n  <performRequest>\n  mbaasRequest.app(params, cb);\n  </performRequest>\n}\n"], ["_generateInterpolatedColor", "\nfunction _generateInterpolatedColor() {\n  <generateInterpolationParameters>\n  const randIndicies = _getNextColorPair();\n  const fraction = Math.random();\n  </generateInterpolationParameters>\n  \n  <calculateInterpolatedColor>\n  const interpolatedColor = [];\n\n  for (let i = 0; i < 4; i++) {\n    interpolatedColor.push(\n      Math.floor(\n        fraction * distinctColors[randIndicies[0]][i] +\n          (1.0 - fraction) * distinctColors[randIndicies[1]][i]\n      )\n    );\n  }\n  </calculateInterpolatedColor>\n\n  return interpolatedColor;\n}\n"], ["function_that_needs_name", "\nfunction (key, howMany) {\n                    \n    if (arguments.length > 2) {\n        <handleAdditionalArguments>\n        var args = copyargs(arguments);\n        args[1] = 0; \n        this._list._spliceFromKey.apply(this._list, args);\n        </handleAdditionalArguments>\n    }\n                    \n    <removeKeysAndCollectResults>\n    var result = [];\n    if (howMany) {\n        var keysToRemove = [];\n        var filteredKeys = this._filteredKeys;\n        var filteredKeyIndex = filteredKeys.indexOf(key);\n        for (var i = filteredKeyIndex, len = filteredKeys.length; i < len && (i - filteredKeyIndex) < howMany; i++) {\n            var key = filteredKeys[i];\n            keysToRemove.push(key);\n        }\n        var that = this;\n        keysToRemove.forEach(function (key) {\n            result.push(that._list._spliceFromKey(key, 1)[0]);\n        });\n    }\n    </removeKeysAndCollectResults>\n    return result;\n}\n"], ["makeServeMiddleware", "\nfunction makeServeMiddleware() {\n  return function handle(req, resp, next) {\n    <handleRequestForStylesheets>\n    if (/^\\/.*\\.css$/.test(req.url)) {\n      resp.end(\"\");\n    }\n    </handleRequestForStylesheets>\n    <passThroughNonStylesheets>\n    else {\n      next();\n    }\n    </passThroughNonStylesheets>\n  };\n}\n"], ["init", "\nfunction init(domainManager) {\n    <setupDomainManager>\n    _domainManager = domainManager;\n    if (!domainManager.hasDomain(\"launcher\")) {\n        domainManager.registerDomain(\"launcher\", {major: 0, minor: 1});\n    }\n    </setupDomainManager>\n    \n    <registerLaunchCommand>\n    domainManager.registerCommand(\n        \"launcher\",      \n        \"launch\",       \n        _cmdLaunch,     \n        false,          \n        \"Launches a given HTML file in the browser for live development\",\n        [\n            { name: \"url\", type: \"string\", description: \"file:\n            { name: \"browser\", type: \"string\", description: \"browser name\"}\n        ],\n        []\n    );\n    </registerLaunchCommand>\n}\n"], ["commitPicker", "\nfunction commitPicker(picker) {\n    <determineActiveFilter>\n    var filter = getActiveFilter();\n    </determineActiveFilter>\n\n    <compileFilterPatterns>\n    return (filter && filter.patterns.length) ? compile(filter.patterns) : \"\";\n    </compileFilterPatterns>\n}\n"], ["anonymousFunction", "\nfunction( fn ){\n    <setupThreadExecution>\n      var self = this;\n      var _p = self._private;\n      var subsize = self.spreadSize(); \n      var pass = _p.pass.shift().concat([]); \n      var runPs = [];\n    </setupThreadExecution>\n\n      <executeFunctionOnThreads>\n      for( var i = 0; i < this.length; i++ ){\n        var thread = this[i];\n        var slice = pass.splice( 0, subsize );\n\n        var runP = thread.pass( slice ).run( fn );\n\n        runPs.push( runP );\n\n        var doneEarly = pass.length === 0;\n        if( doneEarly ){ break; }\n      }\n      </executeFunctionOnThreads>\n\n      <aggregateThreadResults>\n      return $$.Promise.all( runPs ).then(function( thens ){\n        var postpass = new Array();\n        var p = 0;\n\n        \n        for( var i = 0; i < thens.length; i++ ){\n          var then = thens[i]; \n\n          for( var j = 0; j < then.length; j++ ){\n            var t = then[j]; \n\n            postpass[ p++ ] = t;\n          }\n        }\n\n        return postpass;\n      });\n      </aggregateThreadResults>\n}\n"], ["registerEvent", "\nfunction registerEvent(eventName, position, extra){\n\n    <performEventRegistration>\n    currentSession.registerEvent(eventName, position, extra);\n    </performEventRegistration>\n\n    <checkDataPairIntegrity>\n    _checkDataPairs();\n    </checkDataPairIntegrity>\n    \n}\n"], ""]