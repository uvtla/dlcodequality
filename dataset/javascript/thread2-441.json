[["GCM", "\nasync function GCM(cipher, key) {\n  <validateCipher>\n  if (cipher.substr(0, 3) !== 'aes') {\n    throw new Error('GCM mode supports only AES cipher');\n  }\n  </validateCipher>\n\n  <checkWebCryptoSupport>\n  if (util.getWebCrypto() && key.length !== 24) {\n    const _key = await webCrypto.importKey('raw', key, { name: ALGO }, false, ['encrypt', 'decrypt']);\n    return {\n      encrypt: async function(pt, iv, adata = new Uint8Array()) {\n        <edgeConditionEncrypt>\n        if (!pt.length || (!adata.length && navigator.userAgent.indexOf('Edge') !== -1)) {\n          return AES_GCM.encrypt(pt, key, iv, adata);\n        }\n        </edgeConditionEncrypt>\n        const ct = await webCrypto.encrypt(\n          { name: ALGO, iv, additionalData: adata, tagLength: tagLength * 8 },\n          _key,\n          pt\n        );\n        return new Uint8Array(ct);\n      },\n\n      decrypt: async function(ct, iv, adata = new Uint8Array()) {\n        <edgeConditionDecrypt>\n        if (ct.length === tagLength || (!adata.length && navigator.userAgent.indexOf('Edge') !== -1)) {\n          return AES_GCM.decrypt(ct, key, iv, adata);\n        }\n        </edgeConditionDecrypt>\n        const pt = await webCrypto.decrypt(\n          { name: ALGO, iv, additionalData: adata, tagLength: tagLength * 8 },\n          _key,\n          ct\n        );\n        return new Uint8Array(pt);\n      }\n    };\n  }\n  </checkWebCryptoSupport>\n\n  <checkNodeCryptoSupport>\n  if (util.getNodeCrypto()) {\n    key = new Buffer(key);\n\n    return {\n      encrypt: async function(pt, iv, adata = new Uint8Array()) {\n        pt = new Buffer(pt);\n        iv = new Buffer(iv);\n        adata = new Buffer(adata);\n        const en = new nodeCrypto.createCipheriv('aes-' + (key.length * 8) + '-gcm', key, iv);\n        en.setAAD(adata);\n        const ct = Buffer.concat([en.update(pt), en.final(), en.getAuthTag()]);\n        return new Uint8Array(ct);\n      },\n\n      decrypt: async function(ct, iv, adata = new Uint8Array()) {\n        ct = new Buffer(ct);\n        iv = new Buffer(iv);\n        adata = new Buffer(adata);\n        const de = new nodeCrypto.createDecipheriv('aes-' + (key.length * 8) + '-gcm', key, iv);\n        de.setAAD(adata);\n        de.setAuthTag(ct.slice(ct.length - tagLength, ct.length));\n        const pt = Buffer.concat([de.update(ct.slice(0, ct.length - tagLength)), de.final()]);\n        return new Uint8Array(pt);\n      }\n    };\n  }\n  </checkNodeCryptoSupport>\n\n  return {\n    encrypt: async function(pt, iv, adata) {\n      return AES_GCM.encrypt(pt, key, iv, adata);\n    },\n\n    decrypt: async function(ct, iv, adata) {\n      return AES_GCM.decrypt(ct, key, iv, adata);\n    }\n  };\n}\n"], ["checkFileSize", "\nfunction checkFileSize(opt) {\n  var stream = through.obj(function(file, enc, cb) {\n    <checkMaxSize>\n    if (opt && opt.maxSize > 0) {\n      var size = file.contents.length / 1024;\n      if (size > opt.maxSize) {\n        gutil.log(gutil.colors.red('file size error:', '(' + size.toFixed(2) + 'KB)' + file.path));\n        this.emit(\"error\", new PluginError('file size error', '\u6587\u4ef6\u5927\u4e8e' + opt.maxSize + 'KB '));\n      }\n    }\n    </checkMaxSize>\n    this.push(file);\n    cb();\n  });\n  return stream;\n}\n"], ["checkSelectOnlyIds", "\nfunction checkSelectOnlyIds() {\n  this.isSelectOnlyIds = false\n\n  if (this.isSelectById) {\n    return\n  }\n\n  if (this.args.all && (!this.model.cache || this.args.cache === false)) {\n    return\n  }\n\n  if (this.args.limit === 1) {\n    return\n  }\n\n  if (defined(this.args.select)) {\n    return\n  }\n\n  if (this.args.isCurrent) {\n    return\n  }\n\n  this.isSelectOnlyIds = true\n}\n"], ["deconstructComponentInternal", "\nfunction deconstructComponentInternal(component) {\n  if (component) {\n    <removeComponentFromRegistry>\n    var componentIndex = createdComponents_.indexOf(component);\n    createdComponents_.splice(componentIndex, 1);\n    </removeComponentFromRegistry>\n\n    <updateComponentDataAndDispatchEvent>\n    var upgrades = component.element_.getAttribute('data-upgraded').split(',');\n    var componentPlace = upgrades.indexOf(component[componentConfigProperty_].classAsString);\n    upgrades.splice(componentPlace, 1);\n    component.element_.setAttribute('data-upgraded', upgrades.join(','));\n\n    var ev;\n    if ('CustomEvent' in window && typeof window.CustomEvent === 'function') {\n      ev = new CustomEvent('mdl-componentdowngraded', {\n        bubbles: true, cancelable: false\n      });\n    } else {\n      ev = document.createEvent('Events');\n      ev.initEvent('mdl-componentdowngraded', true, true);\n    }\n    component.element_.dispatchEvent(ev);\n    </updateComponentDataAndDispatchEvent>\n  }\n}\n"], ["deploySimpleTokenContract", "\nasync function () {\n  const simpleTokenContractName = 'simpleToken'\n    , simpleTokenContractAbi = coreAddresses.getAbiForContract(simpleTokenContractName)\n    , simpleTokenContractBin = coreAddresses.getBinForContract(simpleTokenContractName)\n  ;\n\n  logger.step('** Deploying Simple Token Contract');\n  const deploymentResult = await deployHelper.perform(\n    simpleTokenContractName,\n    web3ValueProvider,\n    simpleTokenContractAbi,\n    simpleTokenContractBin,\n    'foundation');\n\n  return Promise.resolve(responseHelper.successWithData({\n    contract: 'simpleToken', address: deploymentResult.contractAddress\n  }));\n}\n"], ["canReading", "\nfunction(inst) {\n  can.__reading(inst, inst.constructor.id);\n  return inst.__get(inst.constructor.id);\n}\n"], ["_fillAction", "\nfunction _fillAction(entity, actionObj, actionType) {\n  <validateEntity>\n  if (!(entity instanceof Scope) && !entity.id) {\n    throw new Error('This entity does not have an ID.');\n  }\n  </validateEntity>\n\n  var ret = actionObj;\n\n  if (Utils.isArray(actionObj)) {\n    ret = actionObj.map(function(singleAction) {\n      return _fillAction(entity, singleAction, actionType);\n    });\n  } else {\n    <setActionType>\n    ret.type = actionType !== 'all' && actionType || actionObj.type || '';\n    </setActionType>\n    <addEntityIdentifier>\n    _addEntityIdentifier(entity, ret);\n    </addEntityIdentifier>\n  }\n\n  return ret;\n}\n"], ["getExpression", "\nfunction getExpression(_, ctx, params) {\n  <parseExpressionParameters>\n  if (_.$params) {\n    parseParameters(_.$params, ctx, params);\n  }\n  </parseExpressionParameters>\n  var k = 'e:' + _.$expr + '_' + _.$name;\n  return ctx.fn[k] || (ctx.fn[k] = accessor(parameterExpression(_.$expr, ctx), _.$fields, _.$name));\n}\n"], ["logDebugMessage", "\nfunction(msg) {\n  if (this.options.debugLevel >= 1) {\n    <prefixWithObjectName>\n    Array.prototype.unshift.call(arguments, this.toString());\n    </prefixWithObjectName>\n    <invokeConsoleFunction>\n    consoleApply(\"info\", arguments);\n    </invokeConsoleFunction>\n  }\n}\n"], ["wrapEventHandler", "\nfunction(e) {\n  var evt = {\n    _event: e,\n    type: originToCrossType(e.type),\n    target: e.target,\n    currentTarget: e.currentTarget,\n    relatedTarget: e.relatedTarget,\n    eventPhase: e.eventPhase,\n\n    layerX: e.layerX,\n    layerY: e.layerX,\n    clientX: e.clientX,\n    clientY: e.clientY,\n    pageX: e.pageX,\n    pageY: e.pageY,\n    offsetX: e.offsetX,\n    offsetY: e.offsetY,\n    screenX: e.screenX,\n    screenY: e.screenY,\n    shiftKey: e.shiftKey,\n    charCode: e.charCode,\n    altKey: e.altKey,\n    ctrlKey: e.ctrlKey,\n\n    <stopPropagationPreventDefault>\n    stopPropagation: function() {\n      if (this._event) this._event.stopPropagation();\n    },\n    preventDefault: function() {\n      if (this._event) this._event.preventDefault();\n    },\n    </stopPropagationPreventDefault>\n\n    delta: 0,\n    data: e.customData || data\n  };\n\n\n  <normalizeWheelDelta>\n  if (e.wheelDelta) {\n    evt.delta = e.wheelDelta / 120;\n  } else if (e.detail) {\n    evt.delta = -e.detail / 3;\n  }\n  </normalizeWheelDelta>\n\n  handler.call(el, evt);\n}\n"], ""]