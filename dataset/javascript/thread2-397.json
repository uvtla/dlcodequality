[["zoomTo", "\nfunction zoomTo(ratio) {\n    <parameterHandling>\n    var hasTooltip = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    var _originalEvent = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    var _zoomable = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    </parameterHandling>\n\n    <variableInitialization>\n    var options = this.options,\n        pointers = this.pointers,\n        imageData = this.imageData;\n    </variableInitialization>\n\n    ratio = Math.max(0, ratio);\n\n    <zoomCalculation>\n    if (isNumber(ratio) && this.viewed && !this.played && (_zoomable || options.zoomable)) {\n      if (!_zoomable) {\n        var minZoomRatio = Math.max(0.01, options.minZoomRatio);\n        var maxZoomRatio = Math.min(100, options.maxZoomRatio);\n\n        ratio = Math.min(Math.max(ratio, minZoomRatio), maxZoomRatio);\n      }\n    </zoomCalculation>\n\n    <originalEventAdjustment>\n    if (_originalEvent && ratio > 0.95 && ratio < 1.05) {\n      ratio = 1;\n    }\n    </originalEventAdjustment>\n\n    <imageDimensionsUpdate>\n    var newWidth = imageData.naturalWidth * ratio;\n    var newHeight = imageData.naturalHeight * ratio;\n    </imageDimensionsUpdate>\n\n    <positionUpdate>\n    if (_originalEvent) {\n        var offset = getOffset(this.viewer);\n        var center = pointers && Object.keys(pointers).length ? getPointersCenter(pointers) : {\n          pageX: _originalEvent.pageX,\n          pageY: _originalEvent.pageY\n        };\n\n        imageData.left -= (newWidth - imageData.width) * ((center.pageX - offset.left - imageData.left) / imageData.width);\n        imageData.top -= (newHeight - imageData.height) * ((center.pageY - offset.top - imageData.top) / imageData.height);\n      } else {\n        imageData.left -= (newWidth - imageData.width) / 2;\n        imageData.top -= (newHeight - imageData.height) / 2;\n      }\n    </positionUpdate>\n\n    <renderImage>\n    imageData.width = newWidth;\n    imageData.height = newHeight;\n    imageData.ratio = ratio;\n    this.renderImage();\n    </renderImage>\n\n    <tooltipHandling>\n    if (hasTooltip) {\n      this.tooltip();\n    }\n    </tooltipHandling>\n    }\n\n    return this;\n  }\n"], ["anonymousFunctionCreateCircle", "\nfunction (x, y, r) {\n    return new BVG('circle', x.constructor.name === 'Object' ? x : {\n      x: x,\n      y: y,\n      r: r\n    }, function (tag, data) {\n      tag.setAttribute('cx', data.x);\n      tag.setAttribute('cy', data.y);\n      tag.setAttribute('r', data.r);\n    });\n}\n"], ["WaterlockInit", "\nfunction Waterlock(){\n  events.EventEmitter.call(this);\n\n  <initialization>\n  this.sails      = global.sails; \n  this.engine     = _.bind(this.engine, this)();\n  this.config     = _.bind(this.config, this)();\n  this.methods    = _.bind(this.methods, this)().collect();\n  this.models     = _.bind(this.models, this)();\n  this.actions    = _.bind(this.actions, this)();\n  this.cycle      = _.bind(this.cycle, this)();\n  this.jwt        = require('jwt-simple');\n  this.validator  = _.bind(this.validator, this)();\n  </initialization>\n}\n"], ["requireModule", "\nfunction requireModule(filePath, refreshFlag) {\n    <moduleCaching>\n    if (refreshFlag) {\n        delete injector.require.cache[filePath];\n    }\n    </moduleCaching>\n    \n    return injector.require(filePath);\n}\n"], ["wrap", "\nfunction wrap(obj, method, func) {\n    <interceptMethod>\n\tvar proceed = obj[method];\n\tobj[method] = function () {\n\t\tvar args = Array.prototype.slice.call(arguments);\n\t\targs.unshift(proceed);\n\t\treturn func.apply(this, args);\n\t};\n\t</interceptMethod>\n}\n"], ["DependencyInjectorInit", "\nfunction DependencyInjector(opts) {\n    <configurationSetup>\n    var rootDefault = p.join(__dirname, '../../..');\n    this.rootDir = opts.rootDir || rootDefault;                 \n    this.require = opts.require || require;                     \n    this.container = opts.container || 'api';                   \n    this.servicesDir = opts.servicesDir || 'services';          \n    this.tplDir = opts.tplDir || 'dist/tpls';                   \n    this.debug = opts.debug || false;                           \n    this.debugPattern = opts.debugPattern;                      \n    this.debugHandler = opts.debugHandler;                      \n    this.adapters = opts.adapters || {};                        \n    this.reactors = opts.reactors || {};                        \n    this.adapterMap = this.loadAdapterMap(opts);                \n    this.aliases = this.loadAliases(opts);                      \n    this.factories = this.loadFactories(opts);                  \n    </configurationSetup>\n}\n"], ["modify", "\nfunction modify(translate) {\n    if (Glide.settings.focusAt >= 0) {\n        <calculatePeekTranslation>\n        var peek = Components.Peek.value;\n\n        if (isObject(peek)) {\n          return translate - peek.before;\n        }\n\n        return translate - peek;\n        </calculatePeekTranslation>\n      }\n\n      return translate;\n    }\n"], ["defaults", "\nfunction defaults(object) {\n    <setDefaults>\n    if (!object) {\n      return object;\n    }\n    for (var argsIndex = 1, argsLength = arguments.length; argsIndex < argsLength; argsIndex++) {\n      var iterable = arguments[argsIndex];\n      if (iterable) {\n        for (var key in iterable) {\n          if (typeof object[key] == 'undefined') {\n            object[key] = iterable[key];\n          }\n        }\n      }\n    }\n    </setDefaults>\n    return object;\n}\n"], ["determineClientScope", "\nfunction determineClientScope (req, res, next) {\n  <scopeResolution>\n  var params = req.connectParams\n  var subject = req.client\n  var scope = params.scope || subject.default_client_scope\n\n  if (params.grant_type === 'client_credentials') {\n    Scope.determine(scope, subject, function (err, scope, scopes) {\n      if (err) { return next(err) }\n      req.scope = scope\n      req.scopes = scopes\n      next()\n    })\n  } else {\n    next()\n  }\n  </scopeResolution>\n}\n"], ["promiseHandlerWithFileWriter", "\nfunction(promise, result, output, isProgress) {\n\t<initializePromiseOutcomeElement>\n\tvar element = document.createElement(\"div\"); \n\t</initializePromiseOutcomeElement>\n\n\t<countFileWriteOperations>\n\tvar waitCount = 0;\n\t</countFileWriteOperations>\n\n\t<successFileWriteCallback>\n\tvar successFn = function(file) {\n\t\tthis.callback = function() {\n\t\t\tvar string = i18nUtil.formatMessage(messages[\"WroteMsg\"], typeof(file) === \"string\" ? file : this.shellPageFileService.computePathString(file)); \n\t\t\tvar writer = new mResultWriters.ShellStringWriter(element);\n\t\t\twriter.write(string + \"\\n\"); \n\t\t\tif (--waitCount !== 0 || isProgress) {\n\t\t\t\tpromise.progress(element);\n\t\t\t} else {\n\t\t\t\tpromise.resolve(element);\n\t\t\t}\n\t\t}.bind(this);\n\t\treturn this;\n\t}.bind(this);\n\t</successFileWriteCallback>\n\n\t<errorFileWriteCallback>\n\tvar errorFn = function(file) {\n\t\tthis.callback = function(error) {\n\t\t\tvar string = i18nUtil.formatMessage(messages[\"WriteFailMsg\"], typeof(file) === \"string\" ? file : this.shellPageFileService.computePathString(file)); \n\t\t\tstring += \" [\" + error + \"]\"; \n\t\t\tvar writer = new mResultWriters.ShellStringWriter(element);\n\t\t\twriter.write(string + \"\\n\"); \n\t\t\tif (--waitCount !== 0 || isProgress) {\n\t\t\t\tpromise.progress(element);\n\t\t\t} else {\n\t\t\t\tpromise.resolve(element);\n\t\t\t}\n\t\t}.bind(this);\n\t\treturn this;\n\t}.bind(this);\n\t</errorFileWriteCallback>\n\n\t<manageDirectoryForWriteOperation>\n\tvar destination = output || this.shellPageFileService.getCurrentDirectory();\n\twaitCount++;\n\tthis.shellPageFileService.ensureDirectory(null, destination).then(\n\t\tfunction(directory) {\n\t\t\twaitCount--;\n\n\t\t\tvar files = result.getValue();\n\t\t\tif (!result.isArray()) {\n\t\t\t\tfiles = [files];\n\t\t\t}\n\t\t\tfiles.forEach(function(file) {\n\t\t\t\twaitCount++;\n\t\t\t\tvar pathSegments = file.path.split(this.shellPageFileService.SEPARATOR);\n\n\t\t\t\t<sanitizePathSegments>\n\t\t\t\tvar index = 0;\n\t\t\t\twhile (index < pathSegments.length) {\n\t\t\t\t\tvar segment = pathSegments[index];\n\t\t\t\t\tif (segment === \".\") { \n\t\t\t\t\t\tpathSegments.splice(index, 1);\n\t\t\t\t\t} else if (segment === \"..\") { \n\t\t\t\t\t\tif (index === 0) {\n\t\t\t\t\t\t\terrorFn(i18nUtil.formatMessage(messages[\"WriteFailNotDescendentOfOutputDir\"], file.path));\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpathSegments.splice(index-- - 1, 2);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tindex++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t</sanitizePathSegments>\n\n\t\t\t\t<executeFileWriteOperation>\n\t\t\t\tvar writeFile = function(parentNode, fileToWrite, pathSegments) {\n\t\t\t\t\tvar segment = pathSegments[0];\n\t\t\t\t\tpathSegments.splice(0,1);\n\t\t\t\t\tvar nodeString = this.shellPageFileService.computePathString(parentNode) + this.shellPageFileService.SEPARATOR + segment;\n\t\t\t\t\tif (pathSegments.length === 0) {\n\t\t\t\t\t\tif (fileToWrite.isDirectory) {\n\t\t\t\t\t\t\tthis.shellPageFileService.ensureDirectory(parentNode, segment).then(successFn(nodeString).callback, errorFn(nodeString).callback);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthis.shellPageFileService.ensureFile(parentNode, segment).then(\n\t\t\t\t\t\t\t\tfunction(file) {\n\t\t\t\t\t\t\t\t\tvar writer = new mResultWriters.FileBlobWriter(file, this.shellPageFileService);\n\t\t\t\t\t\t\t\t\twriter.addBlob(fileToWrite.blob);\n\t\t\t\t\t\t\t\t\twriter.write().then(successFn(file).callback, errorFn(file).callback);\n\t\t\t\t\t\t\t\t}.bind(this),\n\t\t\t\t\t\t\t\terrorFn(nodeString).callback\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tthis.shellPageFileService.ensureDirectory(parentNode, segment).then(\n\t\t\t\t\t\tfunction(newNode) {\n\t\t\t\t\t\t\twriteFile(newNode, fileToWrite, pathSegments);\n\t\t\t\t\t\t},\n\t\t\t\t\t\terrorFn(this.shellPageFileService.computePathString(parentNode) + this.shellPageFileService.SEPARATOR + segment).callback\n\t\t\t\t\t);\n\t\t\t\t}.bind(this);\n\t\t\t\twriteFile(directory, file, pathSegments);\n\t\t\t}.bind(this));\n\t\t}.bind(this),\n\t\terrorFn(destination).callback\n\t);\n\t</executeFileWriteOperation>\n}\n"], ""]