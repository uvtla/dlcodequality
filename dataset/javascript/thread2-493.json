[["dateNodeDefinition", "\nfunction() {\n  var def = YAHOO.widget.DateNode.superclass.getNodeDefinition.call(this);\n  <checkForDefinition>\n  if (def === false) { return false; }\n  </checkForDefinition>\n  <setCalendarConfig>\n  if (this.calendarConfig) { def.calendarConfig = this.calendarConfig; }\n  </setCalendarConfig>\n  return def;\n}\n"], ["isMember", "\nfunction sismember(key, member, req) {\n  <getKeyValue>\n  var val = this.getKey(key, req);\n  if(val === undefined) return 0;\n  </getKeyValue>\n  <checkMembership>\n  return val.sismember(member);\n  </checkMembership>\n}\n"], ["renderTemplateFile", "\nfunction renderTemplateFile(engine, filePath, context) {\n  var loader = engine.getLoader();\n  \n  <resolveFilePath>\n  var resolvedFilePath = loader.resolve(null, filePath);\n  </resolveFilePath>\n\n  <getTemplateSource>\n  return Promise()\n  .then(function() {\n    if (!loader.async) {\n      return loader.getSource(resolvedFilePath);\n    }\n\n    var deferred = Promise.defer();\n    loader.getSource(resolvedFilePath, deferred.makeNodeResolver());\n    return deferred.promise;\n  })\n  </getTemplateSource>\n  .then(function(result) {\n    <handleNotFound>\n    if (!result) {\n        throw error.TemplateError(new Error('Not found'), {\n            filename: filePath\n        });\n    }\n    </handleNotFound>\n\n    <renderWithTemplate>\n    return render(engine, result.path, result.src, context);\n    </renderWithTemplate>\n  });\n}\n"], ["handleWebSocketError", "\nfunction receiverOnError(err) {\n  const websocket = this[kWebSocket];\n\n  websocket._socket.removeListener('data', socketOnData);\n\n  websocket.readyState = WebSocket.CLOSING;\n  <setErrorDetails>\n  websocket._closeCode = err[kStatusCode];\n  websocket.emit('error', err);\n  </setErrorDetails>\n  <destroySocket>\n  websocket._socket.destroy();\n  </destroySocket>\n}\n"], ["calculateMindMapDimensions", "\nfunction getMindMapDimensions(root) {\n  <initializeDimensions>\n  var pos = root.getPosition();\n  var left = 0, top = 0, right = 0, bottom = 0;\n  var padding = 50;\n  </initializeDimensions>\n\n  <checkNodeDimensions>\n  function checkDimensions(node) {\n    var pos = node.getPosition();\n    var tm = node.textMetrics;\n\n    if (pos.x < left) {\n      left = pos.x;\n    }\n\n    if (pos.x + tm.width > right) {\n      right = pos.x + tm.width;\n    }\n\n    if (pos.y < top) {\n      top = pos.y;\n    }\n\n    if (pos.y + node.outerHeight() > bottom) {\n      bottom = pos.y + node.outerHeight();\n    }\n  }\n  </checkNodeDimensions>\n\n  <updateDimensions>\n  checkDimensions(root);\n  root.forEachDescendant(checkDimensions);\n  </updateDimensions>\n\n  <calculateDimensions>\n  var horizontal = Math.max(Math.abs(right), Math.abs(left));\n  var vertical = Math.max(Math.abs(bottom), Math.abs(top));\n\n  return {\n    width : 2 * horizontal + padding,\n    height : 2 * vertical + padding\n  };\n  </calculateDimensions>\n}\n"], ["setupDepthTexture", "\nfunction setupDepthTexture (framebuffer, renderTarget) {\n  var isCube = (renderTarget instanceof THREE.WebGLRenderTargetCube);\n    <checkCubeRenderTarget>\n  if (isCube) throw new Error('Depth Texture with cube render targets is not supported!');\n    </checkCubeRenderTarget>\n\n  <bindFramebuffer>\n  _gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\n  </bindFramebuffer>\n\n  <validateDepthTexture>\n  if ( !(renderTarget.depthTexture instanceof THREE.DepthTexture) ) {\n    throw new Error('renderTarget.depthTexture must be an instance of THREE.DepthTexture');\n  }\n  </validateDepthTexture>\n\n  <configureDepthTexture>\n  if ( !properties.get( renderTarget.depthTexture ).__webglTexture ||\n      renderTarget.depthTexture.image.width !== renderTarget.width ||\n      renderTarget.depthTexture.image.height !== renderTarget.height ) {\n    renderTarget.depthTexture.image.width = renderTarget.width;\n    renderTarget.depthTexture.image.height = renderTarget.height;\n    renderTarget.depthTexture.needsUpdate = true;\n  }\n  </configureDepthTexture>\n\n  <attachTextureToFramebuffer>\n  setTexture2D( renderTarget.depthTexture, 0 );\n\n  var webglDepthTexture = properties.get( renderTarget.depthTexture ).__webglTexture;\n  _gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0 );\n  </attachTextureToFramebuffer>\n}\n"], ["appendNode", "\nfunction(node) {\n  this.logger.log(\"insertAfter: \" + node);\n  var p = node.parent;\n  if (p) {\n    \n    <manipulateTree>\n    if (this.tree) {\n      this.tree.popNode(this);\n    }\n    </manipulateTree>\n\n    var refIndex = node.isChildOf(p);\n    this.logger.log(refIndex);\n\n    <insertNode>\n    if (!node.nextSibling) {\n      this.nextSibling = null;\n      return this.appendTo(p);\n    }\n\n    p.children.splice(refIndex + 1, 0, this);\n\n    node.nextSibling.previousSibling = this;\n    this.previousSibling = node;\n    this.nextSibling = node.nextSibling;\n    node.nextSibling = this;\n    </insertNode>\n\n    <applyParent>\n    this.applyParent(p);\n    </applyParent>\n  }\n\n  return this;\n}\n"], ["functionWrapper", "\nfunction F(iid, f, flags) {\n  var bFlags = decodeBitPattern(flags, 1); \n  <createWrappedFunction>\n  return function () {\n    var base = this;\n    return (lastComputedValue = invokeFun(iid, base, f, arguments, bFlags[0], false));\n  }\n  </createWrappedFunction>\n}\n"], ["ruleCreator", "\nfunction create(context) {\n  <ruleDefinition>\n  return {\n    CallExpression(node) {\n      if (isRequireCall(node) && !isValidRequire(node)) {\n        context.report(node, message);\n      }\n    }\n  };\n  </ruleDefinition>\n}\n"], ["encodeBase32", "\nfunction encode(data) {\n  <validateArray>\n  $.checkArgument(data instanceof Array, 'Must be Array');\n  </validateArray>\n  var base32 = '';\n  <createBase32String>\n  for (var i=0; i<data.length; i++) {\n    var value = data[i];\n    $.checkArgument(0 <= value && value < 32, 'Non-base32, value ' + value);\n    base32 += CHARSET[value];\n  }\n  </createBase32String>\n  return base32;\n}\n"], "```"]