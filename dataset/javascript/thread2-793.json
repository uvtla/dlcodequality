[["formatSymbolExport", "function formatSymbolExport(symbol, namespaces, imports) {\n  const name = symbol.name;\n  const parts = name.split('~');\n  const isNamed = parts[0].indexOf('.') !== -1;\n  const nsParts = parts[0].replace(/^module\\:/, '').split(/[\\/\\.]/);\n  const last = nsParts.length - 1;\n  <importNaming>\n  const importName = isNamed ?\n    '_' + nsParts.slice(0, last).join('_') + '$' + nsParts[last] :\n    '$' + nsParts.join('$');\n  </importNaming>  \n  let line = nsParts[0];\n  <namespaceRegistration>\n  for (let i = 1, ii = nsParts.length; i < ii; ++i) {\n    line += `.${nsParts[i]}`;\n    namespaces[line] = (line in namespaces ? namespaces[line] : true) && i < ii - 1;\n  }\n  </namespaceRegistration>\n  line += ` = ${importName};`;\n  <registerImport>\n  imports[getImport(symbol, nsParts.pop())] = true;\n  </registerImport>\n  return line;\n}\n"], ["anonymousFunction1", "function () {\n  var heights = this.s.heights;\n  var max = 1000000;\n  <calculateHeight>\n  heights.virtual = heights.row * this.s.dt.fnRecordsDisplay();\n  heights.scroll = heights.virtual;\n\n  if (heights.scroll > max) {\n    heights.scroll = max;\n  }\n  </calculateHeight>\n  \n  <updateStyle>\n  this.dom.force.style.height = heights.scroll + \"px\";\n  </updateStyle>\n}\n"], ["anonymousFunction2", "function (soundfont, instrumentId, index, key) {\n  var url = soundfont[key]\n  if (url) {\n    <incrementBufferPending>\n    bufferPending[instrumentId]++\n    </incrementBufferPending>\n    <loadAudioBuffer>\n    loadAudio(url, function (buffer) {\n      buffer.id = key\n      var noteId = root.keyToNote[key]\n      <storeBuffer>\n      audioBuffers[instrumentId + '' + noteId] = buffer\n      </storeBuffer>\n      \n      if (--bufferPending[instrumentId] === 0) {\n        <onAllBuffersLoaded>\n        soundfont.isLoaded = true\n        waitForEnd(instrument)\n        </onAllBuffersLoaded>\n      }\n    }, function (err) {\n      console.error(err)\n    })\n    </loadAudioBuffer>\n  }\n}\n"], ["trackObjectChange", "function (object, name, oldval, newval) {\n  var type = edb.ObjectChange.TYPE_UPDATE;\n  var all = this._changes, id = object.$instanceid;\n  <recordObjectChange>\n  var set = all[id] = all[id] || (all[id] = Object.create(null));\n  set[name] = new edb.ObjectChange(object, name, type, oldval, newval);\n  </recordObjectChange>\n  <dispatchTick>\n  gui.Tick.dispatch(edb.TICK_PUBLISH_CHANGES);\n  </dispatchTick>\n}\n"], ["initializeJadeCompilerWithLanguageFile", "function (node, options) {\n  <initializeCompiler>\n  jadeCompiler.call(this, node, options);\n  </initializeCompiler>\n  \n  <loadLanguageFile>\n  if (options.languageFile)\n    this.jsonData = po2json.parseFileSync(options.languageFile);\n  </loadLanguageFile>\n}\n"], ["parseAtKeyframes", "function atkeyframes() {\n  <parsePosition>\n  var pos = position();\n  </parsePosition>\n  \n  <matchKeyframes>\n  var m = match(/^@([-\\w]+)?keyframes\\s*/);\n  if (!m) return;\n  var vendor = m[1];\n  </matchKeyframes>\n  \n  <matchName>\n  var m = match(/^([-\\w]+)\\s*/);\n  if (!m) return error(\"@keyframes missing name\");\n  var name = m[1];\n  </matchName>\n  \n  <checkOpeningBracket>\n  if (!open()) return error(\"@keyframes missing '{'\");\n  </checkOpeningBracket>\n  \n  <keyframeSequence>\n  var frame;\n  var frames = comments();\n  while (frame = keyframe()) {\n    frames.push(frame);\n    frames = frames.concat(comments());\n  }\n  </keyframeSequence>\n  \n  <checkClosingBracket>\n  if (!close()) return error(\"@keyframes missing '}'\");\n  </checkClosingBracket>\n  \n  <constructKeyframeBlock>\n  return pos({\n    type: 'keyframes',\n    name: name,\n    vendor: vendor,\n    keyframes: frames\n  });\n  </constructKeyframeBlock>\n}\n"], ["writeTextToOutput", "function writeText(wasmModule, format, output, callback) {\n  <determineWabtRequirement>\n  if (format === \"linear\" || format === \"stack\") {\n    if (!assemblyscript.util.wabt) {\n      process.stderr.write(\"\\nwabt.js not found\\n\");\n      return callback(EFAILURE);\n    }\n    var binary = wasmModule.ascCurrentBinary || (wasmModule.ascCurrentBinary = wasmModule.emitBinary());\n    </determineWabtRequirement>\n  \n    <writeTextWithLinearOrStackFormat>\n    output.write(assemblyscript.util.wasmToWast(binary, { readDebugNames: true }), \"utf8\", end);\n    </writeTextWithLinearOrStackFormat>\n  } else\n    <writeTextDefaultFormat>\n    output.write(wasmModule.emitText(), \"utf8\", end);\n    </writeTextDefaultFormat>\n  \n  <endOutput>\n  function end(err) {\n    if (err || output === process.stdout) return callback(err);\n    output.end(callback);\n  }\n  </endOutput>\n}\n"], ["parseComponentData", "function (rawData) {\n  var schema = this.schema;\n  if (!Object.keys(schema).length) { return; }\n  rawData = rawData || window.HTMLElement.prototype.getAttribute.call(this.sceneEl, this.name);\n  <parseDataBasedOnSchema>\n  if (isSingleProp(schema)) {\n    this.data = parseProperty(rawData, schema);\n  } else {\n    this.data = parseProperties(styleParser.parse(rawData) || {}, schema);\n  }\n  </parseDataBasedOnSchema>\n}\n"], ["createQualifiedNameAttribute", "function (namespaceURI, qualifiedName) {\n  <createElementToManipulateAttributes>\n  var dummy = document.createElement('dummy');\n  </createElementToManipulateAttributes>\n  \n  <setAttributeOnDummy>\n  dummy.setAttributeNS(namespaceURI, qualifiedName, '');\n  var attr = dummy.attributes[0];\n  </setAttributeOnDummy>\n  \n  <removeAttributeFromDummy>\n  dummy.removeAttributeNode(attr);\n  </removeAttributeFromDummy>\n  \n  <returnStrippedAttribute>\n  return attr;\n  </returnStrippedAttribute>\n}\n"], ["formatOAuthUrl", "function formatUrl(p, callback) {\n  <signUrlIfOAuth>\n  var sign;\n  if (p.authResponse && p.authResponse.oauth && parseInt(p.authResponse.oauth.version, 10) === 1) {\n    sign = p.query.access_token;\n    delete p.query.access_token;\n    p.proxy = true;\n  }\n  </signUrlIfOAuth>\n  \n  <serializeDataIntoQuery>\n  if (p.data && (p.method === 'get' || p.method === 'delete')) {\n    _this.extend(p.query, p.data);\n    p.data = null;\n  }\n  </serializeDataIntoQuery>\n  \n  <buildBasePath>\n  var path = _this.qs(p.url, p.query);\n  </buildBasePath>\n  \n  <constructProxyPath>\n  if (p.proxy) {\n    path = _this.qs(p.oauth_proxy, {\n      path: path,\n      access_token: sign || '',\n      then: p.proxy_response_type || (p.method.toLowerCase() === 'get' ? 'redirect' : 'proxy'),\n      method: p.method.toLowerCase(),\n      suppress_response_codes: true\n    });\n  }\n  </constructProxyPath>\n  \n  <invokeCallbackWithFormattedPath>\n  callback(path);\n  </invokeCallbackWithFormattedPath>\n}\n"], "```"]