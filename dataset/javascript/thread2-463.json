[["_mapOne", "\nfunction _mapOne(name) {\n      const parts = name.split(\".\");\n      let current = _this.parent.model;\n      let current_name = \"\";\n      while (parts.length) {\n        current_name = parts.shift();\n        current = current[current_name];\n      }\n      return {\n        name,\n        model: current,\n        type: current ? current.getType() : null\n      };\n    }\n"], ["anonymous_function", "\nfunction(req, res, next) {\n  <set_default_origin>\n  if (req.headers.origin === undefined) {\n      res.setHeader('Access-Control-Allow-Origin', \"*\");\n  } else {\n      res.setHeader('Access-Control-Allow-Origin', req.headers.origin);\n  }\n  </set_default_origin>\n  \n  <set_headers>\n  res.setHeader('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, OPTIONS');\n  </set_headers>\n  \n  <log_request>\n  console.log(req.method + \" on \" + req.originalUrl);\n  </log_request>\n  \n  <handle_options>\n  if (req.method === \"OPTIONS\") {\n      res.setHeader('Access-Control-Allow-Headers', 'content-type');\n      res.setHeader('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, OPTIONS');\n      res.setHeader('Content-Length', '0');\n      res.setHeader('Content-Type', 'application/json; charset=utf-8');\n      grunt.file.read(req.originalUrl.split(\"?\")[0]);\n      \n      res.end(\"200\");\n      \n  } else {\n      next();\n  }\n  </handle_options>\n}\n"], ["skladConnection_get", "\nfunction skladConnection_get() {\n    const isMulti = (arguments.length === 1 && typeof arguments[0] === 'object');\n    const objStoreNames = isMulti ? Object.keys(arguments[0]) : [arguments[0]];\n\n    <validate_stores>\n    const allObjStoresExist = checkContainingStores.call(this, objStoreNames);\n    if (!allObjStoresExist) {\n        const err = createError('NotFoundError', `Database ${this.database.name} (version ${this.database.version}) doesn't contain all needed stores`);\n        return Promise.reject(err);\n    }\n    </validate_stores>\n\n    let result = {};\n    let data, abortErr;\n\n    <prepare_data>\n    if (isMulti) {\n        data = arguments[0];\n    } else {\n        data = {};\n        data[arguments[0]] = arguments[1];\n    }\n\n    objStoreNames.forEach(function (objStoreName) {\n        result[objStoreName] = [];\n    });\n    </prepare_data>\n\n    return new Promise((resolve, reject) => {\n        let transaction;\n\n        \n        <initiate_transaction>\n        try {\n            transaction = this.database.transaction(objStoreNames, TRANSACTION_READONLY);\n        } handle_transaction_error {\n          } \n\n        transaction.oncomplete = transaction.onerror = transaction.onabort = function skladConnection_get_onFinish(evt) {\n            const err = abortErr || evt.target.error;\n            const isSuccess = !err && evt.type === 'complete';\n\n            if (isSuccess) {\n                resolve(isMulti ? result : result[objStoreNames[0]]);\n            } else {\n                reject(ensureError(err));\n            }\n\n            if (evt.type === 'error') {\n                evt.preventDefault();\n            }\n        };\n        </initiate_transaction>\n\n        for (let objStoreName in data) {\n            const objStore = transaction.objectStore(objStoreName);\n            const options = data[objStoreName] || {};\n            const direction = options.direction || skladAPI.ASC;\n            const range = options.range instanceof IDBKeyRangeRef ? options.range : null;\n\n            <initialize_object_store_request>\n            let useGetAll = false;\n            let iterateRequest;\n\n            if (supportsObjStoreGetAll) {\n                useGetAll = Object.keys(options).every(key => (key !== 'index' && key !== 'direction'));\n            }\n            if (options.index) {\n                if (!objStore.indexNames.contains(options.index)) {\n                    abortErr = createError('NotFoundError', `Object store ${objStore.name} doesn't contain \"${options.index}\" index`);\n                    return;\n                }\n\n                try {\n                    iterateRequest = objStore.index(options.index).openCursor(range, direction);\n                } catch (ex) {\n                    abortErr = ex;\n                    return;\n                }\n            } else {\n                <use_get_all>\n                if (useGetAll) {\n                  // The get all logic is a distinct responsibility\n                }\n                </use_get_all>\n                <use_cursor>\n                else {\n                    try {\n                        iterateRequest = objStore.openCursor(range, direction);\n                    } catch (ex) {\n                        abortErr = ex;\n                        return;\n                    }\n                }\n                </use_cursor>\n            }\n            </initialize_object_store_request>\n            \n            <handle_iteration>\n            let cursorPositionMoved = false;\n\n            iterateRequest.onsuccess = function (evt) {\n                const cursor = evt.target.result;\n\n                \n                if (!cursor) {\n                    return;\n                }\n\n                if (options.offset && !cursorPositionMoved) {\n                    cursorPositionMoved = true;\n                    cursor.advance(options.offset);\n\n                    return;\n                }\n\n                result[objStoreName].push({\n                    key: cursor.key,\n                    value: cursor.value\n                });\n\n                if (options.limit && options.limit === result[objStoreName].length) {\n                    return;\n                }\n\n                cursor.continue();\n            };\n            </handle_iteration>\n        }\n    });\n}\n"], ["getExpandedQuery", "\nfunction getExpandedQuery(basicQuery) {\n  <check_existing_query>\n  let expandedQuery = [];\n  const needsExpandedQuery = isExpandableQuery(basicQuery);\n  </check_existing_query>\n\n  <process_query_expansion>\n  if (!needsExpandedQuery) {\n    expandedQuery = basicQuery;\n  } else {\n    _.each(basicQuery, (query, i) => {\n      let thisNonExpandableQueryWasAlreadyCloned = false;\n      const isExpandableQueryLine = isAlongExpandableQueryLine(query);\n      _.each(query.nested.query.bool.must, (innerQuery, mustI) => {\n        const matchObj = innerQuery.nested.query.match;\n        const values = _.values(matchObj);\n        if (values.length > 1) {\n          console.warn('...warning message...');\n          throw Error('The query expansion algorithm does not expect this query form.');\n        }\n        if (_.isArray(values[0])) {\n          _.each(values[0], (value) => {\n            const key = _.keys(matchObj)[0];\n            const newQuery = _.cloneDeep(basicQuery);\n            const relatedMatchObj = newQuery[i].nested.query.bool.must[mustI].nested.query.match;\n            relatedMatchObj[key] = value;\n            expandedQuery.push(newQuery[i]);\n          });\n        } else {\n          <handle_non_expandable_query>\n          if (!isExpandableQueryLine && !thisNonExpandableQueryWasAlreadyCloned) {\n            \n            expandedQuery.push(basicQuery[i]);\n            thisNonExpandableQueryWasAlreadyCloned = true;\n          }\n          </handle_non_expandable_query>\n        }\n      });\n    });\n  }\n  </process_query_expansion>\n\n  return expandedQuery;\n}\n"], ["resolveAppBuild", "\nfunction resolveAppBuild(appTsConfigPath) {\n  const outDir = getAppBuildFolder(appTsConfigPath);\n  const buildPath = path.join(path.dirname(appTsConfigPath), outDir);\n  return buildPath;\n}\n"], ["anonymous_function_animation", "\nfunction (domElt, refreshArgs) {\n  \n  <initialize_animation>\n  var animation = this._getAnimation();\n  this._animating = true;\n  var newSection = this._domElt.cloneNode(false);\n  </initialize_animation>\n  \n  <setup_dom>\n  domElt.id = null;\n  newSection.className += \" not-visible\";\n  newSection = ariaUtilsDom.replaceHTML(newSection, this.html);\n  var from = domElt;\n  var to = newSection;\n  ariaUtilsDom.insertAdjacentElement(from, \"afterEnd\", newSection);\n  this.setDom(newSection);\n  </setup_dom>\n\n  <configure_animation>\n  var animSemaphore = false;\n  var cfg = {\n      \n      to : to,\n      type : 3,\n      reverse : animation.animIn.reverse,\n      hiddenClass : 'not-visible'\n  };\n\n  var cfg2 = {\n      from : from,\n      \n      type : 3,\n      reverse : animation.animOut.reverse,\n      hiddenClass : 'not-visible'\n  };\n  </configure_animation>\n\n  <animate_elements>\n  var anim = new ariaUtilsCssAnimations();\n  var anim2 = new ariaUtilsCssAnimations();\n\n  var animEnd = {\n      \"animationend\" : function () {\n          if (animSemaphore) {\n              ariaUtilsDom.removeElement(from);\n              this._animating = false;\n              this.tplCtxt.onRefreshAnimationEnd(refreshArgs);\n          } else {\n              animSemaphore = true;\n          }\n      },\n      scope : this\n  };\n\n  anim.$on(animEnd);\n  anim2.$on(animEnd);\n\n  anim.start(animation.animIn.type, cfg);\n  anim2.start(animation.animOut.type, cfg2);\n  </animate_elements>\n}\n"], ["anonymous_function", "\nfunction(_href){\n  \n  \n  <lock_management>\n  if (!!_locked){\n      _locked = !1;\n      return;\n  }\n  </lock_management>\n  \n  var _event = {\n      oldValue:_location,\n      newValue:_getLocation()\n  };\n  \n  <modify_state>\n  if (!!location.ignored){\n      location.ignored = !1;\n  }else{\n      _v._$dispatchEvent(\n          location,'beforeurlchange',_event\n      );\n      if (_event.stopped){\n          if (!!_location){\n              _locked = !0;\n              _setLocation(_location.href,!0);\n          }\n          return;\n      };\n  }\n  \n  _url = _ctxt.location.href;\n  _location = _event.newValue;\n  _v._$dispatchEvent(\n      location,'urlchange',_location\n  );\n  _h.__pushHistory(_location.href);\n  </modify_state>\n}\n"], ["convertToJson", "\nfunction convertToJson(callback) {\n    var output = new File(file);\n    output.contents = new Buffer(JSON.stringify(spritesheet, null, '\\t'));\n    output.path = file;\n    this.push(output);\n    callback();\n  }\n"], ["queryImport", "\nfunction queryImport(styles) {\n    if (styles.indexOf('@import') < 0) return []\n    const arr = []\n    const ast = csstree.parse(styles);\n    <extract_imports>\n    csstree.walk(ast, {\n        enter: function (node) {\n            if (node.type === 'Atrule' && node.name === 'import') {\n                const pat = node.prelude.children.head.data.value\n                arr.push(pat.substring(1, pat.length - 1))\n            }\n        }\n    })\n    </extract_imports>\n    return arr\n}\n"], ["function", "\nfunction(value, attr, required, model, computed) {\n        var isRequired = _.isFunction(required) ? required.call(model, value, attr, computed) : required;\n        \n        <handle_optional_field>\n        if(!isRequired && !hasValue(value)) {\n          return false; \n        }\n        </handle_optional_field>\n        \n        <handle_required_field>\n        if (isRequired && !hasValue(value)) {\n          return this.format(getMessageKey(this.msgKey, defaultMessages.required), this.formatLabel(attr, model));\n        }\n        </handle_required_field>\n      }\n"], "```"]