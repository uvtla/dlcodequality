[["function1", "\nfunction(context, callback, binds) {\n    var instance = new Instance(this);\n    var count = 0,\n        binded = false;\n    for (var i = 1, len = this.parts.length; i < len; i = i + 2) {\n        var block = this.parts[i];\n        if (block.binded) {\n            <setupHandlerAndSubscribe>\n            binded = true;\n            var h = handler(instance, context, block.func, count, callback),\n                dep = block.dep;\n            for (var j = 0, lenJ = dep.length; j < lenJ; j++)\n                context.subscribe(dep[j], h, false, instance.binds);\n            </setupHandlerAndSubscribe>\n        }\n        count++;\n    }\n    if (binded && binds)\n        binds.push(unsub(instance));\n    return instance;\n}\n"], ["regexBodyMatch", "\nfunction regexBodyMatch(path, ruleSet, body, expectedBody){\n\n    var matchingObjects = jsonPath({json: {body: body}, path: path});\n    var matchingExpectedObjects = jsonPath({json: {body: expectedBody}, path: path});\n\n    <validateMin>\n    if(ruleSet.hasOwnProperty(\"min\")){\n        var failing = matchingObjects.map(function(match){\n            if(match.length < ruleSet.min){\n                return {\n                    error: \"failed to meet minimum for :\" + path,\n                    expected: ruleSet.min,\n                    actual: match.length\n                };\n            }\n        }).filter(function(f){\n            return !!f;\n        });\n\n        if(failing.length){\n            return failing[0];\n        }\n    }\n    </validateMin>\n    <validateMax>\n    if(ruleSet.hasOwnProperty(\"max\")){\n        var failing = matchingObjects.map(function(match){\n            if(match.length > ruleSet.max){\n                return {\n                    error: \"failed to meet maximum for :\" + path,\n                    expected: ruleSet.max,\n                    actual: match.length\n                };\n            }\n        }).filter(function(f){\n            return !!f;\n        });\n        if(failing.length){\n            return failing[0];\n        }\n    }\n    </validateMax>\n    <validateMatchType>\n    if(ruleSet.hasOwnProperty(\"match\") && ruleSet.match === \"type\"){\n        var typeCheckFailure = checkTypeMatch(matchingObjects, matchingExpectedObjects, path);\n        if(typeCheckFailure){\n            return typeCheckFailure;\n        }\n    }\n    </validateMatchType>\n    <validateMatchRegex>\n    if(ruleSet.hasOwnProperty(\"match\") && ruleSet.match === \"regex\"){\n        if(!checkRegexMatch(ruleSet, matchingObjects)){\n            return {\n                error: \"Unable to match regex: \",\n                expected: ruleSet.regex,\n                actual: matchingObjects\n            };\n        }\n    }\n    </validateMatchRegex>\n    return false; \n}\n"], ["function3", "\nfunction(out) {\n    this._frame.writeMarkupEnd(out);\n    <appendLabelIfPresent>\n    var label = this._cfg.label;\n    if (label) {\n        var ariaHidden = this._cfg.waiAria ? ' aria-hidden=\"true\"' : '';\n        out.write('<span class=\"xFieldset_' + this._cfg.sclass + '_normal_label\"' + ariaHidden + '>' + ariaUtilsString.escapeHTML(label) + '</span>');\n    }\n    </appendLabelIfPresent>\n}\n"], ["interpolation2", "\nfunction interpolation2(prefix, v0, i0, v1, suffix) {\n    var different = bindingUpdated2(v0, v1);\n    return different ? prefix + stringify$1(v0) + i0 + stringify$1(v1) + suffix : NO_CHANGE;\n}\n"], ["function5", "\nfunction(scriptName, params) {\n    var ctx = u.context(SMALL);\n    logger.debugf('Invoke execute(msgId=%d,scriptName=%s,params=%s)', ctx.id, scriptName, u.str(params));\n    \n    return futureExec(ctx, 0x2B, p.encodeNameParams(scriptName, params), p.decodeValue());\n}\n"], ["constructCode", "\nfunction constructCode(code, system, display) {\n    const codeObj = new models.Concept(system, code, display);\n    return codeObj;\n}\n"], ["setupAndLoadPlugin", "\nfunction(settings, pluginInfo, options) {\n    <setupPlugin>\n    var plugin;\n    if (_.has(pluginInfo, 'plugin')) {\n        plugin = pluginInfo.plugin;\n    } else if (_.has(pluginInfo, 'module')) {\n        if (_.contains(settings.loadedModules, pluginInfo.module)) {\n            return settings;\n        }\n        \n        try {\n            plugin = require(pluginInfo.module);\n        } catch (err) {\n            throw new GrawlixPluginError({\n                msg: \"cannot find module '\" + pluginInfo.module + \"'\",\n                plugin: pluginInfo,\n                trace: new Error() \n            });\n        }\n        settings.loadedModules.push(pluginInfo.module);\n    } else {\n        plugin = pluginInfo;\n    }\n    var pluginOpts = _.has(pluginInfo, 'options') ? pluginInfo.options : {};\n    \n    if (_.isFunction(plugin)) {\n        plugin = plugin(pluginOpts, options);\n    }\n    \n    if (!(plugin instanceof GrawlixPlugin)) {\n        throw new GrawlixPluginError({\n            msg: 'invalid plugin',\n            plugin: pluginInfo\n        });\n    } else if (plugin.name === null || _.isEmpty(plugin.name)) {\n        throw new GrawlixPluginError({\n            msg: 'invalid plugin - name property not provided',\n            plugin: pluginInfo\n        });\n    } else if (_.contains(settings.loadedPlugins, plugin.name)) {\n        return settings;\n    }\n    </setupPlugin>\n    <initializePlugin>\n    plugin.init(pluginOpts);\n    </initializePlugin>\n    <loadPluginFilters>\n    if (!_.isUndefined(plugin.filters) && _.isArray(plugin.filters)) {\n        try {\n            loadFilters(settings, plugin.filters, options.allowed);\n        } catch (err) {\n            err.plugin = pluginInfo;\n            throw err;\n        }\n    }\n    </loadPluginFilters>\n    <loadPluginStyles>\n    if (!_.isUndefined(plugin.styles) && _.isArray(plugin.styles)) {\n        try {\n            loadStyles(settings, plugin.styles);\n        } catch (err) {\n            err.plugin = pluginInfo;\n            throw err;\n        }\n    }\n    </loadPluginStyles>\n    settings.loadedPlugins.push(plugin.name);\n    \n    return settings;\n}\n"], ["updateLocationFromCurrentState", "\nfunction() {\n    var current = $state.current();\n\n    <constructURLFromState>\n    if(current && current.url) {\n        var path;\n        path = current.url;\n        var params = current.params || {};\n        var query = {};\n        for(var name in params) {\n            var re = new RegExp(':'+name, 'g');\n            if(path.match(re)) {\n                path = path.replace(re, params[name]);\n            } else {\n                query[name] = params[name];\n            }\n        }\n    </constructURLFromState>\n    <updateBrowserLocation>\n    $location.path(path);\n    $location.search(query);\n    _url = $location.url();\n    </updateBrowserLocation>\n  }\n}\n"], ["yeast", "\nfunction yeast() {\n    <incrementSeed>\n    var now = encode$1(+new Date());\n    if (now !== prev) return (seed = 0), (prev = now);\n    return now + \".\" + encode$1(seed++);\n    </incrementSeed>\n}\n"], ["triggerEventHandling", "\nfunction trigger(app, evName, data) {\n    <setupTriggerData>\n    var triggerData = app;\n    if (\"string\" === typeof app) {\n        triggerData = {\n            eventName: evName,\n            appName: app,\n            data: data\n        };\n    }\n    if (\"*\" !== defaultAppName) {\n        triggerData.appName = triggerData.appName || defaultAppName;\n        if (\"string\" === typeof app && (\"object\" === typeof evName || \"undefined\" === typeof evName)) {\n            triggerData.eventName = app;\n        }\n    }\n    if (!triggerData || typeof (triggerData.eventName) === \"undefined\") {\n        evUtil.log(\"Ev name not spec for publish\", \"ERROR\", \"Events\");\n        triggerData = null;\n        return null;\n    }\n    triggerData.passDataByRef = triggerData.passDataByRef || !cloneData;\n    _storeEventData(triggerData);\n    </setupTriggerData>\n    <invokeEventListeners>\n    var callBacks = evUtil.getListeners(lstnrs, triggerData.eventName, triggerData.appName);\n    if (callBacks.length > 0) {\n        for (var j = 0; j < callBacks.length; j++) {\n            var eventData = triggerData.passDataByRef ? triggerData.data : evUtil.cloneEventData(triggerData.data);\n            var eventInformation = {appName: triggerData.appName, eventName: triggerData.eventName};\n            var callBack = callBacks[j];\n            if (callBack.aSync || (eventData && eventData.aSync)) {\n                setTimeout(_createCallBack(callBack, eventData, eventInformation), 0);\n            } else {\n                _createCallBack(callBack, eventData, eventInformation)();\n            }\n        }\n    }\n    </invokeEventListeners>\n    triggerData = null;\n    return (callBacks.length > 0);\n}\n"], "```\n\nPlease note that descriptions are provided alongside the tags in some cases for clearer understanding."]