[["getSubjectBarycenter", "\nfunction getSubjectBarycenter(subject){\n\n\t<calculateBarycenter>\n\tvar weighted_number_of_edges = 0;\n\tvar number_of_edges = 0;\n\tfor( var o = 1; o <= object_vector.length; o++ ){\n\t    if( relation_matrix[object_vector[o -1].id()] &&\n\t\trelation_matrix[object_vector[o -1].id()][subject.id()]){\n\t\tweighted_number_of_edges += o;\n\t\tnumber_of_edges++;\n\t    }\n\t}\n\t</calculateBarycenter>\n\t\n\treturn ( weighted_number_of_edges / number_of_edges ) -1;\n}\n"], ["mergeSize", "\nfunction mergeSize(size, result) {\n\t<copySizeProperties>\n    if (size) {\n        if (size.hasOwnProperty(\"scale\")) {\n            result.scale = size.scale;\n        }\n\n        if (size.hasOwnProperty(\"width\")) {\n            result.width = size.width;\n        }\n\n        if (size.hasOwnProperty(\"widthUnit\")) {\n            result.widthUnit = size.widthUnit;\n        }\n\n        if (size.hasOwnProperty(\"height\")) {\n            result.height = size.height;\n        }\n\n        if (size.hasOwnProperty(\"heightUnit\")) {\n            result.heightUnit = size.heightUnit;\n        }\n    }\n\t</copySizeProperties>\n}\n"], ["copyPluginFramework", "\nfunction (framework) {\n\t<defineTargetDestinationAndCheckExistence>\n    var targetDir = framework.targetDir || '';\n    var dest = path.join(cordovaProjectWindowsPlatformDir, 'plugins', dummyPluginInfo.id, targetDir, path.basename(framework.src));\n    var copiedSuccessfully = fs.existsSync(path.resolve(dest));\n    </defineTargetDestinationAndCheckExistence>\n    expect(copiedSuccessfully).toBe(true);\n}\n"], ["findMinimum", "\nfunction min(compare, iterable, dflt = undefined) {\n\n\t<initializeIteration>\n  let iterator = (0, _iter.iter)(iterable);\n  let first = iterator.next();\n\t</initializeIteration>\n\n  if (first.done) return dflt;\n\n\t<findSmallestElement>\n  let smallest = first.value;\n  for (let candidate of iterator) {\n    if (compare(candidate, smallest) < 0) {\n      smallest = candidate;\n    }\n  }\n\t</findSmallestElement>\n\n  return smallest;\n}\n"], ["closureForExitCondition", "\nfunction(){\n\tvar foundNormalContext = false;\n\treturn function shouldExitOnSecondNormalContext(currentScope){\n\t\t<determineExitCondition>\n\t\tvar isNormalContext = !currentScope.isSpecial();\n\t\tvar shouldExit = isNormalContext && foundNormalContext;\n\t\t\n\t\tif(isNormalContext) {\n\t\t\tfoundNormalContext = true;\n\t\t}\n\t\t</determineExitCondition>\n\t\treturn shouldExit;\n\t};\n}\n"], ["logRequestStart", "\nfunction(requestUrl, requestType) {\n\t<buildAndLogMessage>\n    const oThis = this,\n      d = new Date(),\n      dateTime =\n        d.getFullYear() +\n        '-' +\n        (d.getMonth() + 1) +\n        '-' +\n        d.getDate() +\n        ' ' +\n        d.getHours() +\n        ':' +\n        d.getMinutes() +\n        ':' +\n        d.getSeconds() +\n        '.' +\n        d.getMilliseconds(),\n      message = \"Started '\" + requestType + \"'  '\" + requestUrl + \"' at \" + dateTime;\n\n    oThis.info(message);\n\t</buildAndLogMessage>\n}\n"], ["registerCommandInComponentJS", "\nfunction () {\n\t<parseParameters>\n    var params = $cs.params(\"register\", arguments, {\n        name:      { pos: 0,     req: true  },\n        ctx:       {             def: this  },\n        func:      { pos: 1,     req: true  },\n        args:      { pos: \"...\", def: []    },\n        spool:     {             def: null  },\n        capturing: {             def: false },\n        spreading: {             def: false },\n        bubbling:  {             def: true  }\n    });\n\t</parseParameters>\n\n\t<createCommandObject>\n    var cmd = $cs.command({\n        ctx:   params.ctx,\n        func:  params.func,\n        args:  params.args,\n        wrap:  true\n    });\n\t</createCommandObject>\n\n\t<defineCommandListener>\n    cmd.command.listen({\n        name: \"attribute:set:enabled\",\n        args: [ this, params.name ],\n        func: function (comp, name, value_new, value_old) {\n            comp.publish({\n                name:      \"ComponentJS:service:\" + name + \":callable\",\n                args:      [ value_new, value_old ],\n                capturing: false,\n                spreading: false,\n                bubbling:  false,\n                async:     true,\n                noresult:  true\n            });\n        }\n    });\n\t</defineCommandListener>\n\n\t<subscribeToEvent>\n    var id = this.subscribe({\n        name:      \"ComponentJS:service:\" + params.name,\n        ctx:       params.ctx,\n        func:      cmd,\n        noevent:   true,\n        capturing: params.capturing,\n        spreading: params.spreading,\n        bubbling:  params.bubbling,\n        exclusive: true\n    });\n\t</subscribeToEvent>\n\n\t<addToSpoolIfNecessary>\n    if (params.spool !== null) {\n        var info = _cs.spool_spec_parse(this, params.spool);\n        info.comp.spool(info.name, this, \"unregister\", id);\n    }\n\t</addToSpoolIfNecessary>\n\n    return id;\n}\n"], ["createZone", "\nfunction (details, callback) {\n\t<createZonesAndHandleResult>\n    this.createZones([ details ], function (err, zones) {\n      if (err) {\n        return callback(err);\n      }\n\n      if (zones && zones.length === 1) {\n        return callback(err, zones[0]);\n      }\n      else {\n        return callback(new Error('Unexpected error when creating single zone'), zones);\n      }\n    });\n\t</createZonesAndHandleResult>\n}\n"], ["getSymbolId", "\nfunction getSymbolId(glyf, index) {\n\t<generateIdentifier>\n    if (glyf.name) {\n        return glyf.name;\n    }\n\n    if (glyf.unicode && glyf.unicode.length) {\n        return 'uni-' + glyf.unicode[0];\n    }\n    return 'symbol-' + index;\n\t</generateIdentifier>\n}\n"], ["filterBySelector", "\nfunction (selector) {\n\t<applySelectorFilter>\n    if (vQ.isFunction(selector)) return this.not(this.not(selector));\n    return vQ(filter.call(this, function (element) {\n        return vQ.matches(element, selector);\n    }));\n\t</applySelectorFilter>\n}\n"], ""]