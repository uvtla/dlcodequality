[["screenshot", "\nfunction screenshot(name, options) {\n  var options  = options || {};\n  var newPath = path;\n\n  if(options.selector) { selector = options.selector; }\n  if(options.path) { newPath = path + '/' + options.path; }\n  if(Array.isArray(options.exclude)) { exclude = exclude.concat(options.exclude); }\n\n  if(window.callPhantom && window.PhantomScreenshot) {\n    asyncScreenshot(name, newPath);\n  }\n}\n"], ["calculateDistanceVector", "\nfunction (v) {\n  var dx = this.x - v.x, dy = this.y - v.y, dz = this.z - (v.z || 0);\n  return Math.sqrt(dx * dx + dy * dy + dz * dz);\n}\n"], ["createStanzaError", "\nfunction StanzaError(message, type, condition) {\n  Error.apply(this, arguments);\n  Error.captureStackTrace(this, arguments.callee);\n  this.name = 'StanzaError';\n  this.message = message || null;\n  this.type = type || 'wait';\n  this.condition = condition || 'internal-server-error';\n}\n"], ["dataZoomModelHandling", "\nfunction (dataZoomModel) {\n  if (dataZoomModel !== this._dataZoomModel) {\n    return;\n  }\n\n  var targetSeries = this.getTargetSeriesModels();\n  this._dataExtent = calculateDataExtent(this, this._dimName, targetSeries);\n  setMinMaxSpan(this);\n  var dataWindow = this.calculateDataWindow(dataZoomModel.option);\n  this._valueWindow = dataWindow.valueWindow;\n  this._percentWindow = dataWindow.percentWindow;\n  setAxisModel(this);\n}\n"], ["getKeyframesBlocks", "\nfunction getKeyframesBlocks() {\n  const type = NodeType.BlockType;\n  const token = tokens[pos];\n  const line = token.ln;\n  const column = token.col;\n  const keyframesBlocksEnd = token.block_end;\n  let content = [];\n\n  while (pos < keyframesBlocksEnd) {\n    if (checkSC(pos)) content = content.concat(getSC());\n    else if (checkKeyframesBlock(pos)) content.push(getKeyframesBlock());\n    else if (checkAtrule(pos)) content.push(getAtrule()); \n    else break;\n  }\n\n  return newNode(type, content, line, column);\n}\n"], ["Text", "\nfunction Text(text, font, color) {\n  this.DisplayObject_constructor();\n  this.text = text;\n  this.font = font;\n  this.color = color;\n  this.textAlign = \"left\";\n  this.textBaseline = \"top\";\n  this.maxWidth = null;\n  this.outline = 0;\n  this.lineHeight = 0;\n  this.lineWidth = null;\n}\n"], ["insertRules", "\nfunction( rules, priority, options ) {\n  var args = [ this.findIndex( priority ), 0 ];\n\n  for ( var i = 0, len = rules.length; i < len; i++ ) {\n    args.push( {\n      value: rules[ i ],\n      priority: priority,\n      options: options\n    } );\n  }\n\n  this.rules.splice.apply( this.rules, args );\n}\n"], ["findLargestComponent", "\nfunction(components){\n  var largeComponent = components[0];\n  for(var i=1; i<components.length; i++){\n    if(largeComponent.nodes.length < components[i].nodes.length){ largeComponent = components[i];}\n  }\n  return (!!largeComponent ? largeComponent.color : null);\n}\n"], ["VideoBuffer", "\nfunction VideoBuffer(video) {\n  this.readyState = video.readyState;\n  this._video = video;\n  this._canvas = null;\n  this._lastTime = -1;\n  if (this.readyState < 2) { video.addEventListener(\"canplaythrough\", this._videoReady.bind(this)); } \n}\n"], ["autoCleanup", "\nfunction autoCleanup (self, cleanupFn) {\n  if (self.mousedown || self.lastRipple) {\n    self.mousedown = false;\n    self.$mdUtil.nextTick(angular.bind(self, cleanupFn), false);\n  }\n}\n"], ""]