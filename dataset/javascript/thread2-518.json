[["addDetected", "\nfunction addDetected(app, pattern, type, value, key) {\n  app.detected = true;\n\n  \n  app.confidence[`${type} ${key ? `${key} ` : ''}${pattern.regex}`] = pattern.confidence === undefined ? 100 : parseInt(pattern.confidence, 10);\n\n  \n  if (pattern.version) {\n    const versions = [];\n    const matches = pattern.regex.exec(value);\n\n    let { version } = pattern;\n\n    if (matches) {\n      matches.forEach((match, i) => {\n        \n        const ternary = new RegExp(`\\\\\\\\${i}\\\\?([^:]+):(.*)$`).exec(version);\n\n        if (ternary && ternary.length === 3) {\n          version = version.replace(ternary[0], match ? ternary[1] : ternary[2]);\n        }\n\n        \n        version = version.trim().replace(new RegExp(`\\\\\\\\${i}`, 'g'), match || '');\n      });\n\n      if (version && versions.indexOf(version) === -1) {\n        versions.push(version);\n      }\n\n      if (versions.length) {\n        \n        app.version = versions.reduce((a, b) => (a.length > b.length ? a : b));\n      }\n    }\n  }\n}\n"], ["validateSchemas", "\nfunction() {\n    let schemas = utils.parseArg(arguments);\n    schemas.forEach(function(schema) {\n      utils.assert(schema.isOvt, `${utils.obj2Str(schema)} is not a valid ovt schema`);\n    });\n  }\n"], ["asyncSome", "\nfunction asyncSome(promise, iterator, scope, limit) {\n    return asyncArray(asyncLoop(promise, iterator, scope, limit).chain(function (results) {\n        return results.loopResults.some(function (res) {\n            return !!res;\n        });\n    }));\n}\n"], ["done", "\nfunction done(error, ret) {\n    busy = false;\n\n    \n    if (!error) {\n      var everReleased = !!watchList.length;\n      var affectedToCheck = [];\n\n      \n      Object.keys(ret.modified).forEach(function(filepath) {\n        var file = ret.modified[filepath];\n        var filepath = file.realpath;\n\n        ~watchList.indexOf(filepath) || watchList.push(filepath);\n\n        \n        if (file.cache) {\n          _.forEach(file.cache.deps, function(mtime, filepath) {\n            ~watchList.indexOf(filepath) || watchList.push(filepath);\n          });\n        }\n\n        \n        if (everReleased) {\n          file.links.forEach(function(filepath) {\n            filepath = fis.util(root, filepath);\n            if (!~watchList.indexOf(filepath)) {\n              watchList.push(filepath);\n              affectedToCheck.push(filepath);\n              affectedList.push(filepath);\n\n              fis.log.debug('New files detected: %s', filepath);\n            }\n          });\n        }\n      });\n\n      latestTotal = ret.totalBeforePack;\n      process.stdout.write(util.format(' [%s]\\n'.grey, fis.log.now()));\n\n      \n      if (affectedList.length) {\n        affectedToCheck.length && getAffectedFiles(latestTotal, affectedToCheck, false).forEach(function(filepath) {\n          ~affectedList.indexOf(filepath) || affectedList.unshift(filepath);\n        });\n\n        setTimeout(release, 200);\n      }\n    }\n  }\n"], ["createDocumentTypeNode", "\nfunction(qualifiedName, publicId, systemId){\n\t\tvar node = new DocumentType();\n\t\tnode.name = qualifiedName;\n\t\tnode.nodeName = qualifiedName;\n\t\tnode.publicId = publicId;\n\t\tnode.systemId = systemId;\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\treturn node;\n\t}\n"], ["LoopStopInjector", "\nfunction LoopStopInjector() {\n\n    var t = {};\n\n    t.inject = inject;\n\n    return t;\n\n    \n    function inject(code) {\n\n        var LOOP_CHECK = 'if (LoopStopManager.shouldStopExecution(%d)) break; ';\n        var LOOP_EXIT = '\\nLoopStopManager.exitedLoop(%d);\\n';\n\n        var loopId = 1;\n        var patches = [];\n\n        var loopStatements = [\"ForOfStatement\",\n                              \"ForStatement\",\n                              \"ForInStatement\",\n                              \"WhileStatement\",\n                              \"DoWhileStatement\"];\n\n        esprima.parse(code, { range: true }, function(node) {\n\n            var isItLoopStatement = loopStatements.indexOf(node.type) != -1;\n\n            if (isItLoopStatement) {\n\n                var start = 1 + node.body.range[0];\n                var end = node.body.range[1];\n                var prolog = LOOP_CHECK.replace('%d', loopId);\n                var epilog = '';\n\n                if (node.body.type !== 'BlockStatement') {\n\n                    \n                    prolog = '{' + prolog;\n                    epilog = '}';\n                    --start;\n\n                }\n\n                patches.push({ pos: start, str: prolog });\n                patches.push({ pos: end, str: epilog });\n                patches.push({ pos: node.range[1] + 1, str: LOOP_EXIT.replace('%d', loopId) });\n\n                loopId++;\n\n            }\n\n        });\n\n        patches.sort(function (a, b) { return b.pos - a.pos }).forEach(function (patch) {\n\n            code = code.slice(0, patch.pos) + patch.str + code.slice(patch.pos);\n\n        });\n\n        return code;\n\n    }\n\n}\n"], ["parseFile", "\nfunction parseFile(filePath, encoding, callback) {\n\treturn fs.readFile(filePath, encoding, function(err, fileString) {\n\t\tif (err) {\n\t\t\treturn callback(err);\n\t\t}\n\n\t\tfileString = expandIncludes(fileString, path.dirname(filePath));\n\n\t\treturn parse(fileString, callback);\n\t});\n}\n"], ["_fullyReady", "\nfunction _fullyReady(callback) {\n    var self = this;\n\n    var promise = self._initReady().then(function () {\n        var dbContext = dbContexts[self._dbInfo.name];\n\n        if (dbContext && dbContext.dbReady) {\n            return dbContext.dbReady;\n        }\n    });\n\n    executeTwoCallbacks(promise, callback, callback);\n    return promise;\n}\n"], ["_areBatchRequirementsMet", "\nfunction _areBatchRequirementsMet(batch_ops, completed_ops) {\n  var dependencies = common.flatMap(batch_ops, function(op) {\n    return OP_DEPENDENCIES[op] || [];\n  });\n  for (var i = 0; i < dependencies.length; i++) {\n    var required_dep = dependencies[i];\n    if (batch_ops.indexOf(required_dep) === -1 &&\n        completed_ops.indexOf(required_dep) === -1) {\n      return false;\n    }\n  }\n  return true;\n}\n"], ["consoleHandler", "\nfunction consoleHandler(record) {\n  if (typeof console === 'undefined' || !console) {\n    return;\n  }\n  record = (record);\n  var timestamp = new Date(record.getMillis());\n  <formatMessage>\n  var msg =\n      '[' + timestamp.getUTCFullYear() + '-' +\n      padNumber(timestamp.getUTCMonth() + 1, 2) + '-' +\n      padNumber(timestamp.getUTCDate(), 2) + 'T' +\n      padNumber(timestamp.getUTCHours(), 2) + ':' +\n      padNumber(timestamp.getUTCMinutes(), 2) + ':' +\n      padNumber(timestamp.getUTCSeconds(), 2) + 'Z]' +\n      '[' + record.getLevel().name + ']' +\n      '[' + record.getLoggerName() + '] ' +\n      record.getMessage();\n  </formatMessage>\n\n  var level = record.getLevel().value;\n  if (level >= Logger.Level.SEVERE.value) {\n    console.error(msg);\n  } else if (level >= Logger.Level.WARNING.value) {\n    console.warn(msg);\n  } else {\n    console.log(msg);\n  }\n}\n"], "```"]