[["readFileAndFixEncoding", "\nfunction (path, encoding) {\n  <handleEncoding>\n  if (encoding === 'utf-8') {\n      encoding = 'utf8';\n  }\n  if (!encoding) {\n      encoding = 'utf8';\n  }\n  </handleEncoding>\n\n  <readFile>\n  var text = fs.readFileSync(path, encoding);\n  </readFile>\n\n  <removeByteOrderMark>\n  if (text.indexOf('\\uFEFF') === 0) {\n      text = text.substring(1, text.length);\n  }\n  </removeByteOrderMark>\n\n  return text;\n}\n"], ["prostrate", "\nfunction prostrate(source){\n  return function(method, transform){\n    transform = transform || {};\n    return function(){\n      <preprocessArguments>\n      var args = Array.prototype.slice.call(arguments, 0),\n        fn = args.pop(),\n        res,\n        last;\n\n      if(args[0] && ['removeItem', 'getItem', 'setItem'].indexOf(method) > -1){\n        var id = args[0];\n        id = id.toString();\n        if(id.indexOf(module.exports.ns) === -1){\n          id = module.exports.ns + id;\n        }\n        args[0] = id;\n      }\n      if(args.length == 2 && transform.before){\n        args[1] = transform.before(args[1]);\n      }\n      if(method === 'key'){\n        assert(typeof args[0] === 'number', args[0] + ' must be a number');\n      }\n      </preprocessArguments>\n\n      <invokeMethod>\n      if(!source[method]){\n        throw new Error('Unknown localstorage method ' + method);\n      }\n      else{\n        if(source[method].apply){\n          res = source[method].apply(source, args);\n          debug('result for ' +  method, '(', args, ')', res);\n        }\n        else {\n          res = source[method];\n        }\n      }\n      </invokeMethod>\n\n      <postprocessResult>\n      try{\n        if(transform.after){\n          res = transform.after(res);\n        }\n      }\n      catch(e){}\n      </postprocessResult>\n\n      <returnResult>\n      fn(null, res);\n      </returnResult>\n    };\n  };\n}\n"], ["getType", "\nfunction getType(state) {\n  var styles = [];\n\n  <buildStylesArray>\n  if (state.strong) { styles.push(state.em ? emstrong : strong); }\n  else if (state.em) { styles.push(em); }\n\n  if (state.linkText) { styles.push(linktext); }\n\n  if (state.code) { styles.push(code); }\n\n  if (state.header) { styles.push(header); }\n  if (state.quote) { styles.push(quote); }\n  if (state.list !== false) { styles.push(list); }\n  </buildStylesArray>\n\n  <assembleStyleString>\n  return styles.length ? styles.join(' ') : null;\n  </assembleStyleString>\n}\n"], ["createExceptionsPattern", "\nfunction createExceptionsPattern(exceptions) {\n  let pattern = \"\";\n\n  <initializePatternBase>\n  if (exceptions.length === 0) {\n      pattern += \"\\\\s\";\n  } else {\n      pattern += \"(?:\\\\s|\";\n      </initializePatternBase>\n\n      <constructPattern>\n      if (exceptions.length === 1) {\n          pattern += escapeAndRepeat(exceptions[0]);\n      } else {\n          pattern += \"(?:\";\n          pattern += exceptions.map(escapeAndRepeat).join(\"|\");\n          pattern += \")\";\n      }\n      pattern += `(?:$|[${Array.from(astUtils.LINEBREAKS).join(\"\")}]))`;\n      </constructPattern>\n  }\n\n  return pattern;\n}\n"], ["augmented_major_seventh", "\nfunction augmented_major_seventh(note) {\n  <constructChord>\n  var arr = augmented_triad(note);\n  arr.push(intervals.major_seventh(note));\n  </constructChord>\n  return arr;\n}\n"], ["getRxInfo", "\nfunction getRxInfo(rxNode,prefix, optStop) {\n  <baseCases>\n  if( !rxNode ) return unit(prefix);\n  if( optStop && rxNode === n_head(optStop) )  { \n    return getRxInfo(rxNode.nextNode,addOpt(rxNode, prefix),n_tail(optStop));\n  }\n  if(rxNode === DONE ) return unit(prefix);\n  </baseCases>\n\n  <handleDot>\n  if( dot(rxNode) ) { \n    return getRxInfo(rxNode.left,prefix, optStop);\n  } \n  </handleDot>\n  \n  <handleOr>\n  else if( or(rxNode) ) { \n      let LL = getRxInfo(rxNode.left,prefix,optStop);\n      let RL = getRxInfo(rxNode.right,prefix,optStop);\n      return merge(LL,RL); \n  }\n  </handleOr>\n  \n  <handleZeroOrOne>\n  else if(zero_or_one(rxNode)) { \n      if( optional ) {\n        return optional(rxNode, prefix, getRxInfo, optStop );\n      }  \n      else return getRxInfo(rxNode.nextNode,addElem(prefix,HOLDER_ZERO_OR_ONE), optStop);\n  }\n  </handleZeroOrOne>\n  \n  <handleZeroOrMore>\n  else if(zero_or_more(rxNode)) { \n      if( optional ){\n         return optional(rxNode, prefix, getRxInfo,optStop );\n      }\n      else return getRxInfo(rxNode.nextNode,addElem(prefix,HOLDER_ZERO_OR_MORE),optStop);;\n  }\n  </handleZeroOrMore>\n  \n  <handleMatchable>\n  else if( matchable(rxNode) ) {\n      let res = matchable(rxNode)(undefined);\n      let v = res[1] || (mapper?mapper(rxNode,HOLDER_ANY):HOLDER_ANY);\n      \n      return getRxInfo(rxNode.nextNode,addElem(prefix,v),optStop);\n  } \n  </handleMatchable>\n  \n  <handleBoundary>\n  else if( boundary(rxNode) ) {\n      return getRxInfo(rxNode.nextNode,prefix, optStop);\n  } \n  </handleBoundary>\n\n  <returnResult>\n  return unit(prefix);\n  </returnResult>\n}\n"], ["getScenario", "\nfunction getScenario(scenario, isPassed, steps) {\n  <readTemplate>\n  var template = grunt.file.read(templates.scenarioTemplate),\n      scenarioTemplate;\n  </readTemplate>\n\n  <processTemplate>\n  scenarioTemplate = grunt.template.process(template, {\n      data: {\n          status: isPassed ? statuses.PASSED : statuses.FAILED,\n          name: scenario.keyword + ': ' + scenario.name,\n          steps: steps\n      }\n  });\n  </processTemplate>\n\n  <returnProcessedTemplate>\n  return scenarioTemplate;\n  </returnProcessedTemplate>\n}\n"], ["prepareAndLinkGLSLProgram", "\nfunction( vert, frag, prefix ){\n  this.ready = false;\n\n  <prefixInitialization>\n  prefix = ( prefix === undefined ) ? '' : prefix+'\\n';\n  </prefixInitialization>\n\n  <getGLContext>\n  var gl = this.gl;\n  </getGLContext>\n\n  <compileShaders>\n  if( !( compileShader( gl, this.fShader, prefix + frag ) &&\n         compileShader( gl, this.vShader, prefix + vert ) ) ) {\n    return false;\n  }\n  </compileShaders>\n\n  <linkProgram>\n  gl.linkProgram(this.program);\n\n  if ( Program.debug && !gl.getProgramParameter(this.program, gl.LINK_STATUS)) {\n    warn(gl.getProgramInfoLog(this.program));\n    return false;\n  }\n  </linkProgram>\n\n  <cleanupDynamics>\n  while (this.dyns.length>0) {\n    delete this[this.dyns.pop()];\n  }\n  </cleanupDynamics>\n\n  <setUniqueId>\n  this._cuid = (_UID++)|0; \n  </setUniqueId>\n\n  <returnStatus>\n  return true;\n  </returnStatus>\n}\n"], ["renderToStaticMarkup", "\nfunction renderToStaticMarkup(element) {\n  <validateElement>\n  !React.isValidElement(element) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'renderToStaticMarkup(): You must pass a valid ReactElement.') : _prodInvariant('47') : void 0;\n  </validateElement>\n\n  <performRender>\n  return renderToStringImpl(element, true);\n  </performRender>\n}\n"], ["logSASSError", "\nfunction logSASSError({ message, file, line, column }) {\n  <generateLogMessage>\n  log(formatErrorMarker('SASS error'), ': ', ...formatLine(message, file, line, column));\n  </generateLogMessage>\n}\n"], ""]