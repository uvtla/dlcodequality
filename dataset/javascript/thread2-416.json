[["closestPoint0d", "\nfunction closestPoint0d(a, x, result) {\n  var d = 0.0;\n  for(var i=0; i<x.length; ++i) {\n    result[i] = a[i];\n    var t = a[i] - x[i];\n    d += t * t;\n  }\n  return d;\n}\n"], ["unnamedMatrixVectorMultiplication", "\nfunction (m, u) {\n  return [\n    m[0][0] * u[0] + m[0][1] * u[1] + m[0][2] * u[2],\n    m[1][0] * u[0] + m[1][1] * u[1] + m[1][2] * u[2],\n    m[2][0] * u[0] + m[2][1] * u[1] + m[2][2] * u[2]\n  ];\n}\n"], ["doResolve", "\nfunction doResolve(result) {\n  let self = this;\n  if (result === self) {\n    return doReject.call(\n      self,\n      new TypeError(\"Can not resolve 'Promise' itself\")\n    );\n  }\n  \n  try {\n    // Determine if the result has a 'then' method, signifying it is a Promise-like object\n    <determineThen>\n    let then = safelyToThen(result);\n    </determineThen>\n    <handleThenable>\n    if (then) {\n      safelyToExecutor(self, then.bind(result));\n    } else {\n    </handleThenable>\n      // Handle non-thenable results\n      <handleNonThenable>\n      setTimeout(function() {\n        if (self.currentState === Shared.PENDING) {\n          self.currentState = Shared.FULFILLED;\n          self.valOrErr = result;\n          for (let i = 0; i < self.onFulfilledCallback.length; i++) {\n            self.onFulfilledCallback[i](result);\n          }\n          self.onFulfilledCallback = [];\n        }\n      }, 0);\n      </handleNonThenable>\n    }\n    \n    return self;\n  } catch (error) {\n    return doReject.call(self, error);\n  }\n}\n"], ["isConfigurationParametersDefinedCorrectly", "\nfunction isConfigurationParametersDefinedCorrectly(config) {\n  if (!config) {\n    gutil.log('license-check', gutil.colors.red('Config must be defined to run the plugin'));\n    return false;\n  }\n\n  if (!config.path) {\n    gutil.log('license-check', gutil.colors.red('License header property {path} must be defined to run the plugin'));\n    return false;\n  }\n\n  return true;\n}\n"], ["unnamedCleanupCallbacks", "\nfunction() {\n  if (!this._callbacks) return;\n  this.__callbacksFrozen = false;\n  for (var event in this._callbacks) {\n    if (this._callbacks[event]) {\n      // Unbind all event callbacks\n      <unbindEventCallbacks>\n      this._unbindCallbacks(event);\n      </unbindEventCallbacks>\n      // Remove the event handler reference\n      <removeEventHandlerReference>\n      delete handlers[event][this[0]];\n      </removeEventHandlerReference>\n    }\n  }\n}\n"], ["parse", "\nfunction parse(tokens, basePath, iterSuffix) {\n  const len = tokens.length;\n  const body = [];\n\n  let i = 0;\n  while (i < len) {\n    const token = tokens[i];\n    if (subroutines[token.tokenType]) {\n      const rest = tokens.slice(i + 1);\n      // Execute the subroutine for the current token and process the result\n      <executeSubroutine>\n      const [\n        branches,\n        tokensHandled,\n        shouldBreak,\n      ] = subroutines[token.tokenType](token, rest, basePath, iterSuffix);\n      </executeSubroutine>\n\n      body.push(...branches);\n\n      i += tokensHandled;\n\n      if (shouldBreak) {\n        break;\n      }\n    } else {\n      i += 1;\n    }\n  }\n\n  return [body, i + 1];\n}\n"], ["fileExists", "\nfunction fileExists(fileName) {\n  // Return a promise that resolves with the existence status of the file\n  return new BbPromise((resolve) => {\n    fs.exists(fileName, (exists) => resolve(exists));\n  });\n}\n"], ["Star", "\nfunction Star( x, y, starSize, ctx, fgCanvas, analyser, streamData ){\n  this.x = x;\n  this.y = y;\n  this.angle = Math.atan( Math.abs(y) / Math.abs(x) );\n  this.starSize = starSize;\n  this.ctx = ctx;\n  this.high = 0;\n  this.fgCanvas = fgCanvas;\n  this.analyser = analyser;\n  this.streamData = streamData;\n}\n"], ["explore", "\nfunction explore(start, callfile, calldir, options, done) {\n  const argsLen = arguments.length;\n\n  // Argument handling logic\n  <handleArguments>\n  switch (argsLen) {\n    case 0:\n    case 1:\n      throw new Error(\"Too few arguments\");\n    case 2:\n      break;\n    case 3:\n      if (isFunction(calldir)) {\n        done = calldir;\n      } else if (isObject(calldir)) {\n        options = calldir;\n      }\n      calldir = null;\n      break;\n    case 4:\n      if (isFunction(options)) {\n        done = options;\n        options = null;\n      }\n\n      if (isObject(calldir)) {\n        options = calldir;\n        calldir = null;\n      }\n      break;\n    default:\n      // No specific operations to annotate\n  }\n  </handleArguments>\n\n  // Validate function types and set defaults\n  <validateAndSetDefaults>\n  if (!isFunction(callfile)) {\n    throw new Error(\"callfile must be a function\");\n  }\n\n  options = Object.assign({}, defaultOptions, options);\n\n  if (!isFunction(calldir)) {\n    calldir = nextDirectoryFn;\n  }\n\n  if (!isFunction(done)) {\n    done = emptyFn;\n  }\n  </validateAndSetDefaults>\n\n  _explore(start, callfile, calldir, options, done);\n}\n"], ["createFeatureTags", "\nfunction(feature, node) {\n  // Attach feature attributes as tags to an XML node\n  for (var key in feature.attributes) {\n    var tag = this.createElementNS(null, \"tag\");\n    tag.setAttribute(\"k\", key);\n    tag.setAttribute(\"v\", feature.attributes[key]);\n    node.appendChild(tag);\n  }\n}\n"], "```"]