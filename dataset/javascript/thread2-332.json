[["Cursor", "\nfunction Cursor(bson, ns, cmd, options, topology, topologyOptions) {\n  <CoreCursorApply>\n  CoreCursor.apply(this, Array.prototype.slice.call(arguments, 0));\n  </CoreCursorApply>\n  <InitialState>\n  const state = Cursor.INIT;\n  </InitialState>\n  <StreamOptions>\n  const streamOptions = {};\n  </StreamOptions>\n  <CursorOptions>\n  const numberOfRetries = options.numberOfRetries || 5;\n  const tailableRetryInterval = options.tailableRetryInterval || 500;\n  const currentNumberOfRetries = numberOfRetries;\n  const promiseLibrary = options.promiseLibrary || Promise;\n  </CursorOptions>\n  <ReadableStream>\n  Readable.call(this, { objectMode: true });\n  </ReadableStream>\n  <CursorStateSetup>\n  this.s = {\n    numberOfRetries: numberOfRetries,\n    tailableRetryInterval: tailableRetryInterval,\n    currentNumberOfRetries: currentNumberOfRetries,\n    state: state,\n    streamOptions: streamOptions,\n    bson: bson,\n    ns: ns,\n    cmd: cmd,\n    options: options,\n    topology: topology,\n    topologyOptions: topologyOptions,\n    promiseLibrary: promiseLibrary,\n    currentDoc: null,\n    explicitlyIgnoreSession: options.explicitlyIgnoreSession\n  };\n  </CursorStateSetup>\n  <SessionOptions>\n  if (!options.explicitlyIgnoreSession && options.session) {\n    this.s.session = options.session;\n  }\n  if (this.s.options.noCursorTimeout === true) {\n    this.addCursorFlag('noCursorTimeout', true);\n  }\n  </SessionOptions>\n  <SortAndBatchSize>\n  this.sortValue = this.s.cmd.sort;\n  const batchSize =\n    cmd.cursor && cmd.cursor.batchSize\n      ? cmd.cursor && cmd.cursor.batchSize\n      : options.cursor && options.cursor.batchSize\n        ? options.cursor.batchSize\n        : 1000;\n  this.setCursorBatchSize(batchSize);\n  </SortAndBatchSize>\n}\n"], ["RespondActivityTaskFailed", "\nfunction (reason, details, cb) {\n  var self = this;\n  <TaskToken>\n  var o = {\n    \"taskToken\": this.config.taskToken\n  };\n  </TaskToken>\n  <ReasonAndDetails>\n  if (reason) {\n    o.reason = reason;\n  }\n  if (details) {\n    o.details = stringify(details);\n  }\n  </ReasonAndDetails>\n  <RespondFailure>\n  this.swfClient.respondActivityTaskFailed(o, function (err) {\n    if (self.onDone) {\n      self.onDone();\n    }\n    if (cb) {\n      cb(err);\n    }\n  });\n  </RespondFailure>\n}\n"], ["ProcessDirectory", "\nfunction processDirectory(directory) {\n  <CheckRejection>\n  if (rejected === true) {\n    return;\n  }\n  </CheckRejection>\n  <InitiateWaiting>\n  waiting++;\n  </InitiateWaiting>\n  <ReadDirectory>\n  fs.readdir(directory, (error, fileNames) => {\n    if (error) {\n      return reject(error);\n    }\n    for (let i = 0; i < fileNames.length; i++) {\n      processFilePath(directory, fileNames[i]);\n    }\n    done();\n  });\n  </ReadDirectory>\n}\n"], ["ReadDataSync", "\nfunction readDataSync(filePath, opts_) {\n  <ParserSetup>\n  var parser;\n  var parserOptions;\n  if (arguments.length === 2) {\n    if (opts_.parser) {\n      parser = getParser(opts_.parser);\n      opts_ = omit(opts_, ['parser']);\n      if (underscore.isEmpty(opts_)) {\n        opts_ = undefined;\n      }\n    } else {\n      parser = discernParser(filePath);\n    }\n    if (opts_ && opts_.parserOptions) {\n      if (typeof opts_.parserOptions === 'function') {\n        parserOptions = { map: opts_.parserOptions };\n      } else {\n        parserOptions = opts_.parserOptions;\n      }\n    } else if (opts_) {\n      if (typeof opts_ === 'function') {\n        parserOptions = { map: opts_ };\n      } else {\n        parserOptions = opts_;\n      }\n    }\n  } else {\n    parser = discernParser(filePath);\n  }\n  </ParserSetup>\n  <DataLoading>\n  var loader = discernLoader(filePath, { sync: true });\n  return loader(filePath, parser, parserOptions);\n  </DataLoading>\n}\n"], ["GracefulShutdown", "\nfunction GracefulShutdown(server, opts) {\n  <InitializeOptions>\n  opts = opts || {};\n  let options = Object.assign({\n    signals: 'SIGINT SIGTERM',\n    timeout: 30000,\n    development: false\n  }, opts);\n  </InitializeOptions>\n  <SetupSignalListeners>\n  options.signals.split(' ').forEach(function (signal) {\n    if (signal && signal !== '') {\n      process.on(signal, function () {\n        shutdown(signal);\n      });\n    }\n  });\n  </SetupSignalListeners>\n  <SocketListeners>\n  server.on('request', function (req, res) {\n    req.socket._isIdle = false;\n    res.on('finish', function () {\n      req.socket._isIdle = true;\n      destroy(req.socket);\n    });\n  });\n  server.on('connection', function (socket) {\n    let id = connectionCounter++;\n    socket._isIdle = true;\n    socket._connectionId = id;\n    connections[id] = socket;\n    socket.on('close', function () {\n      delete connections[id];\n    });\n  });\n  </SocketListeners>\n  <ProcessExitListener>\n  process.on('exit', function () {\n    if (options.finally && isFunction(options.finally)) {\n      options.finally();\n    }\n    debug('closed');\n  });\n  </ProcessExitListener>\n  <ShutdownFunction>\n  function shutdown(sig) {\n    <ShutdownInit>\n    let counter = 0;\n    </ShutdownInit>\n    <CleanupHttp>\n    function cleanupHttp() {\n      return new Promise((resolve, reject) => {\n        Object.keys(connections).forEach(function (key) {\n          counter++;\n          destroy(connections[key]);\n        });\n        debug('Connections destroyed : ' + counter);\n        debug('Connection Counter    : ' + connectionCounter);\n        server.close(function (err) {\n          if (err) return reject(err);\n          resolve();\n        });\n      });\n    }\n    </CleanupHttp>\n    <HandleShutdown>\n    debug('shutdown signal - ' + sig);\n    if (options.development) {\n      debug('DEV-Mode - imediate forceful shutdown');\n      return process.exit(0);\n    }\n    const finalHandler = () => {\n      process.exit(failed ? 1 : 0);\n    };\n    const exitHandler = promise => promise\n      .catch((err) => {\n        const errString = (typeof err === 'string') ? err : JSON.stringify(err);\n        debug(errString);\n        failed = true;\n      });\n    </HandleShutdown>\n    <ShutdownSequence>\n    if (!isShuttingDown) {\n      isShuttingDown = true;\n      debug('shutting down');\n      if (options.timeout) {\n        setTimeout(function () {\n          debug('Could not close connections in time (' + options.timeout + 'ms), forcefully shutting down');\n          process.exit(1);\n        }, options.timeout).unref();\n      }\n      exitHandler(cleanupHttp()).then(() => {\n        if (options.onShutdown && isFunction(options.onShutdown)) {\n          return exitHandler(options.onShutdown(sig));\n        }\n        return;\n      }).then(finalHandler);\n    }\n    </ShutdownSequence>\n  }\n  </ShutdownFunction>\n}\n"], ["OptionsAndCommands", "\nfunction(options, parentNode) {\n  <MixinOptions>\n  options = options || {};\n  objects.mixin(this, options);\n  </MixinOptions>\n  <OptionsSetup>\n  this.options = options;\n  this.checkOptions(this.options, [\"serviceRegistry\", \"fileClient\", \"siteClient\", \"commandService\", \"statusService\", \"progressService\"]); \n  </OptionsSetup>\n  <ClientInitializations>\n  this._fileClient = this.options.fileClient;\n  this._siteClient = this.options.siteClient;\n  this._commandService = this.options.commandService;\n  this._statusService = this.options.statusService;\n  this._progressService = this.options.progressService;\n  </ClientInitializations>\n  <CommandsContainer>\n  this._commandsContainer = this.options.commandsContainer;\n  </CommandsContainer>\n  <LoadLocation>\n  if (this.options.location) {\n    this.load(this.options.location);\n  }\n  </LoadLocation>\n  <NodeInitialization>\n  this.node = parentNode || document.createElement(\"div\");\n  </NodeInitialization>\n}\n"], ["AllowedForAutoActivation", "\nfunction allowedForAutoActivation(model) {\n  <CheckASTRootNode>\n  const rootNode = model.ast.children[0];\n  return rootNode && /^[a-z]/i.test(rootNode.name);\n  </CheckASTRootNode>\n}\n"], ["RemoveChildWrapper", "\nfunction (child, node) {\n  var update = this.removeChild(child, node);\n  child._mountIndex = null;\n  return update;\n}\n"], ["ColorMatrixInitializer", "\nfunction ColorMatrix(brightness, contrast, saturation, hue) {\n  <SetColor>\n  this.setColor(brightness, contrast, saturation, hue);\n  </SetColor>\n}\n"], ["SelectAllMovies", "\nfunction selectAllMovies() {\n  <MovieTableReference>\n  var movie = db.getSchema().table('Movie');\n  </MovieTableReference>\n  <SelectQueryAndHandling>\n  db.select(movie.id, movie.title, movie.year).\n    from(movie).exec().then(\n    function(results) {\n      var elapsed = Date.now() - startTime;\n      $('#load_time').text(elapsed.toString() + 'ms');\n      $('#master').bootstrapTable('load', results).\n          on('click-row.bs.table', function(e, row, $element) {\n            startTime = Date.now();\n            generateDetails(row.id);\n          });\n    });\n  </SelectQueryAndHandling>\n}\n"], ""]