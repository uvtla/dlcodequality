[["disableFileInput", "\nfunction(state) {\n  var runtime = this.getRuntime();\n  if (runtime) {\n    runtime.exec.call(this, 'FileInput', 'disable', Basic.typeOf(state) === 'undefined' ? true : state);\n  }\n}\n"], ["createSyntaxErrorAndLog", "\nfunction error(sMessage, sInput, iAt) {\n  var oError = new SyntaxError(sMessage);\n  oError.at = iAt;\n  oError.text = sInput;\n  if (iAt !== undefined) {\n    sMessage += \" at position \" + iAt;\n  }\n  Log.error(sMessage, sInput, sExpressionParser);\n  throw oError;\n}\n"], ["processFile", "\nfunction process (filePath, complete) {\n  var filename = path.basename(filePath),\n      pathParts = path.dirname(filePath).split(path.sep)\n\n  pathParts = pathParts.slice(transform.by)\n  pathParts.push(filename)\n\n  var newPath = pathParts.join(path.sep),\n      fileData = files[filePath]\n\n  delete files[filePath]\n  files[newPath] = fileData\n\n  complete()\n}\n"], ["initializeView", "\nfunction(options){\n  this._initChildViewStorage();\n\n  Marionette.View.prototype.constructor.apply(this, slice(arguments));\n\n  this._initialEvents();\n}\n"], ["storeDeviceKeys", "\nasync function _storeDeviceKeys(_olmDevice, userStore, deviceResult) {\n  if (!deviceResult.keys) {\n    return false;\n  }\n\n  const deviceId = deviceResult.device_id;\n  const userId = deviceResult.user_id;\n\n  const signKeyId = \"ed25519:\" + deviceId;\n  const signKey = deviceResult.keys[signKeyId];\n  if (!signKey) {\n    logger.warn(\"Device \" + userId + \":\" + deviceId + \" has no ed25519 key\");\n    return false;\n  }\n\n  const unsigned = deviceResult.unsigned || {};\n\n  try {\n    await olmlib.verifySignature(_olmDevice, deviceResult, userId, deviceId, signKey);\n  } catch (e) {\n    logger.warn(\"Unable to verify signature on device \" + userId + \":\" + deviceId + \":\" + e);\n    return false;\n  }\n\n  let deviceStore;\n\n  if (deviceId in userStore) {\n    deviceStore = userStore[deviceId];\n\n    if (deviceStore.getFingerprint() != signKey) {\n      logger.warn(\"Ed25519 key for device \" + userId + \":\" + deviceId + \" has changed\");\n      return false;\n    }\n  } else {\n    userStore[deviceId] = deviceStore = new DeviceInfo(deviceId);\n  }\n\n  deviceStore.keys = deviceResult.keys || {};\n  deviceStore.algorithms = deviceResult.algorithms || [];\n  deviceStore.unsigned = unsigned;\n  return true;\n}\n"], ["processQuery", "\nfunction(json, queryStr, unique) { \n  var pick = new RegExp(/select|pivot/),\n      trim = /^\\s+|\\s+$/g,\n      _query = {};\n\n  queryStr = queryStr && _.isString(queryStr) && queryStr.replace(/[\"]/g, '');\n  if (pick.test(queryStr)) {\n    _query = _.reduce(queryStr.split(/,/), function(res, str) {\n      if (str.replace(trim, '').split(/ /)) {\n        res[_.first(str.replace(trim, '').split(/ /))] = _.last(str.split(pick)).replace(trim, '');\n      }\n      return res;\n    }, {'select': ''});\n  } else {\n    _query = {'select': ''};\n  }\n\n  return _query.hasOwnProperty('pivot') \n    ? pivot(select(json, _query.select, unique))\n    : select(json, _query.select, unique);\n}\n"], ["diffArrays", "\nfunction (array1, array2) {\n  var result = [];\n\n  array.each(array1, function(i) {\n    if (!array.contains(array2, i)) {\n      array.add(result, i);\n    }\n  });\n\n  array.each(array2, function(i) {\n    if (!array.contains(array1, i)) {\n      array.add(result, i);\n    }\n  });\n\n  return result;\n}\n"], ["middlewareHandler", "\nfunction handle(type, req, res, out) {\n  var index = 0;\n  var ended = false;\n\n  res.end = end;\n\n  function next(err) {\n    var middleware = stack[index++];\n\n    if (!middleware || ended) {\n      if (out) out(err, req, res);\n      return;\n    }\n\n    if (middleware.type.indexOf(type) === -1 && middleware.type.length > 0)\n      return next(err);\n\n    try {\n      var arity = middleware.cb.length;\n      if (err) {\n        if (arity === 4) {\n          middleware.cb(err, req, res, next);\n        } else {\n          next(err);\n        }\n      } else if (arity < 4) {\n        middleware.cb(req, res, next);\n      } else {\n        next();\n      }\n    }\n    catch (e) {\n      next(e);\n    }\n  }\n\n  function end() {\n    ended = true;\n  }\n\n  next();\n}\n"], ["logWithColorAndMethod", "\nfunction stamp() {\n  let i = 0;\n  const args = new Array(arguments.length);\n\n  for (; i < args.length; ++i) {\n    args[i] = arguments[i];\n  }\n\n  process.stdout.write(clorox[this.color](getTime()) + ' ');\n  console[this.method].apply(console, (this.custom ? [this.custom].concat(args) : args));\n}\n"], ["attemptEnableFullscreenAndPointerLock", "\nfunction tryFullscreen(shell) {\n    var elem = shell.element\n\n    if(shell._wantFullscreen && !shell._fullscreenActive) {\n        var fs = elem.requestFullscreen ||\n                elem.requestFullScreen ||\n                elem.webkitRequestFullscreen ||\n                elem.webkitRequestFullScreen ||\n                elem.mozRequestFullscreen ||\n                elem.mozRequestFullScreen ||\n                function() {}\n        fs.call(elem)\n    }\n    if(shell._wantPointerLock && !shell._pointerLockActive) {\n        var pl = elem.requestPointerLock ||\n                elem.webkitRequestPointerLock ||\n                elem.mozRequestPointerLock ||\n                elem.msRequestPointerLock ||\n                elem.oRequestPointerLock ||\n                function() {}\n        pl.call(elem)\n    }\n}\n"], "```\n\nEach of these functions is annotated with a single responsibility enclosed in tags denoting what they aim to achieve. The responsibilities are identified based on the blocks of code serving specific purposes within the functions."]