[["withTranspositions", "\nfunction withTranspositions(maxOffset, maxDistance, a, b) {\n  if (a === b)\n    return 0;\n\n  const la = a.length,\n        lb = b.length;\n\n  if (!la || !lb)\n    return Math.max(la, lb);\n\n  let cursorA = 0,\n      cursorB = 0,\n      longestCommonSubsequence = 0,\n      localCommonSubstring = 0,\n      transpositions = 0;\n\n  const offsetArray = [];\n\n  while (cursorA < la && cursorB < lb) {\n    if (a[cursorA] === b[cursorB]) {\n      localCommonSubstring++;\n\n      let isTransposition = false,\n          i = 0;\n\n      while (i < offsetArray.length) {\n        const offset = offsetArray[i];\n\n        if (cursorA <= offset.cursorA || cursorB <= offset.cursorB) {\n          isTransposition = Math.abs(cursorB - cursorA) >= Math.abs(offset.cursorB - offset.cursorA);\n\n          if (isTransposition) {\n            transpositions++;\n          } else {\n            if (!offset.isTransposition) {\n              offset.isTransposition = true;\n              transpositions++;\n            }\n          }\n\n          break;\n        } else {\n          if (cursorA > offset.cursorB && cursorB > offset.cursorA)\n            offsetArray.splice(i, 1);\n          else\n            i++;\n        }\n      }\n\n      offsetArray.push({\n        cursorA,\n        cursorB,\n        isTransposition\n      });\n    } else {\n      longestCommonSubsequence += localCommonSubstring;\n      localCommonSubstring = 0;\n\n      if (cursorA !== cursorB)\n        cursorA = cursorB = Math.min(cursorA, cursorB);\n\n      for (let i = 0; i < maxOffset && (cursorA + i < la || cursorB + i < lb); i++) {\n        if ((cursorA + i < la) && a[cursorA + i] === b[cursorB]) {\n          cursorA += i - 1;\n          cursorB--;\n          break;\n        }\n\n        if ((cursorB + i < lb) && a[cursorA] === b[cursorB + i]) {\n          cursorA--;\n          cursorB += i - 1;\n          break;\n        }\n      }\n    }\n\n    cursorA++;\n    cursorB++;\n\n    if (cursorA >= la || cursorB >= lb) {\n      longestCommonSubsequence += localCommonSubstring;\n      localCommonSubstring = 0;\n      cursorA = cursorB = Math.min(cursorA, cursorB);\n    }\n\n    if (maxDistance) {\n      const tempDistance = (\n        Math.max(cursorA, cursorB) -\n        longestCommonSubsequence +\n        transpositions\n      );\n\n      if (tempDistance === maxDistance)\n        return maxDistance;\n\n      if (tempDistance > maxDistance)\n        return Infinity;\n    }\n  }\n\n  longestCommonSubsequence += localCommonSubstring;\n\n  return Math.max(la, lb) - longestCommonSubsequence + transpositions;\n}\n"], ["toggleDebug", "\nfunction(enable) {\n  if (arguments.length == 1) {\n    isDebugging = enable;\n    if (isDebugging) {\n      this.log = log;\n      this.error = logError;\n      this.log('Debug:Enabled');\n    } else {\n      this.log('Debug:Disabled');\n      this.log = noop;\n      this.error = noop;\n    }\n  }\n\n  return isDebugging;\n}\n"], ["getTemplateFile", "\nasync function getTemplateFile(templateDir, stackName) {\n  const f = await Promise.any(\n    _.map(['.yml', '.yaml', '.json', ''], async(ext) =>\n      await utils.fileExists(`${path.join(templateDir, stackName)}${ext}`)));\n  if (f) {\n    return f;\n  }\n  throw new Error(`Stack template \"${stackName}\" not found!`);\n}\n"], ["makeMove", "\nfunction makeMove(child, afterNode, toIndex) {\n  return {\n    type: ReactMultiChildUpdateTypes.MOVE_EXISTING,\n    content: null,\n    fromIndex: child._mountIndex,\n    fromNode: ReactReconciler.getHostNode(child),\n    toIndex: toIndex,\n    afterNode: afterNode\n  };\n}\n"], ["StackMobModel", "\nfunction() {\n  StackMob.Model = Backbone.Model.extend({\n    urlRoot : StackMob.getBaseURL(),\n    getBinaryFields: function() {\n      return this.binaryFields || [];\n    },\n    url : function() {\n      var base = StackMob.getBaseURL();\n      base += this.schemaName;\n      return base;\n    },\n    \n    <initializeModel>\n    getPrimaryKeyField : function() {\n      return this.schemaName + '_id';\n    },\n    constructor : function() {\n      this.setIDAttribute();\n      Backbone.Model.prototype.constructor.apply(this, arguments);\n    },\n    initialize : function(attributes, options) {\n      StackMob.getProperty(this, 'schemaName') || StackMob.throwError('A schemaName must be defined');\n      this.setIDAttribute();\n    },\n    </initializeModel>\n    \n    setIDAttribute : function() {\n      this.idAttribute = this.getPrimaryKeyField();\n    },\n    \n    <parseData>\n    parse : function(data, xhr) {\n      if(!data || (data && (!data['text'] || data['text'] === '')))\n        return data;\n\n      var attrs = JSON.parse(data['text']);\n\n      return attrs;\n    },\n    </parseData>\n\n    <remoteSync>\n    sync : function(method, model, options) {\n      StackMob.sync.call(this, method, this, options);\n    },\n    </remoteSync>\n\n    \n    <otherModelResponsibilities>\n    /* Omitted sections here due to length, but they handle responsibilities like querying, binary file manipulation, incrementing/decrementing logic on save, etc. */\n    </otherModelResponsibilities>\n    \n  });\n}\n"], ["renderTemplate", "\nfunction(template, controller, locals) {\n  var deferred = $q.defer();\n  $element.html(template);\n\n  <compileTemplate>\n  var link = $compile($element.contents());\n  </compileTemplate>\n\n  <applyController>\n  if(controller) {\n    var _locals = angular.extend({}, locals || {}, {\n      $scope: scope.$parent\n    });\n    $controller(controller, _locals);\n  }\n  </applyController>\n\n  link(scope.$parent);\n\n  deferred.resolve();\n  return deferred.promise;\n}\n"], ["augmentConfigBasic", "\nfunction augmentConfigBasic(\n  stylelint,\n  config,\n  configDir,\n  allowOverrides\n) {\n  return Promise.resolve()\n    .then(() => {\n      if (!allowOverrides) return config;\n\n      <overrideConfiguration>\n      return _.merge(config, stylelint._options.configOverrides);\n      </overrideConfiguration>\n    })\n    .then(augmentedConfig => {\n      <extendConfigFunction>\n      return extendConfig(stylelint, augmentedConfig, configDir);\n      </extendConfigFunction>\n    })\n    .then(augmentedConfig => {\n      <absolutizePathsFunction>\n      return absolutizePaths(augmentedConfig, configDir);\n      </absolutizePathsFunction>\n    });\n}\n"], ["hexNumber", "\nfunction hexNumber(char) {\n  var code = char.toLowerCase().charCodeAt(0);\n  if (code >= 48 && code <= 57) {\n    return code - 48;\n  }\n  if (code >= 97 && code <= 102) {\n    return code - 87;\n  }\n  return code;\n}\n"], ["discoverMDSCHEMA_HIERARCHIES", "\nfunction(options){\n  var request = _applyProps(options, {\n    requestType: Xmla.MDSCHEMA_HIERARCHIES\n  }, true);\n  return this.discover(request);\n}\n"], ["checkIfMethodHasThisArg", "\nfunction isMethodWhichHasThisArg(node) {\n  for (\n    let currentNode = node;\n    currentNode.type === \"MemberExpression\" && !currentNode.computed;\n    currentNode = currentNode.property\n  ) {\n    if (currentNode.property.type === \"Identifier\") {\n      return arrayMethodPattern.test(currentNode.property.name);\n    }\n  }\n  return false;\n}\n"], ""]