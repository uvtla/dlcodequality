[["replaceFieldNames", "\nfunction replaceFieldNames(sql, identifiers, model) {\n    <databaseInteraction>\n    const {queryInterface} = model.sequelize;\n    _.forIn(identifiers, (fieldName, identifier) => {\n        \n        fieldName = (model.rawAttributes || model.attributes)[fieldName].field;\n\n        \n        sql = sql.replace(\n            new RegExp(`\\\\*${identifier}(?![a-zA-Z0-9_])`, 'g'),\n            queryInterface.quoteIdentifier(fieldName)\n        );\n    });\n    </databaseInteraction>\n    return sql;\n}\n"], ["toggleElementClass", "\nfunction(element, name) {\n    <elementClassToggling>\n    if(OpenLayers.Element.hasClass(element, name)) {\n        OpenLayers.Element.removeClass(element, name);\n    } else {\n        OpenLayers.Element.addClass(element, name);\n    }\n    </elementClassToggling>\n    return element;\n}\n"], ["ReactReconcileTransaction", "\nfunction(module, exports, __webpack_require__) {\n    <importModules>\n    'use strict';\n    var _assign = __webpack_require__(5);\n    var CallbackQueue = __webpack_require__(55);\n    var PooledClass = __webpack_require__(48);\n    var ReactBrowserEventEmitter = __webpack_require__(98);\n    var ReactInputSelection = __webpack_require__(139);\n    var ReactInstrumentation = __webpack_require__(60);\n    var Transaction = __webpack_require__(61);\n    var ReactUpdateQueue = __webpack_require__(128);\n    </importModules>\n\n    <defineTransactionWrappers>\n    var TRANSACTION_WRAPPERS = [SELECTION_RESTORATION, EVENT_SUPPRESSION, ON_DOM_READY_QUEUEING];\n    </defineTransactionWrappers>\n\n    if (false) {\n      TRANSACTION_WRAPPERS.push({\n        initialize: ReactInstrumentation.debugTool.onBeginFlush,\n        close: ReactInstrumentation.debugTool.onEndFlush\n      });\n    }\n\n    <ReactReconcileTransactionDefinition>\n    function ReactReconcileTransaction(useCreateElement) {\n      this.reinitializeTransaction();\n      \n      this.renderToStaticMarkup = false;\n      this.reactMountReady = CallbackQueue.getPooled(null);\n      this.useCreateElement = useCreateElement;\n    }\n    </ReactReconcileTransactionDefinition>\n\n    <MixinDefinition>\n    var Mixin = {\n      getTransactionWrappers: function () {\n        return TRANSACTION_WRAPPERS;\n      },\n\n      getReactMountReady: function () {\n        return this.reactMountReady;\n      },\n\n      getUpdateQueue: function () {\n        return ReactUpdateQueue;\n      },\n\n      checkpoint: function () {\n        return this.reactMountReady.checkpoint();\n      },\n\n      rollback: function (checkpoint) {\n        this.reactMountReady.rollback(checkpoint);\n      },\n\n      destructor: function () {\n        CallbackQueue.release(this.reactMountReady);\n        this.reactMountReady = null;\n      }\n    };\n    </MixinDefinition>\n\n    <assignMixinAndPooling>\n    _assign(ReactReconcileTransaction.prototype, Transaction, Mixin);\n    PooledClass.addPoolingTo(ReactReconcileTransaction);\n    </assignMixinAndPooling>\n\n    module.exports = ReactReconcileTransaction;\n}\n"], ["flattenArray", "\nfunction flattenArray(input, ans = {}) {\n    <checkInput>\n    if (!input || !Array.isArray(input)) return input || {}\n    </checkInput>\n    <recursionFlattening>\n    for (let k in input) {\n        if (Array.isArray(input[k])) {\n            ans = flattenArray(input[k], ans)\n        } else {\n            ans = Object.assign({}, ans, input[k])\n        }\n    }\n    </recursionFlattening>\n    return ans\n}\n"], ["setVertexProperties", "\nfunction () {\n    var vertex = this.get('vertex');\n    this._super();\n    \n    <propertySetting>\n    this.setProperties({\n      id: vertex.get('vertexName') + this.get('name'),\n      depth: vertex.get('depth') + 1\n    });\n    </propertySetting>\n}\n"], ["checkFlashPluginAndSetup", "\nfunction (reqId, callback) {\n    <pluginDetection>\n    var navigator = Aria.$global.navigator;\n    if (navigator.plugins && navigator.plugins.length > 0) {\n        var mime = navigator.mimeTypes, type = \"application/x-shockwave-flash\";\n        if (!mime || !mime[type] || !mime[type].enabledPlugin) {\n            return this.$logError(this.IO_MISSING_FLASH_PLUGIN);\n        }\n    } else if (navigator.appVersion.indexOf(\"Mac\") == -1 && Aria.$frameworkWindow.execScript) {\n        try {\n            var ActiveXObject = Aria.$global.ActiveXObject;\n            var obj = new ActiveXObject(\"ShockwaveFlash.ShockwaveFlash\");\n            if (obj.activeXError) {\n                throw \"ActiveXError\";\n            }\n        } catch (er) {\n            return this.$logError(this.IO_MISSING_FLASH_PLUGIN);\n        }\n    }\n    </pluginDetection>\n\n    <setupPendingRequestAndTransport>\n    this._pending[reqId] = ariaCoreTimer.addCallback({\n        fn : this._swfTimeout,\n        scope : this,\n        args : {\n            reqId : reqId,\n            cb : callback\n        },\n        delay : this.swfTimeout\n    });\n\n    if (!this._transport) {\n        var swfUri = ariaCoreDownloadMgr.resolveURL('aria/resources/handlers/IO.swf');\n        var obj = [\n                '<object id=\"xATIOSwf\" type=\"application/x-shockwave-flash\" data=\"',\n                swfUri,\n                '\" width=\"1\" height=\"1\">',\n                '<param name=\"movie\" value=\"' + swfUri + '\" />',\n                '<param name=\"allowScriptAccess\" value=\"always\" />',\n                '<param name=\"FlashVars\" value=\"readyCallback=' + this.$classpath + '.onXdrReady&handler='\n                        + this.$classpath + '.handleXdrResponse\" />', '</object>'].join(\"\");\n\n        var document = Aria.$frameworkWindow.document;\n        var container = document.createElement('div');\n        container.style.cssText = \"position:fixed;top:-12000px;left:-12000px\";\n        document.body.appendChild(container);\n        container.innerHTML = obj;\n\n        this._transport = document.getElementById(\"xATIOSwf\");\n        this._transportContainer = container;\n    }\n    </setupPendingRequestAndTransport>\n}\n"], ["checkHeadingsRedefined", "\nfunction(parser, reporter){\n    var rule = this;\n\n    <headingsInitialization>\n    var headings =  {\n            h1: 0,\n            h2: 0,\n            h3: 0,\n            h4: 0,\n            h5: 0,\n            h6: 0\n        };\n    </headingsInitialization>\n\n    <parserListener>\n    parser.addListener(\"startrule\", function(event){\n        var selectors = event.selectors,\n            selector,\n            part,\n            i;\n\n        for (i=0; i < selectors.length; i++){\n            selector = selectors[i];\n            part = selector.parts[selector.parts.length-1];\n\n            if (part.elementName && /(h[1-6])/.test(part.elementName.toString())){\n                headings[RegExp.$1]++;\n                if (headings[RegExp.$1] > 1) {\n                    reporter.warn(\"Heading (\" + part.elementName + \") has already been defined.\", part.line, part.col, rule);\n                }\n            }\n        }\n    });\n    </parserListener>\n}\n"], ["handleFileDrop", "\nfunction(e) {\n    <toggleActiveState>\n    toggleActive(e, false);\n    </toggleActiveState>\n\n    <loadDroppedFile>\n    if (e.dataTransfer.files.length) {\n        wavesurfer.loadBlob(e.dataTransfer.files[0]);\n    } else {\n        wavesurfer.fireEvent('error', 'Not a file');\n    }\n    </loadDroppedFile>\n}\n"], ["adjustVirtualScroll", "\nfunction(e) {\n  if (this.isVirtual) {\n    <calculateVirtualParameters>\n    var itemHeight = this.itemHeight;\n    var totalItems = this.listEl.children.length;\n    var scrollHeight = e.target.scrollHeight;\n    var viewportHeight = this.el.parentNode.offsetHeight;\n    var scrollTop = e.scrollTop;\n    </calculateVirtualParameters>\n\n    <computeWatermarks>\n    var highWater = Math.max(0, e.scrollTop + this.virtualRemoveThreshold);\n    var lowWater = Math.min(scrollHeight, Math.abs(e.scrollTop) + viewportHeight + this.virtualAddThreshold);\n    </computeWatermarks>\n\n    <determineRenderRange>\n    var itemsPerViewport = Math.floor((lowWater - highWater) / itemHeight);\n    var first = parseInt(Math.abs(highWater / itemHeight), 10);\n    var last = parseInt(Math.abs(lowWater / itemHeight), 10);\n    </determineRenderRange>\n\n    <identifyItemsForRemoval>\n    this._virtualItemsToRemove = Array.prototype.slice.call(this.listEl.children, 0, first);\n    </identifyItemsForRemoval>\n\n    <sliceVisibleItems>\n    var nodes = Array.prototype.slice.call(this.listEl.children, first, first + itemsPerViewport);\n    </sliceVisibleItems>\n\n    <triggerViewportRender>\n    this.renderViewport && this.renderViewport(highWater, lowWater, first, last);\n    </triggerViewportRender>\n  }\n}\n"], ["Bitid", "\nfunction Bitid(params) {\n  <parameterInitialization>\n  params = params || {};\n  var self = this;\n\n  this._nonce = params.nonce;\n  this.callback = url.parse(params.callback, true);\n  this.signature = params.signature;\n  this.address = params.address;\n  this.unsecure = params.unsecure;\n  this._uri = !params.uri ? buildURI() : url.parse(params.uri, true);\n  </parameterInitialization>\n\n  <buildURI>\n  function buildURI() {\n    var uri = self.callback;\n    uri.protocol = SCHEME;\n    var params = {};\n    params[PARAM_NONCE] = self._nonce;\n    if(self.unsecure) params[PARAM_UNSECURE] = 1;\n    uri.query = params;\n    uri.href = url.format(uri);\n\n    return uri;\n  }\n  </buildURI>\n}\n"], "```"]