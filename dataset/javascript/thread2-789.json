[["getLastCharIndex", "\nfunction getLastCharIndex(font) {\n  return Math.max(0, Math.min(0xffff, Math.abs(_.maxBy(Object.keys(font.codePoints), function (point) {\n    return parseInt(point, 10);\n  }))));\n}\n"], ["checkId", "\nfunction checkId(id) {\n  id = id || \"\";\n  id = id.toString();\n  return _.isString(id) && id.length === 24;\n}\n"], ["_createPlaceholder", "\nfunction _createPlaceholder(treeData, basedir, name, isFolder, options) {\n    options = options || {};\n    var parentPath = _filePathToObjectPath(treeData, basedir);\n\n    if (!parentPath) {\n        return;\n    }\n\n    var newObject = {\n    };\n\n    if (!options.notInCreateMode) {\n        newObject.creating = true;\n    }\n\n    if (isFolder) {\n        \n        \n        \n        if (options.notInCreateMode) {\n            newObject.children = null;\n        } else {\n            newObject.children = Immutable.Map();\n        }\n    }\n\n    var newFile = Immutable.Map(newObject);\n\n    if (!options.doNotOpen) {\n        treeData = _openPath(treeData, basedir);\n    }\n    if (parentPath.length > 0) {\n        var childrenPath = _.clone(parentPath);\n        childrenPath.push(\"children\");\n\n        treeData = treeData.updateIn(childrenPath, function (children) {\n            return children.set(name, newFile);\n        });\n    } else {\n        treeData = treeData.set(name, newFile);\n    }\n    return treeData;\n}\n"], ["loggingConfiguration", "\nfunction(app) {\n  if (process.env.POMELO_LOGGER !== 'off') {\n    var env = app.get(Constants.RESERVED.ENV);\n    var originPath = path.join(app.getBase(), Constants.FILEPATH.LOG);\n    var presentPath = path.join(app.getBase(), Constants.FILEPATH.CONFIG_DIR, env, path.basename(Constants.FILEPATH.LOG));\n    if(fs.existsSync(originPath)) {\n      log.configure(app, originPath);\n    } else if(fs.existsSync(presentPath)) {\n      log.configure(app, presentPath);\n    } else {\n      logger.error('logger file path configuration is error.');\n    }\n  }\n}\n"], ["ActionMiddleware", "\nfunction ActionMiddleware(...middleware) {\n    return function (target, propertyKey, descriptor) {\n        if (middleware != undefined) {\n            let m = exports.globalKCState.getOrInsertController(target.constructor).getOrInsertMethod(propertyKey);\n            m.middleware = middleware.concat(m.middleware);\n        }\n    };\n}\n"], ["defineReactive$$1", "\nfunction defineReactive$$1 (\n  obj,\n  key,\n  val,\n  customSetter,\n  shallow\n) {\n  var dep = new Dep();\n\n  var property = Object.getOwnPropertyDescriptor(obj, key);\n  if (property && property.configurable === false) {\n    return\n  }\n\n  \n  var getter = property && property.get;\n  var setter = property && property.set;\n  if ((!getter || setter) && arguments.length === 2) {\n    val = obj[key];\n  }\n\n  var childOb = !shallow && observe(val);\n  Object.defineProperty(obj, key, {\n    enumerable: true,\n    configurable: true,\n    get: function reactiveGetter () {\n      var value = getter ? getter.call(obj) : val;\n      if (Dep.target) {\n        dep.depend();\n        if (childOb) {\n          childOb.dep.depend();\n          if (Array.isArray(value)) {\n            dependArray(value);\n          }\n        }\n      }\n      return value\n    },\n    set: function reactiveSetter (newVal) {\n      var value = getter ? getter.call(obj) : val;\n      \n      if (newVal === value || (newVal !== newVal && value !== value)) {\n        return\n      }\n      \n      if (process.env.NODE_ENV !== 'production' && customSetter) {\n        customSetter();\n      }\n      \n      if (getter && !setter) { return }\n      if (setter) {\n        setter.call(obj, newVal);\n      } else {\n        val = newVal;\n      }\n      childOb = !shallow && observe(newVal);\n      dep.notify();\n    }\n  });\n}\n"], ["MultiPoint", "\nfunction MultiPoint(input){\n    if(input && input.type === \"MultiPoint\" && input.coordinates){\n      extend(this, input);\n    } else if(isArray(input)) {\n      this.coordinates = input;\n    } else {\n      throw \"Terraformer: invalid input for Terraformer.MultiPoint\";\n    }\n\n    this.type = \"MultiPoint\";\n  }\n"], ["selectNthNode", "\nfunction(n, r) {\n        r = r || 0;\n        var nodes = [];\n        NodeList.each(this, function(node, i) {\n            if (i % n === r) {\n                nodes.push(node);\n            }\n        });\n\n        return Y.all(nodes);\n    }\n"], ["updateExpression", "\nfunction updateExpression() {\n  \n  var nullHighlighter = function(item) { return false; }\n\n  var input = $('.expression');\n  var expression = input.val();\n\n  var highlighter;\n\n  if (!expression) {\n    \n    highlighter = nullHighlighter;\n    input.css('background-color', '#fff');\n  } else {\n    try {\n      \n      highlighter = compileExpression(expression); \n      input.css('background-color', '#dfd');\n    } catch (e) {\n      \n      highlighter = nullHighlighter;\n      input.css('background-color', '#fdd');\n    }\n  }\n\n  highlightRows(highlighter);\n}\n"], ["replacePlaceholders", "\nfunction replacePlaceholders(quasisDoc, expressionDocs) {\n  if (!expressionDocs || !expressionDocs.length) {\n    return quasisDoc;\n  }\n\n  const expressions = expressionDocs.slice();\n  let replaceCounter = 0;\n  const newDoc = mapDoc(quasisDoc, doc => {\n    if (!doc || !doc.parts || !doc.parts.length) {\n      return doc;\n    }\n    let parts = doc.parts;\n    const atIndex = parts.indexOf(\"@\");\n    const placeholderIndex = atIndex + 1;\n    if (\n      atIndex > -1 &&\n      typeof parts[placeholderIndex] === \"string\" &&\n      parts[placeholderIndex].startsWith(\"prettier-placeholder\")\n    ) {\n      \n      const at = parts[atIndex];\n      const placeholder = parts[placeholderIndex];\n      const rest = parts.slice(placeholderIndex + 1);\n      parts = parts\n        .slice(0, atIndex)\n        .concat([at + placeholder])\n        .concat(rest);\n    }\n    const atPlaceholderIndex = parts.findIndex(\n      part =>\n        typeof part === \"string\" && part.startsWith(\"@prettier-placeholder\")\n    );\n    if (atPlaceholderIndex > -1) {\n      const placeholder = parts[atPlaceholderIndex];\n      const rest = parts.slice(atPlaceholderIndex + 1);\n      const placeholderMatch = placeholder.match(\n        /@prettier-placeholder-(.+)-id([\\s\\S]*)/\n      );\n      const placeholderID = placeholderMatch[1];\n      \n      \n      const suffix = placeholderMatch[2];\n      const expression = expressions[placeholderID];\n\n      replaceCounter++;\n      parts = parts\n        .slice(0, atPlaceholderIndex)\n        .concat([\"${\", expression, \"}\" + suffix])\n        .concat(rest);\n    }\n    return Object.assign({}, doc, {\n      parts: parts\n    });\n  });\n\n  return expressions.length === replaceCounter ? newDoc : null;\n}\n"], "```"]