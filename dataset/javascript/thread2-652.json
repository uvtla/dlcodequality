[["resolveRungFolder", "\nfunction resolveRungFolder() {\n    const folder = path.join(os.homedir(), '.rung');\n    const createIfNotExists = tryCatch(\n        ~(fs.lstatSync(folder).isDirectory()\n            ? resolve()\n            : reject(new Error('~/.rung is not a directory'))),\n        ~createFolder(folder)\n    );\n\n    return createIfNotExists();\n}\n"], ["createErrorFromErr", "\nfunction (err) {\n  \"use strict\";\n\n  var message = '';\n\n  <determineErrorType>\n  if (typeof err === 'string') {\n    return new Error(err);\n  } else </determineErrorType> if (typeof err === 'object') {\n\n    if (err.cause) {\n      <processCauseError>\n      try {\n        message = JSON.parse(err.cause.value.message).errorMessage;\n      } catch ($) {\n        message = err.cause.value.message;\n      }\n      </processCauseError>\n    } else {\n      <defaultErrorMessage>\n      message = err.message || err.toString();\n      </defaultErrorMessage>\n    }\n    return new Error(message);\n  }\n  return new Error(err.toString());\n}\n"], ["filterValues", "\nfunction(object, callback) {\n  return inject(object, [], function(selected, key, value){\n    <applyCallback>\n    if (callIterator(callback, key, value))\n      selected.push(value)\n    </applyCallback>\n  })\n}\n"], ["setCalendarSelectedDate", "\nfunction() {\n  var value = this.value;\n  var selectedValue = (value.getMonth()+1)+\"/\"+value.getDate()+\"/\"+value.getFullYear();\n  this.calendar.cfg.setProperty(\"selected\",selectedValue,false);\n  <renderCalendar>\n  this.calendar.render();\n  </renderCalendar>\n}\n"], ["compileAndCacheLayouts", "\nfunction(layouts) {\n  var currentLayout;\n  <prepareLayouts>\n  layouts = layouts.slice(0);\n  currentLayout = self.compile(str, layoutFile);\n  layouts.push(currentLayout);\n  </prepareLayouts>\n  if (useCache) {\n    <cacheLayouts>\n    self.cache[layoutFile] = layouts.slice(0);\n    </cacheLayouts>\n  }\n  <returnCompiledLayouts>\n  cb(null, layouts);\n  </returnCompiledLayouts>\n}\n"], ["manageHelpText", "\nfunction (enable) {\n  var cfg = this._cfg;\n  \n  <earlyReturns>\n  if (!cfg) {\n      return;\n  }\n  var helpText = cfg.helptext, helpTextConfig = this._skinObj.helpText;\n  \n  if (!helpText || !this._helpTextSet && !enable || (this._hasFocus || this._keepFocus) && enable) {\n      return;\n  }\n  </earlyReturns>\n\n  var field = this.getTextInputField();\n  \n  <fieldConditions>\n  if (field.value && enable) {\n      return;\n  }\n  </fieldConditions>\n\n  this._helpTextSet = enable;\n\n  if (!field) {\n      return;\n  }\n\n  <setStyling>\n  var color = enable ? helpTextConfig.color : this._getTextFieldColor();\n  var value = enable ? helpText : \"\";\n  var helpTextClass = \"x\" + this._skinnableClass + \"_\" + cfg.sclass + \"_helpText\";\n  var classNames = field.className.split(/\\s+/);\n  ariaUtilsArray.remove(classNames, helpTextClass);\n  if (enable) {\n      classNames.push(helpTextClass);\n  }\n  field.className = classNames.join(' ');\n  </setStyling>\n\n  <applyStyleAndValue>\n  var style = field.style;\n  style.color = color;\n  field.value = value;\n  </applyStyleAndValue>\n}\n"], ["zoomed", "\nfunction zoomed () {\n  <calculateDimensions>\n  height = el.clientHeight\n  width = el.clientWidth\n  </calculateDimensions>\n\n  <resetTileSize>\n  tile.size([width, height])\n  </resetTileSize>\n\n  <calculateMapBounds>\n  var bounds = display.llBounds()\n  var psw = projection(bounds[0])\n  var pne = projection(bounds[1])\n  </calculateMapBounds>\n\n  <computeScale>\n  var scale = projection.scale() * 2 * Math.PI\n  var translate = projection.translate()\n  var dx = pne[0] - psw[0]\n  var dy = pne[1] - psw[1]\n  scale = scale * (1 / Math.max(dx / width, dy / height))\n  projection\n    .translate([width / 2, height / 2])\n    .scale(scale / 2 / Math.PI)\n  </computeScale>\n\n  <recalculateProjection>\n  psw = projection(bounds[0])\n  pne = projection(bounds[1])\n  var x = (psw[0] + pne[0]) / 2\n  var y = (psw[1] + pne[1]) / 2\n  translate = [width - x, height - y]\n  </recalculateProjection>\n\n  <updateTileTransform>\n  tile\n    .scale(scale)\n    .translate(translate)\n  </updateTileTransform>\n\n  <renderMap>\n  renderTiles(tile())\n  </renderMap>\n}\n"], ["logVuexError", "\nfunction error (error) {\n  var conf = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var path = arguments.length > 2 ? arguments[2] : undefined;\n  var props = arguments.length > 3 ? arguments[3] : undefined;\n  <configureDefaults>\n  conf = Object.assign({}, defaultConfig, conf);\n  </configureDefaults>\n  var errorMessages = getErrors(conf, path, props);\n  <logError>\n  console.error('[vuex-easy-access] Error!', errorMessages[error]);\n  </logError>\n  return error;\n}\n"], ["validateNumber", "\nfunction validateNumber(context, name, def) {\n  var value = context[name]\n\n  <assignDefault>\n  if (value == null) {\n    value = def\n  }\n  </assignDefault>\n\n  <checkIsNaN>\n  if (isNaN(value)) {\n    raise(value, 'options.' + name)\n  }\n  </checkIsNaN>\n\n  <assignContextValue>\n  context[name] = value\n  </assignContextValue>\n}\n"], ["isNamespaceFocused", "\nfunction( nspath ) {\n  var found = true,\n    nsparts = nspath.split( rpathsplit ),\n    focus = render.options.focus;\n\n  <initializeFocusCheck>\n  if ( munit.isString( focus ) ) {\n    focus = [ focus ];\n  }\n  </initializeFocusCheck>\n\n  <evaluateFocusArray>\n  if ( munit.isArray( focus ) && focus.length ) {\n    found = false;\n\n    focus.forEach(function( fpath ) {\n      var fparts = fpath.split( rpathsplit ),\n        i = -1, l = Math.min( fparts.length, nsparts.length );\n\n      <pathComparison>\n      for ( ; ++i < l; ) {\n        if ( fparts[ i ] !== nsparts[ i ] ) {\n          return;\n        }\n      }\n      </pathComparison>\n\n      <setFocusFound>\n      found = true;\n      </setFocusFound>\n    });\n  }\n  </evaluateFocusArray>\n\n  <returnFocusStatus>\n  return found;\n  </returnFocusStatus>\n}\n"], "```"]