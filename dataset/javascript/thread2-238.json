[["listS3Objects", "\nfunction (prefix, callback, marker, contents) {\n\n    <initializeSearchObject>\n    var search = {\n        Prefix: prefix, \n        Bucket: options.bucket\n    };\n\n    if (marker) {\n        search.Marker = marker;\n    }\n    </initializeSearchObject>\n\n    <listObjectsFromS3>\n    s3.listObjects(search, function (err, list) { \n\n        if (!err) {\n\n            <mergeContents>\n            var objects = (contents) ? contents.concat(list.Contents) : list.Contents;\n            </mergeContents>\n\n            <handleTruncatedList>\n            if (list.IsTruncated) {\n                var new_marker = _.last(list.Contents).Key;\n                listObjects(prefix, callback, new_marker, objects);\n            }\n            </handleTruncatedList>\n            <handleCompleteList>\n            else {\n                callback(_.uniq(objects, function (o) { return o.Key; }));\n            }\n            </handleCompleteList>\n        }\n        <handleError>\n        else {\n            grunt.fatal('Failed to list content of bucket ' + options.bucket + '\\n' + err);\n        }\n        </handleError>\n    });\n    </listObjectsFromS3>\n}\n"], ["initializeParser", "\nfunction initializeParser(document, debug) {\n    const chars = new antlr.InputStream(document);\n    const lexer = new grammar.DocumentLexer(chars);\n    <prepareLexer>\n    const listener = new CustomErrorListener(debug);\n    lexer.removeErrorListeners();\n    lexer.addErrorListener(listener);\n    </prepareLexer>\n    const tokens = new antlr.CommonTokenStream(lexer);\n    const parser = new grammar.DocumentParser(tokens);\n    <prepareParser>\n    parser.buildParseTrees = true;\n    parser.removeErrorListeners();\n    parser.addErrorListener(listener);\n    parser._errHandler = new CustomErrorStrategy();\n    </prepareParser>\n    return parser;\n}\n"], ["addItem", "\nfunction(item)\n{\n    <convertArgumentsToArray>\n    var items = conbo.toArray(arguments);\n    </convertArgumentsToArray>\n    \n    if (items.length)\n    {\n        <updateInternalState>\n        this.source.push.apply(this.source, this.__applyItemClass(items));\n        this.__updateBindings(items);\n        this.dispatchEvent(new conbo.ConboEvent(conbo.ConboEvent.ADD));\n        this.dispatchChange('length');\n        </updateInternalState>\n    }\n    \n    return this.length;\n}\n"], ["mulFunction", "\nfunction mul() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    var acc = args[0];\n    for (var i = 1; i < args.length; i++) {\n        <multiplicationLogic>\n        acc = _mul_two(acc, args[i]);\n        </multiplicationLogic>\n    }\n    return acc;\n}\n"], ["getTextRect", "\nfunction getTextRect (node) {\n  if (!isBrowser) return\n  if (!range) range = document.createRange()\n\n  <createTextNodeRange>\n  range.selectNode(node)\n  </createTextNodeRange>\n\n  <getBoundingClientRect>\n  return range.getBoundingClientRect()\n  </getBoundingClientRect>\n}\n"], ["renderTreeFunction", "\nfunction renderTree (object, options) {\n  const tree = require('archy')(transformTree(object, options.fn))\n  <generateCodeOutput>\n  return '<pre><code>\\n' + tree + '</code></pre>'\n  </generateCodeOutput>\n}\n"], ["replaceDomElement", "\nfunction (domElement, event) {\n    var label;\n    var domUtil = ariaUtilsDom;\n    <retrieveLabelText>\n    label = domElement.textContent || domElement.innerText;\n    </retrieveLabelText>\n    \n    <replaceElement>\n    domUtil.replaceDomElement(domElement.parentNode, this._textInputField);\n    </replaceElement>\n    \n    <handleRemovedSuggestion>\n    var removedSuggestionInfo = this._removeValue(label);\n    var removedSuggestion = removedSuggestionInfo.removedSuggestion;\n    var removedSuggestionIndex = removedSuggestionInfo.removedSuggestionIndex;\n    this._keepFocus = true;\n    this._textInputField.focus();\n    </handleRemovedSuggestion>\n    \n    <editControllerValue>\n    if (removedSuggestion) {\n        var report = this.controller.editValue(removedSuggestion, removedSuggestionIndex);\n        this._reactToControllerReport(report);\n    }\n    </editControllerValue>\n    \n    <restoreFocusManager>\n    this._restoreKeepFocus();\n    </restoreFocusManager>\n}\n"], ["buildHashTimeLockContract", "\nfunction buildHashTimeLockContract(network, xHash, destH160Addr, revokerH160Addr, lockTime) {\n  const bitcoinNetwork = bitcoin.networks[network];\n\n  <compileRedeemScript>\n  const redeemScript = bitcoin.script.compile([\n    // ... script opcodes ...\n  ]);\n  </compileRedeemScript>\n\n  <createP2SHAddress>\n  const addressPay = bitcoin.payments.p2sh({\n    redeem: { output: redeemScript, network: bitcoinNetwork },\n    network: bitcoinNetwork,\n  });\n  </createP2SHAddress>\n\n  <extractAddress>\n  const { address } = addressPay;\n  </extractAddress>\n  \n  <constructHTLCObject>\n  return {\n    \n    address,\n    redeemScript: redeemScript.toString('hex'),\n\n    \n    xHash,\n    lockTime,\n    redeemer: hex.ensurePrefix(destH160Addr),\n    revoker: hex.ensurePrefix(revokerH160Addr),\n  };\n  </constructHTLCObject>\n}\n"], ["FileMediatorServiceConstructor", "\nfunction FileMediatorService(mediator, config) {\n  this.mediator = mediator;\n  this.config = config || {};\n  <configureMediatorTopics>\n  this.filesDataTopics = new MediatorTopicUtility(mediator).prefix(this.config.cloudDataTopicPrefix).entity(this.config.datasetId);\n  </configureMediatorTopics>\n}\n"], ["_formatParamFunction", "\nfunction _formatParam(paramReport, verbose = false) {\n  <formatParamVerbose>\n  if (paramReport.valid && verbose) {\n    const result = [[complete('Arg:'), `${paramReport.atomDocArg.name} is complete`, '']];\n    if (paramReport.hasChildren) {\n      result.push(['Nested Params:']);\n      return paramReport.childrenReports.reduce((collector, paramChildReport) => {\n        const paramResult = _formatParam(paramChildReport, verbose);\n        return collector.concat(paramResult);\n      }, result);\n    }\n    return result;\n  } else if (paramReport.valid) {\n    return false;\n  }\n  </formatParamVerbose>\n  \n  const result = [];\n  <formatParamNameMismatch>\n  if (!paramReport.nameMatch.valid) {\n    result.push(\n      [\n        missing('Arg Name:'),\n        paramReport.nameMatch.inspectorValue,\n        paramReport.nameMatch.atomDocValue,\n      ]\n    );\n  }\n  </formatParamNameMismatch>\n  <formatParamOptionalMismatch>\n  if (!paramReport.optionalMatch.valid) {\n    result.push(\n      [missing('Arg Optional:'), 'Missing', `Add (optional) to ${paramReport.atomDocArg.name}`]\n    );\n  }\n  </formatParamOptionalMismatch>\n  <formatParamNested>\n  if (paramReport.hasChildren) {\n    result.push(['Nested Params:']);\n    return paramReport.childrenReports.reduce((collector, paramChildReport) => {\n      const paramResult = _formatParam(paramChildReport, verbose);\n      if (paramResult !== false) {\n        return collector.concat(paramResult);\n      }\n      return collector;\n    }, result);\n  }\n  </formatParamNested>\n  return result;\n}\n"], "```"]