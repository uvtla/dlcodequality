[["function-1", "\nfunction(plugin, message, opt) {\n  opt = opt || {};\n  if (typeof plugin === 'object') {\n    opt = plugin;\n  } else {\n    <handleErrorOrMessage>\n    if (message instanceof Error) {\n      opt.error = message;\n    } else if (typeof message === 'object') {\n      opt = message;\n    } else {\n      opt.message = message;\n    }\n    </handleErrorOrMessage>\n    opt.plugin = plugin;\n  }\n\n  return objectAssign({\n    showStack: false,\n    showProperties: true\n  }, opt);\n}\n"], ["function-2", "\nfunction (options, callback) {\n  if (options instanceof Function) {\n    callback = options;\n    options = {};\n  }\n\n  if (this.initialized) {\n    callback && callback(null, this);\n    return;\n  }\n  var self = this;\n\n  flow()\n    .seq(function (cb) {\n      <handleNewItem>\n      if (self.isNew()) {\n        cb();\n      } else {\n        self.fetch(null, cb);\n      }\n      </handleNewItem>\n    })\n    .seq(function (cb) {\n      <fetchProductType>\n      var productType = self.$.productType;\n      productType.fetch(null, cb);\n      </fetchProductType>\n    })\n    .seq(function () {\n      <setUpProductAppearanceAndView>\n      var productType = self.$.productType;\n\n      var appearance;\n\n      if (self.$.appearance) {\n        appearance = productType.getAppearanceById(self.$.appearance.$.id);\n      }\n\n      appearance = appearance || productType.getDefaultAppearance();\n\n      self.set({\n        appearance: appearance,\n        view: self.$.view || productType.getViewById(self.get(\"defaultValues.defaultView.id\")) || productType.getDefaultView()\n      });\n      </setUpProductAppearanceAndView>\n    })\n    .seq(function (cb) {\n      <initConfigurations>\n      flow()\n        .parEach(self.$.configurations.$items, function (configuration, cb) {\n          self._setUpConfiguration(configuration);\n          options.isExample = self.get('restrictions.example');\n          configuration.init(options, cb);\n        })\n        .exec(function (err) {\n          cb(err);\n        });\n      </initConfigurations>\n    })\n    .exec(function (err) {\n      self.trigger(\"productInitialized\");\n      self.trigger(\"priceChanged\");\n\n      if (err) {\n        callback && callback(err);\n      } else {\n        <markAsInitialized>\n        self.initialized = true;\n        callback && callback(null, self);\n        </markAsInitialized>\n      }\n    });\n}\n"], ["function-3", "\nfunction identifier (options) {\n  var result = ddata._identifier(options)\n  return result ? options.fn(result) : 'ERROR, Cannot find identifier.'\n}\n"], ["function-4", "\nfunction (callback) {\n  return function (err, stdout, stderr) {\n    <handleExecutionOutcome>\n    if (err) {\n      throw err;\n    } else if (stderr) {\n      log('sync error', 'failed with the following output:');\n      console.log('\\n', stderr, '\\n');\n    } else {\n      log('sync', 'completed successfully');\n      log();\n      if (callback) callback();\n    }\n    </handleExecutionOutcome>\n  };\n}\n"], ["function-5", "\nfunction (i1, i2, c1, c2) {\n  <calculateGeometricalPositions>\n  var pos_x0 = BABYLON.Vector3.Lerp(face_vertex_pos[0], face_vertex_pos[2], i2 / subdivisions);\n  var pos_x1 = BABYLON.Vector3.Lerp(face_vertex_pos[1], face_vertex_pos[2], i2 / subdivisions);\n  var pos_interp = (subdivisions === i2) ? face_vertex_pos[2] : BABYLON.Vector3.Lerp(pos_x0, pos_x1, i1 / (subdivisions - i2));\n  pos_interp.normalize();\n  </calculateGeometricalPositions>\n  var vertex_normal;\n  if (flat) {\n    <calculateFlatVertexNormal>\n    var centroid_x0 = BABYLON.Vector3.Lerp(face_vertex_pos[0], face_vertex_pos[2], c2 / subdivisions);\n    var centroid_x1 = BABYLON.Vector3.Lerp(face_vertex_pos[1], face_vertex_pos[2], c2 / subdivisions);\n    vertex_normal = BABYLON.Vector3.Lerp(centroid_x0, centroid_x1, c1 / (subdivisions - c2));\n    </calculateFlatVertexNormal>\n  }\n  else {\n    <calculateSmoothVertexNormal>\n    vertex_normal = new BABYLON.Vector3(pos_interp.x, pos_interp.y, pos_interp.z);\n    </calculateSmoothVertexNormal>\n  }\n  <normalizeAndCalculateTextureCoordinates>\n  vertex_normal.x /= radiusX;\n  vertex_normal.y /= radiusY;\n  vertex_normal.z /= radiusZ;\n  vertex_normal.normalize();\n  var uv_x0 = BABYLON.Vector2.Lerp(face_vertex_uv[0], face_vertex_uv[2], i2 / subdivisions);\n  var uv_x1 = BABYLON.Vector2.Lerp(face_vertex_uv[1], face_vertex_uv[2], i2 / subdivisions);\n  var uv_interp = (subdivisions === i2) ? face_vertex_uv[2] : BABYLON.Vector2.Lerp(uv_x0, uv_x1, i1 / (subdivisions - i2));\n  </normalizeAndCalculateTextureCoordinates>\n  <pushPositionNormalUV>\n  positions.push(pos_interp.x * radiusX, pos_interp.y * radiusY, pos_interp.z * radiusZ);\n  normals.push(vertex_normal.x, vertex_normal.y, vertex_normal.z);\n  uvs.push(uv_interp.x, uv_interp.y);\n  </pushPositionNormalUV>\n  \n  <pushIndices>\n  indices.push(current_indice);\n  current_indice++;\n  </pushIndices>\n}\n"], ["function-6", "\nfunction (poly) {\n  if (arguments.length > 1) {\n    <convertArgumentsToPolygon>\n    var args = Array.prototype.slice.call(arguments, 0);\n    poly = new Crafty.polygon(args);\n    </convertArgumentsToPolygon>\n  }\n  \n  <shiftAndAttachPolygon>\n  poly.shift(this._x, this._y);\n  this.mapArea = poly;\n  this.attach(this.mapArea);\n  </shiftAndAttachPolygon>\n  return this;\n}\n"], ["function-7", "\nfunction CBSocketWrapper(config) {\n  this.config = config;\n  var self = this;\n  \n  <manageConnectionEvents>\n  this.connected = false;\n  this.on('connect', function() {\n    self.connected = true;\n    logger.info('Connected to Continuum Bridge', self.config.cbSocket);\n  });\n  this.on('connecting', function() {\n    self.connected = false;\n    logger.info('Connecting..');\n  });\n  this.on('error', function(error) {\n    self.connected = false;\n    logger.log('Error', error);\n  });\n  this.on('disconnect', function() {\n    self.connected = false;\n    logger.info('Disconnected from Continuum Bridge:', self.config.cbSocket);\n  });\n  </manageConnectionEvents>\n}\n"], ["function-8", "\nfunction findPivot(other) {\n  var p1 = _path.call(this), p2 = _path.call(other), i, len, p;\n\n  for (i = 0, len = p1.length < p2.length ? p1.length : p2.length; i < len; i++) {\n    if (p1[i] === p2[i]) { p = p1[i]; } else { break; }\n  }\n\n  if (!p) {\n    throw new Error('State#findPivot: states ' + this + ' and ' + other + ' do not belong to the same statechart');\n  }\n\n  return p;\n}\n"], ["function-9", "\nfunction(onReady) {\n  var self = this;\n\n  if (APPID === 'change me') {\n    console.log('Error -- edit weatherman.js and provide the APPID for Open Weathermap.'.bold.yellow);\n  }\n\n  <loadRiveScriptFile>\n  rs.loadFile(\"weatherman.rive\").then(function() {\n    rs.sortReplies();\n    onReady();\n  }).catch(function(err) {\n    console.error(err);\n  });\n  </loadRiveScriptFile>\n  \n  <defineSendMessage>\n  self.sendMessage = function(username, message) {\n    console.log(\n      [\"[Brick Tamland]\", message].join(\": \").underline.green\n    );\n  };\n  </defineSendMessage>\n\n  <defineGetReply>\n  self.getReply = function(username, message, callback) {\n    return rs.reply(username, message, self);\n  }\n  </defineGetReply>\n}\n"], ["function-10", "\nfunction character (n) {\n  var message = ' ' + n + ' znak';\n\n  <determinePluralSuffix>\n  if (n % 10 < 5 && n % 10 > 0 && (n % 100 < 5 || n % 100 > 19)) {\n    if (n % 10 > 1) {\n      message += 'a';\n    }\n  } else {\n    message += 'ova';\n  }\n  </determinePluralSuffix>\n\n  return message;\n}\n"], "```"]