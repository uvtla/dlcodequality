[["addAttachment", "\nfunction addAttachment(obj_list) {\n    for (let key in obj_list) {\n        if (typeof(obj_list[key]) === 'string' &&\n            regexAttach.test(obj_list[key])) {\n            <resolveAttachment>\n            const binaryKey = obj_list[key];\n            const replacement = getAttachment(binaryKey);\n            if (replacement !== null) obj_list[key] = replacement;\n            </resolveAttachment>\n        } else if (typeof(obj_list[key]) === 'object') {\n            <recursiveAttachmentHandling>\n            addAttachment(obj_list[key]);\n            </recursiveAttachmentHandling>\n        }\n    }\n}\n"], ["imageGallerySetup", "\nfunction ()\n{\n  <createImageLabel>\n  this.imageLabel = jQuery('<div/>', {'class': 'jBox-image-label-container'}).appendTo(this.wrapper);\n  this.imageLabel.append(jQuery('<div/>', {'class': 'jBox-image-pointer-prev', click: function () { this.showImage('prev'); }.bind(this)})).append(jQuery('<div/>', {'class': 'jBox-image-pointer-next', click: function () { this.showImage('next'); }.bind(this)}));\n  </createImageLabel>\n\n  <downloadButtonSetup>\n  if (this.options.downloadButton) {\n    this.downloadButton = jQuery('<div/>', {'class': 'jBox-image-download-button-wrapper'})\n      .appendTo(this.wrapper)\n      .append(\n        this.options.downloadButtonText ? jQuery('<div/>', {'class': 'jBox-image-download-button-text'}).html(this.options.downloadButtonText) : null\n      )\n      .append(\n        jQuery('<div/>', {'class': 'jBox-image-download-button-icon'})\n      ).on('click touchdown', function () {\n        if (this.images[this.currentImage.gallery][this.currentImage.id].downloadUrl) {\n          var currentImageUrl = this.images[this.currentImage.gallery][this.currentImage.id].downloadUrl;\n        } else {\n          var currentImage = this.wrapper.find('.jBox-image-default-current');\n          var currentImageStyle = currentImage[0].style.backgroundImage;\n          var currentImageUrl = currentImageStyle.slice(4, -1).replace(/[\"']/g, '');\n        }\n        this.downloadImage(currentImageUrl);\n      }.bind(this));\n  }\n  </downloadButtonSetup>\n\n  <imageCounterSetup>\n  if (this.options.imageCounter) {\n    this.imageCounter = jQuery('<div/>', {'class': 'jBox-image-counter-container'}).appendTo(this.wrapper);\n    this.imageCounter.append(jQuery('<span/>', {'class': 'jBox-image-counter-current'})).append(jQuery('<span/>').html(this.options.imageCounterSeparator)).append(jQuery('<span/>', {'class': 'jBox-image-counter-all'}));\n  }\n  </imageCounterSetup>\n}\n"], ["mergeable", "\nfunction mergeable(node) {\n  <mergeableCheck>\n  var start;\n  var end;\n\n  if (node.type !== 'text' || !node.position) {\n    return true;\n  }\n\n  start = node.position.start;\n  end = node.position.end;\n\n  return (\n    start.line !== end.line || end.column - start.column === node.value.length\n  );\n  </mergeableCheck>\n}\n"], ["initState", "\nfunction initState() {\n    <setupDeferred>\n    var result = $.Deferred();\n    </setupDeferred>\n\n    <parseAndUpdateState>\n    updateJsonHandler.parse()\n        .done(function() {\n            result.resolve();\n        })\n        .fail(function (code) {\n            <handleStateError>\n            var logMsg;\n            switch (code) {\n            case StateHandlerMessages.FILE_NOT_FOUND:\n                logMsg = \"AutoUpdate : updateHelper.json cannot be parsed, does not exist\";\n                break;\n            case StateHandlerMessages.FILE_NOT_READ:\n                logMsg = \"AutoUpdate : updateHelper.json could not be read\";\n                break;\n            case StateHandlerMessages.FILE_PARSE_EXCEPTION:\n                logMsg = \"AutoUpdate : updateHelper.json could not be parsed, exception encountered\";\n                break;\n            case StateHandlerMessages.FILE_READ_FAIL:\n                logMsg = \"AutoUpdate : updateHelper.json could not be parsed\";\n                break;\n            }\n            console.log(logMsg);\n            result.reject();\n            </handleStateError>\n        });\n    </parseAndUpdateState>\n    \n    <returnPromise>\n    return result.promise();\n    </returnPromise>\n}\n"], ["initScaffold", "\nfunction initScaffold(fis) {\n    <setFisScaffoldConfigs>\n    fis.set('scaffold.namespace', 'tfux-scaffold');\n    fis.set('scaffold.gitlabDomain', DEFAULT_GITLAB_DOMAIN);\n    fis.set('scaffold.gitlabToken', process.env.GITLAB_TOKEN || 'XsYDeyqyFD777qgovh15');\n    </setFisScaffoldConfigs>\n}\n"], ["processItem", "\nfunction(item) {\n    <labelHandling>\n    if((item.label || item.labelTemplate) && item.labelElement) {\n        item.label ? item.labelElement.html(item.label) : item.labelElement.html(loadHTMLFromFile(item.labelTemplate));\n        item.labelElement.append(item.pictoElement);\n    }\n    if(this.settings.labelClass && item.labelElement) {\n        item.labelElement.addClass(this.settings.labelClass);\n    }\n    </labelHandling>\n\n    <pictoHandling>\n    if(item.picto || item.pictoTemplate) {\n        item.picto ? item.pictoElement.html(item.picto) : item.pictoElement.html(loadHTMLFromFile(item.pictoTemplate));\n    }\n    </pictoHandling>\n\n    <contentHandling>\n    // The content handling contains various tasks like setting short content, height watching, and class adding, thus cannot be split further.\n\n    if((item.shortContent || item.shortContentTemplate) && item.shortContentElement) {\n        item.shortContent ? item.shortContentElement.html(item.shortContent) : item.shortContentElement.html(loadHTMLFromFile(item.shortContentTemplate));\n        // Other related tasks...\n    }\n    // More content-related tasks (omitted for brevity)...\n    </contentHandling>\n}\n"], ["loadPromise", "\nfunction loadPromise (eleOrWindow) {\n    <checkLoaded>\n    if (isLoaded(eleOrWindow)) {\n        return Promise.resolve(eleOrWindow);\n    }\n    </checkLoaded>\n\n    <setupLoadingPromise>\n    let loadingPromise = new Promise((resolve, reject) => {\n        // Code to handle the loading state...\n    });\n    </setupLoadingPromise>\n\n    <returnLoadingPromise>\n    return loadingPromise;\n    </returnLoadingPromise>\n}\n"], ["showNote", "\nfunction showNote(region) {\n  <findNoteElement>\n    if (!showNote.el) {\n        showNote.el = document.querySelector('#subtitle');\n    }\n  </findNoteElement>\n  \n  <updateSubtitleText>\n    showNote.el.textContent = region.data.note || '\u2013';\n  </updateSubtitleText>\n}\n"], ["sanitizeString", "\nfunction( string ){\n    <removeDuplicateSlashes>\n    for( var i = 0; i < string.length; i++ ) string = string.replace( $this.slash.get() + $this.slash.get(), $this.slash.get());\n    </removeDuplicateSlashes>\n\n    <returnSanitizedString>\n    return string;\n    </returnSanitizedString>\n}\n"], ["requestFindRefs", "\nfunction requestFindRefs(session, document, offset) {\n    <guardClause>\n    if (!document || !session) {\n        return;\n    }\n    </guardClause>\n\n    <fileInfoSetup>\n    var path    = document.file.fullPath,\n        fileInfo = {\n            type: MessageIds.TERN_FILE_INFO_TYPE_FULL,\n            name: path,\n            offsetLines: 0,\n            text: ScopeManager.filterText(session.getJavascriptText())\n        };\n    </fileInfoSetup>\n\n    <executeTernQuery>\n    var ternPromise = getRefs(fileInfo, offset);\n    </executeTernQuery>\n\n    <returnTernPromise>\n    return {promise: ternPromise};\n    </returnTernPromise>\n}\n"], "```"]