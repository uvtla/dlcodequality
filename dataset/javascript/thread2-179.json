[["getPrimes", "\nfunction getPrimes(limit) {\n    var sieve = new Array(limit);\n    var n, j, k;\n    var last = Math.floor(Math.sqrt(limit));\n    <initializeSieve>\n    for (n=2; n < limit; n++) {\n        sieve[n] = true;\n    }\n    </initializeSieve>\n    <calculatePrimes>\n    for (n=2; n <= last;) {\n        for (j= n+n; j < limit; j += n) {\n            sieve[j] = false;\n        }\n        for (j=1; j < last; j++) {\n            k = n+j;\n            if (sieve[k]) {\n                n = k;\n                break;\n            }\n        }\n    }\n    </calculatePrimes>\n    <collectPrimes>\n    var primes = [];\n    for (n=2; n < limit; n++) {\n        if (sieve[n]) {\n            primes.push(n);\n        }\n    }\n    </collectPrimes>\n    return primes;\n}\n"], ["buildActions", "\nfunction buildActions (controller, record, parentController, parentRecord) {\n    \n    var actions = {}\n    \n    <createActionViews>\n    if (record.id) {\n        actions.view = {\n            href: '/'+controller.path+'/'+record.id,\n            title: 'View',\n        }\n    }\n    </createActionViews>\n    \n    <defineParentControllerActions>\n    if (defined(parentController)) {\n        \n        <handleRelationActions>\n        var relation = parentController.model.relation(controller.model.name)\n        \n        if (defined(relation.viaModel) && defined(relation.viaModel.columns.d)) {\n            actions.unlink = {\n                href: `/${parentController.path}/${parentRecord.id}/unlink?relation=${controller.model.name}&relationId=${record.id}`,\n                title: 'Unlink',\n            }\n        }\n        </handleRelationActions>\n        \n        <handleDeleteActions>\n        else if (defined(controller.model.columns.d)) {\n            actions.delete = {\n                href: `/${controller.path}/${record.id}/delete`,\n                title: 'Delete',\n            }\n        }\n        </handleDeleteActions>\n    }\n    </defineParentControllerActions>\n    \n    <handleControllerActions>\n    else {\n        \n        if (controller.model.columns.d) {\n            actions.delete = {\n                href: `/${controller.path}/${record.id}/delete`,\n                title: 'Delete',\n            }\n        }\n    }\n    </handleControllerActions>\n    \n    <mergeCustomActions>\n    if (defined(controller.actions)) {\n        \n        var controllerActions = _.cloneDeep(controller.actions)\n        \n        _.each(controllerActions, (action, actionName) => {\n            \n            resolveLinkVariables(action, record)\n            \n            if (defined(actions[actionName])) {\n                _.merge(actions[actionName], action)\n            }\n            \n            else {\n                actions[actionName] = action\n            }\n        })\n    }\n    </mergeCustomActions>\n    \n    <assignActionsToRecord>\n    record.actions = _.map(_.sortBy(_.keys(actions)), actionName => {\n        var action = actions[actionName]\n        action.action = actionName\n        return action\n    })\n    </assignActionsToRecord>\n}\n"], ["queueSubUnsubRequest", "\nfunction queueSubUnsubRequest(message, response) {\n\t<initializeQueue>\n\tif (typeof subUnsubQueue[message.itemName] === 'undefined') {\n\t\tsubUnsubQueue[message.itemName] = [];\n\t}\n\t</initializeQueue>\n\t<enqueueRequest>\n\tsubUnsubQueue[message.itemName].push({'message': message, 'response': response});\n\treturn subUnsubQueue[message.itemName].length;\n\t</enqueueRequest>\n}\n"], ["containsFallback", "\nfunction containsFallback (context, el) {\n  let node = el\n  <traceAncestors>\n  while (node) {\n    if (node === context) {\n      return true\n    }\n    node = node.parentNode\n  }\n  </traceAncestors>\n\n  return false\n}\n"], ["extractDataUrls", "\nfunction extractDataUrls(css, preservedTokens) {\n\n    const pattern = /url\\(\\s*([\"']?)data\\:/g\n    const maxIndex = css.length - 1\n    const sb = []\n\n    let appendIndex = 0\n    let match\n\n    <parseCssForDataUrls>\n    while ((match = pattern.exec(css)) !== null) {\n\n        let startIndex = match.index + 4  \n        let terminator = match[1]         \n\n        if (terminator.length === 0) {\n            terminator = ')'\n        }\n\n        let foundTerminator = false\n        let endIndex = pattern.lastIndex - 1\n\n        <searchForTerminator>\n        while (foundTerminator === false && endIndex + 1 <= maxIndex) {\n            endIndex = css.indexOf(terminator, endIndex + 1)\n\n            \n            if ((endIndex > 0) && (css.charAt(endIndex - 1) !== '\\\\')) {\n                foundTerminator = true\n                if (')' != terminator) {\n                    endIndex = css.indexOf(')', endIndex)\n                }\n            }\n        }\n        </searchForTerminator>\n\n        \n        sb.push(css.substring(appendIndex, match.index))\n\n        <handleTerminatorFound>\n        if (foundTerminator) {\n\n            let token = css.substring(startIndex, endIndex)\n            let parts = token.split(',')\n            if (parts.length > 1 && parts[0].slice(-7) == ';base64') {\n                token = token.replace(/\\s+/g, '')\n            } else {\n                token = token.replace(/\\n/g, ' ')\n                token = token.replace(/\\s+/g, ' ')\n                token = token.replace(/(^\\s+|\\s+$)/g, '')\n            }\n\n            preservedTokens.push(token)\n\n            let preserver = 'url(' + ___PRESERVED_TOKEN_ + (preservedTokens.length - 1) + '___)'\n            sb.push(preserver)\n\n            appendIndex = endIndex + 1\n        } else {\n        </handleTerminatorFound>\n            \n            sb.push(css.substring(match.index, pattern.lastIndex))\n            appendIndex = pattern.lastIndex\n        }\n    }\n    </parseCssForDataUrls>\n\n    <completeStringBuilder>\n    sb.push(css.substring(appendIndex))\n    </completeStringBuilder>\n\n    return sb.join('')\n}\n"], ["_extract", "\nfunction _extract(keyStr, dataObj) {\n\tvar altkey,\n\t\t_subKey,\n\t\t_splitPoint,\n\t\t_found = false,\n\t\tdataValue = null,\n\t\t_queryParts = [];\n\n\t<initializeExtraction>\n\tif (dataObj && typeof dataObj === 'object') {\n\t\tdataValue = Object.create(dataObj);\n\t\t_queryParts = keyStr.split(/[\\-\\_\\.]/);\n\t</initializeExtraction>\n\n\t<keyInDataObj>\n\t\n\tif (keyStr in dataValue) {\n\t\tdataValue = dataValue[keyStr];\n\t\t_queryParts.length = 0;\n\t\t_found = true;\n\t}\n\t</keyInDataObj>\n\n\t<queryPartsExtraction>\n \twhile(_queryParts.length) {\n\t\t_splitPoint = _queryParts.shift();\n\t\t_subKey = keyStr.split(new RegExp('('+_splitPoint+')')).slice(0,2).join(\"\");\n\t\tif (_subKey in dataValue) {\n\t\t\tdataValue = dataValue[_subKey];\n\t\t\tkeyStr = keyStr.split(new RegExp('('+_subKey+'[\\-\\_\\.])')).slice(2).join(\"\");\n\t\t\t_found = true;\n\t\t} else {\n\t\t\t_found = false;\n\t\t}\n\t\t\n\t}\n\t</queryPartsExtraction>\n\n\t<alternativeKeyExtraction>\n\tif (!_found) {\n\t\t\n\t\taltkey = keyStr.replace(/[\\-\\_\\.]/,' ');\n\t\tif (altkey in dataObj) {\n\t\t\tdataValue = dataObj[altkey];\n\t\t\t_found = true;\n\t\t}\n\t}\n\t</alternativeKeyExtraction>\n\n\treturn _found ? dataValue : NaN;\n}\n"], ["LogFileTee", "\nfunction LogFileTee(filename, stream2) {\n\t<initStreams>\n\tvar streams = [fs.createWriteStream(path.resolve(filename))];\n\tif (stream2 === undefined) {\n\t\tstreams.push(process.stdout);\n\t} else if (stream2 !== null) {\n\t\tstreams.push(stream2);\n\t}\n\t</initStreams>\n\t<initializeLogTee>\n\tLogTee.call(this, streams);\n\t</initializeLogTee>\n\tthis.logfile = filename;\n}\n"], ["getTotalFlexGrow", "\nfunction getTotalFlexGrow(columns) {\n    <calculateTotalFlexGrow>\n    var totalFlexGrow = 0;\n    for (var _i = 0, columns_1 = columns; _i < columns_1.length; _i++) {\n        var c = columns_1[_i];\n        totalFlexGrow += c.flexGrow || 0;\n    }\n    </calculateTotalFlexGrow>\n    return totalFlexGrow;\n}\n"], ["function", "\nfunction(query, root) {\n    \n\n    <handleNullOrEmptyQuery>\n    if (!query) {\n      return [];\n    }\n    </handleNullOrEmptyQuery>\n\n    <handleQueryAsArray>\n    if (query.constructor == Array) {\n      return  (query);\n    }\n    </handleQueryAsArray>\n\n    <validateRootElement>\n    if (!goog.isString(query)) {\n      return [query];\n    }\n\n    if (goog.isString(root)) {\n      root = goog.dom.getElement(root);\n      if (!root) {\n        return [];\n      }\n    }\n    </validateRootElement>\n\n    root = root || goog.dom.getDocument();\n    var od = root.ownerDocument || root.documentElement;\n\n    <detectCaseSensitivity>\n    \n    caseSensitive =\n        root.contentType && root.contentType == 'application/xml' ||\n        goog.userAgent.OPERA &&\n          (root.doctype || od.toString() == '[object XMLDocument]') ||\n        !!od &&\n        (goog.userAgent.IE ? od.xml : (root.xmlVersion || od.xmlVersion));\n    </detectCaseSensitivity>\n\n    <executeQueryFunction>\n    \n    var r = getQueryFunc(query)(root);\n    </executeQueryFunction>\n\n    <finalizeResults>\n    \n    if (r && r.nozip) {\n      return r;\n    }\n    return _zip(r);\n    </finalizeResults>\n  }\n"], ["alwaysReturns", "\nfunction alwaysReturns(node) {\n            \n    <handleBlockStatementNode>\n    if (node.type === \"BlockStatement\") {\n\n        \n        return node.body.some(checkForReturnOrIf);\n    }\n    </handleBlockStatementNode>\n\n    <handleSingleNode>\n    \n    return checkForReturnOrIf(node);\n    </handleSingleNode>\n}\n"], "```\n\nEach function has been annotated according to the SRP principle, identifying blocks of code that perform single, separable responsibilities within the larger context of the function. The tags are placed directly before and after the specific lines of code that represent these distinct responsibilities."]