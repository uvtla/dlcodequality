[["numericConverter", "\nfunction ( o ) {\n    this.isNumber = true;\n    this.value = 0;\n    if(o.value !== undefined){\n        if( typeof o.value === 'string' ) this.value = o.value * 1;\n        else this.value = o.value;\n    }\n\n    this.min = o.min === undefined ? -Infinity : o.min;\n    this.max = o.max === undefined ?  Infinity : o.max;\n    this.precision = o.precision === undefined ? 2 : o.precision;\n\n    var s;\n\n    switch(this.precision){\n        case 0: s = 1; break;\n        case 1: s = 0.1; break;\n        case 2: s = 0.01; break;\n        case 3: s = 0.001; break;\n        case 4: s = 0.0001; break;\n    }\n\n    this.step = o.step === undefined ?  s : o.step;\n    this.range = this.max - this.min;\n    this.value = this.numValue( this.value );\n}\n"], ["routeHandler", "\nfunction(router, req, res) {\n    var routeFound = false,\n      url = req.url.toString(),\n      method = req.method;\n    for (var i = 0; i < router.routes.length; i++) {\n      var route = router.routes[i];\n      if (url.indexOf(route.route) != -1 && route.method == method) {\n        if (url != '/' && route.route == '/') {\n          continue;\n        }\n        if (url != route.route && !route.hasObject) {\n          continue;\n        }\n        \n        <getRequestHandler>\n        if (method === 'GET') {\n          req.body = {};\n          if (route.hasObject) {\n            req.body[route.objectName] = basename(url);\n          }\n          route.callback(req, res);\n          routeFound = true;\n          break;\n        }\n        </getRequestHandler>\n        \n        <nonGetRequestHandler>\n        else {\n          ReqToObject(req, res, route);\n          routeFound = true;\n          break;\n        }\n        </nonGetRequestHandler>\n      }\n    }\n    return routeFound;\n}\n"], ["fileStubInitialization", "\nfunction FileStub() {\n  this.settings = {\n    name: '',\n    buffer: new Buffer(0),\n    readdir: false,\n    parentName: '',\n    stats: {\n      dev: 2114,\n      ino: 48064969,\n      mode: 33188,\n      nlink: 1,\n      uid: 85,\n      gid: 100,\n      rdev: 0,\n      size: 0,\n      blksize: 4096,\n      blocks: 0,\n      atime: 'Mon, 10 Oct 2011 23:24:11 GMT',\n      mtime: 'Mon, 10 Oct 2011 23:24:11 GMT',\n      ctime: 'Mon, 10 Oct 2011 23:24:11 GMT'\n    }\n  };\n}\n"], ["unicodeConversion", "\nfunction(match, esc) {\n    if (/^(\\n|\\r\\n|\\r|\\f)$/.test(esc)) { return ''; }\n    var m = /^[0-9a-f]{1,6}/i.exec(esc);\n    if (m) {\n        var codePoint = parseInt(m[0], 16);\n        \n        <fromCodePointUsage>\n        if (String.fromCodePoint) {\n            return String.fromCodePoint(codePoint);\n        } else {\n            return String.fromCharCode(codePoint);\n        }\n        </fromCodePointUsage>\n    }\n    return esc;\n}\n"], ["zestCommunication", "\nfunction (token, path, payload, contentFormat) {\n    return new Promise((resolve,reject)=>{\n        let zh = NewZestHeader();\n        zh.code = 2;\n        zh.token = token;\n        zh.tkl = token.length;\n        zh.payload = payload;\n        zh.oc = 3;\n        zh.options.push(NewZestOptionHeader(11,path,path.length));\n        let hostname = os.hostname();\n        zh.options.push(NewZestOptionHeader(3,hostname,hostname.length));\n        zh.options.push(NewZestOptionHeader(12,contentFormatToInt(contentFormat),2)); \n\n        let msg = MarshalZestHeader(zh)\n        \n        <sendAndHandle>\n        sendRequestAndAwaitResponse(this.ZMQsoc,msg)\n        .then((resp)=>{\n            handleResponse(resp,(zh)=>{resolve(zh.payload)},reject);\n        })\n        .catch((err)=>{\n            reject(err);\n        });\n        </sendAndHandle>\n    });\n}\n"], ["namespaceInstallation", "\nfunction install(ns) {\n    if (!ns || typeof ns !== 'object') {\n        throw new Error('Argument 0 of install is not valid.');\n    }\n\n    return Object.assign(ns, module.exports);\n}\n"], ["dynamicFunctionCreation", "\nfunction pregame(name, path) {\n  var expected = [];\n  var match, possible;\n  \n  <argumentExtraction>\n  pathArgs.lastIndex = 0;\n  while ((match = pathArgs.exec(path)) !== null) {\n    expected.push({\n      name: match[1],\n      allowed: (possible = match[2] !== undefined ? match[2].split(',') : undefined),\n      assume: possible !== undefined ? possible[0] : undefined\n    });\n  }\n  </argumentExtraction>\n\n  return function() {\n    var self = this;\n    var args = slice.call(arguments);\n    var options;\n    var callback;\n    var actual;\n    var adjustedPath = path;\n    var diff;\n    var i;\n\n    <argumentValidation>\n    if (args.length > expected.length + 2 ) {\n      throw new Error('Too many arguments passed to .' + name + '()');\n    }\n    \n    if (typeof args[ args.length - 1 ] !== 'function') {\n      throw new Error('No callback given for .' + name + '()');\n    }\n    </argumentValidation>\n\n    callback = args.pop();\n\n    <optionHandling>\n    if (typeof args[ args.length - 1 ] === 'object') {\n      options = args.pop();\n    }\n    </optionHandling>\n\n    <pathAdjustment>\n    for (i = 0, diff = expected.length - args.length; i < expected.length; i++) {\n      actual = args.length >= expected.length - i ? args[ i - diff ] : expected[i].assume;\n      \n      if (actual === undefined) {\n        throw new Error('No value given for ' + expected[i].name);\n      }\n      \n      if (expected[i].allowed && !~expected[i].allowed.indexOf(actual)) {\n        throw new Error('Value passed is not one of the following: ' + expected[i].allowed.join(', '));\n      }\n      \n      adjustedPath = adjustedPath.replace(pathArg, actual);\n    }\n    </pathAdjustment>\n\n    <apiRequest>\n    (function gameon(options, callback) {\n      // The API request and response handling code would be here.\n    }(options, callback));\n    </apiRequest>\n\n    return this;\n  };\n}\n"], ["hotspotInitialization", "\nfunction Hotspot(domElement, parentDomElement, view, coords, opts) {\n\n  opts = opts || {};\n  opts.perspective = opts.perspective || {};\n  opts.perspective.extraTransforms =\n      opts.perspective.extraTransforms != null ? opts.perspective.extraTransforms : \"\";\n\n  <browserSupportCheck>\n  if ((opts.perspective.radius || opts.perspective.extraTransforms) && !cssSupported()) {\n    throw new Error('CSS transforms on hotspots are not supported on this browser');\n  }\n  </browserSupportCheck>\n\n  <hotspotProperties>\n  this._domElement = domElement;\n  this._parentDomElement = parentDomElement;\n  this._view = view;\n  this._coords = {};\n  this._perspective = {};\n\n  this.setPosition(coords);\n  </hotspotProperties>\n\n  <domAttachment>\n  this._parentDomElement.appendChild(this._domElement);\n  </domAttachment>\n\n  <perspectiveSetup>\n  this.setPerspective(opts.perspective);\n  </perspectiveSetup>\n\n  <visibilityState>\n  this._visible = true;\n  </visibilityState>\n\n  <positionBias>\n  this._position = { x: 0, y: 0 };\n  </positionBias>\n}\n"], ["splineSmoothing", "\nfunction (segment, point, i) {\n    var smoothing = 1.5, \n        denom = smoothing + 1,\n        plotX = point.plotX,\n        plotY = point.plotY,\n        lastPoint = segment[i - 1],\n        nextPoint = segment[i + 1],\n        leftContX,\n        leftContY,\n        rightContX,\n        rightContY,\n        ret;\n\n    <controlPointCalculation>\n    if (i && i < segment.length - 1) {\n        var lastX = lastPoint.plotX,\n            lastY = lastPoint.plotY,\n            nextX = nextPoint.plotX,\n            nextY = nextPoint.plotY,\n            correction;\n\n        leftContX = (smoothing * plotX + lastX) / denom;\n        leftContY = (smoothing * plotY + lastY) / denom;\n        rightContX = (smoothing * plotX + nextX) / denom;\n        rightContY = (smoothing * plotY + nextY) / denom;\n\n        correction = ((rightContY - leftContY) * (rightContX - plotX)) /\n            (rightContX - leftContX) + plotY - rightContY;\n\n        leftContY += correction;\n        rightContY += correction;\n\n        if (leftContY > lastY && leftContY > plotY) {\n            leftContY = mathMax(lastY, plotY);\n            rightContY = 2 * plotY - leftContY; \n        } else if (leftContY < lastY && leftContY < plotY) {\n            leftContY = mathMin(lastY, plotY);\n            rightContY = 2 * plotY - leftContY;\n        }\n        if (rightContY > nextY && rightContY > plotY) {\n            rightContY = mathMax(nextY, plotY);\n            leftContY = 2 * plotY - rightContY;\n        } else if (rightContY < nextY && rightContY < plotY) {\n            rightContY = mathMin(nextY, plotY);\n            leftContY = 2 * plotY - rightContY;\n        }\n\n        point.rightContX = rightContX;\n        point.rightContY = rightContY;\n    }\n    </controlPointCalculation>\n\n    <pathCommand>\n    if (!i) {\n        ret = [M, plotX, plotY];\n    } else { \n        ret = [\n            'C',\n            lastPoint.rightContX || lastPoint.plotX,\n            lastPoint.rightContY || lastPoint.plotY,\n            leftContX || plotX,\n            leftContY || plotY,\n            plotX,\n            plotY\n        ];\n        lastPoint.rightContX = lastPoint.rightContY = null; \n    }\n    </pathCommand>\n    return ret;\n}\n"], ["bufferExtensions", "\nfunction (module, exports, __webpack_require__) {\n\n  \"use strict\";\n\n  var $export = __webpack_require__(0);\n  var $typed = __webpack_require__(61);\n  var buffer = __webpack_require__(90);\n  var anObject = __webpack_require__(1);\n  var toAbsoluteIndex = __webpack_require__(35);\n  var toLength = __webpack_require__(8);\n  var isObject = __webpack_require__(4);\n  var ArrayBuffer = __webpack_require__(2).ArrayBuffer;\n  var speciesConstructor = __webpack_require__(59);\n  var $ArrayBuffer = buffer.ArrayBuffer;\n  var $DataView = buffer.DataView;\n  var $isView = $typed.ABV && ArrayBuffer.isView;\n  var $slice = $ArrayBuffer.prototype.slice;\n  var VIEW = $typed.VIEW;\n  var ARRAY_BUFFER = 'ArrayBuffer';\n\n  <arrayBufferExtension>\n  $export($export.G + $export.W + $export.F * (ArrayBuffer !== $ArrayBuffer), { ArrayBuffer: $ArrayBuffer });\n  </arrayBufferExtension>\n\n  <arrayBufferUtil>\n  $export($export.S + $export.F * !$typed.CONSTR, ARRAY_BUFFER, {\n    isView: function isView(it) {\n      return $isView && $isView(it) || isObject(it) && VIEW in it;\n    }\n  });\n\n  $export($export.P + $export.U + $export.F * __webpack_require__(3)(function () {\n    return !new $ArrayBuffer(2).slice(1, undefined).byteLength;\n  }), ARRAY_BUFFER, {\n    slice: function slice(start, end) {\n      if ($slice !== undefined && end === undefined) return $slice.call(anObject(this), start); \n      var len = anObject(this).byteLength;\n      var first = toAbsoluteIndex(start, len);\n      var final = toAbsoluteIndex(end === undefined ? len : end, len);\n      var result = new (speciesConstructor(this, $ArrayBuffer))(toLength(final - first));\n      var viewS = new $DataView(this);\n      var viewT = new $DataView(result);\n      var index = 0;\n      while (first < final) {\n        viewT.setUint8(index++, viewS.getUint8(first++));\n      } return result;\n    }\n  });\n  </arrayBufferUtil>\n\n  <speciesSymbolSupport>\n  __webpack_require__(38)(ARRAY_BUFFER);\n  </speciesSymbolSupport>\n}\n"], "```"]