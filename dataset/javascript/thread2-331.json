[["createCloneOfSegments", "\nfunction() {\n    var segments = this.segments;\n    var numSegments = segments.length;\n    \n    var path = new Path();\n    for (var i = 0; i < numSegments; i++) {\n        var segment = segments[i].clone();\n        path.appendSegment(segment);\n    }\n\n    return path;\n}\n"], ["panMapWhenInputsChange", "\nfunction panMapWhenInputsChange() {\n    var lat = document.getElementById(options.latId);\n    var lng = document.getElementById(options.lngId);\n\n    <panIfValue>\n    function panIfValue() {\n        if(lat.value && lng.value) {\n            options.panMap(lat.value, lng.value);\n        };\n    }\n    </panIfValue>\n\n    $(lat).change(panIfValue);\n    $(lng).change(panIfValue);\n}\n"], ["initializeCollator", "\nfunction(locale) {\n    this.intCol = (Intl && Intl.Collator) ? new Intl.Collator(locale) : new CollatorPolyfill(locale);\n}\n"], ["setUpTransition", "\nfunction(handleObj) {\n    var el = $(this);\n    var fired = false;\n\n    <markElementForTransition>\n    el.data(\"trend\", true);\n    </markElementForTransition>\n\n    <calculateTransitionTime>\n    var time =\n        parseProperties(el, transitionDurationProperties) +\n        parseProperties(el, transitionDelayProperties) +\n        20;\n    </calculateTransitionTime>\n\n    <transitionCallback>\n    var cb = function(e) {\n        if (fired) return;\n        if (e && e.srcElement !== el[0]) return;\n\n        el.data(\"trend\", false);\n\n        fired = true;\n        if (handleObj.handler) handleObj.handler();\n    };\n    </transitionCallback>\n\n    el.one(transitionEndEvents, cb);\n    el.data(\"trend-timeout\", window.setTimeout(cb, time));\n}\n"], ["processStylesheet", "\nfunction (stylesheet) {\n    var sheetMedia = stylesheet.media && stylesheet.media.mediaText;\n    var sheetHost;\n\n    <checkCrossDomain>\n    if (objectFit.disableCrossDomain == 'true') {\n        sheetHost = getCSSHost(stylesheet.href);\n\n        if ((sheetHost !== window.location.host)) {\n            return [];\n        }\n    }\n    </checkCrossDomain>\n\n    <checkMediaQueries>\n    if (stylesheet.disabled) {\n        return [];\n    }\n\n    if (!window.matchMedia) {\n        if (sheetMedia && sheetMedia.length) {\n            return [];\n        }\n    }\n    else if (sheetMedia && sheetMedia.length && !window.matchMedia(sheetMedia).matches) {\n        return [];\n    }\n    </checkMediaQueries>\n\n    <getCssRulesAsArray>\n    return toArray(stylesheet.cssRules);\n    </getCssRulesAsArray>\n}\n"], ["addLineHints", "\nfunction addLineHints(name, content) {\n    <addHintsToLines>\n    var i = -1, lines = content.split('\\n'), len = lines.length, out = [];\n    while (++i < len) {\n        out.push(lines[i] +\n            ((i % 10 === 9) ? '/* Line ' + (i + 1) + ' End */' : ''));\n    }\n    </addHintsToLines>\n    return out.join('\\n');\n}\n"], ["validateOAuthTokens", "\nfunction (req, res) {\n    var oauthQueryStateToken = req.query.state;\n    var oauthCookieStateToken = req.cookies.oauthStateToken;\n\n    <compareTokens>\n    if (!oauthQueryStateToken || (!oauthCookieStateToken)) {\n        return false;\n    } else if (oauthQueryStateToken !== oauthCookieStateToken) {\n        return false;\n    }\n    </compareTokens>\n\n    <clearCookie>\n    res.clearCookie('oauthStateToken');\n    </clearCookie>\n\n    return true;\n}\n"], ["wrapStreams", "\nfunction wrapStreams () {\n    <wrapEachStream>\n    for (let stream of arguments) {\n        <initializeStreamText>\n        stream.textContent = \"\";\n        </initializeStreamText>\n\n        <setStreamEncoding>\n        stream.setEncoding(\"utf-8\");\n        </setStreamEncoding>\n\n        <handleStreamData>\n        stream.on(\"data\", (data) => { stream.textContent += data; });\n        </handleStreamData>\n    }\n    </wrapEachStream>\n}\n"], ["applyDeltaActions", "\nfunction applyDeltaActions(node, oldLocalNode, callback) {\n    var newParentPath;\n    var actions = node.actions;\n    var id = node.id;\n\n    <calculateNewParentPath>\n    if (actions.create) newParentPath = utility.getParentFromPath(actions.create.path);\n    </calculateNewParentPath>\n\n    <handleOldLocalNode>\n    if (oldLocalNode && actions.create) {/*...*/}\n    else if (oldLocalNode && actions.delete) {/*...*/}\n    else if (!oldLocalNode && actions.create) {/*...*/}\n    else {/*...*/}\n    </handleOldLocalNode>\n\n    <updateOrCreateNodes>\n    if (oldLocalNode && actions.create) {/*...*/}\n    else if (oldLocalNode && actions.delete) {/*...*/}\n    else if (!oldLocalNode && actions.create) {/*...*/}\n    </updateOrCreateNodes>\n\n    <callbackWithoutAction>\n    if (!oldLocalNode && !actions.create && !actions.delete) {\n        callback(null);\n    }\n    </callbackWithoutAction>\n}\n"], ["reverseArrayLike", "\nfunction reverse(arrayLike) {\n    <getArrayLength>\n    var len = _toArrayLength(arrayLike.length);\n    </getArrayLength>\n\n    <initializeResultArray>\n    var result = Array(len);\n    </initializeResultArray>\n\n    <reverseElements>\n    for (var i = 0, ofs = len - 1; i < len; i++) {\n        result[i] = arrayLike[ofs - i];\n    }\n    </reverseElements>\n\n    return result;\n}\n"], "```\n\nIn the `applyDeltaActions` function, actions such as comparing new and old parent paths, handling the old local node's existing data alongside actions like create and delete, updating or creating new nodes, and the callback without action are collectively annotated as `<handleOldLocalNode>` and `<updateOrCreateNodes>` due to their intimate relation with handling node updates based on a delta. However, the final `<callbackWithoutAction>` is isolated as it represents a separate branch where no action is being applied at all and the function is simply exiting with a callback."]