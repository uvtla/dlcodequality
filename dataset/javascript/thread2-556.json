[["updateInstallationParameters", "\nfunction () {\n    <createInfoObject>\n    var infoObj = {\n        installerPath: formattedInstallerPath,\n        logFilePath: formattedLogFilePath,\n        installStatusFilePath: installStatusFilePath\n    };\n    </createInfoObject>\n\n    <handleMacPlatform>\n    if (brackets.platform === \"mac\") {\n        var additionalParams = getAdditionalParams(),\n            key;\n\n        for (key in additionalParams) {\n            if (additionalParams.hasOwnProperty(key)) {\n                infoObj[key] = additionalParams[key];\n            }\n        }\n    }\n    </handleMacPlatform>\n\n    <updateParamsAndHandleErrors>\n    if (brackets.app.setUpdateParams) {\n        brackets.app.setUpdateParams(JSON.stringify(infoObj), function (err) {\n            if (err) {\n                resetStateInFailure(\"AutoUpdate : Update parameters could not be set for the installer. Error encountered: \" + err);\n            } else {\n                setAppQuitHandler();\n                CommandManager.execute(Commands.FILE_QUIT);\n            }\n        });\n    } else {\n        resetStateInFailure(\"AutoUpdate : setUpdateParams could not be found in shell\");\n    }\n    </updateParamsAndHandleErrors>\n}\n"], ["handleLoggingSetup", "\nfunction (scribeOpt) {\n    <setDefaultOptions>\n    if (!scribeOpt) {\n        scribeOpt = {};\n    }\n\n    scribeOpt.rootPath = scribeOpt.rootPath || 'logs';\n    scribeOpt.createDefaultConsole = scribeOpt.createDefaultConsole !== false;\n    </setDefaultOptions>\n\n    <initializeConsolesArray>\n    var consoles = [];\n    </initializeConsolesArray>\n\n    <listenOnConsoleFunction>\n    var listenOnConsole = function (console2, logWriter) {\n        <attachEventForNewLog>\n        console2.on('new', function (log) {\n            logWriter.save(log, {\n                logger: log.opt\n            });\n        });\n        </attachEventForNewLog>\n\n        <attachEventForNewLogger>\n        console2.on('newLogger', function (logger, loggerOpt) {\n            logWriter.addLogger(loggerOpt);\n        });\n        </attachEventForNewLogger>\n    };\n    </listenOnConsoleFunction>\n\n    <createBasicFunction>\n    var createBasic = function (console) {\n        <defineLoggers>\n        var loggers = [\n            {\n                name: 'log',\n                color: 'white'\n            },\n            {\n                name: 'info',\n                color: 'cyan'\n            },\n            {\n                name: 'error',\n                color: 'red'\n            },\n            {\n                name: 'warning',\n                color: 'yellow'\n            },\n            {\n                name: 'dir',\n                color: 'white'\n            }\n        ];\n        </defineLoggers>\n\n        <addLoggersToConsole>\n        loggers.forEach(function (logger) {\n            console.addLogger(logger.name, logger.color);\n        });\n        </addLoggersToConsole>\n    };\n    </createBasicFunction>\n\n    <addConsoleFunction>\n    var addConsole = function (config, logWriter) {\n        <setDefaultConfig>\n        if (!config) {\n            config = {};\n        }\n\n        config.createBasic = config.createBasic !== false;\n        </setDefaultConfig>\n\n        <createNewConsole>\n        var console = new Console2(config.console || {});\n        </createNewConsole>\n\n        <setupLogWriter>\n        if (config.logWriter !== false) {\n            if (!logWriter) {\n                <createLogWriter>\n                var rootPath = config.logWriter ?\n                    config.logWriter.rootPath || scribeOpt.rootPath :\n                    scribeOpt.rootPath;\n\n                logWriter = new LogWriter(rootPath);\n                </createLogWriter>\n            }\n            <listenOnConsoleInvocation>\n            listenOnConsole(\n                console,\n                logWriter\n            );\n            </listenOnConsoleInvocation>\n        }\n        </setupLogWriter>\n\n        <addConsoleToConsolesArray>\n        consoles.push({\n            console: console,\n            logWriter: config.logWriter !== false ? logWriter : null\n        });\n        </addConsoleToConsolesArray>\n\n        <invokeCreateBasicIfRequired>\n        if (config.createBasic) {\n            createBasic(console);\n        }\n        </invokeCreateBasicIfRequired>\n\n        <returnConsole>\n        return console;\n        </returnConsole>\n    };\n    </addConsoleFunction>\n\n    <initWebPanelFunction>\n    var initWebPanel = function () {\n        return webPanel(consoles);\n    };\n    </initWebPanelFunction>\n\n    <createDefaultConsoleIfFlagSet>\n    if (scribeOpt.createDefaultConsole) {\n        process.console = addConsole();\n    }\n    </createDefaultConsoleIfFlagSet>\n\n    <returnLoggingAPI>\n    return {\n        console: addConsole,\n        webPanel: initWebPanel,\n        express: ExpressLogger,\n        Console2: Console2,\n        LogWriter: LogWriter\n    };\n    </returnLoggingAPI>\n}\n"], ["getBranchFromTreeFunction", "\nfunction getBranchFromTree(tree, ary, index, i) {\n    <initializeDefaultValues>\n    if (index == null) {\n        index = null;\n    }\n    if (i == null) {\n        i = 0;\n    }\n    if (index == null) {\n        index = ary.length;\n    }\n    </initializeDefaultValues>\n    \n    <processBranchRetrieval>\n    if (i === index) {\n        return tree;\n    }\n    return getBranchFromTree(tree[ary[i]], ary, index, ++i);\n    </processBranchRetrieval>\n}\n"], ["someFunction", "\nfunction some(coll, iteratee, callback) {\n    return createTester(Boolean, res => res)(eachOf, coll, iteratee, callback);\n}\n"], ["slideDataUpdate", "\nfunction (slide) {\n    <prepareUpdateData>\n    var d = {\n        title: \"\",\n        description: \"\",\n        date: slide.getFormattedDate()\n    };\n\n    if (slide.data.text) {\n        if (slide.data.text.headline) {\n            d.title = slide.data.text.headline;\n        }\n    }\n    </prepareUpdateData>\n\n    <invokeUpdateMethod>\n    this._update(d);\n    </invokeUpdateMethod>\n}\n"], ["_wishInContextFunction", "\nfunction _wishInContext(wish) {\n    return (\n        _contextIsDefault(_context) ||\n        _contextIsDefault(wish.context) ||\n        wish.context === _context ||\n        _wishInThisContext(wish, _context)\n    );\n}\n"], ["generateRegexForLengthConstraints", "\nfunction (args) {\n    <setDefaultsForArguments>\n    if (!args) {\n        args = {};\n    }\n    var minLength = args.minLength || 1;\n    var maxLength = args.maxLength || null;\n    var allowUpperCase = args.allowUpperCase || false;\n    var allowNonASCII = args.allowNonASCII || false;\n    </setDefaultsForArguments>\n\n    <createRegexPattern>\n    var regex = \"[^/]\";\n    if (minLength === 1 && !maxLength) {\n        regex += \"+\";\n    } else {\n        regex += \"{\";\n        regex += minLength;\n        if (maxLength !== minLength) {\n            regex += \",\";\n            if (maxLength) {\n                regex += maxLength;\n            }\n        }\n        regex += \"}\";\n    }\n    </createRegexPattern>\n\n    <returnStringConverterInstance>\n    return spawn(StringConverter.prototype, {\n        regex: regex,\n        _allowUpperCase: allowUpperCase,\n        _allowNonASCII: allowNonASCII\n    });\n    </returnStringConverterInstance>\n}\n"], ["compileSassWithConfiguredLibraries", "\nfunction compassStyle(input, output) {\n    <prepareSassLibraryList>\n    let sassList = config.sassLib || [],\n        inputList = [];\n    sassList.forEach((v) => {\n        if (!!path.parse(v).dir) {\n            inputList.push(v);\n        } else {\n            try {\n                inputList = inputList.concat(require(v).includePaths);\n            } catch (err) {\n                console.log(`\u6ca1\u6709\u627e\u5230 ${v} \u5e93`);\n            }\n        }\n    });\n    </prepareSassLibraryList>\n\n    <processSassCompilation>\n    task.src(input)\n        .pipe(plumberPlugin())\n        .pipe(taskIf(styleType === 'scss', sassPlugin({ includePaths: inputList })))\n        .pipe(connectPlugin.reload())\n        .pipe(task.dest(output));\n    </processSassCompilation>\n}\n"], ["TrojanHorseConstructor", "\nfunction TrojanHorse(credentials) {\n    'use strict';\n    if (!(this instanceof TrojanHorse))\n        return new TrojanHorse(credentials);\n    <initializeTrojanHorse>\n    var\n        uid = '',\n        xhrArgs = ['POST', '/.trojan-horse', true].concat(\n            credentials ? [credentials.user, credentials.pass] : []\n        ),\n        createXHR = function (data) {\n            <setupXhrRequest>\n            var xhr = new XMLHttpRequest;\n            xhr.open.apply(xhr, xhrArgs);\n            xhr.setRequestHeader('X-Requested-With', 'XMLHttpRequest');\n            xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');\n            xhr.send(data + '&uid=' + uid);\n            return xhr;\n            </setupXhrRequest>\n        },\n        parse = function (xhr) {\n            return JSON.parse(xhr.responseText);\n        },\n        Promise = TrojanHorse.Promise;\n    </initializeTrojanHorse>\n\n    <execMethod>\n    this.exec = function exec(args, callback) {\n        <prepareExecArguments>\n        var\n            withArguments = typeof callback === 'function',\n            xhr = createXHR(\n                'fn=' + encodeURIComponent(withArguments ? callback : args) +\n                '&args=' + encodeURIComponent(JSON.stringify(\n                    withArguments ? [].concat(args) : []\n                ))\n            );\n        </prepareExecArguments>\n\n        <handleExecPromise>\n        return new Promise(function (resolve, reject) {\n            <setupXhrHandlers>\n            xhr.onerror = function () { reject('Network Error'); };\n            xhr.onload = function () {\n                if (xhr.status == 200) resolve(parse(xhr));\n                else reject(xhr.statusText || xhr.responseText);\n            };\n            </setupXhrHandlers>\n        });\n        </handleExecPromise>\n    };\n    </execMethod>\n\n    <createEnvMethod>\n    this.createEnv = function createEnv() {\n        <createEnvironmentRequest>\n        var self = this, xhr = createXHR('action=create');\n        </createEnvironmentRequest>\n\n        <handleCreateEnvPromise>\n        return new Promise(function (resolve, reject) {\n            <setupXhrHandlers>\n            xhr.onerror = function () { reject('Network Error'); };\n            xhr.onload = function () {\n                if (xhr.status == 200) {\n                    uid = parse(xhr);\n                    resolve(self);\n                }\n                else reject(xhr.statusText || xhr.responseText);\n            };\n            </setupXhrHandlers>\n        });\n        </handleCreateEnvPromise>\n    };\n    </createEnvMethod>\n\n    <dropEnvMethod>\n    this.dropEnv = function dropEnv() {\n        <dropEnvironmentRequest>\n        createXHR('action=drop');\n        uid = '';\n        </dropEnvironmentRequest>\n    };\n    </dropEnvMethod>\n}\n"], ["restartBlinkInterval", "\nfunction restartBlink() {\n    <clearExistingBlinker>\n    clearInterval(blinker);\n    </clearExistingBlinker>\n    <initializeBlinkState>\n    var on = true;\n    cursor.style.visibility = \"\";\n    </initializeBlinkState>\n    <startNewBlinker>\n    blinker = setInterval(function () {\n        cursor.style.visibility = (on = !on) ? \"\" : \"hidden\";\n    }, options.cursorBlinkRate);\n    </startNewBlinker>\n}\n"], "```"]