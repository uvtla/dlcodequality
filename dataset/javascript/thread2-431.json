[["validatePassword", "\nfunction() {\n    <checkConfirmPasswordField>\n    if(this.options.confirmPasswordField) {\n        if(this.options.confirmPasswordField.getValue() != this.getValue() ) {\n            return false;\n        }\n    }\n    </checkConfirmPasswordField>\n    return inputEx.PasswordField.superclass.validate.call(this);\n}\n"], ["calculateControlPoints", "\nfunction(knots) {\n    console.warn('deprecated');\n\n    var firstControlPoints = [];\n    var secondControlPoints = [];\n    var n = knots.length - 1;\n    var i;\n\n    <handleSpecialCase>\n    if (n == 1) {\n        firstControlPoints[0] = new Point(\n            (2 * knots[0].x + knots[1].x) / 3,\n            (2 * knots[0].y + knots[1].y) / 3\n        );\n        secondControlPoints[0] = new Point(\n            2 * firstControlPoints[0].x - knots[0].x,\n            2 * firstControlPoints[0].y - knots[0].y\n        );\n        return [firstControlPoints, secondControlPoints];\n    }\n    </handleSpecialCase>\n\n    var rhs = [];\n\n    <calculateRHS_X>\n    for (i = 1; i < n - 1; i++) {\n        rhs[i] = 4 * knots[i].x + 2 * knots[i + 1].x;\n    }\n    rhs[0] = knots[0].x + 2 * knots[1].x;\n    rhs[n - 1] = (8 * knots[n - 1].x + knots[n].x) / 2.0;\n    var x = this.getFirstControlPoints(rhs);\n    </calculateRHS_X>\n\n    <calculateRHS_Y>\n    for (i = 1; i < n - 1; ++i) {\n        rhs[i] = 4 * knots[i].y + 2 * knots[i + 1].y;\n    }\n    rhs[0] = knots[0].y + 2 * knots[1].y;\n    rhs[n - 1] = (8 * knots[n - 1].y + knots[n].y) / 2.0;\n    var y = this.getFirstControlPoints(rhs);\n    </calculateRHS_Y>\n\n    <assembleControlPoints>\n    for (i = 0; i < n; i++) {\n        firstControlPoints.push(new Point(x[i], y[i]));\n        if (i < n - 1) {\n            secondControlPoints.push(new Point(\n                2 * knots [i + 1].x - x[i + 1],\n                2 * knots[i + 1].y - y[i + 1]\n            ));\n        } else {\n            secondControlPoints.push(new Point(\n                (knots[n].x + x[n - 1]) / 2,\n                (knots[n].y + y[n - 1]) / 2)\n            );\n        }\n    }\n    </assembleControlPoints>\n\n    return [firstControlPoints, secondControlPoints];\n}\n"], ["filterHeaders", "\nfunction filterSensitiveHeaders(headers, sensitiveKeys) {\n    try {\n        const retval = {};\n        <iterateHeaders>\n        for (const key in headers) {\n            if (sensitiveKeys.findIndex(item => key.toLowerCase() === item.toLowerCase()) === -1) {\n                retval[key] = headers[key];\n            }\n        }\n        </iterateHeaders>\n        return retval;\n    } catch(e) {\n        return headers;\n    }\n}\n"], ["verifyDataSources", "\nfunction verifyDataSources(formDataSourceIds, cb) {\n    findMatchingDocuments(models.MODELNAMES.DATA_SOURCE, formDataSourceIds, dataSourceModel, cb);\n}\n"], ["sendWebSocketMessage", "\nfunction notifyWebSocket(message) {\n    if (!webSocketServer || !message)\n        return;\n\n    <iterateConnections>\n    for (var value in webSocketServer.conn) {\n        var connection = webSocketServer.conn[value];\n        if (connection)\n            connection.send(message)\n    }\n    </iterateConnections>\n}\n"], ["initializeHydroInstance", "\nfunction Hydro() {\n    if (!(this instanceof Hydro)) {\n        return new Hydro();\n    }\n\n    this.loader = loader;\n    this.plugins = [];\n    this.emitter = new EventEmitter;\n    this.runner = new Runner;\n    this.frame = new Frame(this.runner.topLevel);\n    this.interface = new Interface(this, this.frame);\n    this.config = new Config;\n}\n"], ["performSIFTAlgorithm", "\nfunction SIFT( s1, s2, options ) {\n    \n    options = options != null ?\n        options : {}\n\n    var maxDistance = options.maxDistance\n    var maxOffset   = options.maxOffset || SIFT.maxOffset\n    var tokenize    = options.tokenizer || SIFT.tokenizer\n    var match       = options.tokenMatcher || SIFT.tokenMatcher\n    var evalMatch   = options.matchEvaluator || SIFT.matchEvaluator\n    var evalLength  = options.lengthEvaluator || SIFT.lengthEvaluator\n    var evalTrans   = options.transpositionEvaluator || SIFT.transpositionEvaluator\n    \n    var t1 = tokenize( s1 )\n    var t2 = tokenize( s2 )\n    \n    var tl1 = t1.length\n    var tl2 = t2.length\n    \n    if( tl1 === 0 ) return evalLength( tl2 )\n    if( tl2 === 0 ) return evalLength( tl1 )\n    \n    \n    var c1 = 0\n    var c2 = 0\n    \n    var lcss = 0\n    \n    var lcs = 0\n    \n    var trans = 0\n    \n    var offsets = []\n    \n    <performComparisonAndOffsetAdjustment>\n    while( ( c1 < tl1 ) && ( c2 < tl2 ) ) {\n        if( match( t1[c1], t2[c2] ) ) {\n            lcs = lcs + evalMatch( t1[c1], t2[c2] )\n            while( offsets.length ) {\n                if( c1 <= offsets[0][0] || c2 <= offsets[0][1] ) {\n                    trans++\n                    break\n                } else {\n                    offsets.shift()\n                }\n            }\n            offsets.push( [ c1, c2 ] )\n        } else {\n            lcss = lcss + evalLength( lcs )\n            lcs = 0\n            if( c1 !== c2 ) {\n                c1 = c2 = Math.min( c1, c2 )\n            }\n            for( var i = 0; i < maxOffset; i++ ) {\n                if( ( c1 + i < tl1 ) && match( t1[c1+i], t2[c2] ) ) {\n                    c1 = c1 + i - 1\n                    c2 = c2 - 1\n                    break\n                }\n                if( ( c2 + i < tl2 ) && match( t1[c1], t2[c2+i] ) ) {\n                    c1 = c1 - 1\n                    c2 = c2 + i - 1\n                    break\n                }\n            }\n        }\n        \n        c1++\n        c2++\n        \n        if( maxDistance ) {\n            var distance = evalLength( Math.max( c1, c2 ) ) - evalTrans( lcss, trans )\n            if( distance >= maxDistance ) return Math.round( distance )\n        }\n        \n    }\n    </performComparisonAndOffsetAdjustment>\n    \n    lcss = lcss + evalLength( lcs )\n    \n    return Math.round(\n        evalLength( Math.max( tl1, tl2 ) ) -\n        evalTrans( lcss, trans )\n    )\n    \n}\n"], ["findIndentationStartPunctuator", "\nfunction findIndentationStartPunctuator(evaluate) {\n                const searchIndex = evaluate.code.search(/(\\S)\\s*$/u)\n                if (searchIndex < 0) {\n                    return null\n                }\n                const charIndex =\n                    evaluate.expressionStart.range[1] + searchIndex\n                const node = sourceCode.getNodeByRangeIndex(charIndex)\n                if (!node) {\n                    \n                    return null\n                }\n                const tokens = sourceCode\n                    .getTokens(node)\n                    .filter(\n                        t =>\n                            t.range[0] <= evaluate.range[1] &&\n                            t.range[1] >= evaluate.range[0]\n                    )\n\n                let targetToken = tokens.find(\n                    t => t.range[0] <= charIndex && charIndex < t.range[1]\n                )\n                if (!targetToken) {\n                    targetToken = tokens\n                        .reverse()\n                        .find(t => t.range[1] <= charIndex)\n                }\n                let token = targetToken\n                <handleIndentationDetermination>\n                while (token) {\n                    if (\n                        token.range[0] > evaluate.range[1] ||\n                        token.range[1] < evaluate.range[0]\n                    ) {\n                        return null\n                    }\n                    if (isIndentationStartPunctuator(token)) {\n                        return token\n                    }\n                    if (isIndentationEndPunctuator(token)) {\n                        \n                        const next = findPairOpenPunctuator(token)\n                        token = sourceCode.getTokenBefore(next)\n                        continue\n                    }\n\n                    token = sourceCode.getTokenBefore(token)\n                }\n                </handleIndentationDetermination>\n\n                return null\n            }\n"], ["modifyURLParameters", "\nfunction addParas (src, paraName, paraVal) {\n  let paraNameQ = new RegExp('\\\\$?{' + paraName + '}', 'g')\n  <updateURLIfPlaceholderExists>\n  if (src.search(paraNameQ) > -1) {\n    return src.replace(paraNameQ, paraVal)\n  }\n  </updateURLIfPlaceholderExists>\n  <appendParameter>\n  src += src.indexOf('?') > -1 ? '&' : '?'\n  paraName = DEFAULT_PARAMS[paraName] ||  paraName\n  return src + paraName + '=' + paraVal\n  </appendParameter>\n}\n"], ["updateGeometry", "\nfunction() {\n        var angle, point;\n        var ring = this.feature.geometry.components[0];\n        \n        <handleGeometryRecreation>\n        if(ring.components.length != (this.sides + 1)) {\n            this.createGeometry();\n            ring = this.feature.geometry.components[0];\n        }\n        </handleGeometryRecreation>\n        <updateVertices>\n        for(var i=0; i<this.sides; ++i) {\n            point = ring.components[i];\n            angle = this.angle + (i * 2 * Math.PI / this.sides);\n            point.x = this.origin.x + (this.radius * Math.cos(angle));\n            point.y = this.origin.y + (this.radius * Math.sin(angle));\n            point.clearBounds();\n        }\n        </updateVertices>\n    }\n"], "```"]