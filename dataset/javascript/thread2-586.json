[["buildMap", "\nfunction buildMap(map, part) {\n    <makeName>\n    var name = makeName(part.fileName);\n    </makeName>\n\n    <updateMap>\n    if (map[name]) {\n        map[name].parts.push(part);\n    } else {\n        map[name] = {\n            name: name,\n            parts: [part],\n        };\n    }\n    </updateMap>\n\n    return map;\n}\n"], ["buildPaths", "\nfunction buildPaths(initialPaths, optionPaths) {\n    <initializePaths>\n    const paths = Array.isArray(initialPaths) ? initialPaths : [initialPaths]\n    </initializePaths>\n\n    <concatenatePaths>\n    if (_.isString(optionPaths)) {\n        paths.push(optionPaths)\n    } else if (Array.isArray(optionPaths)) {\n        paths.push(...optionPaths)\n    }\n    </concatenatePaths>\n\n    return paths\n}\n"], ["init", "\nfunction init() {\n    <domManipulation>\n    <computeScrollProperties>\n    if ($el.hasClass('horizontal')) {\n        scrollDirection = 'horiz';\n        scrollOffsetAttr = 'scrollLeft';\n        sizeAttr = 'width';\n        offsetAttr = 'left';\n    }\n    </computeScrollProperties>\n\n    <insertScrollbar>\n    $el.prepend('<div class=\"tse-scrollbar\"><div class=\"drag-handle\"></div></div>');\n    $scrollbarEl = $el.find('.tse-scrollbar');\n    $dragHandleEl = $el.find('.drag-handle');\n    </insertScrollbar>\n\n    <wrapContent>\n    if (options.wrapContent) {\n        $contentEl.wrap('<div class=\"tse-scroll-content\" />');\n    }\n    $scrollContentEl = $el.find('.tse-scroll-content');\n    </wrapContent>\n    \n    resizeScrollContent();\n    </domManipulation>\n\n    <eventHandlers>\n    if (options.autoHide) {\n        $el.on('mouseenter', flashScrollbar);\n    }\n\n    $dragHandleEl.on('mousedown', startDrag);\n    $scrollbarEl.on('mousedown', jumpScroll);\n    $scrollContentEl.on('scroll', onScrolled);\n    </eventHandlers>\n\n    resizeScrollbar();\n\n    <windowResizeHandler>\n    $(window).on('resize', function() {\n        recalculate();\n    });\n    </windowResizeHandler>\n\n    <scrollbarVisibility>\n    if (!options.autoHide) {\n        showScrollbar();\n    }\n    </scrollbarVisibility>\n}\n"], ["unknownFunction", "\nfunction(state, node) {\n"], ["decompressOutput", "\nfunction decompressOutput(output, br) {\n    output.value = br.readVarint();\n    <decompressScriptWrapper>\n    decompressScript(output.script, br);\n    </decompressScriptWrapper>\n    return output;\n}\n"], ["modifyConfig", "\nfunction(o) {\n"], ["removeListeners", "\nfunction(type, checks) {\n    var handler = checks[0],\n        global = checks[1];\n    if (global) {\n        this.removeGlobal(type, handler);\n    } else {\n        this.remove(type, handler);\n    }\n}\n"], ["write", "\nfunction write(arr, str, range) {\n    const offset = range[0];\n    arr[offset] = str;\n    for (let i = offset + 1; i < range[1]; i++) {\n        arr[i] = undefined;\n    }\n}\n"], ["enforce", "\nfunction enforce(opts = {}) {\n    var optional = opts.optional || false\n    var range = opts.range\n    var whichExec = opts.which\n    var packageName = opts.packageName || opts.which\n    var versionCommand = opts.versionCommand\n    var installMessage = opts.installMessage\n    var versionMatcher = opts.versionMatcher || defaultVersionMatcher\n\n    <printNotMetMessage>\n    function printNotMetMessage(installedVersion) {\n        console.log('Ignite CLI requires ' + packageName + ' ' + range + ' to be installed.')\n        if (installedVersion) {\n            console.log('')\n            console.log('You currently have ' + installedVersion + ' installed.')\n        }\n        console.log('')\n        console.log(installMessage)\n    }\n    </printNotMetMessage>\n\n    <getVersion>\n    function getVersion() {\n        try {\n            var resolvedPath = which.sync(whichExec)\n            var result = shell.exec(`\"${resolvedPath}\" ${versionCommand}`, { silent: true })\n            var rawOut = ramda.trim(result.stdout || '')\n            var rawErr = ramda.trim(result.stderr || '') \n            var raw = rawOut\n            if (ramda.isEmpty(raw)) {\n                raw = rawErr\n            }\n            if (ramda.isEmpty(raw)) {\n                raw = null\n            }\n            return versionMatcher(raw)\n        } catch (err) {\n            return null\n        }\n    }\n    </getVersion>\n\n    <checkInstallation>\n    var isInstalled = Boolean(shell.which(whichExec))\n\n    if (!isInstalled) {\n        if (optional) {\n            return true\n        } else {\n            printNotMetMessage()\n            return false\n        }\n    }\n    </checkInstallation>\n\n    <validateVersion>\n    try {\n        var installedVersion = getVersion()\n        var isMet = semver.satisfies(installedVersion, range)\n        if (isMet) return true\n    } catch (err) {\n        printNotMetMessage(installedVersion)\n        return false\n    }\n    </validateVersion>\n}\n"], ["selectorToken", "\nfunction() {\n"], " <---- This function is missing its name and proper closure, making annotation difficult and potentially inaccurate."]