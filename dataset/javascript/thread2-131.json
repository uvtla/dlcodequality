[["sendMessage", "\nfunction sendMessage(e) {\n    <inputAndValidation>\n    var txt = $('#msgtxt').val().trim();\n    if(!txt) return;\n    </inputAndValidation>\n\n    <updateDOM>\n    $('#messages').append(createMsgBox(txt));\n    </updateDOM>\n\n    <networkCommunication>\n    socket.emit('sendmsg', txt, function(evtJson) {\n        var evt = JSON.parse(evtJson),\n        reply = evt['Reply-Text'].split(' '), \n        $elm = $('#messages').children().last().removeClass('sending');\n\n        if(reply[0] == '+OK')\n            $elm.addClass('sent').data('uuid', reply[1]);\n        else\n            $elm.addClass('failed').data('error', evt['Reply-Text']);\n    });\n    </networkCommunication>\n    \n    <clearInput>\n    $('#msgtxt').val('');\n    </clearInput>\n}\n"], ["calculateMatrixAndOffset", "\nfunction calculateMatrixAndOffset({\n  viewport,\n  coordinateSystem,\n  coordinateOrigin,\n  coordinateZoom\n}) {\n  <initializeVariables>\n  const {viewMatrixUncentered} = viewport;\n  let {viewMatrix} = viewport;\n  const {projectionMatrix} = viewport;\n  let {viewProjectionMatrix} = viewport;\n  let projectionCenter;\n  let cameraPosCommon = viewport.cameraPosition;\n  let shaderCoordinateSystem = getShaderCoordinateSystem(coordinateSystem);\n  let shaderCoordinateOrigin = coordinateOrigin;\n  </initializeVariables>\n\n  <calculateShaderCoordinate>\n  if (shaderCoordinateSystem === PROJECT_COORDINATE_SYSTEM.LNGLAT_AUTO_OFFSET) {\n    if (coordinateZoom < LNGLAT_AUTO_OFFSET_ZOOM_THRESHOLD) {\n      shaderCoordinateSystem = PROJECT_COORDINATE_SYSTEM.LNG_LAT;\n    } else {\n      const lng = Math.fround(viewport.longitude);\n      const lat = Math.fround(viewport.latitude);\n      shaderCoordinateOrigin = [lng, lat];\n    }\n  }\n  if (shaderCoordinateSystem === PROJECT_COORDINATE_SYSTEM.IDENTITY) {\n    shaderCoordinateOrigin = [Math.fround(viewport.position[0]), Math.fround(viewport.position[1])];\n  }\n  </calculateShaderCoordinate>\n\n  <applyTransformations>\n  switch (shaderCoordinateSystem) {\n    case PROJECT_COORDINATE_SYSTEM.LNG_LAT:\n      projectionCenter = ZERO_VECTOR;\n      break;\n\n    case PROJECT_COORDINATE_SYSTEM.LNGLAT_OFFSETS:\n    case PROJECT_COORDINATE_SYSTEM.METER_OFFSETS:\n    case PROJECT_COORDINATE_SYSTEM.LNGLAT_AUTO_OFFSET:\n    case PROJECT_COORDINATE_SYSTEM.IDENTITY:\n      <mathematicalTransformations>\n      const positionCommonSpace = viewport.projectPosition(shaderCoordinateOrigin, Math.pow(2, coordinateZoom));\n      cameraPosCommon = [cameraPosCommon[0] - positionCommonSpace[0], cameraPosCommon[1] - positionCommonSpace[1], cameraPosCommon[2]];\n      positionCommonSpace[2] = 0;\n      positionCommonSpace[3] = 1;\n      projectionCenter = vec4.transformMat4([], positionCommonSpace, viewProjectionMatrix);\n      viewMatrix = viewMatrixUncentered || viewMatrix;\n      viewProjectionMatrix = mat4.multiply([], projectionMatrix, viewMatrix);\n      viewProjectionMatrix = mat4.multiply([], viewProjectionMatrix, VECTOR_TO_POINT_MATRIX);\n      </mathematicalTransformations>\n      break;\n\n    default:\n      <errorHandling>\n      throw new Error('Unknown projection mode');\n      </errorHandling>\n  }\n  </applyTransformations>\n\n  <returnResult>\n  return {\n    viewMatrix,\n    viewProjectionMatrix,\n    projectionCenter,\n    cameraPosCommon,\n    shaderCoordinateSystem,\n    shaderCoordinateOrigin\n  };\n  </returnResult>\n}\n"], ["layerViewUpdate", "\nfunction (layerCollection, options) {\n    var self = this;\n\n    var oldLayers = this._layerViews;\n    this._layerViews = {};\n\n    <findLayerView>\n    function findLayerView(layer) {\n      var lv = _.find(oldLayers, function (layerView) {\n        var m = layerView.model;\n        return m.isEqual(layer);\n      });\n      return lv;\n    }\n    </findLayerView>\n\n    <canReused>\n    function canReused(layer) {\n      return self.map.layers.find(function (m) {\n        return m.isEqual(layer);\n      });\n    }\n    </canReused>\n\n    <cleanupOldLayers>\n    for (var layer in oldLayers) {\n      var layerView = oldLayers[layer];\n      if (!canReused(layerView.model)) {\n        layerView.remove();\n      }\n    }\n    </cleanupOldLayers>\n\n    <updateLayers>\n    this.map.layers.each(function (layerModel) {\n      var layerView = findLayerView(layerModel);\n      if (!layerView) {\n        self._addLayer(layerModel, layerCollection, {\n          silent: (options && options.silent) || false,\n          index: options && options.index\n        });\n      } else {\n        layerView.setModel(layerModel);\n        self._layerViews[layerModel.cid] = layerView;\n      }\n    });\n    </updateLayers>\n}\n"], ["TargetFactory", "\nfunction Target(options = {}) {\n    options = clone(options);\n\n    <initializeClientAndRoom>\n    let client = new Hipchatter(options.token);\n    let room = options.room;\n    delete options.token;\n    delete options.room;\n    </initializeClientAndRoom>\n\n    <setNotificationDefaults>\n    let proto = {\n        message_format: 'html',\n        notify: false\n    };\n    for (let key in options) {\n        if (!options.hasOwnProperty(key)) {\n            break;\n        }\n        proto[key] = options[key];\n    }\n    </setNotificationDefaults>\n\n    <returnNotifierFunction>\n    return function(options, severity, date, message) {\n        let payload = clone(proto);\n\n        <setColorBasedOnSeverity>\n        if (typeof payload.color !== 'string') {\n            switch(severity) {\n                case 'info':\n                    payload.color = 'green';\n                    break;\n\n                case 'warn':\n                    payload.color = 'yellow';\n                    break;\n\n                case 'error':\n                    payload.color = 'red';\n                    break;\n\n                default:\n                    payload.color = 'gray';\n                    break;\n            }\n        }\n        </setColorBasedOnSeverity>\n\n        <formatMessage>\n        if (proto.message_format === 'html') {\n            payload.message = escape(message)\n                .replace(/\\n/g, '<br/>')\n                .replace(/\\t/g, '&nbsp;&nbsp;&nbsp;&nbsp;');\n        }\n        else {\n            payload.message = message;\n        }\n        </formatMessage>\n\n        <sendMessageThroughClient>\n        client.notify(room, payload, function(err) {\n            if (err) {\n                console.log(err);\n            }\n        });\n        </sendMessageThroughClient>\n    };\n    </returnNotifierFunction>\n}\n"], ["transformOptions", "\nfunction transformOptions(options) {\n  \n  <adjustTypeOfOptions>\n  if (typeof options.ns === 'string') options.ns = [options.ns];\n  if (typeof options.fallbackLng === 'string') options.fallbackLng = [options.fallbackLng];\n  if (typeof options.fallbackNS === 'string') options.fallbackNS = [options.fallbackNS];\n  </adjustTypeOfOptions>\n\n  <updateWhitelist>\n  if (options.whitelist && options.whitelist.indexOf('cimode') < 0) options.whitelist.push('cimode');\n  </updateWhitelist>\n\n  <returnAdjustedOptions>\n  return options;\n  </returnAdjustedOptions>\n}\n"], ["ignoredForGoodReason", ""], ["ignoredForGoodReason", ""], ["ignoredForGoodReason", ""], ["ignoredForGoodReason", ""], ["ignoredForGoodReason", ""], ""]