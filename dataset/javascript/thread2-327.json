[["csvParsingAndFiltering", "\nfunction (cb) {\n    let vehicles = [];\n\n    const options = { newline: '\\r\\n', columns: true };\n    const parser = csv(options);\n\n    parser.on('data', (line) => {\n        \n        line.year = parseInt(line.year);\n        line['comb08'] = parseInt(line['comb08']);\n\n        \n        let satisfies = true;\n\n        \n        \n        constraints.forEach((constr) => {\n            if (!constr(line)) satisfies = false;\n        });\n\n        \n        \n        if (satisfies) {\n            vehicles.push(line);\n        };\n    });\n\n    parser.on('end', () => {\n        cb(vehicles);\n    });\n\n    fs.createReadStream('./vehicles.csv').pipe(parser)\n}\n"], ["updateSeriesType", "\nfunction (newOptions, redraw) {\n    var series = this,\n        chart = this.chart,\n        \n        \n        oldOptions = this.userOptions,\n        oldType = this.type,\n        proto = seriesTypes[oldType].prototype,\n        preserve = ['group', 'markerGroup', 'dataLabelsGroup'],\n        n;\n\n    \n    each(preserve, function (prop) {\n        preserve[prop] = series[prop];\n        delete series[prop];\n    });\n\n    \n    newOptions = merge(oldOptions, {\n        animation: false,\n        index: this.index,\n        pointStart: this.xData[0]\n    }, { data: this.options.data }, newOptions);\n\n    \n    this.remove(false);\n    for (n in proto) {\n        if (proto.hasOwnProperty(n)) {\n            this[n] = UNDEFINED;\n        }\n    }\n    extend(this, seriesTypes[newOptions.type || oldType].prototype);\n\n    \n    each(preserve, function (prop) {\n        series[prop] = preserve[prop];\n    });\n\n    this.init(chart, newOptions);\n    chart.linkSeries();\n    if (pick(redraw, true)) {\n        chart.redraw(false);\n    }\n}\n"], ["getGitTags", "\nasync function getTags(execaOpts) {\n    return (await execa.stdout('git', ['tag'], execaOpts))\n        .split('\\n')\n        .map(tag => tag.trim())\n        .filter(Boolean);\n}\n"], ["webdriverDownload", "\nfunction webdriverDownload(done) {\n    const platform = os.platform();\n    const destDir = path.join(__dirname, '.selenium');\n    const chromeDriverUrl = (() => {\n        const filePath = platform === 'win32' ?\n            '/2.38/chromedriver_win32.zip' :\n            `/2.38/chromedriver_${platform === 'darwin' ? 'mac' : 'linux'}64.zip`;\n        return `http:\n    })();\n\n    \n    if (fs.existsSync(destDir + '/chromedriver') || fs.existsSync(destDir + '/chromedriver.exe')) {\n        done();\n    } else {\n        const selenium = $.download('https:\n            .pipe(gulp.dest(destDir));\n\n        const chromedriver = $.download(chromeDriverUrl)\n            .pipe($.unzip())\n            .pipe($.chmod(755))\n            .pipe(gulp.dest(destDir));\n\n        return mergeStream(selenium, chromedriver);\n    }\n}\n"], ["ImportConstructor", "\nfunction Import(opts) {\n    if (!opts.base) {\n        throw new Error(\"Must specify a file path\");\n    }\n\n    opts = opts || {};\n    this.opts = opts;\n    this.base = opts.base || process.cwd();\n    this.path = opts.path;\n    this.visit = this.visit.bind(this);\n    this.importFile = this.importFile.bind(this);\n    this.map = opts.map || [];\n    this.target = opts.target;\n\n    \n    if (path.resolve(this.path) !== this.path) {\n        this.path = path.resolve(this.base, this.path);\n    }\n}\n"], ["getWmsProvider", "\nfunction getWmsProvider(name, options) {\n    var wmsProvider = void 0;\n    if (name in CONFIG.WMS_PROVIDERS) {\n        wmsProvider = CONFIG.WMS_PROVIDERS[name];\n\n        \n        if (wmsProvider.deprecated && console && console.warn) {\n            \n            console.warn(name + \" is a deprecated wms; it will be redirected to its replacement. For performance improvements, please change your reference.\");\n        }\n    } else {\n        wmsProvider = _extends({}, CONFIG.WMS_DEFAULTS, options);\n        \n        console.log('NL Maps: You asked for a wms which does not exist! Available wmses: ' + Object.keys(CONFIG.WMS_PROVIDERS).join(', ') + '. Provide an options object to make your own WMS.');\n    }\n    return wmsProvider;\n}\n"], ["substring", "\nfunction (indexA, indexB) {\n    \n    \n    if (typeof indexB != 'number')\n        return this.$.nodeValue.substr(indexA);\n    else\n        return this.$.nodeValue.substring(indexA, indexB);\n}\n"], ["createToolbarIcon", "\nfunction (button) {\n    var $element = $('<a/>').addClass('wysiwyg-toolbar-icon')\n        .prop('href', '#')\n        .prop('unselectable', 'on')\n        .append(button.image);\n    \n    $.each(button, function (name, value) {\n        switch (name) {\n            \n            case 'class':\n                $element.addClass(value);\n                break;\n            \n            case 'image':\n            case 'html':\n            case 'popup':\n            case 'click':\n            case 'showstatic':\n            case 'showselection':\n                break;\n            default:\n                $element.attr(name, value);\n                break;\n        }\n    });\n    return $element;\n}\n"], ["parseDateString", "\nfunction makeDateFromStringAndFormat(config) {\n\n    config._a = [];\n    config._pf.empty = true;\n\n    \n    var lang = getLangDefinition(config._l),\n        string = '' + config._i,\n        i, parsedInput, tokens, token, skipped,\n        stringLength = string.length,\n        totalParsedInputLength = 0;\n\n    tokens = expandFormat(config._f, lang).match(formattingTokens) || [];\n\n    for (i = 0; i < tokens.length; i++) {\n        token = tokens[i];\n        parsedInput = (getParseRegexForToken(token, config).exec(string) || [])[0];\n        if (parsedInput) {\n            skipped = string.substr(0, string.indexOf(parsedInput));\n            if (skipped.length > 0) {\n                config._pf.unusedInput.push(skipped);\n            }\n            string = string.slice(string.indexOf(parsedInput) + parsedInput.length);\n            totalParsedInputLength += parsedInput.length;\n        }\n        \n        if (formatTokenFunctions[token]) {\n            if (parsedInput) {\n                config._pf.empty = false;\n            }\n            else {\n                config._pf.unusedTokens.push(token);\n            }\n            addTimeToArrayFromToken(token, parsedInput, config);\n        }\n        else if (config._strict && !parsedInput) {\n            config._pf.unusedTokens.push(token);\n        }\n    }\n\n    \n    config._pf.charsLeftOver = stringLength - totalParsedInputLength;\n    if (string.length > 0) {\n        config._pf.unusedInput.push(string);\n    }\n\n    \n    if (config._isPm && config._a[HOUR] < 12) {\n        config._a[HOUR] += 12;\n    }\n    \n    if (config._isPm === false && config._a[HOUR] === 12) {\n        config._a[HOUR] = 0;\n    }\n\n    dateFromConfig(config);\n    checkOverflow(config);\n}\n"], ["removeRequire", "\nfunction removeRequire(filepath, source, moduleBase) {\n\n    try {\n        return source.replace(/\\brequire\\s*\\(\\s*(\"|')([\\s\\S]*?)\\1\\s*\\)/g, function (match, sign, moduleName) {\n\n            var originalName = moduleName;\n\n            if (/^[.]{1,2}\\\\/) {\n                \n                moduleName = PathModule.resolve(PathModule.dirname(filepath) + PathModule.sep + moduleName);\n            } else if (idMapping.hasOwnProperty(moduleName)) {\n                return depsPoolName + '.r(' + idMapping[moduleName] + ')';\n            } else {\n                moduleName = PathModule.resolve(moduleBase + moduleName);\n            }\n\n            if (PathModule.extname(moduleName) === \"\") {\n                moduleName += \".js\";\n            }\n\n            if (moduleMapping.hasOwnProperty(moduleName)) {\n                return depsPoolName + \".r(\" + moduleMapping[moduleName] + \")\";\n            }\n\n            throw new ModuleNotfoundError(originalName);\n\n        });\n    } catch (e) {\n        if (e.name === \"ModuleNotfoundError\") {\n            grunt.fatal('Module [' + e.message + '] not found, in file: ' + filepath);\n        }\n        throw e;\n    }\n\n}\n"], "```"]