[["processTokenFiles", "\nfunction(inputIndex) {\n    _.each(tokens, function(token, index) {\n        <readTokenFile>\n        if(token.file) {\n            fs.readFile(token.file, 'utf8', function(e, data) {\n                if(e) {\n                    grunt.fail.warn(\"There was an error processing the replacement '\" + token.file + \"' file.\");\n                }\n                tokens[index].contents = data;\n                processTokenCompleteCallback();\n            });\n        }\n        </readTokenFile>\n        <handleStringToken>\n        else if(token.string) {\n            tokens[index].contents = token.string;\n            processTokenCompleteCallback();\n        }\n        </handleStringToken>\n        else {\n            processTokenCompleteCallback();\n        }\n    }, this);\n}\n"], ["getFunctionDescription", "\nfunction getFunctionDescription(func){\n    if (typeof func == 'function' && func.className && func.prototype && typeof func.prototype.init == 'function')\n      func = func.prototype.init;\n\n    if (func.basisDocFD_)\n      return func.basisDocFD_;\n\n    return func.basisDocFD_ = fnInfo(func);\n}\n"], ["cookieReplace", "\nfunction cookieReplace(m,key,value){\n  key = pct.decodeComponent(key);\n  value = pct.decodeComponent(value);\n\n  if(!holder.hasOwnProperty(key)) holder[key] = value;\n}\n"], ["promiseResolver", "\nfunction (err) {\n    if (err) {\n      reject(err);\n    } else if (arguments.length === 2) {\n      resolve(arguments[1]);\n    } else {\n      var cbArgsArray = self.toArgsArray(arguments);\n      resolve(cbArgsArray.slice(1));\n    }\n}\n"], ["generateJsonSchemaFromInputEx", "\nfunction(inputExJson) {\n    var t = inputExJson.type || \"string\",\n        ip = (lang.isObject(inputExJson.inputParams) ? inputExJson.inputParams : inputExJson) || {};\n    \n    return mapInputExTypeToSchema(t, ip);\n}\n"], ["calculateAnimationOptions", "\nfunction(_node,_value,_rules,_stop,_index){\n    var _value= _value.split(' '),\n        _prop = _value[0],\n        _from = parseFloat(_e._$getStyle(_node,_prop))||0,\n        _to   = parseFloat(_rules[_prop])||0,\n        _cutr = _animMap[_value[2]],\n        _delay = _value[3].slice(0,-1) * 1000||0,\n        _durtReal = _value[1].slice(0,-1) * 1000||0,\n        _durt = _value[1].slice(0,-1) * 1000 + _value[3].slice(0,-1) * 1000;\n    if(_durt >= _node.sumTime){\n      _node.sumTime = _durt;\n      _node.isLastOne = _index;\n    }\n    <adaptAnimationProperties>\n    if(_prop === 'opacity'){\n        _prop = _h.__formatOpacity ? _h.__formatOpacity():_prop;\n        _from = _h.__formatFrom ? _h.__formatFrom(_node):_from;\n        _to   = _h.__formatTo ? _h.__formatTo(_to):_to;\n    }\n    </adaptAnimationProperties>\n    var _options = {\n        delay:_delay,\n        from:{\n            offset:_from\n        },\n        to:{\n            offset:_to\n        },\n        duration:_durtReal,\n        <updateAnimation>\n        onupdate:function(_offset){\n          var _value = _offset.offset;\n          if(!_h.__doCheckProp(_prop)){\n            _value = _doAdap(_value,_prop);\n                _e._$setStyle(_node,_prop,_value);\n            }else{\n                _e._$setStyle(_node,_prop,_value + 'px');\n            }\n        },\n        </updateAnimation>\n        <finalizeAnimation>\n        onstop:function(_prop,_args){\n            _args = _args || [];\n            var _effect = _node.effects[_index];\n            if(!_effect) return;\n                _effect = _cutr._$recycle(_effect);\n                _node.effects[_index] = _effect;\n            if(_node.isLastOne === _index){\n              _stop.apply(this,_args);\n            }\n        }._$bind(this,_index)\n        </finalizeAnimation>\n      };\n    return _options;\n}\n"], ["startObserving", "\nfunction startObserving() {\n    if (config.skipObserving) {\n        return;\n    }\n\n    <initializeScheduling>\n    scheduleExecution(1);\n    window.addEventListener('DOMContentLoaded', scheduleExecution.bind(undefined, 1, undefined, undefined));\n    window.addEventListener('load', scheduleExecution.bind(undefined, 1, undefined, undefined));\n    window.addEventListener('resize', scheduleExecution.bind(undefined, 3, true, undefined));\n    </initializeScheduling>\n\n    <setupMutationObserver>\n    var MutationObserver = window.MutationObserver || window.WebKitMutationObserver;\n    if (MutationObserver) {\n        observer = new MutationObserver(checkMutations);\n        observer.observe(document.documentElement, {\n            childList: true,\n            subtree: true,\n        });\n    }\n    else {\n        window.addEventListener('DOMNodeInserted', onDomMutate);\n        window.addEventListener('DOMNodeRemoved', onDomMutate);\n    }\n    </setupMutationObserver>\n}\n"], ["layoutDimensions", "\nfunction layoutDimensions(options) {\n    options = getLayoutDimensionOptions(options);\n\n    if (options.nodeDimensionsIncludeLabels) {\n      var bbDim = this.boundingBox();\n      return {\n        w: bbDim.w,\n        h: bbDim.h\n      };\n    } else {\n      return {\n        w: this.outerWidth(),\n        h: this.outerHeight()\n      };\n    }\n}\n"], ["removeColumnAndUpdateScrollPositions", "\nfunction(oColumn) {\n    <recordScrollPositions>\n    var hdPos = this._elHdContainer.scrollLeft;\n    var bdPos = this._elBdContainer.scrollLeft;\n    </recordScrollPositions>\n\n    <removeColumn>\n    oColumn = SDT.superclass.removeColumn.call(this, oColumn);\n    </removeColumn>\n\n    <restoreScrollPositions>\n    this._elHdContainer.scrollLeft = hdPos;\n    this._elBdContainer.scrollLeft = bdPos;\n    </restoreScrollPositions>\n\n    return oColumn;\n}\n"], ["writeDescriptor", "\nfunction (successCallback, errorCallback, args) {\n    <logEntryAndExit>\n    winble.logger.logApiEntry(\"writeDescriptor\");\n    var deviceHandle = args[0] ? args[0] : \"\";\n    var descHandle = args[1] ? args[1] : \"\";\n    var dataBuffer = args[2] ? args[2] : \"\";\n    winble.deviceManager.writeDescriptor(successCallback, errorCallback, deviceHandle, descHandle, dataBuffer);\n    winble.logger.logApiExit(\"writeDescriptor\");\n    </logEntryAndExit>\n}\n"], "```\n\nSome functions do not present a violation of the SRP and thus they are encapsulated within a single tag defining their cohesive responsibility. Others have clear separations of concerns within them, which are delineated appropriately with nested tags indicating the distinct responsibilities."]