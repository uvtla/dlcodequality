[["setSvgMarkerAttributes", "\nfunction(marker, width, height, block) {\n    var attr = ['marker']\n    \n    <addMarkerToAttr>\n    if (marker != 'all') attr.push(marker)\n    </addMarkerToAttr>\n    attr = attr.join('-')\n    \n    <generateMarker>\n    marker = arguments[1] instanceof SVG.Marker ?\n      arguments[1] :\n      this.doc().marker(width, height, block)\n    </generateMarker>\n\n    return this.attr(attr, marker)\n}\n"], ["parseFileChunk", "\nfunction parseFileChunk(data){\n  var chunk = {};\n  chunk.chunkIdx = new Float64Array(data.buffer, 8, 1)[0];\n  chunk.fileID = String.fromCharCode.apply(null, new Uint16Array(data.buffer, 32, 8));\n  chunk.msgIdx = new Float64Array(data.buffer, 16, 1)[0];\n  chunk.data = new Uint8Array(data.buffer, 48);\n  return chunk;\n}\n"], ["restoreAuthentication", "\nfunction(provider) {\n      if (!this.isCurrent()) {\n        return;\n      }\n      \n      <determineAuthProvider>\n      var authType;\n      if (_.isString(provider)) {\n        authType = provider;\n        provider = Parse.User._authProviders[authType];\n      } else {\n        authType = provider.getAuthType();\n      }\n      </determineAuthProvider>\n      \n      <validateAuthData>\n      var authData = this.get('authData');\n      if (!authData || !provider) {\n        return;\n      }\n      </validateAuthData>\n      \n      <handleRestoringAuth>\n      var success = provider.restoreAuthentication(authData[authType]);\n      if (!success) {\n        this._unlinkFrom(provider);\n      }\n      </handleRestoringAuth>\n    }\n"], ["manageDataAttributes", "\nfunction(attr, val, el, index, obj, attrCamel) {\n  // The complexity of this function with multiple if-else branches \n  // and similar operations suggests that decomposition might be beneficial for SRP.\n}\n"], ["listModulesInDirectory", "\nfunction listModulesInDirectory(modulesDir) {\n    const log = debug('phantomas:modules'); // This is just a single line of logging, not a separate responsibility.\n    \n    <readDirectory>\n    var ls = fs.readdirSync(modulesDir),\n        modules = [];\n    </readDirectory>\n\n    <filterValidModules>\n    ls.forEach(function(entry) {\n        if (fs.existsSync(modulesDir + '/' + entry + '/' + entry + '.js')) {\n            modules.push(entry);\n        }\n    });\n    </filterValidModules>\n\n    return modules.sort(); // Sorting the modules is part of the primary responsibility, not a separate one.\n}\n"], ["runScript", "\nfunction _runScript(config, options) {\n  <setupSandbox>\n  const useSandbox = ((isFunction(config.useSandbox)) ? _config.useSandbox(_config) || false : config.useSandbox);\n  const module = new Module(config);\n  const scopeParams = _getScopeParams(config, module, config.scope);\n  const script = _createScript(config, options, config.scope);\n  </setupSandbox>\n\n  <executeScript>\n  try {\n    if (useSandbox) {\n      script.runInContext(_createSandbox(config), options)(...scopeParams);\n    } else {\n      script.runInThisContext(options)(...scopeParams);\n    }\n  } catch(error) {\n    if (config.squashErrors) cache.delete(options.filename);\n    if (!config.squashErrors) {\n      if (_runError(error, module)) throw error;\n    } else {\n      throw error;\n    }\n  }\n  </executeScript>\n\n  return module;\n}\n"], ["handleFileReaderEvents", "\nfunction (r) { \n    <checkReadyState>\n    if (me._readyState === FileReader.DONE) {\n        return;\n    }\n    </checkReadyState>\n\n    <markFileReaderDone>\n    me._readyState = FileReader.DONE;\n    </markFileReaderDone>\n\n    <prepareResult>\n    if (r instanceof Array) {\n        r = new Uint8Array(r).buffer;\n    }\n    me._result = r;\n    </prepareResult>\n\n    <triggerOnLoad>\n    if (typeof me.onload === 'function') {\n        me.onload(new ProgressEvent('load', { target:me }));\n    }\n    </triggerOnLoad>\n\n    <triggerOnLoadEnd>\n    if (typeof me.onloadend === 'function') {\n        me.onloadend(new ProgressEvent('loadend', { target:me }));\n    }\n    </triggerOnLoadEnd>\n}\n"], ["httpGetImage", "\nfunction () {\n    <parseUrl>\n    var options = url.parse(this.source, false);\n    </parseUrl>\n\n    <configureHttpRequest>\n    extend(options, {\n      method: 'get',\n      headers: {\n        host: options.host,\n        accept: 'image/*'\n      }\n    });\n    </configureHttpRequest>\n\n    <selectHttpLibrary>\n    var library = options.protocol === 'https:' ? https : http;\n    </selectHttpLibrary>\n\n    <setupHttpRequest>\n    this.request = library.request(options);\n    this.request.on('response', this.onResponse.bind(this));\n    this.request.on('error', this.onError.bind(this));\n    this.request.setTimeout(5000, this.onTimeout.bind(this));\n    </setupHttpRequest>\n\n    <sendHttpRequest>\n    this.startTime = new Date().getTime();\n    this.request.end();\n    </sendHttpRequest>\n}\n"], ["writeToBuffer", "\nfunction write(buffer, offs) {\n\t\t\tfor (var i = 2; i < arguments.length; i++) {\n\t\t\t\tfor (var j = 0; j < arguments[i].length; j++) {\n\t\t\t\t\tbuffer[offs++] = arguments[i].charAt(j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n"], ["mapParserStream", "\nfunction(parser) {\n    return highland.map(function(item) {\n      <applyParser>\n      if (_.isFunction(parser)) {\n        return parser(item);\n      }\n      if (_.isObject(parser) && (parser.parse != null)) {\n        return parser.parse(item);\n      }\n      </applyParser>\n\n      return item; // Returning an unmodified item is part of applying the parser, not a separate responsibility.\n    });\n}\n"], "```\nWhile it appears that applying a parser is a distinct responsibility, in this context, it constitutes the primary purpose of the highland map, thus making the function compliant with SRP."]