[["establishTcpConnection", "\nfunction() {\n    that.connected = true;\n    that.tcp_connection.setKeepAlive( true );\t\n    \n    <processMessageBuffer>\n    if ( that.message_buffer.length ) {\n        while( that.message_buffer.length ) {\n            that.tcp_connection.write( that.message_buffer.shift() );\n        }\n    }\n</processMessageBuffer>\n}\n"], ["generateWorkerData", "\nfunction _getWorkerData(code, lang) {\n    let options = {};\n    if (typeof lang === 'object') {\n        options = lang;\n        lang = options.language;\n    }\n\n    lang = aliases[lang] || lang;\n\n    const workerData = {\n        id: id++,\n        code,\n        lang,\n        options: _getPrismOptions(options),\n        isNode\n    };\n\n    return workerData;\n}\n"], ["stopRouter", "\nfunction () {\n    <checkInitialization>\n    if (!this._bIsInitialized) {\n        Log.warning(\"Router is not initialized. But it got stopped\", this);\n    }\n    </checkInitialization>\n\n    <detachEventHandlers>\n    if (this.fnHashChanged) {\n        this.oHashChanger.detachEvent(\"hashChanged\", this.fnHashChanged);\n    }\n\n    if (this.fnHashReplaced) {\n        this.oHashChanger.detachEvent(\"hashReplaced\", this.fnHashReplaced);\n    }\n    </detachEventHandlers>\n\n    <fireEventAndReset>\n    if (this._matchedRoute) {\n        this._matchedRoute.fireEvent(\"switched\");\n        this._matchedRoute = null;\n    }\n\n    this._bIsInitialized = false;\n    </fireEventAndReset>\n\n    return this;\n}\n"], ["createDSVArr", "\nfunction DSVArr (arr, options) {\n    <initializeOptions>\n    const defaultOption = {\n        firstRowHeader: true,\n    };\n    options = Object.assign({}, defaultOption, options);\n    </initializeOptions>\n\n    let header;\n    const columns = [];\n    const push = columnMajor(columns);\n\n    <processHeader>\n    if (options.firstRowHeader) {\n        header = arr.splice(0, 1)[0];\n    } else {\n        header = [];\n    }\n    </processHeader>\n\n    <populateColumns>\n    arr.forEach(field => push(...field));\n    </populateColumns>\n\n    return [header, columns];\n}\n"], ["normalizeConfiguration", "\nfunction normalizeConf (conf) {\n    <applyEnvironmentConfigurations>\n    if (process.env.PROVIDER_URL) {\n        conf.providerURL = process.env.PROVIDER_URL\n    }\n\n    if (process.env.WEBHOOK_URL) {\n        conf.webhookURL = process.env.WEBHOOK_URL\n    }\n\n    if (process.env.AUTOSTART) {\n        conf.autostart = yn(process.env.AUTOSTART)\n    }\n\n    if (process.env.PORT) {\n        conf.port = Number(process.env.PORT)\n    }\n    </applyEnvironmentConfigurations>\n\n    <finalizeConfiguration>\n    conf.providerURL = conf.providerURL.replace(/\\/+$/, '')\n    if (!conf.webhookURL) {\n        conf.webhookURL = `http:\n    }\n\n    if (conf.autostart !== false) {\n        conf.autostart = true\n    }\n    </finalizeConfiguration>\n\n    return conf\n}\n"], ["executeEachTemplate", "\nfunction(path, templ, emptyTempl, initialiser) {\n    if (!templ)\n        throw new Error('yamvish each methods needs a template. (path : ' + path + ')');\n    templ = (typeof templ === 'string') ? y().use(templ) : templ;\n    if (emptyTempl)\n        emptyTempl = (typeof emptyTempl === 'string') ? y().use(emptyTempl) : emptyTempl;\n    return this.exec('each', [path, templ, emptyTempl, initialiser]);\n}\n"], ["setImageFallbackHandler", "\nfunction(fallbackImage, onProgress) {\n    this.onProgress = typeof onProgress === 'function' ? onProgress : null;\n    this.fallbackImage = typeof fallbackImage === 'string' || fallbackImage instanceof HTMLImageElement ? fallbackImage : null;\n}\n"], ["registerListener", "\nfunction (trigger, callback) {\n    var self = this;\n    var id = self.nextId++;\n    \n    <addListener>\n    self.listeners[id] = {trigger: EJSON.clone(trigger), callback: callback};\n    </addListener>\n\n    <manageFactCount>\n    if (self.factName && Package.facts) {\n      Package.facts.Facts.incrementServerFact(\n        self.factPackage, self.factName, 1);\n    }\n    </manageFactCount>\n\n    <createUnregisterFunction>\n    return {\n      stop: function () {\n        if (self.factName && Package.facts) {\n          Package.facts.Facts.incrementServerFact(\n            self.factPackage, self.factName, -1);\n        }\n        delete self.listeners[id];\n      }\n    };\n    </createUnregisterFunction>\n}\n"], ["initializeServer", "\nfunction Server (a, b) {\n  <handleServerSingleton>\n  if (!(this instanceof Server)) {\n    if (!arguments.length && server) return server;\n    var instance = new Server(a, b);\n    if (!server) server = instance;\n    return instance;\n  }\n  </handleServerSingleton>\n\n  <setupDebugging>\n  debug('new server', a, b);\n  \n  var self = this;\n  \n  events.EventEmitter.call(this);\n  </setupDebugging>\n\n  <defineEventHandlers>\n  this.onPublish = function (message) {\n    debug('on publish ', message.id());\n    self.exchange().publish(message);\n  };\n\n  this.onConnection = function (socket) {\n    // ... More code related to handling connections\n  };\n  </defineEventHandlers>\n\n  <additionalServerSetup>\n  this.addListener('error', this.onError);\n  this.incomming();\n  this.processing();\n  this.outgoing();\n  this.autoPropagate(true);\n  </additionalServerSetup>\n\n  <serverListening>\n  if (a) {\n    debug('we have something so we will try to listen to it');\n    this.listen(a, b);\n  }\n  </serverListening>\n}\n"], ["initializeDenseNodes", "\nfunction DenseNodes(properties) {\n    this.id = [];\n    this.lat = [];\n    this.lon = [];\n    this.keysVals = [];\n    if (properties)\n        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n            if (properties[keys[i]] != null)\n                this[keys[i]] = properties[keys[i]];\n}\n"], "```"]