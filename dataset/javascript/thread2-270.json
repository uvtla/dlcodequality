[["calculateInverseHyperbolicCosine", "\nfunction() {\n  \n  var a = this['re'];\n  var b = this['im'];\n\n  if (this['isZero']()) {\n    return Complex['INFINITY'];\n  }\n\n  var d = a * a + b * b;\n  return (d !== 0)\n          ? new Complex(\n                  a / d,\n                  -b / d).acosh()\n          : new Complex(\n                  (a !== 0) ? a / 0 : 0,\n                  (b !== 0) ? -b / 0 : 0).acosh();\n}\n"], ["decorateComment", "\nfunction decorateComment(node, comment, options) {\n  const { locStart, locEnd } = options;\n\n  const childNodes = getSortedChildNodes(node, options);\n  let precedingNode;\n  let followingNode;\n  \n  let left = 0;\n  let right = childNodes.length;\n<binarySearchInsertionPoint>\n  while (left < right) {\n    const middle = (left + right) >> 1;\n    const child = childNodes[middle];\n\n    if (\n      locStart(child) - locStart(comment) <= 0 &&\n      locEnd(comment) - locEnd(child) <= 0\n    ) {\n      \n      comment.enclosingNode = child;\n\n      decorateComment(child, comment, options);\n      return; \n    }\n\n    if (locEnd(child) - locStart(comment) <= 0) {\n      precedingNode = child;\n      left = middle + 1;\n      continue;\n    }\n\n    if (locEnd(comment) - locStart(child) <= 0) {\n      followingNode = child;\n      right = middle;\n      continue;\n    }\n    \n    throw new Error(\"Comment location overlaps with node location\");\n  }\n</binarySearchInsertionPoint>\n\n<assignCommentToNodes>\n  if (\n    comment.enclosingNode &&\n    comment.enclosingNode.type === \"TemplateLiteral\"\n  ) {\n    const quasis = comment.enclosingNode.quasis;\n    const commentIndex = findExpressionIndexForComment(\n      quasis,\n      comment,\n      options\n    );\n\n    if (\n      precedingNode &&\n      findExpressionIndexForComment(quasis, precedingNode, options) !==\n        commentIndex\n    ) {\n      precedingNode = null;\n    }\n    if (\n      followingNode &&\n      findExpressionIndexForComment(quasis, followingNode, options) !==\n        commentIndex\n    ) {\n      followingNode = null;\n    }\n  }\n\n  if (precedingNode) {\n    comment.precedingNode = precedingNode;\n  }\n\n  if (followingNode) {\n    comment.followingNode = followingNode;\n  }\n</assignCommentToNodes>\n}\n"], ["removeChildFromParent", "\nfunction (node) {\n  var children = this._children;\n  var idx = children.indexOf(node);\n  if (idx < 0) {\n      return;\n  }\n\n  children.splice(idx, 1);\n  node._parent = null;\n\n  if (this._scene) {\n      node.traverse(this._removeSelfFromScene, this);\n  }\n}\n"], ["convertImageSrcToBase64", "\nfunction(base) {\n  var node = $(base).children('img:first');\n  if (node.attr('src').substr(0, 5) !== 'data:') {\n    node.attr('src', imgBase64(node, this.file.mime));\n  }\n}\n"], ["subscribeToEventWithDelegation", "\nfunction(type, fn, obj, scope) {\n  scope = scope || this;\n  var Event = YAHOO.util.Event,\n  el = this.get('element') || this.get('id'),\n\tself = this;\n\n\tif (specialTypes[type] && !Event._createMouseDelegate) {\n    return false;\t\n\t}\n\n  if (!this._events[type]) {\n    if (el && this.DOM_EVENTS[type]) {\n<EventDelegationSetup>\n      Event.on(el, type, function(e, matchedEl) {\n        if (e.srcElement && !e.target) { \n          e.target = e.srcElement;\n        }\n\n        if ((e.toElement && !e.relatedTarget) || (e.fromElement && !e.relatedTarget)) {\n          e.relatedTarget = Event.getRelatedTarget(e);\n        }\n        \n        if (!e.currentTarget) {\n          e.currentTarget = el;\n        }\n\n        self.fireEvent(type, e, matchedEl);\n\n      }, obj, scope);\n</EventDelegationSetup>\n    }\n    this.createEvent(type, {scope: this});\n  }\n  \n  return YAHOO.util.EventProvider.prototype.subscribe.apply(this, arguments); \n}\n"], ["mockDirectoryConfiguration", "\nfunction (path) {\n  var mockDirConfig = {\n    openRoute: function (req, res, params) {\n    },\n    \n    closeRoute: function (req, res, params) {\n    },\n  };\n\n  spyOn(mockDirConfig, 'openRoute').and.callThrough();\n  spyOn(mockDirConfig, 'closeRoute').and.callThrough();\n\n  registerRequireMock(testObject._formatPathForRequire(path), function () {\n    return mockDirConfig;\n  });\n\n  filesThatExist.push(path);\n\n  return mockDirConfig;\n}\n"], ["dynamicErrorConstructor", "\nfunction Block(errors, namespace, base, lazy) {\n  if ((base === undefined) || (base === true) || (base === null)) {\n    base = \"Base\";\n  } else if (base === false) {\n    base = Error;\n  } else if (typeof base !== \"function\") {\n    base = \"\" + base;\n  }\n<initializeErrorConstructorProperties>\n  this.p = {\n    errors: errors,\n    namespace: namespace,\n    prefix: namespace ? (namespace + \".\") : \"\",\n    base: base,\n    lazy: !!lazy\n  };\n</initializeErrorConstructorProperties>\n  this.created = false;\n  if (!this.p.lazy) {\n    this.createAll();\n  }\n}\n"], ["cleanupOnUnload", "\nfunction () {\n  unloaded = true;\n  \n  if ($loadSVGPromise && $loadSVGPromise.state() !== 'resolved') {\n    $loadSVGPromise.abort();\n    $loadSVGPromise = null;\n  }\n\n  if (removeOnUnload) {\n    if ($svg) {\n      $svg.remove();\n      $svg = null;\n    }\n    svgLoaded = false;\n  }\n}\n"], ["extractColumnFromRow", "\nfunction extractFromRow(row, context, asString)\n{\n  var map    = row._arrayProcessedColumns;\n  var values = row.values;\n\n  var columnIndex = this.getIndex();\n  var ret = values[columnIndex];\n\n  if (!(asString && this.isVariant() && !map[columnIndex]))\n  {\n    if (!map[columnIndex])\n    {\n      if (ret !== null)\n      {\n        ret = values[columnIndex] =\n            context.convert(values[columnIndex], this, context);\n      }\n      map[columnIndex] = true;\n    }\n\n    var extractFn = !asString ? context.toValue : context.toString;\n    ret = extractFn(ret);\n  }\n\n  return ret;\n}\n"], ["addTsIgnoreComment", "\nfunction addTsIgnore(filePath) {\n  const data = fs.readFileSync(filePath).toString().split('\\n');\n  const lineNumber = data.findIndex((lineText) => lineText.includes('/dist/'));\n  if (lineNumber <= -1) return;\n\n<insertTsIgnoreComment>\n  data.splice(lineNumber, 0, '// @ts-ignore');\n</insertTsIgnoreComment>\n  const text = data.join('\\n');\n<writeUpdatedFile>\n  fs.writeFile(filePath, text, function(err) {\n    if (err) return console.log(err);\n  });\n</writeUpdatedFile>\n}\n"], "```"]