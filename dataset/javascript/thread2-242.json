[["parseAndSendHttpRequest", "\nfunction (param, callbackId) {\n  <validateAndParseParam>\n  if (typeof param === 'string') {\n    try {\n      param = JSON.parse(param)\n    }\n    catch (e) {\n      return\n    }\n  }\n  if (typeof param !== 'object' || !param.url) {\n    return console.error(\n      '[h5-render] invalid config or invalid config.url for sendHttp API')\n  }\n  </validateAndParseParam>\n  \n  <sendHttpRequest>\n  const sender = this.sender\n  const method = param.method || 'GET'\n  const xhr = new XMLHttpRequest()\n  xhr.open(method, param.url, true)\n  xhr.onload = function () {\n    sender.performCallback(callbackId, this.responseText)\n  }\n  xhr.onerror = function (error) {\n    return console.error('[h5-render] unexpected error in sendHttp API', error)\n  }\n  xhr.send()\n  </sendHttpRequest>\n}\n"], ["setNodeCptProbs", "\nfunction setNodeCptProbs(cpt, probs, index) {\n  if(!isArrayOfArray(cpt)) {\n    for(var i=0; i < cpt.length; i++) {\n      cpt[i] = probs[index][i];\n    }\n    var nextIndex = index + 1;\n    return nextIndex;\n  } else {\n    var next = index;\n    for(var i=0; i < cpt.length; i++) {\n      next = setNodeCptProbs(cpt[i], probs, next);\n    }\n    return next;\n  }\n}\n"], ["initializeShell", "\nfunction $$shell() {\n  const SHELL_PROMPT = 'angie > ';\n\n  if (shell) {\n    <terminatePreviousShellOutput>\n    process.stdout.write('\\n');\n    </terminatePreviousShellOutput>\n  }\n\n  return app.$$load().then(function() {\n    <configureShellInputEncoding>\n    process.stdin.setEncoding('utf8');\n    </configureShellInputEncoding>\n\n    <startOrContinueShellSession>\n    if (!shell) {\n      shell = repl.start({\n        prompt: SHELL_PROMPT,\n        input: process.stdin,\n        output: process.stdout\n      });\n    } else {\n      process.stdout.write(SHELL_PROMPT);\n    }\n    </startOrContinueShellSession>\n  });\n}\n"], ["retrieveAndLogTransactionInfo", "\nasync function getTxInfo() {\n  const retVal = await Wormhole.DataRetrieval.transaction(TXID)\n\n  <logTransactionInfo>\n  console.log(`Info from TXID ${TXID}: ${JSON.stringify(retVal, null, 2)}`)\n  </logTransactionInfo>\n}\n"], ["readFeedsRecursively", "\nfunction readNext (ix) {\n  if (ix < feedsArray.length) {\n    <processFeedItem>\n    var item = feedsArray [ix];\n    if (atLeastOneSubscriber (item.url)) {\n      readFeed (item.url, function () {\n        readNext (ix + 1);\n      });\n    }\n    else {\n      readNext (ix + 1);\n    }\n    </processFeedItem>\n  }\n}\n"], ["hasFieldsExcept", "\nfunction hasFieldsExcept(obj, arrFields){\n  for (var field in obj)\n    if (arrFields.indexOf(field) === -1)\n      return true;\n  return false;\n}\n"], ["audioPlayerSetup", "\nfunction(element, options) {\n  var element = element,\n      s = this.helpers.clone(this.settings),\n      id = 'audiojs'+this.instanceCount,\n      wrapperId = 'audiojs_wrapper'+this.instanceCount,\n      instanceCount = this.instanceCount++;\n  \n  <determineSettingsFromAttributes>\n  if (element.getAttribute('autoplay') != null) s.autoplay = true;\n  if (element.getAttribute('loop') != null) s.loop = true;\n  if (element.getAttribute('preload') == 'none') s.preload = false;\n  </determineSettingsFromAttributes>\n  \n  <mergeCustomOptions>\n  if (options) this.helpers.merge(s, options);\n  </mergeCustomOptions>\n  \n  <setupPlayerInterface>\n  if (s.createPlayer.markup) element = this.createPlayer(element, s.createPlayer, wrapperId);\n  else element.parentNode.setAttribute('id', wrapperId);\n  </setupPlayerInterface>\n  \n  <audioInstanceInitialization>\n  var audio = new container[audiojsInstance](element, s);\n  </audioInstanceInitialization>\n\n  <handleFlashFallback>\n  if (s.useFlash && s.hasFlash) {\n    this.injectFlash(audio, id);\n    this.attachFlashEvents(audio.wrapper, audio);\n  } else if (s.useFlash && !s.hasFlash) {\n    this.settings.flashError.apply(audio);\n  }\n  </handleFlashFallback>\n\n  <attachHTML5Events>\n  if (!s.useFlash || (s.useFlash && s.hasFlash)) this.attachEvents(audio.wrapper, audio);\n  </attachHTML5Events>\n\n  <registerPlayerInstance>\n  this.instances[id] = audio;\n  return audio;\n  </registerPlayerInstance>\n}\n"], ["decompressPublicKey", "\nfunction decompressKey(key) {\n  <validateKeyFormat>\n  const format = key[0];\n  assert(key.length === 33);\n  switch (format) {\n    case 0x02:\n    case 0x03:\n      return key;\n    case 0x04:\n      key[0] = 0x02;\n      break;\n    case 0x05:\n      key[0] = 0x03;\n      break;\n    default:\n      throw new Error('Bad point format.');\n  }\n  </validateKeyFormat>\n\n  <convertAndRestoreKeyFormat>\n  const out = secp256k1.publicKeyConvert(key, false);\n  key[0] = format;\n  </convertAndRestoreKeyFormat>\n\n  return out;\n}\n"], ["initializeRPC", "\nfunction RPC(wdb) {\n  if (!(this instanceof RPC))\n    return new RPC(wdb);\n\n  RPCBase.call(this);\n  \n  <assertDependencies>\n  assert(wdb, 'RPC requires a WalletDB.');\n  </assertDependencies>\n\n  <initializeRPCProperties>\n  this.wdb = wdb;\n  this.network = wdb.network;\n  this.logger = wdb.logger.context('rpc');\n  this.client = wdb.client;\n  </initializeRPCProperties>\n\n  <initRPC>\n  this.wallet = null;\n  this.init();\n  </initRPC>\n}\n"], ["constructInterviewInstance", "\nfunction Interview(opts) {\n  <extendWithDefaultsAndOptions>\n  _.extend(this,\n    {\n      inquirer: require('inquirer'),\n      questionLookup: {},\n      logger: require('./logger'),\n      services: null,\n      tmpServiceJsonPath: null\n    },\n    require('./config')(),\n    opts\n  );\n  </extendWithDefaultsAndOptions>\n\n  <loadServiceConfiguration>\n  this._loadServiceJson();\n  </loadServiceConfiguration>\n}\n"], "```"]