[["compileEntity", "\nfunction compileEntity() {\n  var entity = extend({\n    buildId: bff.key(payload),\n    extension: file.extension,\n    filename: file.filename,\n    fingerprint: print,\n    url: file.url\n  }, payload);\n\n  return entity;\n}\n"], ["EmbarkBin", "\nfunction EmbarkBin(binpath, kind) {\n  this.binpath = binpath;\n  this.binrealpath = undefined;\n  this.kind = kind || 'invoked';\n  this.pkgDir = undefined;\n  this.pkgJson = undefined;\n}\n"], ["postRequest", "\nfunction postRequest(requestPost, credentials, baseUrl, apiPath, requestOptions, params, callback) {\n  params = params || {};\n\n  \n  <prepareAndSendRequest>\n  const currentRequest = requestPost(extend({\n    url: baseUrl + apiPath,\n    oauth: credentials,\n  }, requestOptions), function(err, response, body) {\n    try {\n      body = JSON.parse(body);\n    } catch (e) {\n      body = {\n        error: 'Malformed Response: ' + body,\n      };\n    }\n    <handleResponse>\n    requestCallback(callback)(err, response, body);\n    </handleResponse>\n  });\n  </prepareAndSendRequest>\n\n  \n  <handleDataExclusion>\n  const dataKeys = ['data'];\n  currentRequest.form(omit(params, dataKeys));\n  currentRequest.oauth(credentials);\n  </handleDataExclusion>\n\n  \n  <modifyRequestHeaders>\n  delete currentRequest.headers['content-type'];\n  delete currentRequest.body;\n  </modifyRequestHeaders>\n\n  \n  <prepareDataParameters>\n  if ('data' in params && Array.isArray(params.data)) {\n    for (let i = 0; i < params.data.length; ++i) {\n      params['data[' + i + ']'] = params.data[i];\n    }\n    delete params.data;\n  }\n  </prepareDataParameters>\n\n  \n  <formDataAppending>\n  const form = currentRequest.form();\n  for (const key in params) {\n    form.append(key, params[key]);\n  }\n  </formDataAppending>\n\n  \n  <extendRequestHeaders>\n  extend(currentRequest.headers, form.getHeaders());\n  </extendRequestHeaders>\n\n  return currentRequest;\n}\n"], ["parseRemoteBranches", "\nfunction parseRemoteBranches(str) {\n  var res = [],\n      regex = /[\\w]{40}\\s+refs\\/heads\\/(.+)/g,\n      match;\n\n  <extractBranches>\n  while ((match = regex.exec(str)) != null) {\n    if (match.index === regex.lastIndex) {\n      regex.lastIndex++;\n    }\n    res.push(match[1]);\n  }\n  </extractBranches>\n\n  <validateResponse>\n  if (!res.length) {\n    throw new Error('Unable to parse ls-remote response', str);\n  }\n  </validateResponse>\n  return res;\n}\n"], ["transformData", "\nfunction transformData(data, headers, status, fns) {\n  <applyTransformFunctions>\n  if (isFunction(fns))\n    return fns(data, headers, status);\n\n  forEach(fns, function(fn) {\n    data = fn(data, headers, status);\n  });\n  </applyTransformFunctions>\n\n  return data;\n}\n"], ["updateHookValue", "\nfunction (fullHookName, hookValue, rootPropertyValue) {\n    var hookData = CSS.Hooks.registered[fullHookName];\n\n    if (hookData) {\n        var hookRoot = hookData[0],\n            hookPosition = hookData[1],\n            rootPropertyValueParts,\n            rootPropertyValueUpdated;\n\n        rootPropertyValue = CSS.Hooks.cleanRootPropertyValue(hookRoot, rootPropertyValue);\n\n        \n        <updatePropertyValue>\n        rootPropertyValueParts = rootPropertyValue.toString().match(CSS.RegEx.valueSplit);\n        rootPropertyValueParts[hookPosition] = hookValue;\n        rootPropertyValueUpdated = rootPropertyValueParts.join(\" \");\n\n        return rootPropertyValueUpdated;\n        </updatePropertyValue>\n    } else {\n        \n        <returnUnchangedPropertyValue>\n        return rootPropertyValue;\n        </returnUnchangedPropertyValue>\n    }\n}\n"], ["validateNode", "\nfunction(node) {\n\n    var valid = true;\n    \n    <determineNodeValidity>\n    var nodeName;\n    try {\n        nodeName = node.nodeName.toUpperCase();\n    } catch(e) {\n        nodeName = node.nodeName;\n    }\n    valid = valid && !this.invalidHandleTypes[nodeName];\n    valid = valid && !this.invalidHandleIds[node.id];\n\n    for (var i=0, len=this.invalidHandleClasses.length; valid && i<len; ++i) {\n        valid = !Dom.hasClass(node, this.invalidHandleClasses[i]);\n    }\n    </determineNodeValidity>\n\n    <logValidationResult>\n    this.logger.log(\"Valid handle? ... \" + valid);\n    </logValidationResult>\n\n    return valid;\n\n}\n"], ["replaceSizeTokens", "\nfunction replaceSizeTokens(pattern, width, height, next) {\n  \n  <replaceTokensInPattern>\n  pattern = pattern\n    .replace(/%r/g, '%wx%h')\n    .replace(/%w/g, width)\n    .replace(/%h/g, height);\n  </replaceTokensInPattern>\n\n  next(null, pattern);\n}\n"], ["initPageObjects", "\nfunction initPageObjects()\n{\n\t<initializeCanvasForBody>\n\tif(isCanvas(document.body))\n\t{\n\t\tvar newCanvas = new Canvas(document.body);\n\t\tnewCanvas.initCanvas();\n\t\tcanvases.push(newCanvas);\n\t}\n\t</initializeCanvasForBody>\n\telse\n\t{\t\n\t\t<initializeCanvasesForDivs>\n\t\tvar divs = document.getElementsByTagName('div');\n\t\tvar i;\n\t\tfor(i = 0; i < divs.length; i++)\n\t\t{\n\t\t\tif(isCanvas(divs[i]) && !findCanvas(divs[i].id))\n\t\t\t{\n\t\t\t\tvar newCanvas = new Canvas(divs[i]);\n\t\t\t\tnewCanvas.initCanvas();\n\t\t\t\tcanvases.push(newCanvas);\n\t\t\t\tnewCanvas.fitBlocks();\n\t\t\t\tnewCanvas.alignBlocks();\n\t\t\t}\n\t\t}\n\t\t</initializeCanvasesForDivs>\n\t}\n}\n"], ["ReticleRenderer", "\nfunction ReticleRenderer(camera) {\n  this.camera = camera;\n\n  <createAndSetReticle>\n  this.reticle = this.createReticle_();\n  \n  this.reticle.position.z = -0.97;\n  camera.add(this.reticle);\n  </createAndSetReticle>\n\n  <setVisibility>\n  this.setVisibility(false);\n  </setVisibility>\n}\n"], "```"]