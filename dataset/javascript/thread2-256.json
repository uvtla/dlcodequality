[["mergeTableCells", "\nfunction (cell) {\n  <getCellInformation>\n  var cellInfo = this.getCellInfo(cell),\n      rightColIndex = cellInfo.colIndex + cellInfo.colSpan,\n      rightCellInfo = this.indexTable[cellInfo.rowIndex][rightColIndex],\n      rightCell = this.getCell(rightCellInfo.rowIndex, rightCellInfo.cellIndex);\n  </getCellInformation>\n\n  <adjustCellColSpan>\n  cell.colSpan = cellInfo.colSpan + rightCellInfo.colSpan;\n  </adjustCellColSpan>\n\n  <removeAttribute>\n  cell.removeAttribute(\"width\");\n  </removeAttribute>\n\n  <contentManipulation>\n  this.moveContent(cell, rightCell);\n  </contentManipulation>\n\n  <deleteAndUpdate>\n  this.deleteCell(rightCell, rightCellInfo.rowIndex);\n  this.update();\n  </deleteAndUpdate>\n}\n"], ["calculateClipping", "\nfunction () {\n  var bounds = this._renderer._bounds;\n\n  <initializeParts>\n  this._parts = [];\n  </initializeParts>\n\n  <checkBounds>\n  if (!this._pxBounds || !this._pxBounds.intersects(bounds)) {\n    return;\n  }\n  </checkBounds>\n\n  <noClipOption>\n  if (this.options.noClip) {\n    this._parts = this._rings;\n    return;\n  }\n  </noClipOption>\n\n  <clipShapes>\n  var parts = this._parts,\n      i, j, k, len, len2, segment, points;\n\n  for (i = 0, k = 0, len = this._rings.length; i < len; i++) {\n    points = this._rings[i];\n\n    for (j = 0, len2 = points.length; j < len2 - 1; j++) {\n      segment = L.LineUtil.clipSegment(points[j], points[j + 1], bounds, j, true);\n\n      if (!segment) { continue; }\n\n      parts[k] = parts[k] || [];\n      parts[k].push(segment[0]);\n\n      if ((segment[1] !== points[j + 1]) || (j === len2 - 2)) {\n        parts[k].push(segment[1]);\n        k++;\n      }\n    }\n  }\n  </clipShapes>\n}\n"], ["scanSpans", "\nfunction scanSpans(e0, e1, ymin, ymax, scanLine) {\n  <initializeScanLines>\n  var y0 = Math.max(ymin, Math.floor(e1.y0)),\n      y1 = Math.min(ymax, Math.ceil(e1.y1));\n  </initializeScanLines>\n\n  <sortEdges>\n  if ((e0.x0 == e1.x0 && e0.y0 == e1.y0)\n      ? (e0.x0 + e1.dy / e0.dy * e0.dx < e1.x1)\n      : (e0.x1 - e1.dy / e0.dy * e0.dx < e1.x0)) {\n    var t = e0; e0 = e1; e1 = t;\n  }\n  </sortEdges>\n\n  <calculateSpans>\n  var m0 = e0.dx / e0.dy,\n      m1 = e1.dx / e1.dy,\n      d0 = e0.dx > 0, \n      d1 = e1.dx < 0; \n  for (var y = y0; y < y1; y++) {\n    var x0 = m0 * Math.max(0, Math.min(e0.dy, y + d0 - e0.y0)) + e0.x0,\n        x1 = m1 * Math.max(0, Math.min(e1.dy, y + d1 - e1.y0)) + e1.x0;\n    scanLine(Math.floor(x1), Math.ceil(x0), y);\n  }\n  </calculateSpans>\n}\n"], ["findEntriesRecursive", "\nfunction findEntriesByCheck(groups, compareFn) {\n  var foundEntries = [],\n      newEntries;\n  <recursiveSearch>\n  groups.forEach(function(group) {\n    newEntries = group.getEntries().filter(compareFn);\n    if (newEntries.length > 0) {\n        foundEntries = foundEntries.concat(newEntries);\n    }\n    newEntries = findEntriesByCheck(group.getGroups(), compareFn);\n    if (newEntries.length > 0) {\n        foundEntries = foundEntries.concat(newEntries);\n    }\n  });\n  </recursiveSearch>\n  return foundEntries;\n}\n"], ["compareComponents", "\nfunction(other) {\n  var comps = [\"a\", \"b\", \"c\", \"d\"],\n      i, len;\n\n  for (i=0, len=comps.length; i < len; i++) {\n    if (this[comps[i]] < other[comps[i]]) {\n        return -1;\n    } else if (this[comps[i]] > other[comps[i]]) {\n        return 1;\n    }\n  }\n\n  return 0;\n}\n"], ["getMethod", "\nfunction(name, property) {\n  <checkMethodExistence>\n  if (!(name in this._methods)) {\n      throw new Error('Method \"' + name + '\" does not exist!');\n  }\n  </checkMethodExistence>\n  <retrieveMethod>\n  var method = this._methods[name](property);\n  </retrieveMethod>\n\n  <methodFormatting>\n  if (_.isFunction(method)) {\n      method = {\n          name: this.getMethodName(property, name),\n          body: method\n      }\n  }\n  </methodFormatting>\n  return method;\n}\n"], ["decodeIntegers", "\nfunction(encoded) {\n  <decodeUnsignedIntegers>\n  var numbers = this.decodeUnsignedIntegers(encoded);\n  </decodeUnsignedIntegers>\n\n  <flipBits>\n  var numbersLength = numbers.length;\n  for (var i = 0; i < numbersLength; ++i) {\n    var num = numbers[i];\n    numbers[i] = (num & 1) ? ~(num >> 1) : (num >> 1);\n  }\n  </flipBits>\n\n  return numbers;\n}\n"], ["encodeNumericDownscale", "\nfunction encodeArray_NUM_DWS( encoder, data, n_from, n_to ) {\n  <determineDwsType>\n  var n_dws_type = downscaleType( n_from, n_to );\n  </determineDwsType>\n\n  <logging>\n  encoder.counters.arr_dws+=1;\n  encoder.log(LOG.ARR, \"array.numeric.downscaled, len=\"+data.length+\n    \", from=\"+_NUMTYPE[n_from]+\", to=\"+_NUMTYPE[n_to]+\n    \", type=\"+_NUMTYPE_DOWNSCALE_DWS[n_dws_type]+\" (\"+n_dws_type+\")\");\n  </logging>\n\n  <conditionalHeaderWriting>\n  if (data.length < UINT16_MAX) {\n    encoder.stream8.write( pack1b( ARR_OP.NUM_DWS | NUMTYPE_LN.UINT16 | (n_dws_type << 1) ) );\n    encoder.stream16.write( pack2b( data.length, false ) );\n    encoder.counters.arr_hdr+=3;\n  } else {\n    encoder.stream8.write( pack1b( ARR_OP.NUM_DWS | NUMTYPE_LN.UINT32 | (n_dws_type << 1) ) );\n    encoder.stream32.write( pack4b( data.length, false ) );\n    encoder.counters.arr_hdr+=5;\n  }\n  </conditionalHeaderWriting>\n\n  <writeEncodedData>\n  pickStream( encoder, n_to )\n    .write( packTypedArray( convertArray( data, n_to ) ) );\n  </writeEncodedData>\n}\n"], ["retrieveTimeData", "\nfunction time() {\n  <parseDate>\n  let t = new Date().toString().split(' ');\n  </parseDate>\n\n  <constructTimeObject>\n  return {\n    current: Date.now(),\n    uptime: os.uptime(),\n    timezone: (t.length >= 7) ? t[5] : '',\n    timezoneName: (t.length >= 7) ? t.slice(6).join(' ').replace(/\\(/g, '').replace(/\\)/g, '') : ''\n  };\n  </constructTimeObject>\n}\n"], ["auditTimeFunction", "\nfunction auditTime(duration, scheduler) {\n  if (scheduler === void 0) { scheduler = async_1.async; }\n  <liftOperator>\n  return this.lift(new AuditTimeOperator(duration, scheduler));\n  </liftOperator>\n}\n"], "```"]