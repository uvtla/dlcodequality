[["login", "\nfunction login(options) {\n  <validateGUI>\n  if (!gui.isActive()) {\n    throw new Error('Cannot login without a GUI.');\n  }\n  </validateGUI>\n\n  <validateScope>\n  if (!options.scope) {\n    throw new Error('Must specify list of requested scopes');\n  }\n  </validateScope>\n\n  <prepareParams>\n  var params = {\n    response_type: 'token',\n    client_id: core.clientId,\n    redirect_uri: 'https://example.com/callback',\n    scope: options.scope.join(' '),\n  };\n  </prepareParams>\n\n  <includeForceVerify>\n  if(options.force_verify) {\n    params.force_verify = true;\n  }\n  </includeForceVerify>\n\n  <validateClientId>\n  if (!params.client_id) {\n    throw new Error('You must call init() before login()');\n  }\n  </validateClientId>\n\n  <initiateLogin>\n  gui.popupLogin(params);\n  </initiateLogin>\n}\n"], ["uuid", "\nfunction uuid() {\n  <generateUUID>\n    var i, random;\n    var uuid = '';\n\n    for (i = 0; i < 32; i++) {\n        random = Math.random() * 16 | 0;\n        if (i === 8 || i === 12 || i === 16 || i === 20) {\n            uuid += '-';\n        }\n        uuid += (i === 12 ? 4 : (i === 16 ? (random & 3 | 8) : random)).toString(16);\n    }\n  </generateUUID>\n\n  return uuid;\n}\n"], ["onMouseDown", "\nfunction onMouseDown(event, env, isSideEffectsDisabled) {\n  <recordMouseDown>\n    mouse.down(event, env ? env.camera : null);\n  </recordMouseDown>\n\n  <handleSideEffects>\n    if (!env || isSideEffectsDisabled) {\n        return;\n    }\n  </handleSideEffects>\n\n  <selectObject>\n    if (mouse.keys[1] && !mouse.keys[3]) {\n        let focusedObject = focusObject(env.library, env.camera, env.selector);\n\n        if (env.selector.selectFocused()) {\n            events.triggerSelect(focusedObject);\n        }   \n    }\n  </selectObject>\n}\n"], ["serialize", "\nfunction serialize(val) {\n  <serializeValue>\n\tif (val == null) {\n\t\treturn 'NULL'\n\n\t} else if (typeof val == 'string') {\n\t\treturn \"'\" + val.replace(/(\\\\)/g, '\\\\$1').replace(/(')/g, '\\\\$1') + \"'\";\n\t\n\t} else if (typeof val == 'number') {\n\t\tif (isNaN(val)) {\n\t\t\treturn 'NULL';\n\t\t} else {\n\t\t\treturn val.toString();\n\t\t}\n\n\t} else if ([true, false].indexOf(val) != -1) {\n\t\treturn val.toString().toUpperCase();\n\n\t} else if (val instanceof Date) {\n\t\treturn \"'\" + makeDateStr(val) + \"'\";\n\n\t} else {\n\t\tthrow \"Unable to serialize variable of type `\" + typeof val + \"`!\";\n\t}\n  </serializeValue>\n}\n"], ["toCursor", "\nfunction toCursor(item, index) {\n  <encodeCursor>\n  const id = item.id;\n  return base64(cursorPrefix + id + cursorSeparator + index);\n  </encodeCursor>\n}\n"], ["anonymous", "\nfunction () {\n  <handleFilterOrError>\n    var tOpts = this.__opts, clauseObj = tOpts[tOpts.having ? \"having\" : \"where\"];\n    if (clauseObj) {\n        return this.filter.apply(this, arguments);\n    } else {\n        throw new QueryError(\"No existing filter found\");\n    }\n  </handleFilterOrError>\n}\n"], ["icalParser", "\nfunction(ical) {\n      \n  <parseStringToComponent>\n  if (typeof(ical) === 'string') {\n    ical = ICAL.parse(ical);\n  }\n\n  if (!(ical instanceof ICAL.Component)) {\n    ical = new ICAL.Component(ical);\n  }\n  </parseStringToComponent>\n\n  <processComponents>\n  var components = ical.getAllSubcomponents();\n  var i = 0;\n  var len = components.length;\n  var component;\n  \n  for (; i < len; i++) {\n    component = components[i];\n  \n    <handleCalendarComponents>\n    switch (component.name) {\n      case 'vtimezone':\n        if (this.parseTimezone) {\n          var tzid = component.getFirstPropertyValue('tzid');\n          if (tzid) {\n            this.ontimezone(new ICAL.Timezone({\n              tzid: tzid,\n              component: component\n            }));\n          }\n        }\n        break;\n      case 'vevent':\n        if (this.parseEvent) {\n          this.onevent(new ICAL.Event(component));\n        }\n        break;\n      default:\n        continue;\n    }\n    </handleCalendarComponents>\n  }\n  </processComponents>\n\n  <completeParsing>\n  this.oncomplete();\n  </completeParsing>\n}\n"], ["selected2link", "\nfunction selected2link() {\n  <toggleLinkArea>\n\tif(!toolbar.data(\"sourceOpened\")) {\n    // ... remaining code omitted for brevity ...\n\t} else {\n\t  linkAreaSwitch(false);\n\t}\n  </toggleLinkArea>\n}\n"], ["processArray", "\nfunction processArray(aPromises) {\n  <chainPromises>\n\treturn aPromises.reduce(function(pacc, fn) {\n\t\treturn pacc.then(fn);\n\t}, Promise.resolve())\n\t.catch(function() {\n\t\treturn Promise.resolve(false);\n\t});\n  </chainPromises>\n}\n"], ["promisify", "\nfunction promisify(data, prevent = false) {\n  <handlePromisification>\n  let promisified;\n\n  if (typeof data === 'function') {\n    promisified = (...args) => new Promise((resolve, reject) => {\n      data.call(data, ...args.concat((error, ...args) => {\n        error ? reject(error) : resolve.call(data, ...args);\n      }));\n    });\n  } else if (typeof data === 'object' && false === prevent) {\n    promisified = new Proxy({}, {\n      get: (target, property) => promisify(data[property], true),\n    });\n  } else if (typeof data === 'string' && false === prevent) {\n    promisified = promisify(require(data));\n  } else {\n    promisified = data;\n  }\n  </handlePromisification>\n\n  return promisified;\n}\n"], "```\n\nPlease note: Due to length and complexity, the `selected2link` function annotations were simplified to cover the overarching responsibility of toggling the link area. If necessary, more detailed subdivision could be made, such as handling focus, selections, clicking behaviors, etc. However, to maintain the balance between over-segmenting and under-segmenting, only the primary responsibility is highlighted."]