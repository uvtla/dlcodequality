[["removeRootIds", "\nfunction(rootNode){\n  var arr,\n    i;\n\n  arr = modules.domUtils.getNodesByAttribute(rootNode, 'rootids');\n  i = arr.length;\n  while(i--) {\n    modules.domUtils.removeAttribute(arr[i],'rootids');\n  }\n}\n"], ["generateLowerTriangularMatrix", "\nfunction tril(A, k) {\n  <validateMatrix>\n  if (k === void 0) { k = 0; }\n  if (A.shape.length !== 2) {\n    throw new Error('Input is not matrix');\n  }\n  </validateMatrix>\n  \n  <cloneAndZeroElements>\n  var copyA = A.clone();\n  for (var i = 0; i < copyA.shape[0]; i++) {\n    for (var j = 0; j < copyA.shape[1]; j++) {\n      if (i < j - k) {\n        copyA.set(i, j, 0);\n      }\n    }\n  }\n  </cloneAndZeroElements>\n  \n  return copyA;\n}\n"], ["updatePositioningAndClasses", "\nfunction (leftFlushPt, rightFlushPt) {\n  <initializePositioning>\n  if (!this.initHorizontalPositioning()) {\n    return false;\n  }\n\n  var clientRect = this.getBoundingRect(this.node);\n  var innerHeight = this.getViewHeight();\n  </initializePositioning>\n  \n  <applyVerticalPositioningAndClasses>\n  if (this.floating){\n    <floatingHigh>\n    if (this.activatorOffset.top < (innerHeight/2)){\n      this.applyPosition({top: this.activatorOffset.top + this.activatorOffset.height/2});\n      this.addRemoveClass('high', true);\n    }\n    </floatingHigh>\n    <floatingLow>\n    else {\n      this.applyPosition({top:this.activatorOffset.top + this.activatorOffset.height/2 - clientRect.height});\n      this.addRemoveClass('low', true);\n    }\n    </floatingLow>\n  } else {\n    <nonFloatingAdjustment>\n    if (((clientRect.top + clientRect.height) > innerHeight) && ((innerHeight - clientRect.bottom) < (clientRect.top - clientRect.height))) {\n      this.applyPosition({top: clientRect.top - clientRect.height - this.activatorOffset.top - this.activatorOffset.height/2});\n      this.addRemoveClass('low', true);\n    }\n    </nonFloatingAdjustment>\n    <nonFloatingDefault>\n    else {\n      this.applyPosition({top: this.activatorOffset.height/2});\n      this.addRemoveClass('high', true);\n    }\n    </nonFloatingDefault>\n  }\n  </applyVerticalPositioningAndClasses>\n\n  <applyCornerClass>\n  if ((this.activatorOffset.left + this.activatorOffset.width) < leftFlushPt){\n    this.addClass('left');\n    this.addClass('corner');\n    return true;\n  }\n  </applyCornerClass>\n  <applyCornerClass>\n  else if (this.activatorOffset.left > rightFlushPt) {\n    this.addClass('right');\n    this.addClass('corner');\n    return true;\n  }\n  </applyCornerClass>\n\n  return false;\n}\n"], ["iterateStringCharacters", "\nfunction string(obj, fn, ctx) {\n  for (var i = 0; i < obj.length; ++i) {\n    fn.call(ctx, obj.charAt(i), i);\n  }\n}\n"], ["isPlainObject", "\nfunction isPlainObject(value) {\n  return t.binaryExpression(\n    \"===\",\n    toFunctionCall(t.identifier(\"String\"), [value]),\n    t.stringLiteral(\"[object Object]\")\n  );\n}\n"], ["hasBlockElement", "\nfunction(node) {\n  return (this.hasTagsInContent(node) && this.isBlock(node) \n    || <determineIfChildIsBlock>\n    node.children.some(function(child) {\n      return this.isBlock(child);\n    }, this));\n    </determineIfChildIsBlock>\n}\n"], ["handleMouseMoveEvent", "\nfunction mousemove(inEvent) {\n  <eventFilter>\n  if (!this.isEventSimulatedFromTouch_(inEvent)) {\n  </eventFilter>\n    <prepareAndDispatchEvent>\n    const e = prepareEvent(inEvent, this.dispatcher);\n    this.dispatcher.move(e, inEvent);\n    </prepareAndDispatchEvent>\n  }\n}\n"], ["exportTypeDeclaration", "\nfunction exportType(name: string, type: BabelAST) {\n  return t.exportNamedDeclaration(\n    t.typeAlias(t.identifier(name), null, type),\n    [],\n    null,\n  );\n}\n"], ["handleCharacterInput", "\nfunction handlePlainCharacter(element, char) {\n  <updateTextPrefix>\n  const prefix = element[typedPrefixKey] || '';\n  element[typedPrefixKey] = prefix + char;\n  </updateTextPrefix>\n  \n  <selectItemWithPrefix>\n  element.selectItemWithTextPrefix(element[typedPrefixKey]);\n  </selectItemWithPrefix>\n\n  <triggerPrefixTimeout>\n  setPrefixTimeout(element);\n  </triggerPrefixTimeout>\n}\n"], ["calculateAndApplyPhysics", "\nfunction( body, view ){\n  <calculatePosition>\n  var pos = body.state.pos,\n    v = body.state.vel,\n    os = body.offset,\n    t = this._interpolateTime || 0,\n    x,\n    y,\n    ang;\n  </calculatePosition>\n\n  <applyPhysicsToView>\n  x = pos._[0] + v._[0] * t;\n  y = pos._[1] + v._[1] * t;\n  ang = body.state.angular.pos + body.state.angular.vel * t;\n\n  view.position.set( x, y );\n  view.pivot.set( -os._[0], -os._[1] );\n  view.rotation = ang;\n  </applyPhysicsToView>\n}\n"], "```"]