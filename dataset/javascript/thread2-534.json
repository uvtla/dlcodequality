[["chacha20Encryption", "\nfunction chacha20(data, key, iv) {\n    return Promise.resolve().then(function() {\n        var algo = new ChaCha20(new Uint8Array(key), new Uint8Array(iv));\n        return ByteUtils.arrayToBuffer(algo.encrypt(new Uint8Array(data)));\n    });\n}\n"], ["clearTreeNodes", "\nfunction(ctx) {\n    var node = ctx.node;\n    \n    <handleNode>\n    if(node.ul){\n        if( node.isRoot() ) {\n            $(node.ul).empty();\n        } else {\n            $(node.ul).remove();\n            node.ul = null;\n        }\n        node.visit(function(n){\n            n.li = n.ul = null;\n        });\n    }\n    </handleNode>\n}\n"], ["insertionLogic", "\nfunction insertBefore(targetElement, targetScope) {\n            \n    <cssAdjustment>\n    if (placeHolder.css('display') !== 'table-row') {\n        placeHolder.css('display', 'block');\n    }\n    </cssAdjustment>\n    <domManipulationAndMove>\n    if (!targetScope.sortableScope.options.clone) {\n        targetElement[0].parentNode.insertBefore(placeHolder[0], targetElement[0]);\n        dragItemInfo.moveTo(targetScope.sortableScope, targetScope.index());\n    }\n    </domManipulationAndMove>\n}\n"], ["generateValidatorMap", "\nfunction genValidatorMap() {\n  var groupName, group, name\n  for (groupName in PROP_NAME_GROUPS) {\n    group = PROP_NAME_GROUPS[groupName]\n    for (name in group) {\n      validatorMap[name] = group[name]\n    }\n  }\n}\n"], ["promiseResolution", "\nfunction resolve$1(object) {\n      \n    var Constructor = this;\n    \n    <instantiationCheck>\n    if (object && (typeof object === 'undefined' ? 'undefined' : _typeof(object)) === 'object' && object.constructor === Constructor) {\n        return object;\n    }\n    </instantiationCheck>\n    \n    <newPromiseResolution>\n    var promise = new Constructor(noop);\n    resolve(promise, object);\n    return promise;\n    </newPromiseResolution>\n}\n"], ["handleJoinRequest", "\nfunction handleJoinRequestId (jar, token, accept, requestId) {\n  var httpOpt = {\n    url: '\n    options: {\n      method: 'POST',\n      jar: jar,\n      form: {\n        groupJoinRequestId: requestId\n      },\n      headers: {\n        'X-CSRF-TOKEN': token\n      },\n      resolveWithFullResponse: true\n    }\n  };\n  if (!accept) {\n    httpOpt.options.form.accept = false;\n  }\n  <httpRequest>\n  return http(httpOpt)\n  .then(function (res) {\n    if (res.statusCode === 200) {\n        if (!JSON.parse(res.body).success) {\n            throw new Error('Invalid permissions, make sure the user is in the group and is allowed to handle join requests');\n        }\n    } else {\n        throw new Error('Invalid status: ' + res.statusCode + ' ' + res.statusMessage);\n    }\n  });\n  </httpRequest>\n}\n"], ["textAndBackgroundRuleString", "\nfunction bgTextRuleString(className, options) {\n    return classRule(className)\n        .bg(options.background)\n        .text(options.text)\n        .build();\n}\n"], ["compileTemplateForInclude", "\nfunction(content_schema, raw_tag, widget_config, name) {\n\n    <sanityCheck>\n    if (Lava.schema.DEBUG && !name) Lava.t('Sugar: name for include is not provided');\n    </sanityCheck>\n    <templateStorage>\n    Lava.store(\n        widget_config,\n        'includes',\n        name,\n        raw_tag.content ? Lava.parsers.Common.compileTemplate(raw_tag.content, widget_config) : []\n    );\n    </templateStorage>\n}\n"], ["calculateValueFromSlider", "\nfunction() {\n    <valueCalculation>\n    var val = Math.floor(this.options.minValue+(this.options.maxValue-this.options.minValue)*this.slider.getValue()/100);\n    return val;\n    </valueCalculation>\n}\n"], ["findES5ComponentScope", "\nfunction () {\n    <scopeTraversal>\n    let scope = context.getScope();\n    while (scope) {\n        const node = scope.block && scope.block.parent && scope.block.parent.parent;\n        if (node && utils.isES5Component(node)) {\n            return node;\n        }\n        scope = scope.upper;\n    }\n    </scopeTraversal>\n    return null;\n}\n"], "```\n\nIn each annotated function, I've identified blocks of code with different responsibilities according to the Single Responsibility Principle. These blocks of code are delineated to highlight potentially separate concerns that could justify refactoring for better SRP compliance."]