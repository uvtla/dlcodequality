[["prepareColors", "\nfunction prepareColors(colors) {\n    Object.keys(colors).forEach(function (color) {\n        var code = colors[color],\n            replaced = replaceColors(code, colors);\n\n        if (replaced !== code) {\n            colors[color] = replaced;\n        }\n    });\n}\n"], ["getLatencyAndWait", "\nfunction getLatencyAndWait() {\n    var result = null;\n\n    if (isDestroyed) {\n        return Promise.resolve(result);\n    }\n\n    return getLatency(slave)\n        .then(function (latency) { result = latency })  \n        .catch(function (err)    { console.log(err) })  \n        .then(function () { return util.wait(DELAY) })  \n        .then(function () { return result});            \n}\n"], ["addFieldHandler", "\nfunction (handler, ns, name, type, id, from, options) {\n    var hand = new Strophe.Handler(handler, ns, name, type, id, from, options);\n    this.addHandlers.push(hand);\n    return hand;\n}\n"], ["drawHorizontalLegend", "\nfunction drawHorizontalLegend() {\n    let xOffset = markerSize;\n\n    svg.select('.legend-group')\n        .selectAll('g')\n        .remove();\n\n    \n    svg.select('.legend-group')\n        .append('g')\n        .classed('legend-line', true);\n\n    \n    entries = svg.select('.legend-line')\n        .selectAll('g.legend-entry')\n        .data(data);\n\n    \n    entries.enter()\n        .append('g')\n        .classed('legend-entry', true)\n        .attr('data-item', getId)\n        .attr('transform', function({name}) {\n            let horizontalOffset = xOffset,\n                lineHeight = chartHeight / 2,\n                verticalOffset = lineHeight,\n                labelWidth = textHelper.getTextWidth(name, textSize);\n\n            xOffset += markerSize + 2 * getLineElementMargin() + labelWidth;\n\n            return `translate(${horizontalOffset},${verticalOffset})`;\n        })\n        .merge(entries)\n        .append('circle')\n        .classed('legend-circle', true)\n        .attr('cx', markerSize/2)\n        .attr('cy', markerYOffset)\n        .attr('r', markerSize / 2)\n        .style('fill', getCircleFill)\n        .style('stroke-width', 1);\n\n    svg.select('.legend-group')\n        .selectAll('g.legend-entry')\n        .append('text')\n        .classed('legend-entry-name', true)\n        .text(getName)\n        .attr('x', getLineElementMargin())\n        .style('font-size', `${textSize}px`)\n        .style('letter-spacing', `${textLetterSpacing}px`);\n\n    \n    svg.select('.legend-group')\n        .selectAll('g.legend-entry')\n        .exit()\n        .transition()\n        .style('opacity', 0)\n        .remove();\n\n    adjustLines();\n}\n"], ["_findHandler", "\nasync function _findHandler(model, _id, request, Log) {\n  try {\n    let query = Object.assign({}, request.query)\n    try {\n      <preProcessing>\n      if (\n        model.routeOptions &&\n        model.routeOptions.find &&\n        model.routeOptions.find.pre\n      ) {\n        query = await model.routeOptions.find.pre(_id, query, request, Log)\n      }\n      </preProcessing>\n    } catch (err) {\n      handleError(err, 'There was a preprocessing error.', Boom.badRequest, Log)\n    }\n\n    let flatten = false\n    if (query.$flatten) {\n      flatten = true\n    }\n    delete query.$flatten\n    let mongooseQuery = model.findOne({ _id: _id })\n    mongooseQuery = QueryHelper.createMongooseQuery(\n      model,\n      query,\n      mongooseQuery,\n      Log\n    ).lean()\n    let result = await mongooseQuery.exec()\n    if (result) {\n      let data = result\n      try {\n        <postProcessing>\n        if (\n          model.routeOptions &&\n          model.routeOptions.find &&\n          model.routeOptions.find.post\n        ) {\n          data = await model.routeOptions.find.post(request, result, Log)\n        }\n        </postProcessing>\n      } catch (err) {\n        handleError(\n          err,\n          'There was a postprocessing error.',\n          Boom.badRequest,\n          Log\n        )\n      }\n      <handleAssociations>\n      if (model.routeOptions) {\n        let associations = model.routeOptions.associations\n        for (let associationKey in associations) {\n          let association = associations[associationKey]\n          if (association.type === 'ONE_MANY' && data[associationKey]) {\n            \n            result[associationKey] = data[associationKey]\n          }\n          if (association.type === 'MANY_MANY' && flatten === true) {\n            \n            if (result[associationKey]) {\n              result[associationKey] = result[associationKey].map(object => {\n                object = object[association.model]\n                return object\n              })\n            }\n          }\n        }\n      }\n      </handleAssociations>\n\n      <filterDeletedEmbeds>\n      if (config.enableSoftDelete && config.filterDeletedEmbeds) {\n        \n        filterDeletedEmbeds(result, {}, '', 0, Log)\n      }\n      </filterDeletedEmbeds>\n\n      Log.log('Result: %s', JSON.stringify(result))\n\n      return result\n    } else {\n      throw Boom.notFound('No resource was found with that id.')\n    }\n  } catch (err) {\n    handleError(err, null, null, Log)\n  }\n}\n"], ["labelTranslation", "\nfunction(doc_key, map_field, item_key){\n\n    var retlbl = null;\n\n    var map_str = anchor.get_doc_field(doc_key, map_field);\n\n    if( map_str && bbop.what_is(map_str) === 'string' ){\n\n        \n        <mapInitialization>\n        if( typeof(anchor._doc_label_maps[doc_key]) ===  'undefined'){\n            anchor._doc_label_maps[doc_key] = {};\n        }\n        if( typeof(anchor._doc_label_maps[doc_key][map_field]) === 'undefined'){\n            \n            \n            anchor._doc_label_maps[doc_key][map_field] =\n                JSON.parse(map_str);\n        }\n        </mapInitialization>\n\n        \n        var map = anchor._doc_label_maps[doc_key][map_field];\n\n        \n        if( map && map[item_key] ){\n            retlbl = map[item_key];\n        }\n    }\n\n    return retlbl;\n}\n"], ["bodyParsingAndValidation", "\nfunction body(ctx) {\n  if (['HEAD', 'GET'].indexOf(ctx.operation.spec.method) >= 0) return;\n\n  var consumeMimes = ctx.operation.spec.consumes ||\n    ctx.operation.resource.api.spec.consumes || [];\n  var mimes = lodash.intersection(consumeMimes,\n    Object.keys(ctx.router.decoder));\n  var prefix = describe(ctx);\n\n  if (!mimes.length) {\n    debug(prefix + 'body middleware disabled (no consumes)');\n    return;\n  }\n\n  var env = ctx.operation.resource.api.env;\n  var options = validateOptions(ctx.operation, 'form', false);\n  var schema = transform.parameters(ctx.operation.spec, 'body');\n\n  if (!schema) {\n    debug(prefix + 'body middleware disabled (no schema)');\n    return;\n  }\n\n  return function(req, res, next) {\n    var mime = is(req, mimes);\n    var bodyErr;\n\n    if (mime) {\n      var body;\n\n      if (req.sf.text) {\n        try {\n          body = ctx.router.decoder[mime](req.sf.text);\n        } catch (err) {\n          debug(prefix + 'body decoder failed', err);\n\n          bodyErr = new Error('Decode body failed');\n          bodyErr.statusCode = 400;\n          bodyErr.parent = err;\n          bodyErr.expose = true;\n\n          return next(bodyErr);\n        }\n      } else if (schema.required) {\n        bodyErr = new Error('Body required');\n        bodyErr.statusCode = 400;\n        bodyErr.expose = true;\n\n        return next(bodyErr);\n      } else {\n        return next();\n      }\n\n      req.sf.body = body;\n\n      if (validate(res, env.validate(schema, { body: body }, options))) {\n        next();\n      }\n    } else if (schema.required) {\n      bodyErr = new Error('Body required');\n      bodyErr.statusCode = 400;\n      bodyErr.expose = true;\n\n      return next(bodyErr);\n    } else {\n      next();\n    }\n  };\n}\n"], ["returnModelOrCreateError", "\nfunction(attrs, options) {\n    if (attrs instanceof Model) return attrs;\n    options = options ? _.clone(options) : {};\n    options.collection = this;\n    var model = new this.model(attrs, options);\n    if (!model.validationError) return model;\n    this.trigger('invalid', this, model.validationError, options);\n    return false;\n}\n"], ["seriesResolver", "\nasync function series(resolvers){\n    \n    const results = [];\n\n    \n    for (const r of resolvers){\n        results.push(await r.resolve());\n    }\n\n    \n    return results;\n}\n"], ["paginateList", "\nfunction paginateList(formSubmissionModel, params, callback) {\n    logger.debug(\"paginateList\", params);\n    var query = params.query || {};\n    var paginate = params.paginate || {};\n    var fieldModel = params.fieldModel;\n\n    \n    var sortBy = params.sortBy || {\n        submissionCompletedTimestamp: -1\n    };\n\n    formSubmissionModel.paginate(query, {\n        page: paginate.page,\n        limit: paginate.limit,\n        select: CONSTANTS.SUBMISSION_SUMMARY_FIELD_SELECTION,\n        populate: {\"path\": \"formFields.fieldId\", \"model\": fieldModel, \"select\": \"_id type name\"},\n        sortBy: sortBy,\n        lean: true\n    }, function(err, submissionsResult) {\n\n        \n        var paginationResult = _.extend({\n            pages: submissionsResult.pages,\n            total: submissionsResult.total\n        }, params);\n\n        handleListResult(err, paginationResult, submissionsResult.docs, callback);\n    });\n}\n"], "```"]