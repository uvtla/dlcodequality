[["function1", "\nfunction(str, filter, settings) {\n  <determine_style>\n  var style;\n  if (filter.hasStyle() && settings.style.isOverrideAllowed) {\n    style = _.findWhere(settings.styles, { name: filter.style });\n  }\n  if (_.isUndefined(style)) {\n    style = settings.style;\n  }\n  </determine_style>\n  \n  <determine_replacement>\n  var repl;\n  if (!settings.isRandom && style.hasFixed(filter.word)) {\n    repl = style.getFixed(filter.word);\n  } else {\n    repl = generateGrawlix(str, filter, style);\n  }\n  </determine_replacement>\n  \n  <apply_template_if_needed>\n  if (filter.hasTemplate()) {\n    repl = filter.template(repl);\n  }\n  </apply_template_if_needed>\n  \n  return str.replace(filter.regex, repl);\n}\n"], ["function2", "\nfunction(keepCurrentModal) {\n\t\t\t<restore_focus_and_state>\n\t\t\tlib.returnFocus(this.$frameParent, this.$originalFocus, function() {\n\t\t\t\tif(!keepCurrentModal && modalDialogManager.dialog === this) {\n\t\t\t\t\tmodalDialogManager.dialog = null;\n\t\t\t\t}\n\t\t\t\tif (typeof this._beforeHiding === \"function\") { \n\t\t\t\t\tthis._beforeHiding();\n\t\t\t\t}\n\t\t\t\tif (this._modalListener) {\n\t\t\t\t\tthis.$frameParent.removeEventListener(\"focus\", this._modalListener, true);  \n\t\t\t\t\tthis.$frameParent.removeEventListener(\"click\", this._modalListener, true);  \n\t\t\t\t}\n\t\n\t\t\t\tthis.$frame.classList.remove(\"dialogShowing\"); \n\t\t\t\tlib.setFramesEnabled(true);\n\t\t\t\tif (typeof this._afterHiding === \"function\") { \n\t\t\t\t\tthis._afterHiding();\n\t\t\t\t}\n\t\t\t}.bind(this));\n\t\t\t</restore_focus_and_state>\n\t\t\t<destroy_modal_if_needed>\n\t\t\tvar self = this;\n\t\t\tif (!this.keepAlive) {\n\t\t\t\twindow.setTimeout(function() { self.destroy(); }, 0);\n\t\t\t}\n\t\t\t</destroy_modal_if_needed>\n\t\t}\n"], ["function3", "\nfunction responseCallback(response, model, success) {\n        \n        <record_response>\n        responses[model.cid] = {\n            success: success,\n            response: response\n          };\n        </record_response>\n        \n        <handle_responses_completion>\n        if (responsesFailed + responsesSucceeded === numberOfSaves) {\n          <handle_failures>\n          if (responsesFailed > 0) {\n            <rollback_changes_if_needed>\n            if (options.rollback) {\n              _.each(formModel.getTrackedModels(), function(model) {\n                model.set(oldValues[model.cid]);\n                if (responses[model.cid].success) {\n                  model.save();\n                }\n              });\n            }\n            </rollback_changes_if_needed>\n            formModel.trigger('save-fail', responses);\n            deferred.reject(responses);\n          </handle_failures>\n          } else {\n            formModel.trigger('save-success', responses);\n            deferred.resolve(responses);\n          }\n        }\n        </handle_responses_completion>\n      }\n"], ["function4", "\nfunction _get_npm_installed_path(){\n\tvar path_arr, npm_installed_path;\n\t\n\tpath_arr = __dirname.split('/');\n\tpath_arr.pop();\n\treturn path_arr.join(\"/\");\n}\n"], ["parseSLComment", "\nfunction parseSLComment(css) {\n    var start = pos;\n\n    <parse_until_end_of_comment>\n    for (pos += 2; pos < css.length; pos++) {\n      if (css.charAt(pos) === '\\n' || css.charAt(pos) === '\\r') {\n        break;\n      }\n    }\n    </parse_until_end_of_comment>\n\n    <record_comment_token>\n    pushToken(TokenType.CommentSL, css.substring(start, pos--), col);\n    col += pos - start;\n    </record_comment_token>\n  }\n"], ["firstOf", "\nfunction firstOf(items, evaluate) {\n  return new Promise((accept, reject) => {\n    (function next(i) {\n      <iterate_until_condition_met>\n      if (i >= items.length) {\n        accept(null);\n        return;\n      }\n\n      setImmediate(() => evaluate(items[i], (err, value) => {\n        if (err) {\n          reject(err);\n        } else if (value) {\n          accept(value);\n        } else {\n          next(i + 1);\n        }\n      }));\n      </iterate_until_condition_met>\n    })(0);\n  });\n}\n"], ["function7", "\nfunction (logicalPath) {\n        <generate_scripts_tags>\n        var assets = self.getAssetsForLogicalPath(logicalPath);\n        return assets.map(function (asset) {\n          return '<script src=\"' + self.prefix + '/' + asset + '\"></script>';\n        }).join('\\n');\n        </generate_scripts_tags>\n      }\n"], ["assert", "\nfunction assert(condition, message, strings) {\n        <throw_error_if_condition_false>\n        if (!condition) {\n            var err = _.template(message);\n            throw \"[MetaModelManager] \" + err(strings);\n        }\n        </throw_error_if_condition_false>\n    }\n"], ["function9", "\nfunction() {\n            var headerID = this.id + '__header';\n            var $header = this.$pinny.find('h1, .' + classes.TITLE).first();\n            var $wrapper = this.$pinny.find('.' + classes.WRAPPER);\n\n            <update_aria_and_role_attributes>\n            this.$container.attr('aria-hidden', 'false');\n\n            this.$pinny\n                .attr('role', 'dialog')\n                .attr('aria-labelledby', headerID)\n                .attr('aria-hidden', 'true')\n                .attr('tabindex', '-1');\n\n            $wrapper\n                .attr('role', 'document');\n\n            $header\n                .attr('id', headerID);\n            </update_aria_and_role_attributes>\n        }\n"], ["function10", "\nfunction createNamespaceTree() {\n\t<create_namespace_tree_logic>\n\tinfo(\"create namespace tree (\" + __db().count() + \" symbols)\");\n\n\tvar aRootNamespaces = [];\n\tvar aTypes = __db(function() { return isFirstClassSymbol(this); }).get();\n\n\tfor (var i = 0; i < aTypes.length; i++) { \n\n\t\tvar symbol = aTypes[i];\n\t\tif ( symbol.memberof ) {\n\n\t\t\tvar parent = lookup(symbol.memberof);\n\t\t\tif ( !parent ) {\n\t\t\t\twarning(\"create missing namespace '\" + symbol.memberof + \"' (referenced by \" + symbol.longname + \")\");\n\t\t\t\tparent = makeNamespace(symbol.memberof);\n\t\t\t\t__longnames[symbol.memberof] = parent;\n\t\t\t\t__db.insert(parent);\n\t\t\t\taTypes.push(parent); \n\t\t\t}\n\t\t\tsymbol.__ui5.parent = parent;\n\t\t\tparent.__ui5.children = parent.__ui5.children || [];\n\t\t\tparent.__ui5.children.push(symbol);\n\n\t\t} else if ( symbol.longname !== ANONYMOUS_LONGNAME ) {\n\n\t\t\taRootNamespaces.push(symbol);\n\n\t\t}\n\t}\n\n\treturn aRootNamespaces;\n\t</create_namespace_tree_logic>\n}\n"], "```\n\nFor function 1, 2, 3, 5, 7, and 10, I have annotated multiple responsibilities within the function, which means they are possibly violating the SRP. Functions 4, 6, 8, and 9 appear to have a single responsibility, hence no nested tags are needed."]