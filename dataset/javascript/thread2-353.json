[["hasField", "\nfunction hasField(selection, fieldNames) {\n  if (!selection || selection.type === 'empty') {\n    return false;\n  }\n  const fieldsToLookup = [].concat(fieldNames);\n\n  if (selection.type === 'range') {\n    const fields = Object.keys(selection.range.variables);\n    const match = intersect(fieldsToLookup, fields);\n    return match.length > 0;\n  }\n  if (selection.type === 'partition') {\n    return fieldsToLookup.indexOf(selection.partition.variable) !== -1;\n  }\n\n  console.log(\n    'SelectionBuilder::hasField does not handle selection of type',\n    selection.type\n  );\n\n  return false;\n}\n"], ["fold", "\nfunction fold(count, buf)\n{\n  if(!count || buf.length % 2) return buf;\n  var ret = buf.slice(0,buf.length/2);\n  for(i = 0; i < ret.length; i++) ret[i] = ret[i] ^ buf[i+ret.length];\n  return fold(count-1,ret);\n}\n"], ["asyncFunction", "\nasync function() {\n    const oThis = this\n      , existingBrandedTokens = await oThis._loadBrandedTokenConfig()\n    ;\n\n    if (existingBrandedTokens[oThis.uuid]) {\n      logger.error(\"* Branded token uuid already registered and present in BT config file\");\n      process.exit(1);\n    }\n\n    existingBrandedTokens[oThis.uuid] = {\n      Name: oThis.btName,\n      Symbol: oThis.btSymbol,\n      ConversionFactor: oThis.btConversionFactor,\n      Reserve: oThis.reserveAddress,\n      ReservePassphrase: oThis.reservePassphrase,\n      UUID: oThis.uuid,\n      ERC20: oThis.erc20\n    };\n\n    logger.info(\"* Branded token config:\", existingBrandedTokens[oThis.uuid]);\n\n    return tokenHelper.addBrandedToken(existingBrandedTokens);\n  }\n"], ["unknownFunction", "\nfunction ( sx ) {\n  if( !this.autoWidth ) return;\n  this.w = sx;\n  if( this.simple ){\n    this.sb = this.w - this.sa;\n  } else {\n    var pp = this.w * ( this.p / 100 );\n    this.sa = Math.floor( pp + 10 );\n    this.sb = Math.floor( this.w - pp - 20 );\n  }\n}\n"], ["Heap", "\nfunction Heap(compare) {\n  if (!(this instanceof Heap))\n    return new Heap(compare);\n  this.items = [];\n  <setComparer>\n  this.compare = comparator;\n  if (compare)\n    this.set(compare);\n  </setComparer>\n}\n"], ["isEqual", "\nfunction (list) {\n  if (list.size() !== this.size()) {\n    return false;\n  }\n  var isEqual = true,\n      a, b;\n  for (var i = 0; i < this.$items.length; i++) {\n    a = this.$items[i];\n    b = list.at(i);\n    if (a instanceof Bindable && b instanceof Bindable) {\n      if (!a.isDeepEqual(b)) {\n        return false;\n      }\n    } else if (a instanceof Bindable || b instanceof Bindable) {\n      return false;\n    } else {\n      isEqual = _.isEqual(a, b);\n    }\n  }\n  return isEqual;\n}\n"], ["containsWithoutPseudos", "\nfunction containsWithoutPseudos(selector, potentialMatch) {\n  var classesInPotentialMatch = getCssClasses(potentialMatch).map(stripPseudos)\n  return classesInPotentialMatch.some(function (c) {\n    return selector === c\n  })\n}\n"], ["getInstance", "\nfunction(configStrategy) {\n    let instanceKey = getInstanceKey(configStrategy);\n\n    let _instance = instanceMap[instanceKey];\n\n    if (!_instance) {\n      _instance = new OSTCache(configStrategy);\n      instanceMap[instanceKey] = _instance;\n    }\n\n    return _instance;\n  }\n"], ["safelyRenderSubtree", "\nfunction (parentComponent, nextElement, container, callback) {\n    <validateReactComponent>\n    !(parentComponent != null && ReactInstanceMap.has(parentComponent)) ? \"development\" !== 'production' ? invariant(false, 'parentComponent must be a valid React Component') : _prodInvariant('38') : void 0;\n    </validateReactComponent>\n    return ReactMount._renderSubtreeIntoContainer(parentComponent, nextElement, container, callback);\n  }\n"], ["indexOfFilter", "\nfunction indexOfFilter(input, filter, startingPos) {\n  if (filter.length > input.length) {\n    return -1;\n  }\n\n  let filterParts = filter.split('^');\n  let index = startingPos;\n  let beginIndex = -1;\n  let prefixedSeparatorChar = false;\n\n  for (let f = 0; f < filterParts.length; f++) {\n    if (filterParts[f] === '') {\n      prefixedSeparatorChar = true;\n      continue;\n    }\n\n    index = input.indexOf(filterParts[f], index);\n    if (index === -1) {\n      return -1;\n    }\n    if (beginIndex === -1) {\n      beginIndex = index;\n    }\n\n    if (prefixedSeparatorChar) {\n      if (separatorCharacters.indexOf(input[index - 1]) === -1) {\n        return -1;\n      }\n    }\n    \n    if (f + 1 < filterParts.length &&\n        input.length > index + filterParts[f].length) {\n      if (separatorCharacters.indexOf(input[index + filterParts[f].length]) === -1) {\n        return -1;\n      }\n    }\n\n    prefixedSeparatorChar = false;\n  }\n  return beginIndex;\n}\n"], ""]