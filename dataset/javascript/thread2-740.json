[["createAotCompiler", "\nfunction createAotCompiler(compilerHost, options) {\n    <initializeCompilerResources>\n    var translations = options.translations || '';\n    var urlResolver = createOfflineCompileUrlResolver();\n    var symbolCache = new StaticSymbolCache();\n    var summaryResolver = new AotSummaryResolver(compilerHost, symbolCache);\n    var symbolResolver = new StaticSymbolResolver(compilerHost, symbolCache, summaryResolver);\n    var staticReflector = new StaticReflector(summaryResolver, symbolResolver);\n    StaticAndDynamicReflectionCapabilities.install(staticReflector);\n    var console = new __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_37\" ]();\n    var htmlParser = new I18NHtmlParser(new HtmlParser(), translations, options.i18nFormat, __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_7\" ].Warning, console);\n    var config = new CompilerConfig({\n        defaultEncapsulation: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"K\" ].Emulated,\n        useJit: false,\n        enableLegacyTemplate: options.enableLegacyTemplate !== false,\n    });\n    var normalizer = new DirectiveNormalizer({ get: function (url) { return compilerHost.loadResource(url); } }, urlResolver, htmlParser, config);\n    var expressionParser = new Parser(new Lexer());\n    var elementSchemaRegistry = new DomElementSchemaRegistry();\n    var tmplParser = new TemplateParser(config, expressionParser, elementSchemaRegistry, htmlParser, console, []);\n    var resolver = new CompileMetadataResolver(config, new NgModuleResolver(staticReflector), new DirectiveResolver(staticReflector), new PipeResolver(staticReflector), summaryResolver, elementSchemaRegistry, normalizer, console, symbolCache, staticReflector);\n    </initializeCompilerResources>\n    \n    <setupImportResolver>\n    var importResolver = {\n        getImportAs: function (symbol) { return symbolResolver.getImportAs(symbol); },\n        fileNameToModuleName: function (fileName, containingFilePath) { return compilerHost.fileNameToModuleName(fileName, containingFilePath); },\n        getTypeArity: function (symbol) { return symbolResolver.getTypeArity(symbol); }\n    };\n    </setupImportResolver>\n    \n    <initializeViewCompiler>\n    var viewCompiler = new ViewCompiler(config, elementSchemaRegistry);\n    </initializeViewCompiler>\n    \n    <assembleCompiler>\n    var compiler = new AotCompiler(config, compilerHost, resolver, tmplParser, new StyleCompiler(urlResolver), viewCompiler, new NgModuleCompiler(), new TypeScriptEmitter(importResolver), summaryResolver, options.locale, options.i18nFormat, options.genFilePreamble, symbolResolver);\n    </assembleCompiler>\n    \n    return { compiler: compiler, reflector: staticReflector };\n}\n"], ["age", "\nfunction age(time, k, bool) {\n    <initialSetup>\n    let d = bool ? time : Math.abs(Date.now()/1000 - time);\n    let o = '';\n    let r = {};\n    let c = 0;\n    </initialSetup>\n    <defineTimeUnits>\n    const s = {\n      year: 31536000,\n      month: 2592000,\n      week: 604800,\n      day: 86400,\n      hour: 3600,\n      minute: 60,\n      second: 1\n    }\n    </defineTimeUnits>\n\n    <calculateTimeComponents>\n    Object.keys(s).forEach(function(i){\n      r[i] = Math.floor(d / s[i]);\n      d -= r[i] * s[i];\n      if (r[i] && c<k) {\n        c++;\n        o += ` ${r[i]} ${i}${r[i] > 1 ? 's':''}`;\n      }\n    });\n    </calculateTimeComponents>\n    \n    return `${o}${bool ? '':' ago'}`;\n}\n"], ["generateHtml", "\nfunction generateHtml(node) {\n    <handleReactElements>\n    if (isReactElement(node)) {\n        return _react2.default.renderToString(node);\n    } </handleReactElements>\n    <handleReactFragments>\n    else if (isReactFragment(node)) {\n        var htmlStr = '';\n        node.map(function (child) {\n            htmlStr += generateHtml(child);\n        });\n        return htmlStr;\n    } </handleReactFragments>\n    <handleReactText>\n    else if (isReactText(node)) {\n        return String(node);\n    } </handleReactText>\n    <handleReactEmpty>\n    else if (isReactEmpty(node)) {\n        return '';\n    }\n    </handleReactEmpty>\n\n    <trySerializeNodeToJson>\n    try {\n        return JSON.stringify(node);\n    } catch (err) {\n        console.error('stringify error:', err.message);\n        return node;\n    }\n    </trySerializeNodeToJson>\n}\n"], ["handleBreakContext", "\nfunction() {\n    var context = this.breakContext;\n    var forkContext = this.forkContext;\n\n    this.breakContext = context.upper;\n\n    <handleNonBreakableContext>\n    if (!context.breakable) {\n        var brokenForkContext = context.brokenForkContext;\n\n        if (!brokenForkContext.empty) {\n            brokenForkContext.add(forkContext.head);\n            forkContext.replaceHead(brokenForkContext.makeNext(0, -1));\n        }\n    }\n    </handleNonBreakableContext>\n    \n    return context;\n}\n"], ["options", "\nfunction(options){\n    <setDefaultOptions>\n    if (!arguments.length) {\n        options = scope.options;\n    } else {\n        scope.options = options;\n        if (scope._config.deepWatchOptions && !scope._config.disabled) return;\n    }\n    </setDefaultOptions>\n    \n    <clearElement>\n    scope.api.clearElement();\n    </clearElement>\n    \n    <checkOptionsDefined>\n    if (angular.isDefined(options) === false) return;  \n    </checkOptionsDefined>\n    \n    <verifyConfigVisibility>\n    if (!scope._config.visible) return;\n    </verifyConfigVisibility>\n    \n    <initChartModel>\n    scope.chart = nv.models[options.chart.type]();\n    scope.chart.id = Math.random().toString(36).substr(2, 15);\n    </initChartModel>\n    \n    <configureChartComponents>\n    angular.forEach(scope.chart, function(value, key){/*...*/ /* omitted for brevity */});\n    </configureChartComponents>\n    \n    <updateWithData>\n    scope.api.updateWithData();\n    </updateWithData>\n    \n    <configureChartWrappers>\n    if (options['title'] || scope._config.extended) configureWrapper('title');\n    if (options['subtitle'] || scope._config.extended) configureWrapper('subtitle');\n    if (options['caption'] || scope._config.extended) configureWrapper('caption');\n    </configureChartWrappers>\n    \n    <configureChartStyles>\n    if (options['styles'] || scope._config.extended) configureStyles();\n    </configureChartStyles>\n    \n    <finalizeChartSetup>\n    nv.addGraph(/*...*/ /* omitted for brevity */);\n    </finalizeChartSetup>\n}\n"], ["formatsToJSON", "\nfunction formatsToJSON(attrs, options) {\n    <filterFormats>\n    var defaultFormats = ['html'],\n        formatsToKeep = options.formats || defaultFormats;\n\n    _.each(Post.allowedFormats, function (format) {\n        if (formatsToKeep.indexOf(format) === -1) {\n            delete attrs[format];\n        }\n    });\n    </filterFormats>\n\n    return attrs;\n}\n"], ["verifyRelativeDirection", "\nfunction verifyRelativeDirection(direction) {\n    <validateDirection>\n    if (!RELATIVE_DIRECTIONS.includes(direction)) {\n        throw new Error(\n          `Unknown direction: '${direction}'. Should be one of: '${FORWARD}', '${RIGHT}', '${BACKWARD}' or '${LEFT}'.`,\n        );\n    }\n    </validateDirection>\n}\n"], ["translate", "\nfunction translate(cond, queryObj) {\n    let result = '1 == 1';\n\n    <handleConditionType>\n    if (!Array.isArray(cond)) {\n        if (cond.and) {\n            result = translateAndList(cond.and, queryObj)\n        }\n        else if (cond.or) {\n            result = translateOrList(cond.or, queryObj)\n        }\n        else {\n            throw new Error('Invalid query Object keys. Objects must be either \"and\" or \"or\"');\n        }\n    }\n    </handleConditionType>\n    <translateArrayCondition>\n    else {\n        assert(cond.length === 3, 'Invalid condition item. Condition items must be an array of 3 items representing field, comparator, and value')\n        let fieldName = cond[0];\n        // ... rest of the logic omitted for brevity\n    }\n    </translateArrayCondition>\n\n    return result;\n}\n"], ["fetchAll", "\nfunction(options) {\n    <logQueryActivity>\n    debug.trace('fetchAll %s', JSON.stringify(options));\n    </logQueryActivity>\n    <prepareOptions>\n    options = _.clone(options) || {};\n    </prepareOptions>\n    options.action = 'read';\n    var self = this;\n    <handleErrorSetup>\n    function handleError(err) {\n      if (options.ignoreFailures) {\n        return when.resolve(self);\n      }\n      return when.reject(err);\n    }\n    </handleErrorSetup>\n    <fetchDataWithRelations>\n    return this\n      .fetch(options)\n      .then(function() {\n        if (!self.relationDefinitions) {\n          return self;\n        }\n        return self\n          .fetchRelations(options)\n          .then(function() {\n            return self;\n          }, handleError);\n      }, handleError);\n    </fetchDataWithRelations>\n}\n"], ["timedLog", "\nfunction timedLog(msg) {\n    <logWithTimestamp>\n    console.log(Date.now() + \":\" + window.performance.now() + \": \" + msg);\n    </logWithTimestamp>\n}\n"], "```"]