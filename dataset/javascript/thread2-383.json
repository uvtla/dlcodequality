[["fetchDataAndUpdateCollection", "\nfunction(db, namespace) { \n    var collection = this;\n    <triggerRequestEvent>\n    collection.trigger('request', collection); \n    </triggerRequestEvent>\n    <fetchData>\n    fetch(db, namespace, function(err, res) { \n      <handleFetchError>\n      if (err) { \n        throw err;\n      }\n      </handleFetchError>\n      <resetCollection>\n      collection.reset(res, {parse: true}); \n      </resetCollection>\n      <triggerSyncEvent>\n      collection.trigger('sync', collection);\n      </triggerSyncEvent>\n    });\n    </fetchData>\n    return collection;\n}\n"], ["bindFrameBuffer", "\nfunction (renderer) {\n\n        if (renderer.__currentFrameBuffer) {\n            <frameBufferCheck>\n            if (renderer.__currentFrameBuffer === this) {\n                return;\n            }\n\n            console.warn('Renderer already bound with another framebuffer. Unbind it first');\n            </frameBufferCheck>\n        }\n        <setCurrentFrameBuffer>\n        renderer.__currentFrameBuffer = this;\n        </setCurrentFrameBuffer>\n\n        var _gl = renderer.gl;\n\n        <bindGLFrameBuffer>\n        _gl.bindFramebuffer(GL_FRAMEBUFFER, this._getFrameBufferGL(renderer));\n        </bindGLFrameBuffer>\n        this._boundRenderer = renderer;\n        var cache = this._cache;\n\n        <cacheViewport>\n        cache.put('viewport', renderer.viewport);\n        </cacheViewport>\n\n        var hasTextureAttached = false;\n        var width;\n        var height;\n        <attachTextures>\n        for (var attachment in this._textures) {\n            hasTextureAttached = true;\n            var obj = this._textures[attachment];\n            if (obj) {\n                width = obj.texture.width;\n                height = obj.texture.height;\n                this._doAttach(renderer, obj.texture, attachment, obj.target);\n            }\n        }\n        </attachTextures>\n\n        this._width = width;\n        this._height = height;\n\n        <checkTextureAttachment>\n        if (!hasTextureAttached && this.depthBuffer) {\n            console.error('Must attach texture before bind, or renderbuffer may have incorrect width and height.');\n        }\n        </checkTextureAttachment>\n\n        <setViewport>\n        if (this.viewport) {\n            renderer.setViewport(this.viewport);\n        }\n        else {\n            renderer.setViewport(0, 0, width, height, 1);\n        }\n        </setViewport>\n\n        <detachTextures>\n        var attachedTextures = cache.get('attached_textures');\n        if (attachedTextures) {\n            for (var attachment in attachedTextures) {\n                if (!this._textures[attachment]) {\n                    var target = attachedTextures[attachment];\n                    this._doDetach(_gl, attachment, target);\n                }\n            }\n        }\n        </detachTextures>\n        <setupRenderbuffer>\n        if (!cache.get(KEY_DEPTHTEXTURE_ATTACHED) && this.depthBuffer) {\n            if (cache.miss(KEY_RENDERBUFFER)) {\n                cache.put(KEY_RENDERBUFFER, _gl.createRenderbuffer());\n            }\n            var renderbuffer = cache.get(KEY_RENDERBUFFER);\n            if (width !== cache.get(KEY_RENDERBUFFER_WIDTH)\n                    || height !== cache.get(KEY_RENDERBUFFER_HEIGHT)) {\n                _gl.bindRenderbuffer(GL_RENDERBUFFER, renderbuffer);\n                _gl.renderbufferStorage(GL_RENDERBUFFER, _gl.DEPTH_COMPONENT16, width, height);\n                cache.put(KEY_RENDERBUFFER_WIDTH, width);\n                cache.put(KEY_RENDERBUFFER_HEIGHT, height);\n                _gl.bindRenderbuffer(GL_RENDERBUFFER, null);\n            }\n            if (!cache.get(KEY_RENDERBUFFER_ATTACHED)) {\n                _gl.framebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_RENDERBUFFER, renderbuffer);\n                cache.put(KEY_RENDERBUFFER_ATTACHED, true);\n            }\n        }\n        </setupRenderbuffer>\n    }\n"], ["renderLoginRegister", "\nfunction renderLoginRegister(req, res) {\n    <createUrl>\n    var root = sandbox.helpers.url('', true, req.secure);\n    if (req.subdomain) {\n      root = root.replace(':');\n    }\n    </createUrl>\n\n    <checkUserSession>\n    if (req.session.user) {\n      return res.redirect(root);\n    }\n    </checkUserSession>\n\n    <handleFirstTimeLogin>\n    if (req.query.firsttime) {\n      res.flash(\n        req.flash.NOTIFICATION,\n        'We\\'ve <a target=\"_blank\" href=\"/blog/ssl\"><strong>upgraded our login process to use SSL</strong></a>, however, this does mean  you have been logged out today, so please could you log in again below.<br><br><a href=\"http:');\n    }\n    </handleFirstTimeLogin>\n\n    <collectFlashMessages>\n    var info = req.flash(req.flash.INFO),\n      error = req.flash(req.flash.ERROR),\n      notification = req.flash(req.flash.NOTIFICATION);\n    var flash = error || notification || info;\n    </collectFlashMessages>\n    <determineEnvironment>\n    var production =\n      req.cookies && req.cookies.debug ? false : sandbox.helpers.production;\n    </determineEnvironment>\n\n    <renderResponse>\n    res.render('register-login', {\n      flash: flash,\n      token: req.csrfToken(),\n      layout: 'sub/layout.html',\n      referrer: req.flash(req.flash.REFERER) || req.get('referer'),\n      root: root,\n      static: sandbox.helpers.urlForStatic('', req.secure),\n      show: req.url.indexOf('/register') !== -1 ? 'register' : 'login',\n      forgotten: !!req.query.forgotten || !!undefsafe(req, 'body.forgotten'),\n      email: req.query.email || undefsafe(req, 'body.email'),\n    });\n    </renderResponse>\n  }\n"], ["getBidiStreamingListener", "\nfunction _getBidiStreamingListener(method_definition, emitter) {\n  var deserialize = common.wrapIgnoreNull(\n    method_definition.responseDeserialize);\n  <createStreamListener>\n  return {\n    onReceiveMetadata: function (metadata) {\n      emitter.emit('metadata', metadata);\n    },\n    onReceiveMessage: function(message, next, context) {\n      <handleReadStream>\n      if (emitter.push(message) && message !== null) {\n        var call = context.call;\n        var get_listener = function() {\n          return context.listener;\n        };\n        var read_batch = {};\n        read_batch[grpc.opType.RECV_MESSAGE] = true;\n        call.startBatch(read_batch, _getStreamReadCallback(emitter, call,\n          get_listener, deserialize));\n      } else {\n        emitter.reading = false;\n      }\n      </handleReadStream>\n    },\n    onReceiveStatus: function (status) {\n      emitter._receiveStatus(status);\n    }\n  };\n  </createStreamListener>\n}\n"], ["filterAttributes", "\nfunction(attrs) {\n      <createOptionsObject>\n      var options = {};\n      </createOptionsObject>\n      <sanitizeAttributes>\n      for(var key in attrs) {\n        if (key.match(/^\\$/) || key.match(/^ng[A-Z]/)) {\n          <ignoreFrameworkAttributes>\n          void(0);\n          </ignoreFrameworkAttributes>\n        } else {\n          <accumulateValidOptions>\n          options[key] = attrs[key];\n          </accumulateValidOptions>\n        }\n      }\n      </sanitizeAttributes>\n      return options;\n    }\n"], ["checkKeyEvent", "\nfunction (evt) {\n        <checkForKeyMask>\n        if(this.keyMask == null) {\n            return true;\n        }\n        </checkForKeyMask>\n        \n        <computeKeyModifiers>\n        var keyModifiers =\n            (evt.shiftKey ? OpenLayers.Handler.MOD_SHIFT : 0) |\n            (evt.ctrlKey  ? OpenLayers.Handler.MOD_CTRL  : 0) |\n            (evt.altKey   ? OpenLayers.Handler.MOD_ALT   : 0) |\n            (evt.metaKey  ? OpenLayers.Handler.MOD_META  : 0);\n        </computeKeyModifiers>\n    \n        <evaluateModifiersAgainstMask>\n        return (keyModifiers == this.keyMask);\n        </evaluateModifiersAgainstMask>\n    }\n"], ["showContentInModal", "\nfunction(content) {\n        \n        <bypassOnTrueContent>\n        if (content === true) {\n            return;\n        }\n        </bypassOnTrueContent>\n\n        <handleBlackoutLoader>\n        if (this.blackout) {\n            this.blackout.hideLoader();\n        }\n        </handleBlackoutLoader>\n\n        <fireShowingEvent>\n        this.fireEvent('showing');\n        </fireShowingEvent>\n\n        <updateContentOnElement>\n        var body = this.element.find(this.ns('content'));\n            body.html(content);\n        </updateContentOnElement>\n\n        <fireLoadEvent>\n        this.fireEvent('load', [content]);\n        </fireLoadEvent>\n\n        <revealElement>\n        this.element.reveal();\n        </revealElement>\n\n        <applyFullScreenStyling>\n        if (this.options.fullScreen) {\n            body.css('min-height', $(window).height());\n        }\n        </applyFullScreenStyling>\n\n        <fireShownEvent>\n        this.fireEvent('shown');\n        </fireShownEvent>\n    }\n"], ["lookupDefinitionByName", "\nfunction (bodySchemaModels, defName) {\n        <findDefinitionInCollection>\n        for (var i in bodySchemaModels) {\n            if (bodySchemaModels[i][\"name\"] == defName) {\n                return bodySchemaModels[i];\n            }\n        }\n        </findDefinitionInCollection>\n        return null;\n    }\n"], ["equalsPixel", "\nfunction(px) {\n        <checkPixelEquality>\n        var equals = false;\n        if (px != null) {\n            equals = ((this.x == px.x && this.y == px.y) ||\n                      (isNaN(this.x) && isNaN(this.y) && isNaN(px.x) && isNaN(px.y)));\n        }\n        </checkPixelEquality>\n        return equals;\n    }\n"], ["popRandomKey", "\nfunction spop() {\n  <selectRandomKey>\n  var ind = Math.floor(Math.random() * this._keys.length)\n    , val = this._keys[ind];\n  </selectRandomKey>\n  <deleteKeyAndReturnValue>\n  this.delKey(val);\n  return val;\n  </deleteKeyAndReturnValue>\n}\n"], "```"]