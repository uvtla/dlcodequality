[["_biDimensionalArrayToObject", "\nfunction _biDimensionalArrayToObject(aArr) {\n    var obj = {},\n      nIndex,\n      nLen = aArr.length,\n      oItem;\n    for (nIndex = 0; nIndex < nLen; nIndex++) {\n      oItem = aArr[nIndex];\n      obj[oItem[0]] = oItem[1];\n    }\n    return obj;\n}\n"], ["mergeAncestorElementsOfSelectionEnds", "\nfunction mergeAncestorElementsOfSelectionEnds( range, blockLimit, startPath, endPath ) {\n\t<initializeWalker>\n\t\tvar walkerRange = range.clone(),\n\t\t\twalker, nextNode, previousNode;\n\t\twalkerRange.setEndAt( blockLimit, CKEDITOR.POSITION_BEFORE_END );\n\t\twalker = new CKEDITOR.dom.walker( walkerRange );\n\t</initializeWalker>\n\n\t<mergeElements>\n\t\tif ( ( nextNode = walker.next() ) &&\t\t\t\t\t\t\t\n\t\t\tcheckIfElement( nextNode ) &&\t\t\t\t\t\t\t\t\n\t\t\tblockMergedTags[ nextNode.getName() ] &&\t\t\t\t\t\n\t\t\t( previousNode = nextNode.getPrevious() ) &&\t\t\t\t\n\t\t\tcheckIfElement( previousNode ) &&\t\t\t\t\t\t\t\n\t\t\t!previousNode.getParent().equals( range.startContainer ) && \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\tstartPath.contains( previousNode ) &&\t\t\t\t\t\t\n\t\t\tendPath.contains( nextNode ) &&\t\t\t\t\t\t\t\t\n\t\t\tnextNode.isIdentical( previousNode ) )\t\t\t\t\t\t\n\t\t{\n\t\t\t\n\t\t\tnextNode.moveChildren( previousNode );\n\t\t\tnextNode.remove();\n\t\t\tmergeAncestorElementsOfSelectionEnds( range, blockLimit, startPath, endPath );\n\t\t}\n\t</mergeElements>\n}\n"], ["mean", "\nfunction mean(input) {\n    <validateInput>\n\t\tif (!Array.isArray(input)) {\n\t\t\tthrow new Error('input must be an array');\n\t\t}\n\n\t\tif (input.length === 0) {\n\t\t\tthrow new Error('input must not be empty');\n\t\t}\n\t</validateInput>\n\n\t<calculateMean>\n\t\tvar sum = 0;\n\t\tfor (var i = 0; i < input.length; i++) {\n\t\t\tsum += input[i];\n\t\t}\n\t\treturn sum / input.length;\n\t</calculateMean>\n}\n"], ["Pokespotter", "\nfunction Pokespotter(users, password, provider) {\n  <inputValidation>\n\t  if (!Array.isArray(users) && !password) {\n\t\tif (process.env.PGO_USERNAME && process.env.PGO_PASSWORD) {\n\t\t  users = [{\n\t\t\tusername: process.env.PGO_USERNAME,\n\t\t\tpassword: process.env.PGO_PASSWORD,\n\t\t\tprovider: (process.env.PGO_PROVIDER || 'google')\n\t\t  }];\n\t\t} else {\n\t\t  throw new Error('You need to pass a username and password');\n\t\t}\n\t  } else if (!Array.isArray(users)) {\n\t\tusers = [{\n\t\t  username: users,\n\t\t  password: password, \n\t\t  provider: (provider || 'google')\n\t\t}];\n\t  } \n\t  \n\t  if (users.length === 0) {\n\t\tthrow new Error('Invalid or no credentials passed');\n\t  }\n  </inputValidation>\n\n  <initializeSpotters>\n\t  var spotters = users.map(function (u) { return Spotter(u, DEBUG) });\n  </initializeSpotters>\n\n  <getLocationFunction>\n  function get(location, options) {\n    // ... [Code truncated for brevity] ...\n  }\n  </getLocationFunction>\n\n  <constructPokespotterObject>\n\t  var obj = {\n\t\tget: get,\n\t\tgetNearby: get\n\t  };\n\n\t  Object.defineProperty(obj, 'DEBUG', {\n\t\tset: function (val) {\n\t\t  DEBUG = val;\n\t\t},\n\t\tget: function () {\n\t\t  return DEBUG\n\t\t}\n\t  });\n  </constructPokespotterObject>\n\n  return obj;\n}\n"], ["dependencyMatch", "\nfunction dependencyMatch (expected, actual) {\n  <normalizeExpectedActual>\n\t  if (expected.indexOf('github:') === 0) {\n\t\texpected = expected.replace(/^github:/, 'git:');\n\t\tvar parsed = url.parse(expected)\n\t\tparsed.pathname += '.git'\n\t\texpected = url.format(parsed)\n\t  }\n\t  actual = actual.replace(/^git\\+https/, 'git')\n\t  expected = expected.replace(/^git\\+https/, 'git')\n\n\t  expected = ngu(expected)\n\t  actual = ngu(actual)\n\n\t  expected.url = expected.url.replace('https://', 'git://');\n\t  actual.url = actual.url.replace('https://', 'git://');\n  </normalizeExpectedActual>\n\n  <checkMismatch>\n\t  if (expected.url !== actual.url) {\n\t\treturn false\n\t  }\n\n\t  if (actual.branch && actual.branch.indexOf(expected.branch) !== 0) {\n\t\treturn false\n\t  }\n  </checkMismatch>\n\n  return true\n}\n"], ["initializeModule", "\nfunction(moduleName, context) {\n\t<createModule>\n\t\tvar module = modules[moduleName].creator(context);\n\t</createModule>\n\n\t<setupContext>\n\t\tif (!context.getElement) {\n\t\t\tcontext.getElement = function() {\n\t\t\t\treturn document.querySelector('[data-module=\"' + moduleName + '\"]');\n\t\t\t};\n\t\t}\n\t</setupContext>\n\t\n\treturn module;\n}\n"], ["printUsage", "\nfunction printUsage () {\n    // ... [All log statements serve a single purpose of printing usage instructions] ...\n    printSupportedExchanges ()\n    // ... [Code truncated for brevity] ...\n}\n"], ["getPropertyValueLists", "\nfunction (oProperty) {\n\t<extractValueLists>\n\t\tvar aMatches,\n\t\t\tsName,\n\t\t\tsQualifier,\n\t\t\tmValueLists = {};\n\n\t\tfor (sName in oProperty) {\n\t\t\taMatches = rValueList.exec(sName);\n\t\t\tif (aMatches){\n\t\t\t\tsQualifier = (aMatches[1] || \"\").slice(1); \n\t\t\t\tmValueLists[sQualifier] = oProperty[sName];\n\t\t\t}\n\t\t}\n\t</extractValueLists>\n\n\treturn mValueLists;\n}\n"], ["setControllerModel", "\nfunction (controller, context, transition) {\n\t<updateModel>\n\t  if (controller && context !== undefined) {\n\t\t_emberMetalProperty_set.set(controller, 'model', context);\n\t  }\n\t</updateModel>\n}\n"], ["incrementMetric", "\nfunction(name, incr  ) {\n\t<updateMetric>\n\t\tvar currVal = this.metrics[name] || 0;\n\t\tincr = incr || 1;\n\t\tthis.setMetric(name, currVal + incr);\n\t</updateMetric>\n}\n"], "```\n\nSome functions, like printUsage, are compliant because all code contributes to a single clear purpose, which is printing usage instructions. Others have segments tagged separately within the main annotation to indicate distinct responsibilities that could potentially violate the SRP if these sections had significant complexity or were better suited modularized into separate functions."]