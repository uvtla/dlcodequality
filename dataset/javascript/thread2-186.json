[["injectEdgeLabelProxies", "\nfunction injectEdgeLabelProxies(g) {\n  _.forEach(g.edges(), function(e) {\n    <createEdgeLabelProxy>\n    var edge = g.edge(e);\n    if (edge.width && edge.height) {\n      <calculateProxyLabelPosition>\n      var v = g.node(e.v);\n      var w = g.node(e.w);\n      var label = { rank: (w.rank - v.rank) / 2 + v.rank, e: e };\n      </calculateProxyLabelPosition>\n      util.addDummyNode(g, \"edge-proxy\", label, \"_ep\");\n    }\n    </createEdgeLabelProxy>\n  });\n}\n"], ["onUpdateProfile", "\nfunction onUpdateProfile() {\n  <getUserInput>\n  var displayName = $('#display-name').val();\n  var photoURL = $('#photo-url').val();\n  </getUserInput>\n  <updateUserProfile>\n  activeUser().updateProfile({\n    'displayName': displayName,\n    'photoURL': photoURL\n  }).then(function() {\n    <notifyUserOfSuccess>\n    refreshUserData();\n    alertSuccess('Profile updated!');\n    </notifyUserOfSuccess>\n  }, onAuthError);\n  </updateUserProfile>\n}\n"], ["disableButton", "\nfunction() {   \n  this.disabled = true;   \n  Dom.addClass(this.el,\"inputEx-Button-disabled\"); \n  <handleSubmitType>\n  if (this.options.type === \"submit\") {\n     this.el.disabled = true;\n  }\n  </handleSubmitType>\n}\n"], ["getPointRelativeToCanvas", "\nfunction getPointRelativeToCanvas (point) {\n  return {\n    x: point.x / canvas.width,\n    y: point.y / canvas.height\n  };\n}\n"], ["sortBy", "\nfunction sortBy(collection, evaluator) {\n  <convertToSortableArray>\n  var array = map(collection, function(item){return item})\n  </convertToSortableArray>\n  <sortArray>\n  array.sort(function(a,b){\n    var aValue = evaluator(a),\n        bValue = evaluator(b)\n    return aValue==bValue ? 0 : (aValue>bValue ? 1 : -1)\n  })\n  </sortArray>\n  <convertBackToCollection>\n  var sortedCollection = map(array, function(item){return item}, features.newCollection, features.append)\n  </convertBackToCollection>\n  return sortedCollection\n}\n"], ["addVariable", "\nfunction addVariable() {\n  <updateVariableService>\n  variableService.addOrUpdate(vm.variable, function () {\n    vm.variables[vm.variable.key] = vm.variable.value;\n    <resetVariable>\n    vm.variable = {\n      key: undefined,\n      value: undefined\n    };\n    </resetVariable>\n  });\n  </updateVariableService>\n}\n"], ["parseLimit", "\nfunction parseLimit(string) {\n  <interpretStringForLimit>\n  var matches = ('' + string).toLowerCase().match(regexp),\n      bytes = null, power;\n  </interpretStringForLimit>\n  <calculateBytes>\n  if (matches) {\n    bytes = parseFloat(matches[1]);\n    power = powers[matches[2]];\n\n    if (bytes && power) {\n      bytes = Math.pow(bytes * 1024, power);\n    }\n  }\n  </calculateBytes>\n  return bytes || null;\n}\n"], ["validate", "\nfunction validate(globs, options) {\n  <initializeErrorFlag>\n  let hasError = false\n  </initializeErrorFlag>\n  <validateInputs>\n  <checkGlobs>\n  if (globs == null || globs.length === 0) {\n      console.error(\"ERROR: requires file globs.\")\n      hasError = true\n  }\n  </checkGlobs>\n  <checkOutputOption>\n  if (options.output != null && Array.isArray(options.output)) {\n      console.error(\"ERROR: --output option should not be multiple.\")\n      hasError = true\n  }\n  </checkOutputOption>\n  <checkPrefixOption>\n  if (options.prefix != null) {\n      if (Array.isArray(options.prefix)) {\n          console.error(\"ERROR: --prefix option should not be multiple.\")\n          hasError = true\n      }\n  }\n  </checkPrefixOption>\n  <checkVerboseOption>\n  if (options.verbose && !options.output) {\n      console.error(\"ERROR: --verbose option should be used together with --output option.\")\n      hasError = true\n  }\n  </checkVerboseOption>\n  <checkWatchOption>\n  if (options.watch && !options.output) {\n      console.error(\"ERROR: --watch option should be used together with --output option.\")\n      hasError = true\n  }\n  </checkWatchOption>\n  </validateInputs>\n  return !hasError\n}\n"], ["Command", "\nfunction Command(types, commandSpec) {\n  <processCommandSpec>\n  Object.keys(commandSpec).forEach(function(key) {\n    this[key] = commandSpec[key];\n  }, this);\n  </processCommandSpec>\n  <validateCommand>\n  if (!this.name) {\n    throw new Error('All registered commands must have a name');\n  }\n  </validateCommand>\n  <initializeParams>\n  if (this.params == null) {\n    this.params = [];\n  }\n  </initializeParams>\n  <validateParamsArray>\n  if (!Array.isArray(this.params)) {\n    throw new Error('command.params must be an array in ' + this.name);\n  }\n  </validateParamsArray>\n  <setDefaultDescriptions>\n  this.hasNamedParameters = false;\n  this.description = 'description' in this ? this.description : undefined;\n  this.description = lookup(this.description, 'canonDescNone');\n  this.manual = 'manual' in this ? this.manual : undefined;\n  this.manual = lookup(this.manual);\n  </setDefaultDescriptions>\n  <processParamSpecs>\n  <initializeParamCollections>\n  var paramSpecs = this.params;\n  this.params = [];\n  this.paramGroups = {};\n  this._shortParams = {};\n  </initializeParamCollections>\n  <addParamFunction>\n  var addParam = function(param) {\n    var groupName = param.groupName || l10n.lookup('canonDefaultGroupName');\n    this.params.push(param);\n    if (!this.paramGroups.hasOwnProperty(groupName)) {\n      this.paramGroups[groupName] = [];\n    }\n    this.paramGroups[groupName].push(param);\n  }.bind(this);\n  </addParamFunction>\n  <groupParamProcessing>\n  var usingGroups = false;\n  paramSpecs.forEach(function(spec) {\n    if (!spec.group) {\n      var param = new Parameter(types, spec, this, null);\n      addParam(param);\n      if (!param.isPositionalAllowed) {\n        this.hasNamedParameters = true;\n      }\n      if (usingGroups && param.groupName == null) {\n        throw new Error('Parameters can\\'t come after param groups.' +\n                        ' Ignoring ' + this.name + '/' + spec.name);\n      }\n      if (param.groupName != null) {\n        usingGroups = true;\n      }\n    }\n    else {\n      spec.params.forEach(function(ispec) {\n        var param = new Parameter(types, ispec, this, spec.group);\n        addParam(param);\n        if (!param.isPositionalAllowed) {\n          this.hasNamedParameters = true;\n        }\n      }, this);\n      usingGroups = true;\n    }\n  }, this);\n  </groupParamProcessing>\n  <shortParamSetup>\n  this.params.forEach(function(param) {\n    if (param.short != null) {\n      if (this._shortParams[param.short] != null) {\n        throw new Error('Multiple params using short name ' + param.short);\n      }\n      this._shortParams[param.short] = param;\n    }\n  }, this);\n  </shortParamSetup>\n  </processParamSpecs>\n}\n"], ["setupFrameBufferTexture", "\nfunction setupFrameBufferTexture ( framebuffer, renderTarget, attachment, textureTarget ) {\n  <convertRenderFormats>\n  var glFormat = paramThreeToGL( renderTarget.texture.format );\n  var glType = paramThreeToGL( renderTarget.texture.type );\n  </convertRenderFormats>\n  <initializeTexture>\n  state.texImage2D( textureTarget, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );\n  </initializeTexture>\n  <attachTexture>\n  _gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\n  _gl.framebufferTexture2D( _gl.FRAMEBUFFER, attachment, textureTarget, properties.get( renderTarget.texture ).__webglTexture, 0 );\n  _gl.bindFramebuffer( _gl.FRAMEBUFFER, null );\n  </attachTexture>\n}\n"], "```"]