[["globMatch", "\nfunction globMatch(match, file) {\n    var directiveType = match[1];\n    var globPattern = match[2]; \n\n    <processDirective>\n    if (directiveType.indexOf('_tree') !== -1) {\n      globPattern = globPattern.concat('*');\n      directiveType = directiveType.replace('_tree', '');\n    }\n\n    if (directiveType.indexOf('_directory') !== -1) {\n      globPattern = globPattern.concat('/*');\n      directiveType = directiveType.replace('_directory', '');\n    }\n    </processDirective>\n\n    <validateDirectiveType>\n    if (directiveType !== 'require' && directiveType !== 'include') {\n      return [];\n    }\n    </validateDirectiveType>\n\n    <appendJsExtension>\n    var jsExt = '.js';\n    if (globPattern.substr(globPattern.length-jsExt.length).indexOf(jsExt) !== 0) {\n      globPattern += jsExt;\n    }\n    </appendJsExtension>\n\n    <constructGlobPattern>\n    var relativeDir = getRelativeDir(file);\n    globPattern = relativeDir+globPattern;\n    </constructGlobPattern>\n\n    var possibleIncludes = [];\n    <matchFiles>\n    _.each(_.keys(allFiles), function(fileName) {\n      \n      if (fileName.indexOf(relativeDir) !== 0) {\n        return;\n      }\n\n      possibleIncludes.push(fileName);\n    });\n    </matchFiles>\n    \n    <matchGlobPattern>\n    return minimatch.match(possibleIncludes, globPattern);\n    </matchGlobPattern>\n  }\n"], ["getModelMonitor", "\nfunction getModelMonitor(id) {\n      var t = this,\n          components = t.model.get('components');\n      <getComponentMonitor>  \n      return components.get(id).get('monitor');\n      </getComponentMonitor>\n}\n"], ["siblise", "\nfunction siblise(a, b) {\n\tvar list = [a, b];\n\t<calculateHeight>\n\tlist.height = a.height + 1;\n\t</calculateHeight>\n\t<calculateSizes>\n\tlist.sizes = [length(a), length(a) + length(b)];\n\t</calculateSizes>\n\treturn list;\n}\n"], ["polyfillMap", "\nfunction polyfillMap(callback, thisArg) {\n    if (Array.prototype.map) {\n      return arr.map(callback, thisArg);\n    } else {\n      <mapPolyfill>\n      var len = arr.length >>> 0,\n          A = new Array(len),\n          i = 0;\n      for (; i < len; i++) {\n        A[i] = callback.call(thisArg, arr[i], i, arr);\n      }\n      return A;\n      </mapPolyfill>\n    }\n}\n"], ["rollup", "\nfunction rollup(imbuff)\n{\n  var roll = new Buffer(0);\n  <concatenateHash>\n  Object.keys(imbuff).sort().forEach(function(id){\n    roll = crypto.createHash('sha256').update(Buffer.concat([roll,new Buffer(id, 'hex')])).digest();\n    roll = crypto.createHash('sha256').update(Buffer.concat([roll,imbuff[id]])).digest();\n  });\n  </concatenateHash>\n  return roll;\n}\n"], ["processThreadState", "\nfunction processThreadState(state) {\n            if (wakeup !== undefined) {\n              <calculateMidDuration>\n              midDuration = wakeup.ts - prevSlice.end;\n              </calculateMidDuration>\n            }\n\n            if (blocked_reason !== undefined) {\n              <handleBlockedState>\n              var args = {\n                'kernel callsite when blocked:' : blocked_reason.caller\n              };\n              if (blocked_reason.iowait) {\n                <updateSleepState>\n                switch (state) {\n                  case SCHEDULING_STATE.UNINTR_SLEEP:\n                    state = SCHEDULING_STATE.UNINTR_SLEEP_IO;\n                    break;\n                  case SCHEDULING_STATE.UNINTR_SLEEP_WAKE_KILL:\n                    state = SCHEDULING_STATE.UNINTR_SLEEP_WAKE_KILL_IO;\n                    break;\n                  case SCHEDULING_STATE.UNINTR_SLEEP_WAKING:\n                    state = SCHEDULING_STATE.UNINTR_SLEEP_WAKE_KILL_IO;\n                    break;\n                  default:\n                }\n                </updateSleepState>\n              }\n              <createBlockedSlice>\n              slices.push(new tr.model.ThreadTimeSlice(\n                  thread,\n                  state, '', prevSlice.end, args, midDuration));\n              </createBlockedSlice>\n            } else {\n              <createNormalSlice>\n              slices.push(new tr.model.ThreadTimeSlice(\n                  thread,\n                  state, '', prevSlice.end, {}, midDuration));\n              </createNormalSlice>\n            }\n            if (wakeup !== undefined) {\n              <handleWakeup>\n              var wakeupDuration = nextSlice.start - wakeup.ts;\n              var args = {'wakeup from tid': wakeup.fromTid};\n              slices.push(new tr.model.ThreadTimeSlice(\n                  thread, SCHEDULING_STATE.RUNNABLE, '',\n                  wakeup.ts, args, wakeupDuration));\n              </handleWakeup>\n              wakeup = undefined;\n            }\n          }\n"], ["isProcessMaster", "\nfunction isProcessMaster(opts, cb) {\n\tif (!opts) opts = {}\n\tvar gotClose\n\t<defaultLogFunction>\n\tif (typeof opts.log == 'function') log = opts.log\n\t</defaultLogFunction>\n\t<processNameAssignment>\n\tvar processName = opts.processName || process.pid + ':' +\n\t\tpath.basename(__filename, path.extname(__filename))\n\t</processNameAssignment>\n\n\tvar server = new masterserver.MasterServer(opts.port, opts.interface)\n\t\t.on('connect', isMaster)\n\t\t.on('fail', isNotMaster)\n\t\t.on('error', errorLogger)\n\t\t.on('end', serverDiedLogger)\n\t\t.on('data', resetUi)\n\n\tfunction isMaster() {\n\t\tcb(true, closeServer)\n\t}\n\tfunction isNotMaster() {\n\t\t<findMasterPid>\n\t\tpidgetter.getPidFromPort({port: opts.port, host: opts.interface}, hazMasterPid)\n\t\t</findMasterPid>\n\t}\n\tfunction hazMasterPid(err, result) {\n\t\tcb(err ? err : result)\n\t}\n\t<handleResetUi>\n\tfunction resetUi(data) { \n\t\tvar text\n\t\tvar pid = +data\n\t\tif (!isNaN(pid) && pid > 0) text = 'from process: ' + pid\n\t\telse text = 'from another process'\n\t\tlog(processName, (new Date).toISOString(), 'ui reset requested', text)\n\n\t\tif (typeof resetUiFn == 'function') resetUiFn()\n\t}\n\t</handleResetUi>\n\n\t<logError>\n\tfunction errorLogger(err) { \n\t\tlog(processName, (new Date).toISOString(), 'error', err.message)\n\t}\n\t</logError>\n\t<logServerShutdown>\n\tfunction serverDiedLogger() {\n\t\tlog(processName, (new Date).toISOString(), 'master server', gotClose ? 'shut down' : 'died')\n\t}\n\t</logServerShutdown>\n\n\t<shutdownServer>\n\tfunction closeServer() {\n\t\tgotClose = true\n\t\tserver.shutdown()\n\t}\n\t</shutdownServer>\n}\n"], ["updateExchangeCount", "\nfunction updateExchangeCount(fileName) {\n    <logUpdateAttempt>\n    log.bright.cyan('Updating exchange count \u2192', fileName.yellow)\n    </logUpdateAttempt>\n\n    <readAndUpdateFileContent>\n    let oldContent = fs.readFileSync(fileName, 'utf8')\n    let newContent =\n        oldContent.replace(/shields\\.io\\/badge\\/exchanges\\-[0-9a-z]+\\-blue/g, 'shields.io/badge/exchanges-' + ccxt.exchanges.length + '-blue')\n    </readAndUpdateFileContent>\n\n    <overwriteFile>\n    fs.truncateSync(fileName)\n    fs.writeFileSync(fileName, newContent)\n    </overwriteFile>\n}\n"], ["doRollup", "\nfunction doRollup(component) {\n    <setupGulp>\n    return gulp.src(component.src)\n    .pipe(\n        rollup({\n            input: component.entry,\n            output: {\n                name: 'ImageCropper',\n                format: 'iife',\n            },\n            plugins: [\n                resolve({\n                    jsnext: true,\n                    main: true,\n                    browser: true,\n                }),\n                commonjs(),\n                eslint('.eslintrc'),\n                babel({\n                    presets: ['es2015-rollup'],\n                    plugins : [\n                        'check-es2015-constants',\n                        'transform-minify-booleans',\n                        'transform-property-literals',\n                        'transform-member-expression-literals',\n                    ]\n                }),\n                uglify()\n            ],\n        })\n    )\n    </setupGulp>\n    <renameAndSave>\n    .pipe(rename({\n        suffix : '.min'\n    }))\n    .pipe(gulp.dest(component.dest));\n    </renameAndSave>\n}\n"], ["loadFile", "\nfunction loadFile(req, res) {\n    if (req.user) {\n        <checkUserPermission>\n        writeError(403, res, 'Forbidden');\n        </checkUserPermission>\n        return;\n    }\n    var relativeFilePath = req.params['0'];\n    var hubid = req.params['hubId'];\n\n    <retrieveFilePath>\n    return sharedProjects.getProjectPathFromHubID(hubid)\n    .then(function(filepath) {\n        if (!filepath) {\n            <fileNotFoundError>\n            writeError(404, res, 'Session not found: ' + hubid);\n            </fileNotFoundError>\n            return;\n        }\n        getTree(req, res);\n    });\n    </retrieveFilePath>\n}\n"], "```"]