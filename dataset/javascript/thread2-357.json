[["_gpfCompatibilityInstallMethods", "\nfunction _gpfCompatibilityInstallMethods(typeName, description) {\n    var on = description.on;\n    _gpfInstallCompatibleMethods(on, description.methods);\n    _gpfInstallCompatibleStatics(on, description.statics);\n}\n"], ["list", "\nfunction list(options = {}) {\n  <setDefaultOptions>\n  options = _.defaults(options, {\n    limit: -1,\n    keys: true,\n    values: true,\n    fillCache: false,\n    json: true\n  });\n  </setDefaultOptions>\n\n  <processPrefixOption>\n  if (options.prefix) {\n    options.gte = options.prefix + '\\x00';\n    options.lte = options.prefix + '\\xff';\n  }\n  </processPrefixOption>\n\n  let readStream,\n    transformOptions = {\n      objectMode: options.values,\n      isArray: options.isArray\n    };\n\n  <setTransformOptions>\n  if (options.keys && !options.values || !options.keys && options.values) {\n    transformOptions.isArray = true;\n  }\n  </setTransformOptions>\n\n  <createReadStream>\n  readStream = module.exports.createReadStream(options);\n  </createReadStream>\n\n  <processTransforms>\n  if (_.isFunction(options.transforms)) {\n    options.transforms = options.transforms();\n  }\n  \n  if (options.transforms) {\n    readStream = _.reduce(options.transforms, function (readStream, transform) {\n      return readStream.pipe(transform);\n    }, readStream);\n  }\n  </processTransforms>\n\n  <applyJsonTransform>\n  if (options.json) {\n    readStream = readStream.pipe(jsonTransform(transformOptions));\n  }\n  </applyJsonTransform>\n\n  return readStream;\n}\n"], ["getSubdivisions", "\nfunction(opt) {\n    opt = opt || {};\n    <setPrecision>\n    var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n    </setPrecision>\n\n    var subdivisions = [new Curve(this.start, this.controlPoint1, this.controlPoint2, this.end)];\n    <earlyReturn>\n    if (precision === 0) return subdivisions;\n    </earlyReturn>\n\n    var previousLength = this.endpointDistance();\n    var precisionRatio = pow(10, -precision);\n\n    var iteration = 0;\n    <iterateSubdivisions>\n    while (true) {\n        iteration += 1;\n        <divideCurve>\n        var newSubdivisions = [];\n        var numSubdivisions = subdivisions.length;\n        for (var i = 0; i < numSubdivisions; i++) {\n            var currentSubdivision = subdivisions[i];\n            var divided = currentSubdivision.divide(0.5); \n            newSubdivisions.push(divided[0], divided[1]);\n        }\n        </divideCurve>\n\n        <calculateLengths>\n        var length = 0;\n        var numNewSubdivisions = newSubdivisions.length;\n        for (var j = 0; j < numNewSubdivisions; j++) {\n            var currentNewSubdivision = newSubdivisions[j];\n            length += currentNewSubdivision.endpointDistance();\n        }\n        </calculateLengths>\n\n        <checkPrecision>\n        var observedPrecisionRatio = ((length !== 0) ? ((length - previousLength) / length) : 0);\n        if (iteration > 1 && observedPrecisionRatio < precisionRatio) {\n            return newSubdivisions;\n        }\n        </checkPrecision>\n\n        subdivisions = newSubdivisions;\n        previousLength = length;\n    }\n    </iterateSubdivisions>\n}\n"], ["ignoreLinks", "\nfunction(element) {\n    var depth = 3,\n        ignore = false;\n    <checkForLinks>\n    do {\n        if (element.nodeName.toLowerCase() === 'a') {\n            ignore = true;\n            break;\n        }\n        element = element.parentNode;\n    } while (--depth > 0 && element);\n    </checkForLinks>\n    return ignore;\n}\n"], ["filterString", "\nfunction (str, highlight) {\n  highlight = highlight || false;\n  var self = this;\n\n  <defineHighlightColor>\n  var highlightColor = this.highlightColor;\n  </defineHighlightColor>\n\n  <replaceFunction>\n  var replace = function (str, pattern) {\n    if (!highlight) {\n      return str.replace(pattern, function (match) {\n        self.currentMatch.matches.push(match);\n        return self.replacementString;\n      });\n    }\n\n    return str.replace(pattern, function (match) {\n      self.currentMatch.matches.push(match);\n      return '<span style=\"background: #' + highlightColor + ';\">' + match + '</span>';\n    });\n  }.bind(this);\n  </replaceFunction>\n\n  <validateString>\n  if (typeof str !== 'string') {\n    throw 'Invalid \"str\" type supplied in filterString. Expected string.';\n  }\n  </validateString>\n\n  <processPatterns>\n  for (var p in this.patterns) {\n    if (!this.patterns[p].enabled) {\n      continue;\n    }\n\n    if (this.patterns[p].pattern instanceof RegExp) {\n      str = replace(str, this.patterns[p].pattern);\n\n      continue;\n    }\n\n    if (!this.isArray(this.patterns[p].pattern)) {\n      throw 'Invalid pattern type supplied. Expected Array.';\n    }\n\n    for (var i = 0; i < this.patterns[p].pattern.length; i++) {\n      if (!this.patterns[p].pattern[i] instanceof RegExp) {\n        throw 'Expected valid RegExp.';\n      }\n\n      str = replace(str, this.patterns[p].pattern[i]);\n    }\n  }\n  </processPatterns>\n\n  return str;\n}\n"], ["assert", "\nfunction( result, message ) {\n    message = message || ( result ? \"okay\" : \"failed, expected argument to be truthy, was: \" +\n    QUnit.dump.parse( result ) );\n    <pushResult>\n    if ( !!result ) {\n        this.push( true, result, true, message );\n    } else {\n        this.test.pushFailure( message, null, result );\n    }\n    </pushResult>\n}\n"], ["calculatePixelForValue", "\nfunction(index) {\n    var me = this;\n    var offset = me.options.offset;\n    <calculateHorizontalPosition>\n    if (me.isHorizontal()) {\n        var innerWidth = me.width - (me.paddingLeft + me.paddingRight);\n        var tickWidth = innerWidth / Math.max((me._ticks.length - (offset ? 0 : 1)), 1);\n        var pixel = (tickWidth * index) + me.paddingLeft;\n\n        if (offset) {\n            pixel += tickWidth / 2;\n        }\n\n        var finalVal = me.left + pixel;\n        finalVal += me.isFullWidth() ? me.margins.left : 0;\n        return finalVal;\n    }\n    </calculateHorizontalPosition>\n    <calculateVerticalPosition>\n    var innerHeight = me.height - (me.paddingTop + me.paddingBottom);\n    return me.top + (index * (innerHeight / (me._ticks.length - 1)));\n    </calculateVerticalPosition>\n}\n"], ["traverse", "\nfunction(filter){\n    filter = filter || this.filter;\n\n    var cursor = this.cursor_ || this.root_;\n\n    <iterateTreeNodes>\n    do\n    {\n        var node = cursor[this.a]; \n        while (!node)\n        {\n            if (cursor === this.root_)\n                return this.cursor_ = null;\n\n            node = cursor[this.b]; \n\n            if (!node)\n                cursor = cursor[PARENT_NODE];\n        }\n    }\n    while (!filter(cursor = node));\n    </iterateTreeNodes>\n\n    return this.cursor_ = cursor;\n}\n"], ["values", "\nfunction values(object, follow) {\n  <checkForNonEmptyObject>\n  if (is(object) && !empty(object)) {\n    const result = [];\n    </checkForNonEmptyObject>\n\n    <getAllKeys>\n    const keysObject = follow\n      ? deflate(object)\n      : object;\n    </getAllKeys>\n\n    <collectValues>\n    Object.keys(keysObject).forEach((key) => {\n      const value = keysObject[key];\n      result.push(value);\n    });\n    </collectValues>\n\n    return result;\n  }\n  <handleEmptyObject>\n  return [];\n  </handleEmptyObject>\n}\n"], ["executeOnText", "\nfunction(filePath, callback) {\n    <readFile>\n    var text = fs.readFileSync(path.resolve(filePath), 'utf8');\n    </readFile>\n    return this.executeOnText(text, filePath, callback);\n}\n"], "```"]