[["parseSourceText", "\nfunction() {\n    <setupVariables>\n    var line, lines = this.sourceText.split(/\\n/mg),\n        lineLen = lines.length;\n\n    var inCommenting, curComment, closeCommentIdx;\n    </setupVariables>\n\n    for (var i = 0; i < lineLen; ++i) {\n        <processLines>\n        line = lines[i].trim();\n        if (line.startsWith('')) {\n            inCommenting = false;\n            closeCommentIdx = i;\n        } else if (!inCommenting && (1 === i - closeCommentIdx) && /(\\bfunction\\b\\s*?(\\w+?)\\s*\\(([^\\(\\)]*)\\))|((\\w+)?\\s*(?::|=)\\s*function\\s*\\(([^\\(\\)]*)\\))/.test(line)) {\n            curComment.setFunc(RegExp.$2 || RegExp.$5, RegExp.$3 || RegExp.$6);\n            if ('string' !== typeof curComment.getTag('ignore')) {\n                this.Comments.push(curComment);\n            }\n            curComment = null;\n        } else if (!inCommenting && (1 === i - closeCommentIdx) && /(\\w+)\\s*(?::|=)(?!\\s*function)/.test(line)) {\n            curComment.setAttr(RegExp.$1);\n            if ('string' !== typeof curComment.getTag('ignore')) {\n                this.Comments.push(curComment);\n            }\n            curComment = null;\n        } else if (inCommenting) {\n            line = line.replace(/^\\*/, '').trim();\n            if (/^@(\\w+)([^\\r\\n]*)/.test(line)) {\n                curComment.addTag(RegExp.$1, RegExp.$2 || \"\");\n            } else {\n                curComment.addDesc(line);\n            }\n        }\n        </processLines>\n    } \n\n    <mergeResults>\n    this._merge();\n    </mergeResults>\n}\n"], ["RugConstructor", "\nfunction Rug( graph ) {\n    \n    <initializeProperties>\n    this._parent = graph;\n    this._root = undefined;\n    this._children = {};\n    this._config = {\n        \"type\": \"rug\",\n        \"size\": 6,\n        \"labels\": []\n    };\n    this._data = graph._data;\n    </initializeProperties>\n    \n    <defineTransforms>\n    this._transforms = {\n        'x': function X( d ) {\n            return graph._xScale( d[ 0 ] );\n        },\n        'y': function Y( d ) {\n            return d[ 1 ];\n        }\n    };\n    </defineTransforms>\n\n    <configurePath>\n    this._path = this.path()\n        .x( this._transforms.x )\n        .y( this._transforms.y );\n    </configurePath>\n    \n    <addToGraphConfiguration>\n    if ( graph._config.hasOwnProperty( 'marks' ) ) {\n        graph._config.marks.push( this._config );\n    } else {\n        graph._config.marks = [ this._config ];\n    }\n    if ( graph._children.hasOwnProperty( 'marks' ) ) {\n        graph._children.marks.push( this );\n    } else {\n        graph._children.marks = [ this ];\n    }\n    </addToGraphConfiguration>\n\n    return this;\n}\n"], ["nearest", "\nfunction nearest(predicate, node) {\n    <traverseAncestors>\n    while ((node = node.parent)) {\n        if (predicate(node)) return node;\n    }\n    </traverseAncestors>\n\n    return undefined;\n}\n"], ["createUniformBlockInfoFromProgram", "\nfunction createUniformBlockInfoFromProgram(gl, program, uniformBlockSpec, blockName) {\n    <setupUniformBlock>\n    const blockSpecs = uniformBlockSpec.blockSpecs;\n    const uniformData = uniformBlockSpec.uniformData;\n    const blockSpec = blockSpecs[blockName];\n    if (!blockSpec) {\n        warn(\"no uniform block object named:\", blockName);\n        return {\n            name: blockName,\n            uniforms: {},\n        };\n    }\n    </setupUniformBlock>\n\n    <initializeBuffer>\n    const array = new ArrayBuffer(blockSpec.size);\n    const buffer = gl.createBuffer();\n    const uniformBufferIndex = blockSpec.index;\n    gl.bindBuffer(gl.UNIFORM_BUFFER, buffer);\n    gl.uniformBlockBinding(program, blockSpec.index, uniformBufferIndex);\n    </initializeBuffer>\n\n    <createUniformsMap>\n    let prefix = blockName + \".\";\n    if (arraySuffixRE.test(prefix)) {\n        prefix = prefix.replace(arraySuffixRE, \".\");\n    }\n    const uniforms = {};\n    blockSpec.uniformIndices.forEach(function(uniformNdx) {\n        const data = uniformData[uniformNdx];\n        const typeInfo = typeMap[data.type];\n        const Type = typeInfo.Type;\n        const length = data.size * typeInfo.size;\n        let name = data.name;\n        if (name.substr(0, prefix.length) === prefix) {\n            name = name.substr(prefix.length);\n        }\n        uniforms[name] = new Type(array, data.offset, length / Type.BYTES_PER_ELEMENT);\n    });\n    </createUniformsMap>\n\n    return {\n        name: blockName,\n        array: array,\n        asFloat: new Float32Array(array),  \n        buffer: buffer,\n        uniforms: uniforms,\n    };\n}\n"], ["microTimestamp", "\nfunction microTimestamp () {\n    <generateTimestamp>\n    var time = microtime.nowStruct()\n    var micro = ('000000' + time[1]).slice(-6)\n    </generateTimestamp>\n    \n    <formatTimestamp>\n    return moment.unix(time[0]).format('YYYY-MM-DD HH:mm:ss') + '.' + micro\n    </formatTimestamp>\n}\n"], ["fe", "\nfunction fe($e,et,tt){\n    <configureEventEmitter>\n    return\"function\"==typeof $e.prependListener?$e.prependListener(et,tt):void($e._events&&$e._events[et]?Me($e._events[et])?$e._events[et].unshift(tt):$e._events[et]=[tt,$e._events[et]]:$e.on(et,tt))\n    </configureEventEmitter>\n}\n"], ["copyBoundingBox", "\nfunction (bbox) {\n        <initializeVariables>\n        var min = this.min;\n        var max = this.max;\n        </initializeVariables>\n\n        <copyValues>\n        vec3Copy(min.array, bbox.min.array);\n        vec3Copy(max.array, bbox.max.array);\n        </copyValues>\n\n        <setDirtyFlags>\n        min._dirty = true;\n        max._dirty = true;\n        </setDirtyFlags>\n\n        return this;\n}\n"], ["wrap", "\nfunction wrap(method) {\n            return <createWrappedFunction>function() {\n                \n                <gatherArguments>\n                var args = Array.prototype.slice.apply(arguments);\n                </gatherArguments>\n                \n                <invokeOriginalMethod>\n                args.unshift(this);\n                return ss[method].apply(ss, args);\n                </invokeOriginalMethod>\n            </createWrappedFunction>;\n}\n"], ["_ioComplete", "\nfunction _ioComplete(o, c) {\n        <prepareResponse>\n        var r = o.e ? { status: 0, statusText: o.e } : o.c,\n            a = c.arguments;\n        </prepareResponse>\n\n        <fireCompleteEvents>\n        if (a) {\n            Y.fire(E_COMPLETE, o.id, r, a);\n        }\n        else {\n            Y.fire(E_COMPLETE, o.id, r);\n        }\n        </fireCompleteEvents>\n\n        <handleConfiguration>\n        if (c.on && c.on.complete) {\n            _tE('complete', c).fire(o.id, r);\n        }\n        </handleConfiguration>\n}\n"], ["_getTripsFromStop", "\nfunction _getTripsFromStop(db, stop, tripSearchDate, callback) {\n\n    <initializeResults>\n    let rtn = [];\n    </initializeResults>\n\n    <setupCounters>\n    let done = 0;\n    let count = 0;\n    </setupCounters>\n\n    <prepareQuery>\n    let serviceIdString = \"'\" + tripSearchDate.serviceIds.join(\"', '\") + \"'\";\n    let select = \"SELECT gtfs_stop_times.trip_id \" +\n        \"FROM gtfs_stop_times \" +\n        \"INNER JOIN gtfs_trips ON gtfs_stop_times.trip_id=gtfs_trips.trip_id \" +\n        \"WHERE stop_id='\" + stop.id + \"' AND \" +\n        \"departure_time_seconds >= \" + tripSearchDate.preSeconds + \" AND departure_time_seconds <= \" + tripSearchDate.postSeconds + \" AND \" +\n        \"pickup_type <> \" + StopTime.PICKUP_TYPE_NONE + \" AND \" +\n        \"gtfs_trips.service_id IN (\" + serviceIdString + \")\";\n    </prepareQuery>\n\n    <executeQuery>\n    db.select(select, function(err, results) {\n\n        <handleErrors>\n        if ( err ) {\n            return callback(\n                new Error('Could not get Trip(s) from database')\n            );\n        }\n        </handleErrors>\n\n        <handleNoResults>\n        if ( results.length === 0 ) {\n            return callback(null, rtn);\n        }\n        </handleNoResults>\n\n        <processResults>\n        count = results.length;\n        for ( let i = 0; i < results.length; i++ ) {\n            TripsTable.getTrip(db, results[i].trip_id, tripSearchDate.date, function(err, trip) {\n\n                <handleTripErrors>\n                if ( err ) {\n                    return callback(err);\n                }\n                </handleTripErrors>\n\n                <addTripToResults>\n                rtn.push(trip);\n                </addTripToResults>\n\n                <checkCompletion>\n                _finish();\n                </checkCompletion>\n\n            });\n        }\n        </processResults>\n\n    });\n    </executeQuery>\n\n    <_finish>\n    function _finish() {\n        done++;\n        if ( done === count ) {\n            return callback(null, rtn);\n        }\n    }\n    </_finish>\n}\n"], "```"]