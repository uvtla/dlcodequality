[["withSharoFunction", "\nfunction withSharo(nextConfig = {}) {\n  <setupExtensions>\n  const withMdx = require('@zeit/next-mdx')({\n    extension: /\\.mdx?$/\n  })\n  </setupExtensions>\n  \n  <returnEnhancedConfig>\n  return (\n    withSass(withMdx(\n      Object.assign(\n        {},\n        nextConfig,\n        {\n          <modifyWebpackConfig>\n          webpack(config, options) {\n            config.resolve.extensions.push('.md', '.mdx', '.scss', '.sass')\n          \n            if (typeof nextConfig.webpack === 'function') {\n              return nextConfig.webpack(config, options)\n            }\n          \n            return config\n          }\n          </modifyWebpackConfig>\n        }\n      )\n    ))\n  )\n  </returnEnhancedConfig>\n}\n"], ["_arrayCopyFunction", "\nfunction _arrayCopy(dest, src) {\n  <copyArrayContent>\n  if (Array.isArray(src)) {\n    src.forEach(function (item) {\n      dest.push(item);\n    });\n  }\n  </copyArrayContent>\n}\n"], ["_buildResponseFunction", "\nfunction _buildResponse(xhr, fullResponse) {\n  <parseHeaders>\n  var _parseHeaders = function (headers) {\n    var parsed = {};\n  \n    if (headers) {\n      headers = headers.trim().split(\"\\n\");\n      for (var h in headers) {\n        // Violating SRP by incorporating \"hasOwnProperty\" check within the loop.\n        if (headers.hasOwnProperty(h)) {\n          var header = headers[h].match(/([^:]+):(.*)/);\n          parsed[header[1].trim().toLowerCase()] = header[2].trim();\n        }\n      }\n    }\n    return parsed;\n  };\n  </parseHeaders>\n \n  <processResponse>\n  var headers = _parseHeaders(xhr.getAllResponseHeaders()),\n    response = null;\n  \n  if (xhr.responseText) {\n    var contentType = headers['content-type'];\n    if (contentType && contentType.indexOf('application/json') !== -1) {\n      try {\n        response = JSON.parse(xhr.responseText);\n      } catch (e) {\n        response = xhr.responseText;\n      }\n    } else {\n      response = xhr.responseText;\n    }\n  }\n  \n  if (fullResponse) {\n    response = {\n      data: response,\n      headers: headers,\n      status: xhr.status\n    };\n  \n    if (response.data && response.data.errors) {\n      response.errors = response.data.errors;\n      delete response.data.errors;\n    }\n  }\n  </processResponse>\n\n  return response;\n}\n"], ["streamDataHandler", "\nfunction(viewers, req) {\n  <createStream>\n  var stream = bl();\n  </createStream>\n\n  <handleRequestData>\n  req.on('data', function(chunk) {\n    stream.append(chunk);\n  });\n  </handleRequestData>\n\n  <handleRequestEnd>\n  req.on('end', function() {\n    var data = stream.toString('ascii');\n    console.log('Dispatching: ' + data);\n  })\n  </handleRequestEnd>\n}\n"], ["randomNumberGenerator", "\nfunction random(len) {\n  <handleRandomGenerationStrategy>\n  if (subtle) {\n      return safeRandom(len);\n  } else if (nodeCrypto) {\n      return new Uint8Array(nodeCrypto.randomBytes(len));\n  } else {\n      throw new KdbxError(Consts.ErrorCodes.NotImplemented, 'Random not implemented');\n  }\n  </handleRandomGenerationStrategy>\n}\n"], ["fileUploadAndReadDataFunction", "\nfunction (file, callback) {\n  <initializeUpload>\n  var self = this,\n      reader = new FileReader();\n  \n  var uploadDesign = this.$.imageUploadService.upload(file, function (err) {\n      <handleUploadResponse>\n      if (!err) {\n          self.trigger(\"uploadComplete\", {\n              uploadDesign: uploadDesign\n          });\n      } else {\n          self.trigger(\"uploadError\", {\n              error: err,\n              uploadDesign: uploadDesign\n          });\n      }\n      </handleUploadResponse>\n\n      callback && callback(err, uploadDesign);\n  });\n  </initializeUpload>\n\n  <setupReaderOnload>\n  reader.onload = function(evt) {\n    var img = new Image();\n    img.onload = function() {\n      uploadDesign.set({\n          previewImage: evt.target.result,\n          localImage: evt.target.result\n      });\n    };\n    img.src = evt.target.result;\n  };\n  </setupReaderOnload>\n\n  reader.readAsDataURL(file);\n  \n  return uploadDesign;\n}\n"], ["generateLegendFunction", "\nfunction generateLegend(legendHelper) {\n  <determineLegendProperties>\n  var legendProps;\n  if (\n    !defined(legendHelper.tableColumn) ||\n    !defined(legendHelper.tableColumn.values)\n  ) {\n    // The function's responsibility is split further but collectively serves to determineLegendProperties.\n    \n    <handleNoValuesCase>\n    if (legendHelper.regionProvider) {\n      legendHelper._binColors = buildEnumBinColors(\n        legendHelper,\n        legendHelper.regionProvider.regions,\n        \"top\",\n        undefined\n      );\n      legendProps = buildEnumLegendProps(\n        legendHelper,\n        legendHelper.regionProvider.regions\n      );\n    } else {\n      legendProps = defined(legendHelper.name)\n        ? {\n            items: [\n              {\n                title: legendHelper.name,\n                color: convertColorArrayToCssString(\n                  legendHelper._noColumnColorArray\n                )\n              }\n            ]\n          }\n        : undefined;\n    }\n    </handleNoValuesCase>\n  } else if (legendHelper.tableColumn.isEnum) {\n    <handleEnumCase>\n    var tableColumnStyle = legendHelper.tableColumnStyle;\n    var uniqueValues = legendHelper.tableColumn.uniqueValues;\n    legendHelper._binColors = buildEnumBinColors(\n      legendHelper,\n      uniqueValues,\n      tableColumnStyle.colorBinMethod,\n      tableColumnStyle.colorBins\n    );\n    legendProps = buildEnumLegendProps(legendHelper, uniqueValues);\n    </handleEnumCase>\n  } else {\n    <handleScalarCase>\n    var colorMap = defaultValue(\n      legendHelper.tableColumnStyle.colorMap,\n      defaultScalarColorMap\n    );\n    var colorBins = defaultValue(\n      legendHelper.tableColumnStyle.colorBins,\n      defaultNumberOfColorBins\n    );\n    \n    legendHelper._colorGradient = buildColorGradient(colorMap);\n    legendHelper._binColors = buildBinColors(legendHelper, colorBins);\n    legendProps = buildLegendProps(legendHelper, colorMap);\n    </handleScalarCase>\n  }\n  </determineLegendProperties>\n  \n  <createLegendInstance>\n  if (defined(legendProps)) {\n    legendHelper._legend = new Legend(legendProps);\n  } else {\n    legendHelper._legend = null;\n  }\n  </createLegendInstance>\n}\n"], ["resolveFunction", "\nfunction resolve(variable, model) {\n  <resolveVariable>\n  if (variable[0] == '-') {\n    var value = model[variable.slice(1)];\n    return value === undefined? undefined : !value;\n  } else return model[variable];\n  </resolveVariable>\n}\n"], ["buildURLPathFunction", "\nfunction(first) {\n  <determineURLPath>\n  if (first === \"/\") {\n      return \"/\" + _url_join.apply(_url_join, [].splice.call(arguments, 1));\n  } else {\n      return _url_join.apply(_url_join, [].splice.call(arguments, 0));\n  }\n  </determineURLPath>\n}\n"], ["PowerSampleClassConstructor", "\nfunction PowerSample(series, start, power) {\n  <invokeParentConstructor>\n  Event.call(this);\n  </invokeParentConstructor>\n\n  this.series_ = series;\n  this.start_ = start;\n  this.power_ = power;\n}\n"], "```"]