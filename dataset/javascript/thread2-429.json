[["findOutliers", "\nfunction() {\n\t\t\t\n\t\t\t<calculateMedianAndRange>\n\t\t\tvar median = this.median();\n\t\t\tvar range  = this.iqr() * 1.5;\n\t\t\t</calculateMedianAndRange>\n\n\t\t\t<initializeOutliers>\n\t\t\tvar outliers = stats([]);\t\t\t\n\t\t\t</initializeOutliers>\n\n\t\t\t<iterateAndPushOutliers>\n\t\t\tthis.each(function(num) {\n\t\t\t\tif (Math.abs(num - median) > range) {\n\t\t\t\t\toutliers.push(num);\n\t\t\t\t}\n\t\t\t});\n\t\t\t</iterateAndPushOutliers>\n\n\t\t\treturn outliers;\n\t\t}\n"], ["getMinimumValue", "\nfunction getMinimum() {\n        var args = [];\n        <argsAssignment>\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        </argsAssignment>\n        return Math.min.apply(Math, args);\n    }\n"], ["removeItem", "\nfunction(item, dontPushVal, options) {\n      var self = this;\n\n      <determineItem>\n      if (self.objectItems) {\n        if (typeof item === \"object\")\n          item = $.grep(self.itemsArray, function(other) { return self.options.itemValue(other) ==  self.options.itemValue(item); } );\n        else\n          item = $.grep(self.itemsArray, function(other) { return self.options.itemValue(other) ==  item; } );\n\n        item = item[item.length-1];\n      }\n      </determineItem>\n\n      <checkAndTriggerBeforeRemoveEvent>\n      if (item) {\n        var beforeItemRemoveEvent = $.Event('beforeItemRemove', { item: item, cancel: false, options: options });\n        self.$element.trigger(beforeItemRemoveEvent);\n        if (beforeItemRemoveEvent.cancel)\n          return;\n      </checkAndTriggerBeforeRemoveEvent>\n\n      <removeItemFromDOM>\n        $('.tag', self.$container).filter(function() { return $(this).data('item') === item; }).remove();\n        $('option', self.$element).filter(function() { return $(this).data('item') === item; }).remove();\n      </removeItemFromDOM>\n      \n      <updateItemsArray>\n      if($.inArray(item, self.itemsArray) !== -1)\n          self.itemsArray.splice($.inArray(item, self.itemsArray), 1);\n      </updateItemsArray>\n\n      <pushValues>\n      if (!dontPushVal)\n        self.pushVal(self.options.triggerChange);\n      </pushValues>\n\n      <manageContainerState>\n      if (self.options.maxTags > self.itemsArray.length)\n        self.$container.removeClass('bootstrap-tagsinput-max');\n      </manageContainerState>\n\n      <triggerItemRemovedEvent>\n      self.$element.trigger($.Event('itemRemoved',  { item: item, options: options }));\n      </triggerItemRemovedEvent>\n    }\n"], ["filterDataByFields", "\nfunction(fields, data) {\n    if (!_.isString(fields)) {\n      return data;\n    }\n    \n    <createFieldMap>\n    var map = {};\n    _.forEach(fields.split(','), function(field) {\n      map[field.split('.')[0]] = 1;\n    });\n    </createFieldMap>\n\n    <filterData>\n    var keys = _.keys(map);\n    if (_.isArray(data)) {\n      data = _.map(data, function(object) {\n        return _.pick(object, keys);\n      });\n    } else if (_.isObject(data)) {\n      data = _.pick(data, keys);\n    }\n    </filterData>\n\n    return data;\n  }\n"], ["handleNotKeydownEvent", "\nfunction handleNotKeydown(keyCodes, e, callback) {\n    <getKeyCode>\n    const keyCode = e.charCode || e.keyCode;\n    </getKeyCode>\n    <triggerCallbackIfNotKeydown>\n    if (keyCodes.indexOf(keyCode) === -1) {\n        callback();\n    }\n    </triggerCallbackIfNotKeydown>\n}\n"], ["dimensionsListParsing", "\nfunction dimensionsList(buffer) {\n  <initializeVariables>\n  var recordId, recordName;\n  </initializeVariables>\n  <checkForZeroTag>\n  const dimList = buffer.readUint32();\n  if (dimList === ZERO) {\n    utils.notNetcdf((buffer.readUint32() !== ZERO), 'wrong empty tag for list of dimensions');\n    return [];\n  } else {\n    utils.notNetcdf((dimList !== NC_DIMENSION), 'wrong tag for list of dimensions');\n  </checkForZeroTag>\n\n  <readDimensions>\n    const dimensionSize = buffer.readUint32();\n    var dimensions = new Array(dimensionSize);\n    for (var dim = 0; dim < dimensionSize; dim++) {\n      \n      var name = utils.readName(buffer);\n\n      \n      const size = buffer.readUint32();\n      if (size === NC_UNLIMITED) { \n        recordId = dim;\n        recordName = name;\n      }\n\n      dimensions[dim] = {\n        name: name,\n        size: size\n      };\n    }\n  </readDimensions>\n  return {\n    dimensions: dimensions,\n    recordId: recordId,\n    recordName: recordName\n  };\n}\n"], ["getElementHtml", "\nfunction() {\n        if (this._element) {\n          \n          <getOuterHtml>\n          var thisElement = this.element();\n          var outerHTML = thisElement.outerHTML;\n          if (typeof outerHTML === 'undefined') {\n            return jQuery('<div/>').append(thisElement).html();\n          }\n          return outerHTML;\n          </getOuterHtml>\n        } else {\n          <getInnerString>\n          return this.innerString();\n          </getInnerString>\n        }\n      }\n"], ["removeClassIfValueEmpty", "\nfunction(_clazz,_event){\n            <getElementAndCheckValue>\n            var _element = _v._$getElement(_event);\n            if (!_element.value)\n                _e._$delClassName(_element,_clazz);\n            </getElementAndCheckValue>\n        }\n"], ["batchProcessingTasks", "\nfunction batcher(state, tasks, callback)\n{\n  <handleStateArray>\n  if (Array.isArray(state))\n  {\n    callback = tasks;\n    tasks    = state;\n    state    = {};\n  }\n  </handleStateArray>\n\n  <validateInitialState>\n  if (typeOf(state) != 'object')\n  {\n    throw new TypeError('Initial state should be an object');\n  }\n  </validateInitialState>\n\n  <extendState>\n  state = mixin(state, stateMethods);\n  tasks = tasks.slice();\n  </extendState>\n\n  <hideCurrentTask>\n  Object.defineProperty(state, '_currentTask', {\n    enumerable: false,\n    writable: true\n  });\n  </hideCurrentTask>\n  \n  <reportInitialization>\n  report('init', clone(state));\n  </reportInitialization>\n\n  <iterateTasksWithReporting>\n  iterator(state, tasks, function(error, finalState)\n  {\n    <handleCompletion>\n    finalState = finalState || state;\n    if (error)\n    {\n      process.exitCode = error.code || 1;\n    }\n    </handleCompletion>\n    <invokeCallback>\n    return callback ? callback(error, finalState) : report('done', finalState, error);\n    </invokeCallback>\n  });\n  </iterateTasksWithReporting>\n}\n"], ["conditionalReducer", "\nfunction reduceUnless(array, initValue, condFunc, func) {\n  <initializeAccumulator>\n  var result = initValue;\n  </initializeAccumulator>\n  <iterateAndReduce>\n  for (var i = 0; i < array.length; i++) {\n    var value = array[i];\n    <conditionCheck>\n    if (condFunc(value)) {\n      return value;\n    }\n    </conditionCheck>\n    <performReduction>\n    result = func(result, value);\n    </performReduction>\n  }\n  </iterateAndReduce>\n  return result;\n}\n"], "```"]