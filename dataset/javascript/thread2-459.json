[["functionGetAllFilesWithExtension", "\nfunction (handler, directory) {\n        <getExtensionGlobPattern>\n        var globPattern = this.getExtensionGlob(handler.extensions, ALL_DIRS); \n        </getExtensionGlobPattern>\n        \n        <constructFileObjects>\n        return _.map(glob.sync(globPattern, {cwd: directory}), function (file) {\n            return {name: file, path: path.join(directory, file)};\n        });\n        </constructFileObjects>\n}\n"], ["functionHttpContext", "\nfunction HttpContext(httpRequest, httpResponse) {\n    // not annotated as no distinct blocks identified\n    \n    this.application = null;\n\n    \n    this.request = httpRequest;\n    \n    this.response = httpResponse;\n    \n    // Below are property definitions that are part of the HttpContext setup\n    // Following the balanced SRP approach, these are not individually annotated\n    // as they collectively represent the responsibility of defining the context   \n    \n    // omitted other similar definitions for brevity\n}\n"], ["functionRegisterPostMessageCallback", "\nfunction registerPostMessageCallback(iframe, callback) {\n        <initializeVariables>\n        var iframeName = iframe.id,\n            fileId = getFileIdForIframeName(iframeName),\n            uuid = getUuid(fileId);\n        </initializeVariables>\n\n        <storeCallback>\n        onloadCallbacks[uuid] = callback;\n        </storeCallback>\n\n        <setupIframeLoadEvent>\n        detachLoadEvents[fileId] = qq(iframe).attach(\"load\", function() { /* implementation omitted */ });\n        </setupIframeLoadEvent>\n\n        <startMessageReceiver>\n        corsMessageReceiver.receiveMessage(iframeName, function(message) { /* implementation omitted */ });\n        </startMessageReceiver>\n}\n"], ["functionToJSON", "\nfunction toJSONMethod() {\n    <prepareSerialization>\n    function toJSON(item) {\n      return item.toJSON();\n    }\n\n    var result = Object.create(null);\n    result.ruleIterators = this.ruleIterators.map(toJSON);\n    /* omitted similar lines for brevity */\n    result.dtstart = this.dtstart.toJSON();\n    result.complete = this.complete;\n    </prepareSerialization>\n\n    <returnSerializedObject>\n    return result;\n    </returnSerializedObject>\n}\n"], ["functionCsvToMarkdown", "\nfunction csvToMarkdown(csvContent, delimiter, hasHeader) {\n    <initializeDefaults>\n    if (delimiter === void 0) { delimiter = \"\\t\"; }\n    if (hasHeader === void 0) { hasHeader = false; }\n    </initializeDefaults>\n\n    <prepareContentFormatting>\n    if (delimiter != \"\\t\") {\n        csvContent = csvContent.replace(/\\t/g, \"    \");\n    }\n    </prepareContentFormatting>\n\n    <parseCsvContent>\n    var columns = csvContent.split(\"\\n\");\n    /* omitted similar lines for brevity */\n    </parseCsvContent>\n\n    <generateMarkdownOutput>\n    var headerOutput = \"\";\n    var seperatorOutput = \"\";\n    /* omitted similar lines for brevity */\n    return \"\" + headerOutput + seperatorOutput + rowOutput;\n    </generateMarkdownOutput>\n}\n"], ["functionEventKeyUp", "\nfunction eventKeyUp(e) {\n  <getKeyCode>\n  var keycode = ('which' in e) ? e.which : e.keyCode;\n  </getKeyCode>\n\n  <triggerKeyUp>\n  keyUp(keycode);\n  </triggerKeyUp>\n}\n"], ["functionHasTextMimeType", "\nfunction hasTextMimetype(types) {\n      <checkForTextMimeType>\n      if (!types) return true;\n      for (var i = 0; i < types.length; i++) {\n        if (types[i] === 'Text' || types[i] === 'text/plain') return true;\n      }\n      </checkForTextMimeType>\n      \n      <returnDefault>\n      return false;\n      </returnDefault>\n}\n"], ["functionNextLine", "\nfunction next_line() {\n            <prepareForNextLine>\n            var at;\n            if (line >= lines.length) {\n                return false;\n            }\n            </prepareForNextLine>\n            \n            <analyzeAndValidateLine>\n            character = 1;\n            /* omitted lines for brevity */\n            if (option.maxlen && option.maxlen < source_row.length) {\n                warn_at('too_long', line, source_row.length);\n            }\n            </analyzeAndValidateLine>\n            \n            <returnSuccess>\n            return true;\n            </returnSuccess>\n}\n"], ["functionParseAttributes", "\nfunction parseAttributes(attrStr) {\n    <parseAttributresRegex>\n    var reAttributes = /([^=<>\\\"\\'\\s]+)\\s*(?:=\\s*[\"']?([^\"']*)[\"']?)?/g;\n    var result = {};\n    var match;\n    </parseAttributresRegex>\n\n    <matchAndStoreAttributes>\n    if (attrStr) {\n        while (match = reAttributes.exec(attrStr)) {\n            result[match[1]] = match[2] || true;\n        }\n    }\n    </matchAndStoreAttributes>\n\n    <returnAttributeObject>\n    return result;\n    </returnAttributeObject>\n}\n"], ["functionAddToChildRegistry", "\nfunction addToChildRegistry(childRegistry, child, name) {\n    <assertParameters>\n    assertType(childRegistry, 'object', false, 'Invalid child registry specified');\n    assertType(child, [Node, Array], false, 'Invalid child(ren) specified');\n    assertType(name, 'string', true, 'Invalid name specified');\n    </assertParameters>\n\n    <addChildToRegistry>\n    let inferredName = getInstanceNameFromElement(child);\n    /* omitted lines for brevity */\n    childRegistry[name] = child;\n    </addChildToRegistry>\n\n    <returnSuccess>\n    return true;\n    </returnSuccess>\n}\n"], "```"]