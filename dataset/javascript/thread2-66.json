[["createByFacebook", "\nfunction createByFacebook(profile, callback) {\n  <checkProfileId>\n  if (!profile.id) {\n    return callback(new Error('Profile id is undefined'));\n  }\n  </checkProfileId>\n\n  <findOrUpdateUser>\n  this.findByFacebookID(profile.id, ok(callback, (user) => {\n    if (user) {\n      return updateUserByFacebookProfile(user, profile, callback);\n    }\n  </findOrUpdateUser>\n\n    <createUserWithProfile>\n    this.create({\n      username: profile.username || null,\n      firstName: profile.first_name,\n      lastName: profile.last_name,\n      name: profile.name,\n      email: profile.email,\n      locale: profile.locale,\n    }, ok(callback, (newUser) => {\n      newUser.addProvider('facebook', profile.id, profile, ok(callback, () => {\n        callback(null, newUser);\n      }));\n    }));\n    </createUserWithProfile>\n  }));\n}\n"], ["readSource", "\nfunction readSource (source, from, to, offset, delimiter) {\n  \n  <initializeParameters>\n  from = from | 0\n  to = to | 0 || from\n  delimiter = delimiter || PREVIEW_OPTS.delimiter\n  if (typeof offset === 'undefined') {\n    offset = PREVIEW_OPTS.offset\n  } else {\n    offset = offset | 0\n  }\n  </initializeParameters>\n\n  <readLines>\n  let lastIdx = -1\n  let currIdx = lastIdx\n  let line = 1\n  let reads = []\n\n  from -= offset\n  to += offset\n\n  while (currIdx < source.length) {\n    currIdx = source.indexOf(delimiter, lastIdx + 1)\n    if (currIdx < 0) {\n      currIdx = source.length\n    }\n\n    if (line > to) {\n      break\n    } else if (line >= from && line <= to) {\n      reads.push({\n        number: line,\n        source: source.substring(lastIdx + delimiter.length, currIdx)\n      })\n    }\n\n    lastIdx = currIdx\n    line ++\n  }\n\n  return reads\n  </readLines>\n}\n"], ["undefinedFunctionName", " // The function name is missing here.\nfunction(args, connectionInfo, processPagedResults) {\n  <setDefaultPaging>\n  args.page = {value: 1};\n  args.pageSize = {value: 200};\n  </setDefaultPaging>\n  \n  <setDefaultProcessMethod>\n  if (!processPagedResults) {\n    processPagedResults = defaultMethod_ForProcessingPagedResults_ForConsignmentProducts; \n  }\n  </setDefaultProcessMethod>\n\n  <processPagedResults>\n  return utils.processPagesRecursively(args, connectionInfo, fetchProductsByConsignment, processPagedResults);\n  </processPagedResults>\n}\n"], ["plugin", "\nfunction plugin(options){\n  <setDefaults>\n  options = options || {};\n  var keys = options.keys || [];\n  </setDefaults>\n\n  <returnMiddlewareFunction>\n  return function(files, metalsmith, done){\n    <finalizeAsync>\n    setImmediate(done);\n    </finalizeAsync>\n\n    <processFiles>\n    Object.keys(files).forEach(function(file){\n      <checkFile>\n      debug('checking file: %s', file);\n      if (!markdown(file)) return;\n      </checkFile>\n      <convertFile>\n      var data = files[file];\n      var dir = dirname(file);\n      var html = basename(file, extname(file)) + '.html';\n      if ('.' != dir) html = dir + '/' + html;\n\n      debug('converting file: %s', file);\n      var str = mmd.convert(data.contents.toString(), options);\n      data.contents = new Buffer(str);\n      keys.forEach(function(key) {\n        data[key] = mmd.convert(data[key], options);\n      });\n\n      delete files[file];\n      files[html] = data;\n      </convertFile>\n    });\n    </processFiles>\n  };\n  </returnMiddlewareFunction>\n}\n"], ["decodeTransaction", "\nfunction (data) { // No function name provided\n\n  <decodeOrConvertData>\n  var txBuffer;\n  if (utils.isString(data)) {\n      txBuffer = new Array(protobuf.util.base64.length(data));\n      protobuf.util.base64.decode(data, txBuffer, 0);\n  } else {\n      txBuffer = data;\n  }\n  </decodeOrConvertData>\n\n  <parseTransactionProto>\n  var TransactionProto = root.lookup(\"corepb.Transaction\");\n  var txProto = TransactionProto.decode(txBuffer);\n  </parseTransactionProto>\n\n  <setTransactionProperties>\n  this.hash = cryptoUtils.toBuffer(txProto.hash);\n  this.from = account.fromAddress(txProto.from);\n  this.to = account.fromAddress(txProto.to);\n  this.value = utils.toBigNumber(\"0x\" + cryptoUtils.toBuffer(txProto.value).toString(\"hex\"));\n  this.nonce = parseInt(txProto.nonce.toString());\n  this.timestamp = parseInt(txProto.timestamp.toString());\n  this.data = txProto.data;\n  if (this.data.payload.length === 0) {\n      this.data.payload = null;\n  }\n  this.chainID = txProto.chainId;\n  this.gasPrice = utils.toBigNumber(\"0x\" + cryptoUtils.toBuffer(txProto.gasPrice).toString(\"hex\"));\n  this.gasLimit = utils.toBigNumber(\"0x\" + cryptoUtils.toBuffer(txProto.gasLimit).toString(\"hex\"));\n  this.alg = txProto.alg;\n  this.sign = cryptoUtils.toBuffer(txProto.sign);\n  </setTransactionProperties>\n\n  return this;\n}\n"], ["LCDCharacter", "\nfunction LCDCharacter(memoryPosition, map) {\n  <constructLCDCharacter>\n  if (!(this instanceof LCDCharacter)) {\n      return new LCDCharacter(memoryPosition, map);\n  }\n  </constructLCDCharacter>\n  \n  <validateMemoryPosition>\n  if (!(typeof memoryPosition === 'number') || memoryPosition < 0 || memoryPosition > 7) {\n      throw new Error('The specified memory position is invalid (should be between 0 and 7).');\n  }\n  </validateMemoryPosition>\n  \n  <validateMap>\n  if (!Array.isArray(map) || map.length !== 8) {\n      throw new Error('The specified map is invalid (should be an array containing eight 8-bit integers).');\n  }\n  </validateMap>\n  \n  <setCharacterProperties>\n  this.memoryPosition = memoryPosition;\n  this.map = map;\n  </setCharacterProperties>\n}\n"], ["getGesture", "\nfunction getGesture(element_) {\n  <initializeElement>\n  const element = ensureDom(element_);\n  if (!element[SYMBOL]) element[SYMBOL] = new Gesture(element);\n  </initializeElement>\n  return element[SYMBOL];\n}\n"], ["populateInterfacesList", "\nfunction populateInterfacesList(intfs) {\n  <clearInterfaceList>\n  e_interfaceList.innerHTML = \"\"\n  </clearInterfaceList>\n\n  <normalizeInterfaceDefinitions>\n  fixedIntfs = []\n  intfs.forEach(function(intf){\n      fixedIntfs.push(intf.name)\n      Interfaces[intf.name] = intf\n\n      if (!intf.methods) intf.methods = []\n      if (!intf.attributes) intf.attributes = []\n  })\n  </normalizeInterfaceDefinitions>\n\n  <sortAndPopulateList>\n  intfs = fixedIntfs\n  intfs.sort()\n  intfs.forEach(function(intf){\n    <createElement>\n    var a  = document.createElement(\"a\")\n    a.href          = \"#\"\n    a.innerHTML     = intf\n    a.interfaceName = intf\n    a.addEventListener(\"click\", el_interfaceClicked, false)\n    </createElement>\n\n    <appendToList>\n    var li = document.createElement(\"li\")\n    li.appendChild(a)\n    e_interfaceList.appendChild(li)\n    </appendToList>\n  })\n  </sortAndPopulateList>\n}\n"], ["changeMode", "\nfunction changeMode(newMode) {\n  <getEditorPosition>\n  var editorPos = editable.getDocumentPosition();\n  </getEditorPosition>\n\n  <updateEditorPosition>\n  switch (newMode) {\n    case 'top':\n      updatePos('absolute', 'top', editorPos.y - spaceHeight - dockedOffsetY);\n      break;\n    case 'pin':\n      updatePos('fixed', 'top', pinnedOffsetY);\n      break;\n    case 'bottom':\n      updatePos('absolute', 'top', editorPos.y + (editorRect.height || editorRect.bottom - editorRect.top) + dockedOffsetY);\n      break;\n  }\n  </updateEditorPosition>\n\n  <setNewMode>\n  mode = newMode;\n  </setNewMode>\n}\n"], ["getLocaleExtraDayPeriods", "\nfunction getLocaleExtraDayPeriods(locale, formStyle, width) {\n  <findLocaleData>\n  var data = findLocaleData(locale);\n  </findLocaleData>\n  <ensureFullData>\n  checkFullData(data);\n  </ensureFullData>\n  <retrieveDayPeriods>\n  var dayPeriodsData = [\n    data[19 ][0 ],\n    data[19 ][1 ]\n  ];\n  var dayPeriods = getLastDefinedValue(dayPeriodsData, formStyle) || [];\n  </retrieveDayPeriods>\n  return getLastDefinedValue(dayPeriods, width) || [];\n}\n"], "```"]