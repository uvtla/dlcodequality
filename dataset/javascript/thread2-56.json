[["parseDSV2ChartData", "\nfunction parseDSV2ChartData(code, delimiter) {\n  \n  <trimCode>\n  code = trimKeepingTabs(code);\n  </trimCode>\n\n  <setDelimiter>\n  csv.COLUMN_SEPARATOR = delimiter || detectDelimiter(code);\n  </setDelimiter>\n\n  <parseCSV>\n  let dsv = csv.parse(code);\n  </parseCSV>\n\n  <trimValues>\n  dsv = dsv.map(arr => arr.map(val => val.trim()));\n  </trimValues>\n\n  <detectLegends>\n  const hasLegends = dsv[0].filter((v, i) => i > 0).reduce((hasNaN, item) => hasNaN || !isNumeric(item), false);\n  const legends = hasLegends ? dsv.shift() : [];\n  </detectLegends>\n\n  <detectCategories>\n  const hasCategories = dsv.slice(1).reduce((hasNaN, row) => hasNaN || !isNumeric(row[0]), false);\n  const categories = hasCategories ? dsv.map(arr => arr.shift()) : [];\n  if (hasCategories) {\n    legends.shift();\n  }\n  </detectCategories>\n\n  <parseNumericalData>\n  dsv = dsv[0].map((t, i) => dsv.map(x => parseFloat(x[i])));\n  </parseNumericalData>\n\n  <createSeries>\n  const series = dsv.map((data, i) => hasLegends ? {\n    name: legends[i],\n    data\n  } : {\n    data\n  });\n  </createSeries>\n\n  return {\n    categories,\n    series\n  };\n}\n"], ["activateEditables", "\nfunction(name) {\n  var i;\n  if (this.$editables.length) {\n    \n    <checkByName>\n    if (angular.isString(name)) {\n      for(i=0; i<this.$editables.length; i++) {\n        if (this.$editables[i].name === name) {\n          this.$editables[i].activate();\n          return;\n        }\n      }\n    }\n    </checkByName>\n\n    <checkByError>\n    for(i=0; i<this.$editables.length; i++) {\n      if (this.$editables[i].error) {\n        this.$editables[i].activate();\n        return;\n      }\n    }\n    </checkByError>\n\n    <activateFirst>\n    this.$editables[0].activate();\n    </activateFirst>\n  }\n}\n"], ["numberLines", "\nfunction numberLines(node, startLineNum, isPreformatted) {\n  <initialSetup>\n  var nocode = /(?:^|\\s)nocode(?:\\s|$)/;\n  var lineBreak = /\\r\\n?|\\n/;\n\n  var document = node.ownerDocument;\n\n  var li = document.createElement('li');\n  while (node.firstChild) {\n    li.appendChild(node.firstChild);\n  }\n  var listItems = [li];\n  </initialSetup>\n\n  <walkNodes>\n  function walk(node) {\n    <visitElementNodes>\n    var type = node.nodeType;\n    if (type == 1 && !nocode.test(node.className)) {  \n      if ('br' === node.nodeName.toLowerCase()) {\n        breakAfter(node);\n        \n        if (node.parentNode) {\n          node.parentNode.removeChild(node);\n        }\n      } else {\n        for (var child = node.firstChild; child; child = child.nextSibling) {\n          walk(child);\n        }\n      }\n    }\n    </visitElementNodes>\n    else if ((type == 3 || type == 4) && isPreformatted) {  \n      <splitTextNode>\n      var text = node.nodeValue;\n      var match = text.match(lineBreak);\n      if (match) {\n        var firstLine = text.substring(0, match.index);\n        node.nodeValue = firstLine;\n        var tail = text.substring(match.index + match[0].length);\n        if (tail) {\n          var parent = node.parentNode;\n          parent.insertBefore(\n            document.createTextNode(tail), node.nextSibling);\n        }\n        breakAfter(node);\n        if (!firstLine) {\n          \n          node.parentNode.removeChild(node);\n        }\n      }\n      </splitTextNode>\n    }\n  }\n  </walkNodes>\n\n  <generateListItems>\n  function breakAfter(lineEndNode) {\n    \n    \n    while (!lineEndNode.nextSibling) {\n      lineEndNode = lineEndNode.parentNode;\n      if (!lineEndNode) { return; }\n    }\n\n    function breakLeftOf(limit, copy) {\n      \n      \n      var rightSide = copy ? limit.cloneNode(false) : limit;\n      var parent = limit.parentNode;\n      if (parent) {\n        \n        \n        var parentClone = breakLeftOf(parent, 1);\n        \n        \n        var next = limit.nextSibling;\n        parentClone.appendChild(rightSide);\n        for (var sibling = next; sibling; sibling = next) {\n          next = sibling.nextSibling;\n          parentClone.appendChild(sibling);\n        }\n      }\n      return rightSide;\n    }\n\n    var copiedListItem = breakLeftOf(lineEndNode.nextSibling, 0);\n\n    \n    for (var parent;\n         \n         (parent = copiedListItem.parentNode) && parent.nodeType === 1;) {\n      copiedListItem = parent;\n    }\n    \n    listItems.push(copiedListItem);\n  }\n  </generateListItems>\n\n  <walkAndSplit>\n  for (var i = 0;  \n       i < listItems.length;  \n       ++i) {\n    walk(listItems[i]);\n  }\n  </walkAndSplit>\n\n  <configureLineNumbers>\n  if (startLineNum === (startLineNum|0)) {\n    listItems[0].setAttribute('value', startLineNum);\n  }\n\n  var ol = document.createElement('ol');\n  ol.className = 'linenums';\n  var offset = Math.max(0, ((startLineNum - 1 )) | 0) || 0;\n  for (var i = 0, n = listItems.length; i < n; ++i) {\n    li = listItems[i];\n    \n    \n    \n    li.className = 'L' + ((i + offset) % 10);\n    if (!li.firstChild) {\n      li.appendChild(document.createTextNode('\\xA0'));\n    }\n    ol.appendChild(li);\n  }\n  </configureLineNumbers>\n\n  node.appendChild(ol);\n}\n"], ["exampleScripts", "\nfunction exampleScripts() {\n  <gulpWebpackPipeline>\n  return gulp.src( './examples/index.js' )\n    .pipe( webpackStream( {\n      module: {\n        <webpackConfiguration>\n        rules: [ {\n          use: [ {\n            loader: 'babel-loader?cacheDirectory=true',\n            options: {\n              presets: [ [ 'env', {\n                targets: {\n                  browsers: config.supportedBrowsers\n                },\n                debug: true\n              } ] ]\n            }\n          } ],\n          exclude: /node_modules/\n        } ]\n        </webpackConfiguration>\n      },\n      output: {\n        <webpackOutput>\n        filename: 'example.js'\n        </webpackOutput>\n      },\n    }, webpack ) )\n    .pipe( gulp.dest( config.BUILD ) );\n  </gulpWebpackPipeline>\n}\n"], ["adjustEventPosition", "\nfunction(evt) {\n  <calculatePosition>\n  var pos = OpenLayers.Util.pagePosition(this.map.viewPortDiv);\n  evt.xy.x -= pos[0];\n  evt.xy.y -= pos[1];\n  </calculatePosition>\n}\n"], ["initI18n", "\nfunction _init () {\n  if (_locale) return\n\n  <configureI18n>\n  i18nL.configure({\n    directory: appRoot + '/locales',\n    defaultLocale: 'en'\n  })\n  </configureI18n>\n\n  <setAndReloadLocale>\n  watch(api.settings.obs.get('patchwork.lang'), currentLocale => {\n    currentLocale = currentLocale || navigator.language\n    var locales = i18nL.getLocales()\n\n    \n    if (locales.indexOf(currentLocale) !== -1) {\n      i18nL.setLocale(currentLocale)\n    } else {\n      i18nL.setLocale(getSimilar(locales, currentLocale))\n    }\n\n    \n    \n    if (_locale) {\n      electron.remote.getCurrentWebContents().reloadIgnoringCache()\n    }\n  })\n  </setAndReloadLocale>\n\n  _locale = true\n}\n"], ["flattenDepth", "\nfunction flattenDepth(array, depth) {\n  <flattenArray>\n  var length = array ? array.length : 0;\n  if (!length) {\n    return [];\n  }\n  depth = depth === undefined ? 1 : toInteger(depth);\n  return baseFlatten(array, depth);\n  </flattenArray>\n}\n"], ["wrapPorts", "\nfunction wrap() {\n  var ports = this.compiledModule.ports;\n\n  <setupEmitters>\n  var incomingEmitter = new EventEmitter();\n  var outgoingEmitter = new EventEmitter();\n  </setupEmitters>\n\n  var emit = incomingEmitter.emit.bind(incomingEmitter);\n\n  <managePortSubscriptions>\n  Object.keys(ports).forEach(function(key) {\n    outgoingEmitter.addListener(key, function() {\n      var args = Array.prototype.slice.call(arguments)\n\n      ports[key].send.apply(ports[key], args);\n    });\n\n    if (ports[key].subscribe) {\n      ports[key].subscribe(function() {\n        var args = Array.prototype.slice.call(arguments);\n        args.unshift(key);\n\n        emit.apply(incomingEmitter, args);\n      });\n    }\n  });\n  </managePortSubscriptions>\n\n  <overrideEmitMethod>\n  incomingEmitter.emit = outgoingEmitter.emit.bind(outgoingEmitter);;\n  </overrideEmitMethod>\n\n  this.emitter = incomingEmitter;\n  this.ports = this.compiledModule.ports;\n}\n"], ["createArbiter", "\nfunction create () {\n    \n    var\n      <topicsInitialization>\n      topics = createNode(''),\n      </topicsInitialization>\n      <optionsInitialization>\n      options = {\n        persist: false,\n        sync: false,\n        preventBubble: false,\n        latch: 0.9999999999999999,\n        settlementLatch: false,\n        semaphor: Infinity,\n        updateAfterSettlement: false\n      },\n      </optionsInitialization>\n      <arbiterInitialization>\n      arbiter = {\n        _topics: topics,\n        options: options,\n        version: 'v1.0.0',\n        id: mkGenerator(),\n        create: create\n      };\n      </arbiterInitialization>\n\n    <setupArbiterFunctions>\n    arbiter.subscribe = partial1(subscribeDispatcher, arbiter);\n    arbiter.publish = partial1(publish, arbiter);\n    arbiter.unsubscribe = partial1(unsubscribe, arbiter);\n    arbiter.resubscribe = partial1(resubscribe, arbiter);\n    arbiter.removePersisted = partial1(removePersistedDispatcher, arbiter);\n    </setupArbiterFunctions>\n\n    return arbiter;\n  }\n"], ["pushInUnicode", "\nfunction pushInUnicode(cat, elt) {\n  <manageUnicodeEntries>\n  if (!unicode.hasOwnProperty(cat)) {\n    unicode[cat] = {\n      unicode: [],\n      ranges: []\n    };\n  }\n\n  if (Array.isArray(elt)) {\n    unicode[cat].ranges.push(elt);\n  } else {\n    unicode[cat].unicode.push(elt);\n  }\n  </manageUnicodeEntries>\n}\n"], "```"]