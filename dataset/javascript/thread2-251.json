[["isWindowObject", "\nfunction(o) {\n    return o && o.document && o.location && o.alert && o.setInterval;\n}\n"], ["searchBase", "\nfunction searchBase(base) {\n    <resolveBaseName>\n    var basename = path.resolve(base, modulename);\n    </resolveBaseName>\n\n    <searchForExactFileName>\n    var filename = searchArray(dirMap, basename);\n    if (filename) return filename;\n    </searchForExactFileName>\n\n    <searchForJSExtension>\n    filename = searchArray(dirMap, basename + '.js');\n    if (filename) return filename;\n    </searchForJSExtension>\n\n    <searchForJSONExtension>\n    filename = searchArray(dirMap, basename + '.json');\n    if (filename) return filename;\n    </searchForJSONExtension>\n\n    <checkForPathValidity>\n    if (isPath) return false;\n    </checkForPathValidity>\n\n    <searchForPackage>\n    if (packageMap[basename]) {\n      return packageMap[basename];\n    }\n    </searchForPackage>\n\n    <searchForIndexJSFile>\n    return searchArray(dirMap, basename + '/index.js');\n    </searchForIndexJSFile>\n}\n"], ["repack", "\nfunction repack(obj) {\n  var outp = [];\n  <convertObjectToArray>\n  Object.keys(obj||{}).forEach(function(k){\n    outp.push({name:k, version:obj[k]});\n  });\n  </convertObjectToArray>\n  return outp;\n}\n"], ["rollback", "\nfunction rollback() {\n    <ensureConfigAndGetName>\n    var parsed = ensureConfig();\n    var name = parsed.name;\n    </ensureConfigAndGetName>\n\n    <parseIndexIfNumeric>\n    try {\n        var idx = void 0;\n        if (/^[0-9]+$/.test(name)) {\n            idx = parseInt(parsed.name) - 1;\n            if (idx >= 0) {\n                var keys = Object.keys(mu.rollbacks);\n                var key = keys[idx];\n                if (key)\n                    name = key;\n            }\n        }\n    }\n    catch (ex) { }\n    </parseIndexIfNumeric>\n\n    <performRollback>\n    mu.rollback(parsed.name, parsed.output);\n    </performRollback>\n}\n"], ["promiseAssertionHandler", "\nfunction (resolved, val) {\n    <setupAssertion>\n    var should = (negate ?\n        (new Assertion(val)).not :\n        (new Assertion(val))\n    );\n    </setupAssertion>\n\n    <handleThrowableAssert>\n    if (storedAssertions[0][0] !== 'throw' && !resolved) {\n        throw val;\n    }\n    </handleThrowableAssert>\n\n    <processAssertions>\n    var result = storedAssertions.reduce(function (accum, cur) {\n        <handleThrowAssertion>\n        if (cur[0] === 'throw') {\n            var obj = accum.obj;\n            accum.obj = function () {\n                if (resolved) { return obj; }\n                else { throw obj; }\n            };\n        }\n        </handleThrowAssertion>\n\n        <validateResolution>\n        if (cur[0] === 'throw') {\n            if (resolved === !!accum.negate) {\n                caught = true;\n            } else {\n                throw new AssertionError({\n                    message: 'Expected promise to be ' + (negate ? 'resolved' : 'rejected') +\n                        ' but instead it was ' + (resolved ? 'resolved' : 'rejected') + ' with ' + inspect(val),\n                    actual: val\n                });\n            }\n        }\n        </validateResolution>\n\n        <assertCurArguments>\n        if (cur.length === 1) {\n            return accum[cur[0]];\n        } else {\n            return accum[cur[0]].apply(accum, cur[1]);\n        }\n        </assertCurArguments>\n    }, should); \n    </processAssertions>\n\n    <throwOnUnresolvedRejection>\n    if (!resolved && !caught) {\n        throw new AssertionError({\n            message: 'Promise was rejected unexpectedly with ' + inspect(val),\n            actual: val\n        });\n    }\n    </throwOnUnresolvedRejection>\n\n    return result;\n}\n"], ["collationNotSupported", "\nfunction collationNotSupported(server, cmd) {\n  return cmd && cmd.collation && server.ismaster && server.ismaster.maxWireVersion < 5;\n}\n"], ["getCookieByName", "\nfunction(name) {\n    var cookie = document.cookie, e, p = name + \"=\", b;\n\n    <checkIfCookieExists>\n    if ( !cookie )\n        return;\n    </checkIfCookieExists>\n\n    <findCookie>\n    b = cookie.indexOf(\"; \" + p);\n\n    if ( b == -1 ) {\n        b = cookie.indexOf(p);\n\n        if ( b != 0 )\n            return null;\n\n    } else {\n        b += 2;\n    }\n    </findCookie>\n\n    <extractCookieValue>\n    e = cookie.indexOf(\";\", b);\n\n    if ( e == -1 )\n        e = cookie.length;\n\n    return decodeURIComponent( cookie.substring(b + p.length, e) );\n    </extractCookieValue>\n}\n"], ["DOMViewControllerMixin", "\nfunction DOMViewControllerMixin(view) {\n\n  <attachEventsToView>\n  function attachEvents() {\n\n    <retrieveEvents>\n    var events;\n    if (isFunction(view.events)) {\n      events = view.events();\n    } else {\n      events = view.events || {};\n    }\n    </retrieveEvents>\n\n    <bindEvents>\n    for (var key in events) {\n      if (events.hasOwnProperty(key)) {\n        var fn;\n\n        <bindEvent>\n        (function () {\n          var firstSpaceIndex = key.indexOf(' ');\n          var type = undefined;\n          var selector = undefined;\n          if (firstSpaceIndex === -1) {\n            type = key;\n          } else {\n            type = key.substr(0, firstSpaceIndex);\n            selector = key.substr(firstSpaceIndex + 1);\n          }\n          fn = events[key];\n\n          <invokeEventHandler>\n          (function (fn) {\n            view.$el.on(type, selector, function (event) {\n              if (_this[fn] === undefined) {\n                throw new Error('mixin target has no function: ' + fn);\n              }\n              _this[fn](event, view);\n            });\n          })(fn);\n          </invokeEventHandler>\n        })();\n        </bindEvent>\n\n      }\n    }\n    </bindEvents>\n  }\n  </attachEventsToView>\n\n  attachEvents();\n}\n"], ["createEntryFacade", "\nfunction createEntryFacade(entry) {\n    <validateEntry>\n    if (entry instanceof Entry !== true) {\n        throw new Error(\"Failed creating entry facade: Provided item is not an Entry\");\n    }\n    </validateEntry>\n\n    <getFacadeTypeAndFields>\n    const facadeType = getEntryFacadeType(entry);\n    const createFields = facadeFieldFactories[facadeType];\n    if (!createFields) {\n        throw new Error(`Failed creating entry facade: No factory found for type \"${facadeType}\"`);\n    }\n    const fields = createFields(entry);\n    </getFacadeTypeAndFields>\n\n    <createFacade>\n    return {\n        type: facadeType,\n        fields: addExtraFieldsNonDestructive(entry, fields)\n    };\n    </createFacade>\n}\n"], ["registerTypeAlias", "\nfunction(alias, type) {\n    <parseAndResolveType>\n    var parameters = {},\n        __type = parse_type(type, parameters).toLowerCase(),\n        constructor = resolve_ctr(__type, parameters);\n    if (!constructor)\n        throw new TypeError('Type ' + __type + ' not registered!');\n    </parseAndResolveType>\n\n    <setAlias>\n    this[alias.toLowerCase()] = { __type: __type, parameters: parameters, isAlias: true };\n    </setAlias>\n}\n"], "```"]