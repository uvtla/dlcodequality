[["histogram", "\nfunction histogram() {\n  <initializeHistogram>\n  const histogram = {\n    r: new Array(256).fill(0),\n    g: new Array(256).fill(0),\n    b: new Array(256).fill(0)\n  };\n  </initializeHistogram>\n\n  <calculateHistogram>\n  this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(\n    x,\n    y,\n    index\n  ) {\n    histogram.r[this.bitmap.data[index + 0]]++;\n    histogram.g[this.bitmap.data[index + 1]]++;\n    histogram.b[this.bitmap.data[index + 2]]++;\n  });\n  </calculateHistogram>\n\n  return histogram;\n}\n"], ["isAtCodePoint", "\nfunction isAtCodePoint(stream) {\n\tconst code = stream.peek();\n\n\treturn (isQuote(code) && getPrevCode(stream) === code)\n\t\t|| (code === 60  && getPrevCode(stream) === 62 )\n\t\t|| (isLineBreak(code) && reEmptyLine.test(stream.buffer.lineForRow(stream.pos.row)));\n}\n"], ["formatTime", "\nfunction formatTime(time) {\n\t<validateAndFormatTime>\n\tif (time == '') {\n\t\tif (settings.required) return settings.duration ? '0:00' : '00:00';\n\t\telse return time;\n\t}\n\tif ((new RegExp('^(-|\\\\+)?([0-9]+)(.([0-9]{1,2})?)?$', 'i')).test(time)) {\n\t\tvar hour = parseInt(RegExp.$2);\n\t\tvar min = parseInt(RegExp.$4);\n\t\tif (!min) min = 0;\n\t\tvar negative = settings.duration && settings.durationNegative && RegExp.$1 == '-' ? true : false;\n\t\tif (hour >= 24 && !settings.duration) hour = hour % 24;\n\t\tif (min >= 60) min = min % 60;\n\t\tif (settings.precision != 1) {\n\t\t\tvar f = Math.floor(min / settings.precision);\n\t\t\tmin = f * settings.precision + (Math.round((min - f * settings.precision) / settings.precision) == 1 ? settings.precision : 0);\n\t\t\tif (min >= 60) min = 0;\n\t\t}\n\t\ttime = (negative ? '-' : '') + (hour < 10 && !settings.duration ? '0' : '') + hour + settings.separator + (RegExp.$3 ? (min < 10 ? '0' : '') + min : '00');\n\t}\n\telse if ((new RegExp('^(-|\\\\+)?.([0-9]{1,2})')).test(time)) {\n\t\tvar min = parseInt(RegExp.$2);\n\t\tvar negative = settings.duration && settings.durationNegative && RegExp.$1 == '-' ? true : false;\n\t\tif (min >= 60) min = min % 60;\n\t\ttime = (negative && min > 0 ? '-' : '') + '0' + (!settings.duration ? '0' : '') + settings.separator + (min < 10 ? '0' : '') + min;\n\t}\n\telse {\n\t\ttime = '0' + (!settings.duration ? '0' : '') + settings.separator + '00';\n\t}\n\t</validateAndFormatTime>\n\treturn (settings.duration && settings.useDurationPlusSign && !time.match(/^\\-/) && !time.match(/^0+:00$/) ? '+' : '') + time;\n}\n"], ["function", "\nfunction(def, thisArg, func) {\n            \n    <createDeferred>\n    var d = new can.Deferred();\n    </createDeferred>\n    \n    <resolveOrReject>\n    def.then(function() {\n        var args = can.makeArray(arguments),\n            success = true;\n\n        try {\n            args[0] = func.apply(thisArg, args);\n        } catch (e) {\n            success = false;\n            d.rejectWith(d, [e].concat(args));\n        }\n        if (success) {\n            d.resolveWith(d, args);\n        }\n    }, function() {\n        d.rejectWith(this, arguments);\n    });\n    </resolveOrReject>\n\n    <abortFunction>\n    if (typeof def.abort === 'function') {\n        d.abort = function() {\n            return def.abort();\n        };\n    }\n    </abortFunction>\n\n    return d;\n}\n"], ["uniq", "\nfunction uniq() {\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    <performUniqOperation>\n    return multiArrayMacro(args, function (dependentKeys) {\n      var _this2 = this;\n\n      var uniq = _emberRuntimeSystemNative_array.A();\n\n      dependentKeys.forEach(function (dependentKey) {\n        var value = _emberMetalProperty_get.get(_this2, dependentKey);\n        if (_emberRuntimeUtils.isArray(value)) {\n          value.forEach(function (item) {\n            if (uniq.indexOf(item) === -1) {\n              uniq.push(item);\n            }\n          });\n        }\n      });\n\n      return uniq;\n    });\n    </performUniqOperation>\n}\n"], ["_encodePkcs1_v1_5", "\nfunction _encodePkcs1_v1_5(m, key, bt) {\n  <initializeBuffer>\n  var eb = forge.util.createBuffer();\n  </initializeBuffer>\n\n  <calculateKeyLength>\n  var k = Math.ceil(key.n.bitLength() / 8);\n  </calculateKeyLength>\n\n  <checkMessageLength>\n  if(m.length > (k - 11)) {\n    var error = new Error('Message is too long for PKCS#1 v1.5 padding.');\n    error.length = m.length;\n    error.max = k - 11;\n    throw error;\n  }\n  </checkMessageLength>\n\n  <createPadding>\n  eb.putByte(0x00);\n  eb.putByte(bt);\n\n  var padNum = k - 3 - m.length;\n  var padByte;\n  if(bt === 0x00 || bt === 0x01) {\n    padByte = (bt === 0x00) ? 0x00 : 0xFF;\n    for(var i = 0; i < padNum; ++i) {\n      eb.putByte(padByte);\n    }\n  } else {\n    while(padNum > 0) {\n      var numZeros = 0;\n      var padBytes = forge.random.getBytes(padNum);\n      for(var i = 0; i < padNum; ++i) {\n        padByte = padBytes.charCodeAt(i);\n        if(padByte === 0) {\n          ++numZeros;\n        } else {\n          eb.putByte(padByte);\n        }\n      }\n      padNum = numZeros;\n    }\n  }\n  </createPadding>\n\n  <finalizeBuffer>\n  eb.putByte(0x00);\n  eb.putBytes(m);\n  </finalizeBuffer>\n\n  return eb;\n}\n"], ["transform", "\nfunction transform(path) {\n    <processPath>\n    if (shouldProcess(path)) {\n        const renderer = Renderer.forPath(path);\n        transformer(path.node, renderer, buildErrorHandler(path));\n        \n        if (Renderer.isParent(path)) {\n            path.parentPath.replaceWith(renderer.toFunctionCall());\n        } else {\n            path.replaceWith(renderer.toFunctionCall());\n        }\n    }\n    </processPath>\n}\n"], ["loadFromIndividualConfigFile", "\nfunction loadFromIndividualConfigFile(key) {\n    <sanitizeKey>\n    key = _.replace(key, /\\/|\\\\/g, ''); \n    </sanitizeKey>\n\n    <checkCache>\n    if (individualKeyCache[key]) {\n        return individualKeyCache[key];\n    } else {\n    </checkCache>\n\n        <loadFile>\n        var toLoad = path.resolve(global.__appDir, 'config/' + key + '.json');\n\n        var content = '{}';\n        try {\n            content = fs.readFileSync(toLoad);\n        } catch (err) {\n            \n        }\n        </loadFile>\n\n        <parseAndDecrypt>\n        var json = {};\n        try {\n            json = JSON.parse(stripJsonComments(content.toString()));\n        } catch (err) {\n            console.warn('Error parsing JSON for %s', toLoad);\n        }\n\n        security.decryptObject(json, function (str) {\n            \n            return security.decrypt(str, process.env.decryptionKey);\n        });\n        </parseAndDecrypt>\n        \n        <updateCache>\n        individualKeyCache[key] = json;\n\n        return individualKeyCache[key];\n        </updateCache>\n    }\n}\n"], ["translate", "\nfunction translate() {\n      <calculateOffset>\n      var offset = this.move * this.percentage;\n\n      if (!this.$refs.stripContainer) return;\n\n      if (offset < 0) {\n        offset = 0;\n      }\n      if (offset > this.maxOffset) {\n        offset = this.maxOffset;\n      }\n      this.currentOffset = offset;\n      </calculateOffset>\n\n      <applyTranslation>\n      return {\n        transform: this.config.translate + '(' + offset + 'px)'\n      };\n      </applyTranslation>\n}\n"], ["createBlobReadStream", "\nasync function createBlobReadStream(dir, oid) {\n  <readObject>\n  const { object: content } = await git.readObject({ dir, oid });\n  </readObject>\n  \n  <createStream>\n  const stream = new PassThrough();\n  stream.end(content);\n  </createStream>\n  \n  return stream;\n}\n"], "```"]