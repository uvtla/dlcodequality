[["objectToQueryString", "\nfunction objectToQueryString(obj) {\n  var str = [];\n  for (var p in obj) {\n    if (obj.hasOwnProperty(p)) {\n      str.push(p + '=' + obj[p]);\n    }\n  }\n  return str.join('&');\n}\n"], ["toBoolean", "\nfunction toBoolean(input) {\n  if (_.isString(input) && [\"false\", \"f\", \"n\", \"no\"].indexOf(input.toLowerCase()) !== -1) {\n    return false;\n  }\n  return (input === null) ? null : !!input;\n}\n"], ["RangeTreeNode", "\nfunction RangeTreeNode(parent) {\n  this.parent = parent;\n  this.start = undefined;\n  this.end = undefined;\n  this.children = [];\n\n  \n  <setStart>\n  this.setStart = function (node, index) {\n    this.start = { node: node, index: index };\n  };\n  </setStart>\n\n  \n  <setEnd>\n  this.setEnd = function (node, index) {\n    this.end = { node: node, index: index };\n  };\n  </setEnd>\n\n  \n  <getParent>\n  this.getParent = function () {\n    if (!this.parent) {\n      this.parent = new RangeTreeNode();\n      this.parent.children.push(this);\n    }\n    return this.parent;\n  };\n  </getParent>\n\n  \n  <createNewChild>\n  this.createNewChild = function () {\n    var child = new RangeTreeNode(this);\n    this.children.push(child);\n    return child;\n  };\n  </createNewChild>\n\n  \n  <getNextSibling>\n  this.getNextSibling = function () {\n    return this.getParent().createNewChild();\n  };\n  </getNextSibling>\n\n  \n  <toRanges>\n  this.toRanges = function () {\n    var top = this;\n    while (top.parent) {\n      top = top.parent;\n    }\n    return _toRangesRecursive(top, []);\n  };\n  </toRanges>\n\n  \n  <_toRangesRecursive>\n  function _toRangesRecursive(node, list) {\n    if (node.start && node.end) {\n      var range = $window.document.createRange();\n      range.setStart(node.start.node, node.start.index);\n      range.setEnd(node.end.node, node.end.index);\n      list.push(range);\n    }\n    for (var c in node.children) {\n      _toRangesRecursive(node.children[c], list);\n    }\n    return list;\n  }\n  </_toRangesRecursive>\n}\n"], ["randProbPrime", "\nfunction randProbPrime(k) {\n  if (k >= 600) return randProbPrimeRounds(k, 2);\n  if (k >= 550) return randProbPrimeRounds(k, 4);\n  if (k >= 500) return randProbPrimeRounds(k, 5);\n  if (k >= 400) return randProbPrimeRounds(k, 6);\n  if (k >= 350) return randProbPrimeRounds(k, 7);\n  if (k >= 300) return randProbPrimeRounds(k, 9);\n  if (k >= 250) return randProbPrimeRounds(k, 12);\n  if (k >= 200) return randProbPrimeRounds(k, 15);\n  if (k >= 150) return randProbPrimeRounds(k, 18);\n  if (k >= 100) return randProbPrimeRounds(k, 27);\n  return randProbPrimeRounds(k, 40);\n}\n"], ["serverRestart", "\nfunction () {\n  this.tries = 1;\n  \n  <handleMaxTries>\n  if (this.tries++ >= 10) {\n    console.error('\u5c1d\u8bd5\u65b0\u7aef\u53e3\u8fc7\u591a\uff0c\u8bf7\u624b\u52a8\u5207\u6362\u5230\u5176\u4ed6\u7aef\u53e3');\n    return process.exit(0);\n  }\n  </handleMaxTries>\n  \n  this.server.listen(this.options.port);\n  this.__reseting = false;\n}\n"], ["androidEnvironmentCheck", "\nfunction (context) {\n  const androidHome = process.env['ANDROID_HOME']\n  const hasAndroidEnv = !context.strings.isBlank(androidHome)\n  \n  <checkAndroidDirectoryExistence>\n  const hasAndroid = hasAndroidEnv && context.filesystem.exists(`${androidHome}/tools`) === 'dir'\n  </checkAndroidDirectoryExistence>\n\n  return Boolean(hasAndroid)\n}\n"], ["getPixelValues", "\nfunction getPixelValues(pixelData) {\n  let minPixelValue = Number.MAX_VALUE;\n  let maxPixelValue = Number.MIN_VALUE;\n  const len = pixelData.length;\n  let pixel;\n  for (let i = 0; i < len; i++) {\n    pixel = pixelData[i];\n    minPixelValue = minPixelValue < pixel ? minPixelValue : pixel;\n    maxPixelValue = maxPixelValue > pixel ? maxPixelValue : pixel;\n  }\n  return {\n    minPixelValue,\n    maxPixelValue\n  };\n}\n"], ["storedPixelDataToImageData", "\nfunction storedPixelDataToImageData(image) {\n  const pixelData = image.getPixelData();\n  const numberOfChannels = 2;\n  const data = new Uint8Array(image.width * image.height * numberOfChannels);\n  let offset = 0;\n  for (let i = 0; i < pixelData.length; i++) {\n    data[offset++] = pixelData[i];\n    data[offset++] = pixelData[i] < 0 ? 0 : 1;\n  }\n  return data;\n}\n"], ["rearrangeArrayIndices", "\nfunction (arr, ct, key) {\n  if (arr[ct] !== undefined) {\n    var tmp = ct;\n    ct += 1;\n    if (ct === key) {\n      ct += 1;\n    }\n    ct = _checkToUpIndices(arr, ct, key)\n    arr[ct] = arr[tmp];\n    delete arr[tmp];\n  }\n  return ct;\n}\n"], ["makeMapForInstanceTearDown", "\nfunction (obj, instance) {\n  var teardown;\n\n  <initializeTeardown>\n  if (!madeMap) {\n    teardown = teardownMap;\n    madeMap = {};\n  }\n  </initializeTeardown>\n\n  <generateUniqueIdForObj>\n  var hasCid = obj._cid;\n  var cid = can.cid(obj);\n  </generateUniqueIdForObj>\n\n  <populateMadeMap>\n  if (!madeMap[cid]) {\n    madeMap[cid] = {\n      obj: obj,\n      instance: instance,\n      added: !hasCid\n    };\n  }\n  </populateMadeMap>\n\n  return teardown;\n}\n"], "```\n\nThe function appears to have multiple responsibilities: initializing data structures, ensuring unique Ids, and populating map structures, thereby violating SRP."]