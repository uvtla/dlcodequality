[["mkitem", "\nfunction mkitem(expr, key, val) {\n  var item = {}\n  item[expr.key] = key\n  if (expr.pos) item[expr.pos] = val\n  return item\n}\n"], ["Validation", "\nfunction (Vue) {\n  var ValidityGroup = Group(Vue);\n\n  var Validation = function Validation (options) {\n    if ( options === void 0 ) options = {};\n\n    this._result = {};\n    this._host = options.host;\n    this._named = Object.create(null);\n    this._group = Object.create(null);\n    this._validities = Object.create(null);\n    this._beginDestroy = false;\n    Vue.util.defineReactive(this._host, '$validation', this._result);\n  };\n\n  Validation.prototype.register = function register (\n    field,\n    validity,\n    options\n  ) {\n    if ( options === void 0 ) options = {};\n\n    <ensureValidityManager>\n    if (!this._validityManager) {\n      this._validityManager = new Vue(ValidityGroup);\n      this._watchValidityResult();\n    }\n    </ensureValidityManager>\n\n    <registerValidity>\n    if (this._validities[field]) {\n      return\n    }\n    this._validities[field] = validity;\n    </registerValidity>\n\n    <manageGroupAndNamedValidity>\n    // similar logic repeated for managing group and named validities\n    var named = options.named;\n    var group = options.group;\n    // snipped for brevity...\n    </manageGroupAndNamedValidity>\n  };\n\n  // Other methods excluded for brevity...\n\n  return Validation\n}\n"], ["findDataByFlavor", "\nfunction(dataFlavor){\n  for (var i = 0; i < this.data.length; i++){\n    var tempdata = this.data[i];\n    if (tempdata.dataFlavor === dataFlavor){\n      return tempdata.val;\n    }\n  }\n}\n"], ["groupContribs", "\nfunction _groupContribs (contribs) {\n  let groups = new Map()\n  groups.set('NOGROUP', [])\n  for (let contrib of contribs) {\n    let groupId = contrib.group\n    if (groupId) {\n      if (!groups.has(groupId)) {\n        groups.set(groupId, [])\n      }\n      groups.get(groupId).push(contrib)\n    } else {\n      groups.get('NOGROUP').push(contrib)\n    }\n  }\n  return groups\n}\n"], ["scroll", "\nfunction scroll(comp, destOffset = 0, times = 20, propName = 'scrollTop') {\n  if (!comp || !comp.dom) throw new Error('invalid params')\n  if (typeof times !== 'number' || times <= 0) times = 1\n\n  destOffset = destOffset < 0 ? 0 : destOffset\n\n  const dom = comp.dom\n  const delta = destOffset - dom[propName]\n  \n  const unit = ~~(delta / times)\n  const env = _.getEnv()\n\n  <domManipulationForNodejs>\n  if (env === 'nodejs') {\n    for (let i = 0; i < times; i++) {\n      setTimeout(() => {\n        if (i === times - 1) dom[propName] = destOffset\n        else dom[propName] += unit\n        dom.dispatchEvent(new Event('scroll', {bubbles: true, cancelable: false}))\n      }, 0)\n    }\n  } else {\n  </domManipulationForNodejs>\n    <domManipulationForBrowser>\n    dom[propName] = destOffset\n    </domManipulationForBrowser>\n  }\n}\n"], ["initModule", "\nfunction initModule(forge) {\n  forge.pki = forge.pki || {};\n  var oids = forge.pki.oids = forge.oids = forge.oids || {};\n\n  <setupOids>\n  // Mapping of numerous OIDs to their respective string representation\n  oids['1.2.840.113549.1.1.1'] = 'rsaEncryption';\n  // ...more OIDs mapping skipped for brevity...\n  </setupOids>\n}\n"], ["functionWithNoNameAndVisibleToggle", "\nfunction () {\n  if (!this.visible) {\n    <addChildToGameWorld>\n    me.game.world.addChild(this, Infinity);\n    </addChildToGameWorld>\n\n    <registerPointerEvent>\n    me.input.registerPointerEvent(\"pointerdown\", this, this.onClick.bind(this));\n    </registerPointerEvent>\n\n    <setVisibilityAndRepaint>\n    this.visible = true;\n    me.game.repaint();\n    </setVisibilityAndRepaint>\n  }\n}\n"], ["taskSchedulingFunction", "\nfunction(started_time) {\n  <initializeTimers>\n  var now = new Date().getTime();\n  this._started_time = started_time || now;\n  this._end_time = this._started_time + this._duration;\n  </initializeTimers>\n\n  <taskScheduling>\n  if (now < this._end_time) {\n    this._is_running = true;\n    Lava.Cron.acceptTask(this);\n    this.onTimer(now);\n  } else {\n    this.onTimer(this._end_time);\n  }\n  </taskScheduling>\n}\n"], ["attributeTransferFunction", "\nfunction (source, destination, attrs) {\n  <validateSourceAndDestination>\n  if (!Node.isElement(source) || !Node.isElement(destination)) return;\n  </validateSourceAndDestination>\n  <transferAttributes>\n  Arr.each(attrs, function (attr) {\n    transferOne(source, destination, attr);\n  });\n  </transferAttributes>\n}\n"], ["callHookFunction", "\nfunction callHook(name, getArgument, handleResult, output) {\n  getArgument = getArgument || defaultGetArgument;\n  handleResult = handleResult || defaultHandleResult;\n\n  var logger = output.getLogger();\n  var plugins = output.getPlugins();\n\n  <logHookCall>\n  logger.debug.ln('calling hook \"' + name + '\"');\n  </logHookCall>\n\n  <setupContextForCall>\n  var context = Api.encodeGlobal(output);\n  </setupContextForCall>\n\n  return timing.measure(\n    'call.hook.' + name,\n\n    <handleArgumentAndGetResult>\n    Promise(getArgument(output))\n    \n    .then(function(arg) {\n      return Promise.reduce(plugins, function(prev, plugin) {\n        var hook = plugin.getHook(name);\n        if (!hook) {\n          return prev;\n        }\n        return hook.call(context, prev);\n      }, arg);\n    })\n    </handleArgumentAndGetResult>\n\n    <handleAndDecodeResult>\n    .then(function(result) {\n      output = Api.decodeGlobal(output, context);\n      return handleResult(output, result);\n    })\n    </handleAndDecodeResult>\n  );\n}\n"], "```"]