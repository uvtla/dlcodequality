[["getWidth", "\nfunction getWidth(element) {\n  var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n  return _getLength(element, 'Width', offset);\n}\n"], ["bounce", "\nfunction bounce(t) {\n  const s = 7.5625;\n  const p = 2.75;\n  let l;\n  if (t < (1 / p)) {\n    l = s * t * t;\n  } else {\n    if (t < (2 / p)) {\n      t -= (1.5 / p);\n      l = s * t * t + 0.75;\n    } else {\n      if (t < (2.5 / p)) {\n        t -= (2.25 / p);\n        l = s * t * t + 0.9375;\n      } else {\n        t -= (2.625 / p);\n        l = s * t * t + 0.984375;\n      }\n    }\n  }\n  return l;\n}\n"], ["arraySampleSize", "\nfunction arraySampleSize(array, n) {\n  return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length));\n}\n"], ["PluginInitialization", "\nfunction(options) {\n  // Initialization and assignment of multiple plugin properties\n  this.name = options.name;\n  this.isInternal = options.isInternal;\n  // ... (many other similar assignments)\n  this.apiCalls = [];\n  this.imports = [];\n  // ... (and more)\n  this._loggerObject = options.logger;\n  this.logger = this._loggerObject; \n  this.events = options.events;\n  // ... (even more assignments)\n  if (!Array.isArray(this.currentContext)) {\n    this.currentContext = [this.currentContext];\n  }\n  if (!Array.isArray(this.acceptedContext)) {\n    this.acceptedContext = [this.acceptedContext];\n  }\n}\n"], ["setUpdateStateInJSON", "\nfunction setUpdateStateInJSON(key, value) {\n  var result = $.Deferred();\n\n  updateJsonHandler.set(key, value)\n    .done(function () {\n      result.resolve();\n    })\n    .fail(function () {\n      resetStateInFailure(\"AutoUpdate : Could not modify updatehelper.json\");\n      result.reject();\n    });\n\n  return result.promise();\n}\n"], ["KO_Bind_Listener", "\nfunction () {\n  var _data = this._dataElement().data(\"bind\");\n  if (typeof _data == \"string\" && typeof ko == \"object\") {\n    var _vm = ko.dataFor(this._dataElement()[0]);\n    if (typeof _vm == \"undefined\") return true;\n    var _all = _data.split(\",\"), _handler;\n    for (var i = 0; i < _all.length; i++) {\n      var d = _all[i].split(\":\");\n      if ($.trim(d[0]) == \"value\") {\n        _handler = $.trim(d[1]);\n        break;\n      }\n    }\n    if (_handler) {\n      this._isKO = true;\n      ko.computed(function () { this.option(\"value\", _vm[_handler]()); }, this);\n    }\n  }\n}\n"], ["AttachEventListeners", "\nfunction () {\n  eventUtil.addListener(Aria.$window.document.body, \"mousedown\", {\n    fn : this._onMouseDown,\n    scope : this\n  });\n  eventUtil.addListener(Aria.$window.document.body, \"touchstart\", {\n    fn : this._onMouseDown,\n    scope : this\n  });\n}\n"], ["cryptocurrencyTransfer", "\nasync function(senderAddr, senderPassphrase, recipient, amountInWei) {\n  const oThis = this\n    , web3Provider = web3ProviderFactory.getProvider('value', 'ws')\n    , gasPrice = coreConstants.OST_VALUE_GAS_PRICE\n    , gas = coreConstants.OST_VALUE_GAS_LIMIT;\n\n  // Validation of input parameters and addresses\n  <validationBlock>\n  if (!basicHelper.isAddressValid(senderAddr)) {\n    // ...\n    return Promise.resolve(errObj);\n  }\n  if (!basicHelper.isAddressValid(recipient)) {\n    // ...\n    return Promise.resolve(errObj);\n  }\n  if (senderAddr.equalsIgnoreCase(recipient)) {\n    // ...\n    return Promise.resolve(errObj);\n  }\n  if (!basicHelper.isNonZeroWeiValid(amountInWei)) {\n    // ...\n    return Promise.resolve(errObj);\n  }\n  </validationBlock>\n\n  // Balance check before transfer\n  <balanceCheck>\n  var bigNumAmount = basicHelper.convertToBigNumber(amountInWei);\n  const senderBalanceValidationResponse = await oThis.validateEthBalance(senderAddr, bigNumAmount);\n  if (senderBalanceValidationResponse.isFailure()) {\n    return Promise.resolve(senderBalanceValidationResponse);\n  }\n  </balanceCheck>\n\n  // Actual asynchronous transfer function\n  <asyncTransferFunction>\n  const asyncTransfer = async function() {\n    // ...\n    .catch(function(reason) {\n      // ...\n    });\n  };\n  </asyncTransferFunction>\n\n  return asyncTransfer();\n}\n"], ["AndOrPredicate", "\nfunction AndOrPredicate(op, preds) {\n  this.op = this._resolveOp(op);\n  // Handling different formats of predicates input\n  if (preds.length == 1 && Array.isArray(preds[0])) {\n    preds = preds[0];\n  }\n  // Filter and possibly map predicates\n  this.preds = preds.filter(function (pred) {\n    return pred != null;\n  }).map(function (pred) {\n    return Predicate(pred);\n  });\n  // Handling empty or single-element predicate scenarios\n  if (this.preds.length == 0) {\n    this.op = null;\n  }\n  if (this.preds.length == 1) {\n    return this.preds[0];\n  }\n}\n"], ["focusControl", "\nfunction (keyboard) {\n  var self = this, focusCtrl, keyboardNav, items;\n\n  // Initializing keyboard navigation if needed\n  if (keyboard) {\n    <keyboardNavigation>\n    keyboardNav = self.keyboardNav || self.parents().eq(-1)[0].keyboardNav;\n    if (keyboardNav) {\n      keyboardNav.focusFirst(self);\n      return;\n    }\n    </keyboardNavigation>\n  }\n\n  // Querying all focusable items and the status bar\n  items = self.find('*');\n  if (self.statusbar) {\n    <addStatusBarItems>\n    items.add(self.statusbar.items());\n    </addStatusBarItems>\n  }\n\n  // Finding initial control to focus\n  <findInitialFocus>\n  items.each(function (ctrl) {\n    if (ctrl.settings.autofocus) {\n      focusCtrl = null;\n      return false;\n    }\n    if (ctrl.canFocus) {\n      focusCtrl = focusCtrl || ctrl;\n    }\n  });\n  if (focusCtrl) {\n    focusCtrl.focus();\n  }\n  </findInitialFocus>\n\n  return self;\n}\n"], "```"]