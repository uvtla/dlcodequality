[["funnelPiece", "\nfunction FunnelPiece(data, idx) {\n\n    graphic.Group.call(this);\n\n    var polygon = new graphic.Polygon();\n    var labelLine = new graphic.Polyline();\n    var text = new graphic.Text();\n    this.add(polygon);\n    this.add(labelLine);\n    this.add(text);\n\n    this.highDownOnUpdate = function (fromState, toState) {\n        if (toState === 'emphasis') {\n            labelLine.ignore = labelLine.hoverIgnore;\n            text.ignore = text.hoverIgnore;\n        }\n        else {\n            labelLine.ignore = labelLine.normalIgnore;\n            text.ignore = text.normalIgnore;\n        }\n    };\n\n    this.updateData(data, idx, true);\n}\n"], ["computedProperty", "\nfunction ComputedProperty(config, opts) {\n    this.isDescriptor = true;\n    <handleFunctionConfig>\n    if (typeof config === 'function') {\n      this._getter = config;\n    } else {\n      _emberMetalDebug.assert('Ember.computed expects a function or an object as last argument.', typeof config === 'object' && !Array.isArray(config));\n      _emberMetalDebug.assert('Config object pased to a Ember.computed can only contain `get` or `set` keys.', (function () {\n        var keys = Object.keys(config);\n        for (var i = 0; i < keys.length; i++) {\n          if (keys[i] !== 'get' && keys[i] !== 'set') {\n            return false;\n          }\n        }\n        return true;\n      })());\n      this._getter = config.get;\n      this._setter = config.set;\n    }\n    _emberMetalDebug.assert('Computed properties must receive a getter or a setter, you passed none.', !!this._getter || !!this._setter);\n    </handleFunctionConfig>\n    this._dependentKeys = undefined;\n    this._suspended = undefined;\n    this._meta = undefined;\n    this._volatile = false;\n    this._dependentKeys = opts && opts.dependentKeys;\n    this._readOnly = false;\n  }\n"], ["trimTrailingBr", "\nfunction trimTrailingBr(rootNode) {\n      var brNode1, brNode2;\n\n      <isBrFunction>\n      function isBr(node) {\n        return node && node.name === 'br';\n      }\n      </isBrFunction>\n\n      brNode1 = rootNode.lastChild;\n      if (isBr(brNode1)) {\n        brNode2 = brNode1.prev;\n\n        if (isBr(brNode2)) {\n          brNode1.remove();\n          brNode2.remove();\n        }\n      }\n    }\n"], ["calcMinimalDistance", "\nfunction (line, p) {\n        var minDist = Infinity;\n        var minX, minY, minI, minT;\n\n<calculateDistances>\n        for (var i = 0; i < line.length - 1; i++) {\n\n            var x = line[i][0];\n            var y = line[i][1];\n            var dx = (line[i + 1][0] - x) * this.kx;\n            var dy = (line[i + 1][1] - y) * this.ky;\n\n            if (dx !== 0 || dy !== 0) {\n\n                var t = ((p[0] - x) * this.kx * dx + (p[1] - y) * this.ky * dy) / (dx * dx + dy * dy);\n\n                if (t > 1) {\n                    x = line[i + 1][0];\n                    y = line[i + 1][1];\n\n                } else if (t > 0) {\n                    x += (dx / this.kx) * t;\n                    y += (dy / this.ky) * t;\n                }\n            }\n\n            dx = (p[0] - x) * this.kx;\n            dy = (p[1] - y) * this.ky;\n\n            var sqDist = dx * dx + dy * dy;\n            if (sqDist < minDist) {\n                minDist = sqDist;\n                minX = x;\n                minY = y;\n                minI = i;\n                minT = t;\n            }\n        }\n</calculateDistances>\n\n        return {\n            point: [minX, minY],\n            index: minI,\n            t: Math.max(0, Math.min(1, minT))\n        };\n    }\n"], ["tokensToFunction", "\nfunction tokensToFunction (tokens) {\n  \n<initializeMatches>\n  var matches = new Array(tokens.length);\n</initializeMatches>\n\n<compileRegex>\n  for (var i = 0; i < tokens.length; i++) {\n    if (typeof tokens[i] === 'object') {\n      matches[i] = new RegExp('^(?:' + tokens[i].pattern + ')$');\n    }\n  }\n</compileRegex>\n\n<returnPathFunction>\n  return function (obj, opts) {\n    var path = '';\n    var data = obj || {};\n    var options = opts || {};\n    var encode = options.pretty ? encodeURIComponentPretty : encodeURIComponent;\n\n<generatePath>\n    for (var i = 0; i < tokens.length; i++) {\n      var token = tokens[i];\n\n      if (typeof token === 'string') {\n        path += token;\n\n        continue\n      }\n\n      var value = data[token.name];\n      var segment;\n\n      if (value == null) {\n        if (token.optional) {\n          \n          if (token.partial) {\n            path += token.prefix;\n          }\n\n          continue\n        } else {\n          throw new TypeError('Expected \"' + token.name + '\" to be defined')\n        }\n      }\n\n      if (index$1(value)) {\n        if (!token.repeat) {\n          throw new TypeError('Expected \"' + token.name + '\" to not repeat, but received `' + JSON.stringify(value) + '`')\n        }\n\n        if (value.length === 0) {\n          if (token.optional) {\n            continue\n          } else {\n            throw new TypeError('Expected \"' + token.name + '\" to not be empty')\n          }\n        }\n\n        for (var j = 0; j < value.length; j++) {\n          segment = encode(value[j]);\n\n          if (!matches[i].test(segment)) {\n            throw new TypeError('Expected all \"' + token.name + '\" to match \"' + token.pattern + '\", but received `' + JSON.stringify(segment) + '`')\n          }\n\n          path += (j === 0 ? token.prefix : token.delimiter) + segment;\n        }\n\n        continue\n      }\n\n      segment = token.asterisk ? encodeAsterisk(value) : encode(value);\n\n      if (!matches[i].test(segment)) {\n        throw new TypeError('Expected \"' + token.name + '\" to match \"' + token.pattern + '\", but received \"' + segment + '\"')\n      }\n\n      path += token.prefix + segment;\n    }\n</generatePath>\n\n    return path\n  }\n</returnPathFunction>\n"], ["checkDomain", "\nfunction checkDomain(result) {\n  \n<returnDomainFunction>\n  return function(domain, options, callback) {\n    result.domain = domain;\n    return callback(null, true);\n  };\n</returnDomainFunction>\n"], ["findTopdocComments", "\nfunction _findTopdocComments(css, regex, includeNodes) {\n<initializeComponents>\n  const components = [];\n</initializeComponents>\n  let currentComponentIndex;\n\n<iterateCSS>\n  css.walk((node) => {\n    if (node.type === 'comment' && node.text.match(regex)) {\n      components.push(_parseTopdocComment(node, regex, includeNodes));\n      currentComponentIndex = components.length - 1;\n      debug(`Started adding ${components[currentComponentIndex].name}`);\n    } else if (components.length && node.type !== 'decl') {\n      if (includeNodes) components[currentComponentIndex].nodes.push(node);\n      components[currentComponentIndex].css += node.toString();\n      debug(`Added ${node.type} to ${components[currentComponentIndex].name}`);\n    }\n  });\n</iterateCSS>\n\n  return components;\n}\n"], ["handleFragments", "\nfunction ( fragment ) {\n  \t\tif ( !batch ) return;\n\n  \t\tvar b = batch;\n  \t\t<locateBaseBatch>\n  \t\twhile ( b.previousBatch ) {\n  \t\t\tb = b.previousBatch;\n  \t\t}\n  \t\t</locateBaseBatch>\n\n  \t\t<addFragmentToArray>\n  \t\taddToArray( b.fragments, fragment );\n  \t\t</addFragmentToArray>\n  \t}\n"], ["isZeitWorld", "\nfunction isZeitWorld(ns) {\n  <returnFalseIfEmpty>\n  if (!ns.length) {\n    return false;\n  }\n  </returnFalseIfEmpty>\n  \n  <checkEachHost>\n  return ns.every(host => host.endsWith('.zeit.world'));\n  </checkEachHost>\n}\n"], ["renderAttrs", "\nfunction renderAttrs (node) {\n  var attrs = node.data.attrs;\n  var res = '';\n\n<inheritAttributes>\n  var opts = node.parent && node.parent.componentOptions;\n  if (isUndef(opts) || opts.Ctor.options.inheritAttrs !== false) {\n    var parent = node.parent;\n    while (isDef(parent)) {\n      if (isDef(parent.data) && isDef(parent.data.attrs)) {\n        attrs = extend(extend({}, attrs), parent.data.attrs);\n      }\n      parent = parent.parent;\n    }\n  }\n</inheritAttributes>\n\n<checkUndefAttrs>\n  if (isUndef(attrs)) {\n    return res\n  }\n</checkUndefAttrs>\n\n<constructAttributeString>\n  for (var key in attrs) {\n    if (isSSRUnsafeAttr(key)) {\n      continue\n    }\n    if (key === 'style') {\n      \n      continue\n    }\n    res += renderAttr(key, attrs[key]);\n  }\n</constructAttributeString>\n  \n  return res\n}\n"], "```\n\nEach function is annotated with tags indicating its compliance or violation of the Single Responsibility Principle (SRP). Functions that contain nested tags hold distinct responsibilities, which might be considered a breach of SRP. Functions without such nested tags are more likely to comply with SRP as they have a single cohesive responsibility."]