[["srem", "\nfunction srem(members) {\n  var i, c = 0;\n  for (i = 0; i < members.length; i++) {\n    <keyRemoval>\n    if (this.keyExists(members[i])) {\n      this.delKey(members[i]);\n      c++;\n    }\n    </keyRemoval>\n  }\n  return c;\n}\n"], ["isEmpty", "\nfunction isEmpty(value: mixed): boolean {\n  if (Array.isArray(value)) {\n    return value.length === 0;\n  } else if (typeof value === 'object') {\n    if (value) {\n      <ensureNotIterable>\n      invariant(\n        !isIterable(value) || value.size === undefined,\n        'isEmpty() does not support iterable collections.',\n      );\n      </ensureNotIterable>\n      <checkProperties>\n      for (const _ in value) {\n        return false;\n      }\n      </checkProperties>\n    }\n    return true;\n  } else {\n    return !value;\n  }\n}\n"], ["_ajax$", "\nfunction _ajax$(url, settings, override) {\n  <prepareArguments>\n  var originalArgs = settings ? [url, settings] : [url];\n  var originalSettings = settings || url;\n  var extracted = bluetry.extractBluejaxOptions(originalArgs);\n  var bluejaxOptions = $.extend({}, override, extracted[0]);\n  var cleanedOptions = extracted[1];\n  </prepareArguments>\n\n  return doit(originalArgs, originalSettings, cleanedOptions, bluejaxOptions);\n}\n"], ["closest", "\nfunction closest(el, sel) {\n  if (!el) return\n  <findMatching>\n  if (matches(el, sel)) {\n    return el\n  } else {\n    return closest(el.parentNode, sel)\n  }\n  </findMatching>\n}\n"], ["getProdModules", "\nfunction getProdModules(externalModules, packagePath, dependencyGraph, forceExcludes) {\n  <readPackageJson>\n  const packageJsonPath = path.join(process.cwd(), packagePath);\n  const packageJson = require(packageJsonPath);\n  </readPackageJson>\n\n  <initialCheck>\n  if (!packageJson.dependencies) {\n    return [];\n  }\n  </initialCheck>\n\n  const prodModules = [];\n\n  <processModules>\n  _.forEach(externalModules, module => {\n    let moduleVersion = packageJson.dependencies[module.external];\n\n    if (moduleVersion) {\n      prodModules.push(`${module.external}@${moduleVersion}`);\n      <handlePeerDependencies>\n      try {\n        const modulePackagePath = path.join(\n          path.dirname(path.join(process.cwd(), packagePath)),\n          'node_modules',\n          module.external,\n          'package.json'\n        );\n        const peerDependencies = require(modulePackagePath).peerDependencies;\n        if (!_.isEmpty(peerDependencies)) {\n          this.options.verbose && this.serverless.cli.log(`Adding explicit peers for dependency ${module.external}`);\n          const peerModules = getProdModules.call(this, _.map(peerDependencies, (value, key) => ({ external: key })), packagePath, dependencyGraph, forceExcludes);\n          Array.prototype.push.apply(prodModules, peerModules);\n        }\n      } catch (e) {\n        this.serverless.cli.log(`WARNING: Could not check for peer dependencies of ${module.external}`);\n      }\n      </handlePeerDependencies>\n    } else {\n      <processNonProductionModules>\n      if (!packageJson.devDependencies || !packageJson.devDependencies[module.external]) {\n        const originInfo = _.get(dependencyGraph, 'dependencies', {})[module.origin] || {};\n        moduleVersion = _.get(_.get(originInfo, 'dependencies', {})[module.external], 'version');\n        if (!moduleVersion) {\n          this.serverless.cli.log(`WARNING: Could not determine version of module ${module.external}`);\n        }\n        prodModules.push(moduleVersion ? `${module.external}@${moduleVersion}` : module.external);\n      } else if (packageJson.devDependencies && packageJson.devDependencies[module.external] && !_.includes(forceExcludes, module.external)) {\n        const ignoredDevDependencies = ['aws-sdk'];\n\n        if (!_.includes(ignoredDevDependencies, module.external)) {\n          this.serverless.cli.log(`ERROR: Runtime dependency '${module.external}' found in devDependencies. Move it to dependencies or use forceExclude to explicitly exclude it.`);\n          throw new this.serverless.classes.Error(`Serverless-webpack dependency error: ${module.external}.`);\n        }\n\n        this.options.verbose && this.serverless.cli.log(`INFO: Runtime dependency '${module.external}' found in devDependencies. It has been excluded automatically.`);\n      }\n      </processNonProductionModules>\n    }\n  });\n</processModules>\n\n  return prodModules;\n}\n"], ["superPropertiesClass", "\nfunction superPropertiesClass(constructor) {\n  const superCtor = Object.getPrototypeOf(constructor);\n  <checkSuperConstructor>\n  return (superCtor.prototype instanceof PropertiesMixin) ?\n    (superCtor) : null;\n  </checkSuperConstructor>\n}\n"], ["bootstrap", "\nfunction bootstrap(bootstrappers) {\n  <runBootstrappers>\n  const bootstrapPromise = bootstrappers.reduce(\n    (metaPromise, bootstrapper) => metaPromise.then((prevMeta) =>\n      Promise.resolve(bootstrapper(prevMeta)).then((newMeta) => Object.assign({}, prevMeta, newMeta))\n    ),\n    Promise.resolve({})\n  ).then((meta) => checkIfReadyToBoot(meta));\n  </runBootstrappers>\n  \n  <addListenMethod>\n  bootstrapPromise.listen = function listen(port, hostname) {\n    return bootstrapPromise.then((meta) => promisifiedListen(meta.app, port, hostname));\n  }\n  </addListenMethod>\n\n  return bootstrapPromise;\n}\n"], ["loadPaths", "\nfunction loadPaths(pkg) {\n  const name = pkg.name;\n  const file = pkg.path;\n  <resolveEntryAndPackage>\n  return resolveFile(tmp, path.join(name, file)).then(entry => ({\n    entry: entry,\n    package: path.join(tmp, 'node_modules', name, 'package.json')\n  }));\n  </resolveEntryAndPackage>\n}\n"], ["unnamed", "\nfunction (record, index) {\n  \n  <codeExtraction>\n  var code = this.options.codeField ? L.Util.getFieldValue(record, this.options.codeField) : index;\n  </codeExtraction>\n\n  \n  <initializeLookup>\n  this._lookupIndex = this._lookupIndex || L.GeometryUtils.indexFeatureCollection(this.options.locationLookup, this.options.locationIndexField || this.options.codeField);\n  </initializeLookup>\n\n  \n  <findLocation>\n  var geoJSON = this._lookupIndex[code];\n  var location = null;\n\n  if (!geoJSON && code.indexOf('0') === 0) {\n    geoJSON = this._lookupIndex[code.substring(1)];\n  }\n\n  if (geoJSON) {\n    var me = this;\n    var recordToLayer = function (location, record) {\n      return me.recordToLayer(location, record);\n    };\n\n    location = L.GeometryUtils.getGeoJSONLocation(geoJSON, record, this.options.locationTextField, recordToLayer);\n  }\n  </findLocation>\n\n  return location;\n}\n"], ["guessObjectType", "\nfunction guessObjectType(obj, shortname=false) {\n  \n  <determineType>\n  var type\n  if (typeof obj === \"string\" && obj) {\n    <matchUris>\n    if (obj in objectTypeUris) {\n      type = objectTypeUris[obj];\n    } else {\n    </matchUris>\n      <inferType>\n      obj = obj.toLowerCase().replace(/s$/,\"\");\n      type = Object.keys(objectTypes).find(name => {\n        const lowercase = name.toLowerCase();\n        if (lowercase === obj || lowercase === \"concept\" + obj) {\n          return true;\n        }\n      });\n      </inferType>\n    }\n  } else if (typeof obj === \"object\") {\n    <processObjectType>\n    if (obj.type) {\n      let types = Array.isArray(obj.type) ? obj.type : [obj.type];\n      for (let uri of types) {\n        if (uri in objectTypeUris) {\n          type = objectTypeUris[uri];\n          break;\n        }\n      }\n    }\n    </processObjectType>\n  }\n  </determineType>\n\n  <formatType>\n  return (shortname && type) ? type.toLowerCase().replace(/^concept(.+)/, \"$1\") : type;\n  </formatType>\n}\n"], ""]