[["isNodeIgnored", "\nfunction isNodeIgnored(node) {\n    const parent = node.parent;\n\n    if (!parent) {\n        return false;\n    }\n\n    if (parent.some((child) => (child.type === 'comment' && PATTERN_IGNORE.test(child.text)))) {\n        return true;\n    }\n\n    return isNodeIgnored(parent);\n}\n"], ["build", "\nfunction build (app, mod, args) {\n  <getConfiguration>\n  var conf = getConf(app, mod);\n  args = args || {};\n  var appConf = conf.appConf;\n  var comboConf = (typeof appConf.comboConf === 'object') && !_.isEmpty(appConf.comboConf) ? appConf.comboConf : {\n    mode: 'client'\n  };\n  </getConfiguration>\n  \n  <buildProcess>\n  if (args.isSimple) {\n    if (comboConf.mode === 'client') {\n      return buildCheck(app, mod, conf, args, buildSingleModuleSimple);\n    }\n    return buildCheck(app, mod, conf, args, buildSingleModuleSimpleServer);\n  }\n  if (comboConf.mode === 'client') {\n    return buildCheck(app, mod, conf, args, buildSingleModule);\n  }\n  return buildCheck(app, mod, conf, args, buildSingleModuleServer);\n  </buildProcess>\n}\n"], ["_revealMasks", "\nfunction _revealMasks(diff) {\n    <processDiffs>\n    for (var i = 0; i < diff.length; i++) {\n        var currPart = diff[i];\n\n        if (!_isDiffPart(currPart)) continue;\n\n        var prevPart = diff[i - 1],\n            nextPart = diff[i + 1],\n            matchedMask = currPart.value.match(MASK_REGEXP);\n\n        if (!matchedMask) continue;\n\n        <maskRegExpCreation>\n        var regExp = new RegExp('^' +\n            matchedMask[1].replace(special\u0421hars, '\\\\$1') +\n                matchedMask[2] +\n                    matchedMask[3].replace(special\u0421hars, '\\\\$1') + '$');\n        </maskRegExpCreation>\n\n        <updateDiffs>\n        if (currPart.added && nextPart && nextPart.removed) {\n            if (nextPart.value.match(regExp)) {\n                nextPart.removed = undefined;\n                diff.splice(i--, 1);\n            }\n        } else if (currPart.removed && prevPart && prevPart.added) {\n            if (prevPart.value.match(regExp)) {\n                prevPart.added = undefined;\n                diff.splice(i--, 1);\n            }\n        }\n        </updateDiffs>\n    }\n    </processDiffs>\n\n    return diff;\n}\n"], ["involuteXbez", "\nfunction involuteXbez(t) {\n    <calculateInvoluteParameters>\n    var x = t*2-1;\n    var theta = x*(te-ts)/2 + (ts + te)/2;\n    </calculateInvoluteParameters>\n    \n    <returnXbezValue>\n    return Rb*(Math.cos(theta)+theta*Math.sin(theta));\n    </returnXbezValue>\n}\n"], ["_getPathValue", "\nfunction _getPathValue(parsed, obj) {\n    <traverseObject>\n    var tmp = obj\n      , res;\n    for (var i = 0, l = parsed.length; i < l; i++) {\n        var part = parsed[i];\n        if (tmp) {\n            if ('undefined' !== typeof part.p)\n                tmp = tmp[part.p];\n            else if ('undefined' !== typeof part.i)\n                tmp = tmp[part.i];\n            if (i == (l - 1)) res = tmp;\n        } else {\n            res = undefined;\n        }\n    }\n    </traverseObject>\n\n    return res;\n}\n"], ["processPending", "\nfunction () {\n    this.isReady = true;\n\n    for (var id in this._pending) {\n        if (this._pending.hasOwnProperty(id)) {\n            <cancelPending>\n            ariaCoreTimer.cancelCallback(this._pending[id]);\n            ariaCoreIO.reissue(id);\n            </cancelPending>\n        }\n    }\n    this._pending = {};\n}\n"], ["flip", "\nfunction flip(fn) {\n    return function () {\n        <reverseArguments>\n        var args = list.apply(null, arguments).reverse();\n        </reverseArguments>\n\n        <applyFlippedFunction>\n        return fn.apply(this, args);\n        </applyFlippedFunction>\n    };\n}\n"], ["getValue", "\nfunction getValue(key, name, raw) {\n    <applyTransform>\n    if (this.conf.transform) {\n        if (typeof (this.conf.transform.value) == 'function') {\n            return this.conf.transform.value.call(this, key, name, raw);\n        }\n    }\n    </applyTransform>\n\n    <retrieveValue>\n    var value = process.env[raw] || this[name];\n    </retrieveValue>\n\n    <convertNative>\n    if (this.conf.native && typeof (value) == 'string') {\n        value = native.to(\n            value, this.conf.native.delimiter, this.conf.native.json);\n    }\n    </convertNative>\n\n    return value;\n}\n"], ["onSDPDescription", "\nfunction onSDPDescription(id, rtcId, data) {\n    if (scope._servConn.useRTC) {\n        if (scope.hasWebRTCSupport()) {\n            <handleWebRTCConnection>\n            var peer = getOrCreatePeer(id);\n            peer.rtcId = rtcId;\n            peer.onServerMessage(JSON.parse(data));\n            </handleWebRTCConnection>\n        } else {\n            <sendRTCState>\n            scope._servConn.sendRTCState(false, id);\n            </sendRTCState>\n        }\n    }\n}\n"], ["rotate", "\nfunction(angle) {\n    <calculateRotation>\n    var rad = this.DEG_TO_RAD * angle,\n        cosVal = Math.cos(rad),\n        sinVal = Math.sin(rad),\n        mtx3d = new $B.geom.Matrix3D(1, 0, 0, 0, 0, cosVal, -sinVal, 0, 0, sinVal, cosVal, 0);\n    </calculateRotation>\n\n    <applyRotation>\n    return this.concat(mtx3d);\n    </applyRotation>\n}\n"], "```"]