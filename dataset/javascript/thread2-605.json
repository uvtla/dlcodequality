[["normalizeConfiguration", "\nfunction normalizeConfiguration(oObject, oConfiguration) {\n    <metadataExtraction>\n    var oMetadata = oObject.getMetadata(),\n        aProperties = Object.keys(oMetadata.getAllProperties()),\n        aAggregations = Object.keys(oMetadata.getAllAggregations()),\n        aAssociations = Object.keys(oMetadata.getAllAssociations()),\n        aBindings = uniqueSort(aProperties.concat(aAggregations)),\n        aEvents = Object.keys(oMetadata.getAllEvents());\n    </metadataExtraction>\n\n    <configurationAssignment>\n    oConfiguration.properties = oConfiguration.properties === true ? aProperties : oConfiguration.properties;\n    oConfiguration.aggregations = oConfiguration.aggregations === true ? aAggregations : oConfiguration.aggregations;\n    oConfiguration.associations = oConfiguration.associations === true ? aAssociations : oConfiguration.associations;\n    oConfiguration.bindings = oConfiguration.bindings === true ? aBindings : oConfiguration.bindings;\n    oConfiguration.events = oConfiguration.events === true ? aEvents : oConfiguration.events;\n    oConfiguration.destroy = (oConfiguration.destroy == null) ? false : oConfiguration.destroy;\n    oConfiguration.parent = (oConfiguration.parent == null) ? false : oConfiguration.parent;\n    </configurationAssignment>\n}\n"], ["runningMap", "\nfunction runningMap(a, fn, init) {\n  return a.map(v => init = fn(v, init));\n}\n"], ["functionForAttributes", "\nfunction (moreattrs) {\n    <attributeAssignmentLoop>\n    for (var k in moreattrs) {\n        if (moreattrs.hasOwnProperty(k)) {\n            this.node.setAttribute(k, moreattrs[k]);\n        }\n    }\n    </attributeAssignmentLoop>\n    return this;\n}\n"], ["reflowText", "\nfunction reflowText (text, width, gfm) {\n  <splitText>\n  var splitRe = gfm ? HARD_RETURN_GFM_RE : HARD_RETURN_RE,\n      sections = text.split(splitRe),\n      reflowed = [];\n  </splitText>\n\n  <sectionIteration>\n  sections.forEach(function (section) {\n    <reflowSection>\n    var fragments = section.split(/(\\u001b\\[(?:\\d{1,3})(?:;\\d{1,3})*m)/g);\n    var column = 0;\n    var currentLine = '';\n    var lastWasEscapeChar = false;\n\n    <fragmentProcessing>\n    while (fragments.length) {\n      var fragment = fragments[0];\n\n      <fragmentCleaning>\n      if (fragment === '') {\n        fragments.splice(0, 1);\n        lastWasEscapeChar = false;\n        continue;\n      }\n      </fragmentCleaning>\n\n      <nonTextFragmentHandling>\n      if (!textLength(fragment)) {\n        currentLine += fragment;\n        fragments.splice(0, 1);\n        lastWasEscapeChar = true;\n        continue;\n      }\n      </nonTextFragmentHandling>\n\n      <wordProcessing>\n      var words = fragment.split(/[ \\t\\n]+/);\n      for (var i = 0; i < words.length; i++) {\n        <handleWordWrapping>\n        var word = words[i];\n        var addSpace = column != 0;\n        if (lastWasEscapeChar) addSpace = false;\n        if (column + word.length + addSpace > width) {\n          <performWordWrapping>\n          if (word.length <= width) {\n            \n            reflowed.push(currentLine);\n            currentLine = word;\n            column = word.length;\n          } else {\n            \n            \n            var w = word.substr(0, width - column - addSpace);\n            if (addSpace) currentLine += ' ';\n            currentLine += w;\n            reflowed.push(currentLine);\n            currentLine = '';\n            column = 0;\n            </performWordWrapping>\n\n            <breakLongWord>\n            word = word.substr(w.length);\n            while (word.length) {\n              var w = word.substr(0, width);\n              if (!w.length) break;\n              if (w.length < width) {\n                currentLine = w;\n                column = w.length;\n                break;\n              } else {\n                reflowed.push(w);\n                word = word.substr(width);\n              }\n            }\n            </breakLongWord>\n          }\n        } else {\n          <appendWord>\n          if (addSpace) {\n            currentLine += ' ';\n            column++;\n          }\n          currentLine += word;\n          column += word.length;\n          </appendWord>\n        }\n        </handleWordWrapping>\n        lastWasEscapeChar = false;\n      }\n      </wordProcessing>\n\n      fragments.splice(0, 1);\n    }\n    </fragmentProcessing>\n    if (textLength(currentLine)) reflowed.push(currentLine);\n    </reflowSection>\n  });\n  </sectionIteration>\n  return reflowed.join('\\n');\n}\n"], ["functionProcessingParserStream", "\nfunction(done) {\n    <initialSetup>\n    var p, parser, stream, _i, _len;\n    parser = this.parser();\n    stream = highland(this.source());\n    </initialSetup>\n    \n    <parserApplication>\n    if (_.isArray(parser)) {\n      for (_i = 0, _len = parser.length; _i < _len; _i++) {\n        p = parser[_i];\n        stream = this._mapWith(p)(stream).flatten().compact();\n      }\n    } else {\n      stream = this._mapWith(parser)(stream).flatten().compact();\n    }\n    </parserApplication>\n\n    <streamReduction>\n    stream = stream.reduce({}, _.merge);\n    </streamReduction>\n\n    <eventTriggerCallback>\n    if (done == null) {\n      return stream;\n    }\n    stream.pull(done);\n    </eventTriggerCallback>\n\n    return this;\n}\n"], ["getInstalledNPMVersion", "\nfunction getInstalledNPMVersion () {\n  return new Promise((resolve, reject) => {\n    <execNpmVersion>\n    exec('npm -v', (err, stdout) => {\n      if (err) {\n        reject(new Error('Could not determine npm version.'));\n      } else {\n        var nodeVersion = stdout.replace(/\\n/, '');\n        resolve(nodeVersion);\n      }\n    });\n    </execNpmVersion>\n  })\n}\n"], ["groupBy", "\nfunction groupBy(expression) {\n    <expressionValidation>\n    if (!expression)\n        throw new Error(\"Expression is invalid\");\n    </expressionValidation>\n\n    <initialization>\n    var maps = [];\n    </initialization>\n\n    <groupingLoop>\n    for (var i = 0; i < this.items.length; i++) {\n        <groupRetrieval>\n        var groupKey = expression(this.items[i]);\n        </groupRetrieval>\n\n        <existingMapSearch>\n        var existingMap = null;\n        for (var n = 0; n < maps.length; n++) {\n            if (equals(maps[n].key, groupKey)){\n                existingMap = maps[n];\n                break;\n            }\n        }\n        </existingMapSearch>\n\n        <mapCreation>\n        if (!existingMap) {\n            existingMap = {\n                key: groupKey,\n                count: 0, \n                elements: []\n            };\n            maps.push(existingMap);\n        }\n        </mapCreation>\n\n        <aggregation>\n        existingMap.count++;\n        existingMap.elements.push(this.items[i]);\n        </aggregation>\n    }\n    </groupingLoop>\n\n    <returnNewInstance>\n    return new jslinq(maps);\n    </returnNewInstance>\n}\n"], ["normalizePage", "\nfunction normalizePage(content) {\n    <dataInitialization>\n    var data = {\n        \"head-start\": [],\n        \"head\": [],\n        \"head-end\": [],\n        body: []\n    };\n    </dataInitialization>\n\n    <contentProcessing>\n    if (typeof content === \"string\") {\n        data.body.push(content);\n    } else {\n        <sectionAssignment>\n        [\"head-start\", \"head\", \"head-end\", \"body\"].forEach(function (section) {\n            var sectionContent = content[section];\n            if (!sectionContent) {\n                return;\n            }\n            if (!_.isArray(sectionContent)) {\n                data[section].push(sectionContent);\n            } else {\n                data[section] = sectionContent;\n            }\n        });\n        </sectionAssignment>\n    }\n    </contentProcessing>\n\n    return data;\n}\n"], ["forEach", "\nfunction forEach(parameters, dIt = global.it, dDescribe = global.describe) {\n    <testCaseDefiners>\n    const it = makeTestCaseDefiner(parameters, dIt);\n    it.skip = makeParameterizedSkip(parameters, dIt);\n    it.only = makeParameterizedOnly(parameters, dIt);\n    const describe = makeTestCaseDefiner(parameters, dDescribe);\n    describe.skip = makeParameterizedSkip(parameters, dDescribe);\n    describe.only = makeParameterizedOnly(parameters, dDescribe);\n    </testCaseDefiners>\n    return { it, describe };\n}\n"], ["functionPublicKeyAlgo", "\nfunction(algo) {\n    <switchPublicKeyAlgo>\n    switch (algo) {\n        \n        <rsaEncryptCases>\n        case enums.publicKey.rsa_encrypt:\n        case enums.publicKey.rsa_encrypt_sign:\n            return [type_mpi];\n        </rsaEncryptCases>\n\n        <elgamalCase>\n        case enums.publicKey.elgamal:\n            return [type_mpi, type_mpi];\n        </elgamalCase>\n\n        <ecdhCase>\n        case enums.publicKey.ecdh:\n            return [type_mpi, type_ecdh_symkey];\n        </ecdhCase>\n        \n        <defaultError>\n        default:\n            throw new Error('Invalid public key encryption algorithm.');\n        </defaultError>\n    }\n    </switchPublicKeyAlgo>\n}\n"], "```"]