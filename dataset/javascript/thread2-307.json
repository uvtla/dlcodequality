[["correctQuestionMarkAndAnd", "\nfunction correctQuestionMarkAndAnd(url) {\n  var baseURL = url;\n  \n  <replaceDoubleAnd>\n  baseURL = baseURL.replace(new RegExp('&&', 'g'), '&');\n  </replaceDoubleAnd>\n  \n  <ensureProperQueryString>\n  if (new RegExp('[\\?]$').test(baseURL)) {\n    // No code inside this conditional\n  } else {\n    <ensureQueryStringPresent>\n    if (baseURL.includes('?')) {\n      <ensureTrailingAmpersand>\n      if (new RegExp('[\\&]$').test(baseURL)) {\n        // No code here either\n      } else {\n        baseURL += '&';\n      }\n      </ensureTrailingAmpersand>\n    } else {\n      <replaceLastAmpersandWithQuestionMark>\n      var countOfAnd = baseURL.split('&').length - 1;\n      if (new RegExp('[\\&]$').test(baseURL)) {\n        if (countOfAnd === 1) {\n          baseURL = baseURL.slice(0, -1);\n          baseURL += '?';\n        } else {\n          baseURL = baseURL.replace('&', '?');\n        }\n      } else {\n        if (countOfAnd > 1) {\n          baseURL = baseURL.replace('&', '?');\n          baseURL += '&';\n        } else {\n          baseURL += '?';\n        }\n      }\n      </replaceLastAmpersandWithQuestionMark>\n    }\n    </ensureQueryStringPresent>\n  }\n  </ensureProperQueryString>\n  \n  return baseURL;\n}\n"], ["getAppFormsForApp", "\nfunction get(req, res, next) {\n  <prepareParameters>\n  var params = {\n    appId: req.params.projectid || req.params.id\n  };\n  </prepareParameters>\n  \n  <handleAppForms>\n  forms.getAppFormsForApp(_.extend(req.connectionOptions, params), formsResultHandlers(constants.resultTypes.formProjects, req, next));\n  </handleAppForms>\n}\n"], ["parseTemplate", "\nfunction parseTemplate(code, parserOptions) {\n    <initializeStores>\n    const sourceCodeStore = new SourceCodeStore(code);\n    </initializeStores>\n    \n    <parseScript>\n    let script = \"\"\n    let pre = 0\n    let template = \"\"\n    const microTemplateTokens = [] \n    for (const token of genMicroTemplateTokens(code, parserOptions, sourceCodeStore)) {\n        microTemplateTokens.push(token);\n        // ... Truncated for brevity\n    }\n    const scriptResult = parseScript(script, parserOptions);\n    </parseScript>\n    \n    <finalizeTemplateAndScript>\n    sourceCodeStore.template = template;\n    sourceCodeStore.script = script;\n    </finalizeTemplateAndScript>\n    \n    <setupMicroTemplateService>\n    const service = new MicroTemplateService({ ... });\n    container.addService(parserOptions.filePath, service);\n    scriptResult.services = Object.assign(scriptResult.services || {}, { ... });\n    </setupMicroTemplateService>\n    \n    return scriptResult;\n}\n"], ["addRoute", "\nfunction(route, name, callback) {\n  <prepareRegExpAndCallback>\n  var regExp = conbo.isRegExp(route) ? route : this.__routeToRegExp(route);\n  if (!callback) {\n    callback = this[name];\n  }\n  if (conbo.isFunction(name)) {\n    callback = name;\n    name = '';\n  }\n  if (!callback) {\n    callback = this[name];\n  }\n  </prepareRegExpAndCallback>\n\n  <defineRoute>\n  this.__history.addRoute(regExp, (function(path) {\n    <extractAndMapParameters>\n    var args = this.__extractParameters(regExp, path);\n    var params = conbo.isString(route)\n      ? conbo.object((route.match(/:\\w+/g) || []).map(function(r) { return r.substr(1); }), args)\n      : {};\n    </extractAndMapParameters>\n\n    <invokeCallback>\n    callback && callback.apply(this, args);\n    </invokeCallback>\n\n    <dispatchEvents>\n    var options = {\n      // ... Object properties\n    };\n    this.dispatchEvent(new conbo.ConboEvent('route:'+name, options));\n    this.dispatchEvent(new conbo.ConboEvent(conbo.ConboEvent.ROUTE, options));\n    </dispatchEvents>\n  }).bind(this));\n  </defineRoute>\n\n  return this;\n}\n"], ["aggregate", "\nfunction aggregate(sAlias) {\n  <processAggregateWithDetails>\n  var oDetails = oAggregation.aggregate[sAlias],\n      sAggregate = oDetails.name || sAlias,\n      sGrandTotal = sAlias,\n      sWith = oDetails.with;\n  \n  if (sWith) {\n    // ... Code for handling with aggregation\n  } else if (oDetails.name) {\n    sAggregate += \" as \" + sAlias;\n  }\n  </processAggregateWithDetails>\n\n  <handleMinOrMax>\n  if (!bFollowUp) {\n    if (oDetails.min) {\n      processMinOrMax(sAlias, \"min\");\n    }\n    if (oDetails.max) {\n      processMinOrMax(sAlias, \"max\");\n    }\n  }\n  </handleMinOrMax>\n\n  <processGrandTotal>\n  if (oDetails.grandTotal) {\n    bHasGrandTotal = true;\n    if (!mQueryOptions.$skip) {\n      // ... Code that adds grand total to the aggregate\n    }\n  }\n  </processGrandTotal>\n\n  return sAggregate;\n}\n"], ["defaultAutoAuthorizeHtmlResponse", "\nfunction defaultAutoAuthorizeHtmlResponse(req, res) {\n  <processRedirect>\n  var config = req.app.get('stormpathConfig');\n  res.redirect(302, url.parse(req.query.next || '').path || config.web.register.nextUri);\n  </processRedirect>\n}\n"], ["vueFieldStates", "\nfunction (Vue) {\n  <initializeHelpers>\n  var ref = Vue.util;\n  var isPlainObject = ref.isPlainObject;\n  </initializeHelpers>\n\n  <defineFieldStateMethods>\n  function getValue (options) { /* ... */ }\n  function checkModified () { /* ... */ }\n  function willUpdateTouched (options) { /* ... */ }\n  function willUpdateDirty () { /* ... */ }\n  function willUpdateModified () { /* ... */ }\n  function handleInputable (e) { /* ... */ }\n  function watchInputable (val) { /* ... */ }\n  function _initStates (keys, target, init) { /* ... */ }\n  function reset () { /* ... */ }\n  function _walkValid (keys, target) { /* ... */ }\n  function _watchValidationRawResults () { /* ... */ }\n  function _unwatchValidationRawResults () { /* ... */ }\n  function touch () { /* ... */ }\n  </defineFieldStateMethods>\n\n  return {\n    getValue,\n    checkModified,\n    // ... Other methods\n  }\n}\n"], ["collapseTopLevelNodes", "\nfunction() {\n  <collapseAll>\n  var topLevelNodes = this._navHandler.getTopLevelNodes();\n  for (var i = 0; i < topLevelNodes.length ; i++){\n    this.myTree.collapse(topLevelNodes[i]);\n  }\n  </collapseAll>\n}\n"], ["addListenerToDashboard", "\nfunction addListener(uid) {\n  <updateListenerRecord>\n  var addedListener = false;\n  if(typeof(dashboardListeners[uid]) === 'undefined') {\n    dashboardListeners[uid] = {\n      'startTime': new Date(),\n      'numIterations': 0,\n      'uid': uid,\n      'numStarts': 1,\n    };\n    addedListener = true;\n  } else {\n    dashboardListeners[uid].numStarts += 1;\n  }\n  </updateListenerRecord>\n  return addedListener;\n}\n"], ["isConsecutiveComment", "\nfunction isConsecutiveComment(comment) {\n  <checkConsecutiveTokenOrComment>\n  const previousTokenOrComment = sourceCode.getTokenBefore(comment, { includeComments: true });\n  return Boolean(\n    previousTokenOrComment &&\n    [\"Block\", \"Line\"].indexOf(previousTokenOrComment.type) !== -1\n  );\n  </checkConsecutiveTokenOrComment>\n}\n"], "```\n\nIn the provided functions, each annotated section represents distinct responsibilities within the context of their function. Some annotations encompass multiple lines where the combined operations act towards a single responsibility."]