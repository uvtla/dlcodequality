[["createError", "\nfunction createError(code, error, original) {\n  var e = new Error(error);\n  e.code = code; \n  if (original)\n    e.original = original;\n  return e;\n}\n"], ["functionManipulateHtml", "\nfunction(location, html) {\n  <cleanHtml>\n  clean(this);\n  </cleanHtml>\n\n  <argumentHandling>\n  if (arguments.length == 0) {\n    var i = [];\n    this.each(function(el) {\n      i.push(el.innerHTML);\n    });\n    return i;\n  }\n  if (arguments.length == 1 && arguments[0] != 'remove') {\n    html = location;\n    location = 'inner';\n  }\n  </argumentHandling>\n\n  <htmlManipulation>\n  if (location != 'remove' && html && html.each !== undefined) {\n    if (location == 'inner') {\n      var d = document.createElement('p');\n      html.each(function(el) {\n        d.appendChild(el);\n      });\n      this.each(function(el) {\n        el.innerHTML = d.innerHTML;\n      });\n    } else {\n      var that = this;\n      html.each(function(el) {\n        that.html(location, el);\n      });\n    }\n    return this;\n  }\n  </htmlManipulation>\n\n  <domElementHandling>\n  return this.each(function(el) {\n    if (location == \"inner\") {\n      if (typeof html == string || typeof html == \"number\") {\n        el.innerHTML = html;\n        var list = el.getElementsByTagName('SCRIPT');\n        var len = list.length;\n        for (var i = 0; i < len; i++) {\n          eval(list[i].text);\n        }\n      } else {\n        el.innerHTML = '';\n        el.appendChild(html);\n      }\n    } else {\n      <removeElement>\n      if (location == 'remove') {\n        el.parentNode.removeChild(el);\n      }\n      </removeElement>\n      <insertElement>\n      else {\n        var elArray = ['outer', 'top', 'bottom'],\n            wrappedE = wrapHelper(html, (elArray.indexOf(location) > -1 ? el : el.parentNode )),\n            children = wrappedE.childNodes;\n\n        if (location == \"outer\") {\n          el.parentNode.replaceChild(wrappedE, el);\n        } else if (location == \"top\") {\n          el.insertBefore(wrappedE, el.firstChild);\n        } else if (location == \"bottom\") {\n          el.insertBefore(wrappedE, null);\n        } else if (location == \"before\") {\n          el.parentNode.insertBefore(wrappedE, el);\n        } else if (location == \"after\") {\n          el.parentNode.insertBefore(wrappedE, el.nextSibling);\n        }\n        \n        var parent = wrappedE.parentNode;\n        while(children.length) {\n          parent.insertBefore(children[0], wrappedE);\n        }\n        parent.removeChild(wrappedE);\n      }\n      </insertElement>\n    }\n  });\n  </domElementHandling>\n}\n"], ["MaxRetryExceededError", "\nfunction MaxRetryExceededError(missingOptimizedPaths) {\n  var instance = new Error(\"The allowed number of retries have been exceeded.\");\n\n  instance.name = \"MaxRetryExceededError\";\n  instance.missingOptimizedPaths = missingOptimizedPaths || [];\n\n  <setPrototype>\n  if (Object.setPrototypeOf) {\n    Object.setPrototypeOf(instance, Object.getPrototypeOf(this));\n  }\n  </setPrototype>\n\n  <captureStackTrace>\n  if (Error.captureStackTrace) {\n    Error.captureStackTrace(instance, MaxRetryExceededError);\n  }\n  </captureStackTrace>\n\n  return instance;\n}\n"], ["_cleanResults", "\nfunction _cleanResults(results, stringify) {\n  var clean = _.map(results, function (res) {\n    return _.reduce(res, _cleanObject, {});\n  });\n\n  <convertToJson>\n  if (stringify) return JSON.stringify(clean, '', '  ');\n  </convertToJson>\n  \n  return clean;\n}\n"], ["processModelData", "\nfunction(snap) {\n\n  <checkAndAssignId>\n  var newModel = Backbone.Firebase._checkId(snap);\n  </checkAndAssignId>\n\n  <unsetAttributes>\n  if (typeof newModel === 'object' && newModel !== null) {\n    var diff = _.difference(_.keys(this.attributes), _.keys(newModel));\n    _.each(diff, _.bind(function(key) {\n      this.unset(key);\n    }, this));\n  }\n  </unsetAttributes>\n\n  <setId>\n  this._setId(snap);\n  </setId>\n\n  return newModel;\n}\n"], ["buildWebpackProject", "\nfunction build(previousSizeMap) {\n  <logStart>\n  console.log('Creating an optimized production build...');\n  </logStart>\n\n  <webpackCompile>\n  webpack(config).run((err, stats) => {\n    if (err) {\n      printErrors('Failed to compile.', [err]);\n      process.exit(1);\n    }\n    \n    if (stats.compilation.errors.length) {\n      printErrors('Failed to compile.', stats.compilation.errors);\n      process.exit(1);\n    }\n\n    <treatWarningsAsErrors>\n    if (process.env.CI && stats.compilation.warnings.length) {\n      printErrors('Failed to compile. When process.env.CI = true, warnings are treated as failures. Most CI servers set this automatically.', stats.compilation.warnings);\n      process.exit(1);\n    }\n    </treatWarningsAsErrors>\n  });\n  </webpackCompile>\n\n  console.log(chalk.green('Compiled successfully.'));\n  console.log();\n\n  <printFileSizesAfterGzip>\n  console.log('File sizes after gzip:');\n  console.log();\n  printFileSizes(stats, previousSizeMap);\n  console.log();\n  </printFileSizesAfterGzip>\n\n  <deploymentInstructions>\n  // ... (omitted for brevity, but each console.log statement relating to instructions would be enclosed)\n  </deploymentInstructions>\n}\n"], ["transformJsonValue", "\nfunction (key) {\n\n  <checkForNull>\n  if ($scope.json[key] === null);\n  </checkForNull>\n\n  <handleUndefinedOrEmpty>\n  else if ($scope.json[key] === undefined || $scope.json[key] === '') $scope.json[key] = null;\n  </handleUndefinedOrEmpty>\n\n  <convertToNumber>\n  else if (!isNaN(+$scope.json[key]) && isFinite($scope.json[key]))\n    $scope.json[key] = +$scope.json[key];\n  </convertToNumber>\n\n  <replaceWithFunction>\n  else if ($scope.utils.tryGetFunction($scope.json[key])) {\n    $scope.json[key] = $scope.utils.tryGetFunction($scope.json[key]);\n    $scope.utils.textarea.init(key);\n  }\n  </replaceWithFunction>\n\n  <parseJsonOrBoolean>\n  else {\n    if ($scope.node.isHighEditLevel) { \n      try {\n        var json = JSON.parse($scope.json[key]);\n        $scope.json[key] = json;\n        $scope.refresh();\n      } catch (e) {}\n    } else { \n      if ($scope.json[key] === \"true\" || $scope.json[key] === \"false\") {\n        $scope.json[key] = JSON.parse($scope.json[key]);\n        $scope.refresh();\n      }\n    }\n  }\n  </parseJsonOrBoolean>\n}\n"], ["shuffleArray", "\nfunction shuffle(o) {\n  for (var j, x, i = o.length; i; j = Math.floor(Math.random() * i), x = o[--i], o[i] = o[j], o[j] = x);\n  return o;\n}\n"], ["closeDropdown", "\nfunction (target) {\n  <getInstance>\n  var inst = this._getInst(target);\n  </getInstance>\n\n  if (!inst || !inst.isOpen) {\n    return;\n  }\n\n  <invokeOnClose>\n  var onClose = this._get(inst, 'onClose');\n  </invokeOnClose>\n  \n  <hideOptions>\n  inst.settings.effect === \"fade\" ? $(\"#sbOptions_\" + inst.uid).fadeOut(inst.settings.speed) : $(\"#sbOptions_\" + inst.uid).slideUp(inst.settings.speed);\n  </hideOptions>\n  \n  <updateToggle>\n  $(\"#sbToggle_\" + inst.uid).removeClass(inst.settings.classToggleOpen);\n  </updateToggle>\n  \n  <changeHolderState>\n  var holder = $(\"#sbHolder_\" + inst.uid);\n  holder.removeClass('open');\n  holder.addClass('closed');\n  </changeHolderState>\n    \n  <updateState>\n  this._state[inst.uid] = FALSE;\n  inst.isOpen = FALSE;\n  </updateState>\n  \n  <applyCloseCallback>\n  if (onClose) {\n    onClose.apply((inst.input ? inst.input[0] : null), [inst]);\n  }\n  </applyCloseCallback>\n  \n  <storeInstanceData>\n  $.data(target, PROP_NAME, inst);\n  </storeInstanceData>\n}\n"], ["trackPointers", "\nfunction (type, pointerEvent) {\n  <endEventReset>\n  if (type == ionic.Gestures.EVENT_END) {\n    this.pointers = {};\n  }\n  </endEventReset>\n  \n  <updatePointers>\n  else {\n    pointerEvent.identifier = pointerEvent.pointerId;\n    this.pointers[pointerEvent.pointerId] = pointerEvent;\n  }\n  </updatePointers>\n\n  return Object.keys(this.pointers).length;\n}\n"], "```"]