[["commitAndHide", "\nfunction() {\n  commitColor.call($this);\n  settings.window.expandable && hide.call($this);\n  $.isFunction(commitCallback) && commitCallback.call($this, color.active, okButton);\n}\n"], ["lightenColor", "\nfunction lighten(scale) {\n  scale = me.Math.clamp(scale, 0, 1);\n  this.glArray[0] = me.Math.clamp(this.glArray[0] + (1 - this.glArray[0]) * scale, 0, 1);\n  this.glArray[1] = me.Math.clamp(this.glArray[1] + (1 - this.glArray[1]) * scale, 0, 1);\n  this.glArray[2] = me.Math.clamp(this.glArray[2] + (1 - this.glArray[2]) * scale, 0, 1);\n  return this;\n}\n"], ["filterNamespaces", "\nfunction (type) {\n  var namespaces = _emberRuntimeSystemNative_array.A(_emberRuntimeSystemNamespace.default.NAMESPACES);\n  <typeNameRegexCreation>\n  var types = _emberRuntimeSystemNative_array.A();\n  var typeSuffixRegex = new RegExp(_emberRuntimeSystemString.classify(type) + '$');\n  </typeNameRegexCreation>\n\n  namespaces.forEach(function (namespace) {\n    if (namespace !== _emberMetalCore.default) {\n      for (var key in namespace) {\n        if (!namespace.hasOwnProperty(key)) {\n          continue;\n        }\n        if (typeSuffixRegex.test(key)) {\n          <collectClassTypes>\n          var klass = namespace[key];\n          if (_emberRuntimeUtils.typeOf(klass) === 'class') {\n            types.push(_emberRuntimeSystemString.dasherize(key.replace(typeSuffixRegex, '')));\n          }\n          </collectClassTypes>\n        }\n      }\n    }\n  });\n  return types;\n}\n"], ["setMobileRequest", "\nfunction setMobile (registrationId, mobileNumber, callback) {\n  var json = {}\n  json['mobile'] = mobileNumber\n\n  var url = HOST_NAME_SSL + DEVICE_PATH + '/' + registrationId\n  return _request(this, url, JSON.stringify(json), 'POST', callback)\n}\n"], ["extendObservablePrototype", "\nfunction(module, exports, __webpack_require__) {\n  \"use strict\";\n  var Observable_1 = __webpack_require__(5);\n  var let_1 = __webpack_require__(484);\n  Observable_1.Observable.prototype.let = let_1.letProto;\n  Observable_1.Observable.prototype.letBind = let_1.letProto;\n}\n"], ["deleteIndex", "\nfunction(spec, callback) { \n  spec = spec || {};\n  if (!spec.ddoc) { throw new Error('index.del() must specify a \"ddoc\" value'); }\n  if (!spec.name) { throw new Error('index.del() must specify a \"name\" value'); }\n  var type = spec.type || 'json';\n  var path = encodeURIComponent(db) + '/_index/' +\n             encodeURIComponent(spec.ddoc) + '/' +\n             encodeURIComponent(type) + '/' +\n             encodeURIComponent(spec.name);\n  return nano.request({ path: path, method: 'delete' }, callback);\n}\n"], ["FormArrayInitialization", "\nfunction FormArray(controls, validatorOrOpts, asyncValidator) {\n  var _this = _super.call(this, coerceToValidator(validatorOrOpts), coerceToAsyncValidator(asyncValidator, validatorOrOpts)) || this;\n  _this.controls = controls;\n  _this._initObservables();\n  _this._setUpdateStrategy(validatorOrOpts);\n  _this._setUpControls();\n  _this.updateValueAndValidity({ onlySelf: true, emitEvent: false });\n  return _this;\n}\n"], ["setupAuthenticatedRoute", "\nfunction authRoute(seneca, options, context, method, route, middleware, auth) {\n  const opts = {\n    failureRedirect: route.auth.fail,\n    successRedirect: route.auth.pass\n  }\n\n  const routeArgs = [route.path]\n    .concat([auth.authenticate(route.auth.strategy, opts)])\n    .concat(middleware)\n    .concat([\n      (request, reply, next) => {\n        handleRoute(seneca, options, request, reply, route, next)\n      }\n    ])\n\n  context[method].apply(context, routeArgs)\n}\n"], ["initializeRegistrar", "\nfunction Registrar(web3, ens = new ENS(web3), tld = 'eth', minLength = 7, callback) {\n  this.web3 = web3;\n  \n  this.sha3 = function sha3withZeroX(...args) {\n    const result = web3.sha3.apply(this, args);\n    if (result[1] !== 'x') {\n      return `0x${result}`;\n    }\n    return result;\n  };\n\n  this.ens = ens;\n  this.tld = tld;\n  this.minLength = minLength;\n  this.rootNode = namehash(this.tld);\n\n  const thisRegistrar = this;\n\n  ens.owner(this.tld, (err, result) => {\n    if (err) {\n      callback(err, null);\n    } else {\n      this.address = result;\n      this.contract = this.web3.eth.contract(interfaces.registrarInterface).at(result);\n      this.contract.registryStarted((startingErr, startingDate) => {\n        thisRegistrar.registryStarted = startingDate;\n        callback(null, result);\n      });\n    }\n  });\n}\n"], ["parseArguments", "\nfunction _class(_ref) {\n    var args = _ref.args;\n    var config = _ref.config;\n\n    _classCallCheck(this, _class);\n\n    var on = null;\n    var from = '*';\n    var cbOn = null;\n    var cbOff = null;\n    var alwaysTrigger = false;\n\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = args[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var arg = _step.value;\n\n        <interpretArgument>\n        switch (typeof arg === 'undefined' ? 'undefined' : _typeof(arg)) {\n          case 'string':\n            if (on === null) {\n              on = arg;\n            } else {\n              from = arg;\n            }\n            break;\n          case 'function':\n            if (cbOn === null) {\n              cbOn = arg;\n            } else {\n              cbOff = arg;\n            }\n            break;\n          case 'boolean':\n            alwaysTrigger = arg;\n        }\n        </interpretArgument>\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    _extends(this, {\n      isActive: null,\n      matchesOn: parseMatchInputString(on, config.inversePrefix),\n      matchesFrom: parseMatchInputString(from, config.inversePrefix),\n      cbOn: cbOn, cbOff: cbOff, alwaysTrigger: alwaysTrigger\n    });\n  }\n"], "```\nThis constructor function seems to be handling multiple responsibilities as it interprets argument types and extends the class with parsed arguments. It could potentially violate SRP, if these processes are considered significant and distinct enough to warrant separate handling."]