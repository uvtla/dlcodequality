[["handlePathObj", "\nfunction handlePathObj(path, event, EventObject, newIndex) {\n  if (typeof path === 'function') {\n    return path(event, newIndex);\n  } else if ((typeof path === 'undefined' ? 'undefined' : _typeof(path)) === 'object' && !Array.isArray(path) && path) {\n    return EventObject.reduce((0, _helpers.matchAndAddition)(path, event), {});\n  } else if ((typeof path === 'undefined' ? 'undefined' : _typeof(path)) === 'object' && Array.isArray(path) && path) {\n    return EventObject.reduce((0, _helpers.matchAndAddition)(path[newIndex], event), {});\n  }\n  return {};\n}\n"], ["oTreeFunction", "\nfunction (oTree) {\n  var sDebugString = this.toDebugInfo(oTree);\n\n  if (sDebugString === true) {\n    return 1;\n  } else if (sDebugString) {\n    return sDebugString.split(\",\").length;\n  }\n  return 0;\n}\n"], ["hostElement", "\nfunction hostElement(tag, rNode, def, sanitizer) {\n  resetApplicationState();\n  var node = createLNode(0, 3 , rNode, null, null, createLViewData(renderer, getOrCreateTView(def.template, def.directiveDefs, def.pipeDefs, def.viewQuery), null, def.onPush ? 4  : 2 , sanitizer));\n  if (firstTemplatePass) {\n    node.tNode.flags = 4096 ;\n    if (def.diPublic)\n      def.diPublic(def);\n    tView.directives = [def];\n  }\n  return node;\n}\n"], ["fileFormatter", "\nfunction(file) {\n  return {\n    name: file.name,\n    size: file.size,\n    lastModifiedDate: file.lastModifiedDate\n  };\n}\n"], ["xmlParserFunction", "\nfunction (bodyStr) {\n  var d = {};\n  xmlParser.parseString(bodyStr, function (err, result) {\n    d = result;\n  });\n  return d;\n}\n"], ["formatTo", "\nfunction formatTo(decimals, [...]) {\n  [...]\n}\n"], ["highestFrequencySite", "\nfunction highestFrequencySite(objs, noIdentities, logger) {\n  logger.info('finding highest frequency site');\n  <findFrequency>\n  var highest = 0, \n      out ='';\n  </findFrequency>\n  <processIdentities>\n  if(!noIdentities)    \n    findHighest(objs.identities);   \n  </processIdentities>\n  <processDomains>\n  findHighest(objs.domainsNotMapped);  \n  </processDomains>\n  <findHighest>\n  function findHighest(arr) {\n    if(arr) {\n      var i = arr.length,\n          x = 0;\n      while (x < i) {\n        if(arr[x].frequency > highest) {\n          highest = arr[x].frequency;\n          out = (arr[x].matchedUrl) ? arr[x].matchedUrl : arr[x].url;\n        }\n        x++;\n      }\n    }\n  }\n  </findHighest>    \n  return out;\n}\n"], ["setExtremes", "\nfunction setExtremes(newMin, newMax, redraw, animation) {\n  <redrawCheck>\n  redraw = pick(redraw, true); \n  </redrawCheck>\n  <setExtremesEvent>\n  fireEvent(axis, 'setExtremes', { \n    min: newMin,\n    max: newMax\n  }, function () {\n    <minMaxUpdate>\n    userMin = newMin;\n    userMax = newMax;\n    </minMaxUpdate>\n    <redrawChart>\n    if (redraw) {\n      chart.redraw(animation);\n    }\n    </redrawChart>\n  });\n  </setExtremesEvent>\n}\n"], ["ProcessingInstruction", "\nfunction ProcessingInstruction(doc, name, content) {\n  <argumentValidation>\n  if (!doc) {\n      throw new Error('document argument required');\n  } else if (!(doc instanceof bindings.Document)) {\n      throw new Error('document argument must be an ' +\n                      'instance of Document');\n  } else if (!name) {\n      throw new Error('name argument required');\n  }\n  </argumentValidation>\n  return new bindings.ProcessingInstruction(doc, name, content);\n}\n"], ["parseDateTime", "\nfunction (value, withOffset, nullOnError) {\n  <dateParsing>\n  var parts = parseDateTimeRE.exec(value);\n  var offset = (parts) ? getCanonicalTimezone(parts[8]) : null;\n  <validationCheck>\n  if (!parts || (!withOffset && offset !== \"Z\")) {\n    if (nullOnError) {\n      return null;\n    }\n    throw { message: \"Invalid date/time value\" };\n  }\n  </validationCheck>\n  </dateParsing>\n  <parseComponents>\n  var year = parseInt10(parts[1]);\n  [...]\n  if (isNaN(result.valueOf())) {\n    if (nullOnError) {\n      return null;\n    }\n    throw { message: \"Invalid date/time value\" };\n  }\n  </parseComponents>\n  <returnResult>\n  if (withOffset) {\n    result.__edmType = \"Edm.DateTimeOffset\";\n    result.__offset = offset;\n  }\n  if (ns) {\n    result.__ns = ns;\n  }\n  return result;\n  </returnResult>\n}\n"], "```\n\nEach function has been enclosed in tags that identify the major responsibility of the function. Within some functions, nested tags highlight distinct sequences of operations that correspond to separate sub-tasks while still being a part of the overall responsibility of the function."]