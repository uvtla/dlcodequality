[["processArray", "\nfunction(arr, iterator, callback) {\n  callback = _doOnce(callback || noop);\n  var amount = arr.length;\n\n  <checkArrayValidity>\n  if (!isArray(arr)) return callback();\n  </checkArrayValidity>\n\n  var completed = 0;\n  <iterateArrayElements>\n  doEach(arr, function(item) {\n    iterator(item, doOnce(function(err) {\n      if (err) {\n        callback(err);\n        callback = noop;\n      } else {\n        completed++;\n        <checkCompletion>\n        if (completed >= amount) callback(null);\n        </checkCompletion>\n      }\n    }));\n  });\n  </iterateArrayElements>\n}\n"], ["createWindow", "\nfunction(name, title, url, setupTemplate, setup, showDevTools){\n    \n    <checkExistingWindow>\n    if(windowManager.windows[name]){\n        console.log('Window ' + name + ' already exists!');\n        \n        windowManager.focusOn(name);\n        return;\n    }\n    </checkExistingWindow>\n\n    <initializeWindow>\n    this.name = name || ( 'window_' + ( Object.keys(windowManager.windows).length + 1 ) );\n    this.object = null;\n    this.setup = {\n        'show': false,\n        'setupTemplate': setupTemplate\n    };\n    if(title) this.setup.title = title;\n    if(url) this.setup.url = url;\n    if(showDevTools) this.setup.showDevTools = showDevTools;\n    \n    if(isString(setup) && setup.indexOf('x') >= 0){\n        const dimensions = setup.split('x');\n        setup = {\n            'width': parseInt(dimensions[0], 10),\n            'height': parseInt(dimensions[1], 10)\n        };\n    }\n\n    if(isObject(setup)){\n        this.setup = Object.assign(this.setup, setup);\n    }\n    </initializeWindow>\n\n    <registerWindow>\n    windowManager.windows[this.name] = this;\n    </registerWindow>\n}\n"], ["uploadFunction", "\nfunction(fileName) {\n    let file = assets[fileName] || {};\n    fileName = basePath + \"/\" + fileName.replace(/\\\\/g, '/');\n    let key = path.posix.join(uploadPath, fileName);\n\n    <uploadPromise>\n    return new Promise((resolve, reject) => {\n        let begin = Date.now();\n        cos.putObject(\n            {\n                Bucket: bucket,\n                Region: region,\n                Key: key,\n                Body: fs.createReadStream(file.existsAt),\n                ContentLength: fs.statSync(file.existsAt).size\n            },\n            function(err, body) {\n                uploadedFiles++;\n                spinner.text = tip(uploadedFiles, totalFiles);\n\n                if (err) return reject(err);\n                body.duration = Date.now() - begin;\n                resolve(body);\n            }\n        );\n    });\n    </uploadPromise>\n}\n"], ["deferredObjectCreator", "\nfunction() {\n    var _status = STATUS_PENDING;\n    var _args;\n    var _callbacks = {\n        success: [],\n        fail: [],\n        done: []\n    };\n\n    <registerCallback>\n    function _registerCallback(resultType, callback) {\n        if (typeof callback !== 'function') {\n            \n            throw 'Invalid argument: callback. Must be a function.';\n        }\n\n        if (_status !== STATUS_PENDING) {\n            if (_status === resultType || resultType === RESULT_TYPE_DONE) {\n                \n                \n                callback.apply(null, _args);\n            }\n        } else {\n            \n            \n            _callbacks[resultType].push(callback);\n        }\n    }\n    </registerCallback>\n\n    <satisfyCallbacks>\n    function _satisfy(resultType, args) {\n        if (_status !== STATUS_PENDING) {\n            return;\n        }\n        _args = args;\n        _status = resultType;\n\n        function doCallback(item, index) {\n            item.apply(null, _args);\n        }\n\n        _callbacks[resultType].forEach(doCallback);\n        _callbacks.done.forEach(doCallback);\n        \n        _callbacks.succes = [];\n        _callbacks.fail = [];\n        _callbacks.done = [];\n    }\n    </satisfyCallbacks>\n\n    var _promise = {\n        \n        done: function(callback) {\n            _registerCallback(RESULT_TYPE_DONE, callback);\n            return (_promise);\n        },\n        success: function(callback) {\n            _registerCallback(STATUS_SUCCESS, callback);\n            return (_promise);\n        },\n        fail: function(callback) {\n            _registerCallback(STATUS_FAIL, callback);\n            return (_promise);\n        },\n        results: function() {\n            return _args;\n        }\n    }\n\n    var deferredObject = {\n        done: _promise.done,\n        success: _promise.success,\n        fail: _promise.fail,\n        resolve: function() {\n            _satisfy(STATUS_SUCCESS, Array.prototype.slice.call(arguments, 0));\n        },\n        reject: function() {\n            _satisfy(STATUS_FAIL, Array.prototype.slice.call(arguments, 0));\n        },\n        promise: function() {\n            return Object.create(_promise);\n        },\n        getResolver: function() {\n            var ctxArgs = Array.prototype.slice.call(arguments, 0);\n            return function(err, data) {\n                if (!err) {\n                    var args = Array.prototype.slice.call(arguments, 1);\n                    deferredObject.resolve.apply(null,\n                        ctxArgs.concat(args));\n                } else {\n                    deferredObject.reject.apply(null,\n                        ctxArgs.concat([err]));\n                }\n            };\n        },\n        getMultiStepResolver: function(count) {\n            var _count = count;\n            var ctxArgs = Array.prototype.slice.call(arguments, 1);\n\n            if (_count === 0) {\n                deferredObject.resolve.apply(null, ctxArgs);\n            }\n\n            return {\n                stepComplete: function() {\n                    var ca\n                    _count--;\n                    if (_count === 0) {\n                        var args = Array.prototype.slice.call(arguments, 0);\n                        deferredObject.resolve.apply(null,\n                            ctxArgs.concat(args));\n                    }\n                },\n                reject: function() {\n                    var args = Array.prototype.slice.call(arguments, 0);\n                    deferredObject.reject.apply(null, ctxArgs.concat(args));\n                }\n            }\n        }\n    };\n\n    return deferredObject;\n}\n"], ["handleMessage", "\nfunction onMessage(message) {\n  <runCommand>\n  if (message.command === 'run') {\n    run(message.opts);\n    return;\n  }\n  </runCommand>\n\n  <stopCommand>\n  if (message.command === 'stop') {\n    cleanup();\n  }\n  </stopCommand>\n}\n"], ["ServerConstructor", "\nfunction(options) {\n  options = options || {};\n  \n  <serverInitialization>\n  EventEmitter.call(this);\n  this.id = id++;\n  \n  this.s = {\n    options: options,\n    logger: Logger('Server', options),\n    Cursor: options.cursorFactory || BasicCursor,\n    bson: ...\n    \n    pool: null,\n    disconnectHandler: options.disconnectHandler,\n    monitoring: ...,\n    inTopology: !!options.parent,\n    monitoringInterval: ...,\n    topologyId: -1,\n    compression: { compressors: createCompressionInfo(options) },\n    parent: options.parent\n  };\n  \n  if (!this.s.parent) {\n    this.s.clusterTime = null;\n  }\n  </serverInitialization>\n\n  <objectStateInitialization>\n  this.ismaster = null;\n  this.lastIsMasterMS = -1;\n  this.monitoringProcessId = null;\n  this.initialConnect = true;\n  this._type = 'server';\n  this.clientInfo = createClientInfo(options);\n  \n  this.lastUpdateTime = 0;\n  this.lastWriteDate = 0;\n  this.staleness = 0;\n  </objectStateInitialization>\n}\n"], ["ContainerConstructor", "\nfunction (cfg, ctxt) {\n    var configurationOfCommonBinding = this._getConfigurationOfCommonBinding(cfg);\n\n    <bindProperties>\n    if (configurationOfCommonBinding != null) {\n        var bind = cfg.bind;\n        var inside = configurationOfCommonBinding.inside;\n\n        bind.controlledTabPanelId = {\n            inside: inside,\n            to: this._getControlledTabPanelIdPropertyName(cfg)\n        };\n\n        bind.labelId = {\n            inside: inside,\n            to: this._getLabelIdPropertyName(cfg)\n        };\n    }\n    </bindProperties>\n\n    <waiAriaSupport>\n    if (cfg.waiAria) {\n        this._customTabIndexProvided = true;\n    }\n    </waiAriaSupport>\n\n    <ContainerSuperCall>\n    this.$Container.constructor.apply(this, arguments);\n    this._setSkinObj(this._skinnableClass);\n    </ContainerSuperCall>\n\n    <initializeContainerState>\n    this._mouseOver = false;\n    this._hasFocus = false;\n    this._updateState(true);\n    </initializeContainerState>\n\n    <createFrame>\n    this._frame = ariaWidgetsFramesFrameFactory.createFrame({\n        height : cfg.height,\n        state : this._state,\n        width : cfg.width,\n        sclass : cfg.sclass,\n        skinnableClass : this._skinnableClass,\n        printOptions : cfg.printOptions,\n        id : Aria.testMode ? this._domId + \"_\" + cfg.tabId : undefined\n    });\n    </createFrame>\n\n    <stylingInitialization>\n    this._spanStyle = \"z-index:100;vertical-align:top;\";\n    </stylingInitialization>\n}\n"], ["viewSessionMessage", "\nfunction view_session_message(req, msg) {\n\t<copyMessage>\n    var result = copy(msg);\n    </copyMessage>\n    <createRef>\n    result.$ref = ref(req, opts.path + '/messages', msg.$id );\n    </createRef>\n    return result;\n}\n"], ["defineOptionConstructor", "\nfunction defineOptionConstructor(constructor, code, name, repeatable, ...args) {\n    <storeConstructor>\n    optionConstructors[code] = optionConstructors[name] =\n        constructor.create.bind(constructor, ...[code, name, repeatable, ...args]);\n    </storeConstructor>\n}\n"], ["flattenGlobalProperties", "\nfunction flattenProperties(obj, prefix = null, globals = {}) {\n    <setPrefix>\n    prefix = prefix ? (prefix + '.') : 'global.';\n    </setPrefix>\n\n    <iterateProperties>\n    for (const p in obj) {\n        const key = prefix + p;\n        const val = obj[p];\n        globals[key] = val;\n\n        <recursivelyFlatten>\n        if (typeof val === 'object' && !Array.isArray(val)) {\n            flattenProperties(val, key, globals);\n        }\n        </recursivelyFlatten>\n    }\n    </iterateProperties>\n    \n    return globals;\n}\n"], "```"]