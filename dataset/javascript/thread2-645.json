[["buildGrammar", "\nfunction buildGrammar(match, namespace, optOhmGrammarForTesting) {\n  var builder = new Builder();\n  var decl;\n  var currentRuleName;\n  var currentRuleFormals;\n  var overriding = false;\n  var metaGrammar = optOhmGrammarForTesting || ohmGrammar;\n  \n  <semanticOperations>\n  var helpers = metaGrammar.createSemantics().addOperation('visit', {\n    // ... semantic operation methods ...\n  });\n  </semanticOperations>\n  \n  return helpers(match).visit();\n}\n"], ["structureEquals", "\nfunction structureEquals(structure1, structure2, keys1, keys2, getter, traversedValues) {\n  // ... function body performing deep equality check ...\n  return true\n}\n"], ["dummyMarkdown", "\nfunction dummyMarkdown() {\n    var codeBlock = /^```/;\n    var quoteBlock = /^>/;\n    var listBlock = /^\\* /;\n\n    var commentInline = '<!--.*-->';\n    var codeInline = '`.+`';\n\n    <split>\n    function split(content) {\n        // ... function to split markdown content ...\n    }\n    </split>\n\n    return function (input) {\n        // ... function to process markdown input ...\n    };\n}\n"], ["escapeValue", "\nfunction escapeValue(str) {\n  // ... function body to escape values in a string ...\n  return out;\n}\n"], ["wrrRoute", "\nfunction wrrRoute(client, serverType, msg, cb) {\n    // ... function body implementing weighted round-robin routing ...\n}\n"], ["simplifyObjectAccess", "\nfunction(type, obj) {\n     <getCommand>\n     switch (type) {\n       case 'greet':\n         var name = _.get(obj, 'profile.displayName') || _.get(obj, 'username', '') || obj;\n\n         return _.get(name, 'length') ? name : 'Hey';\n         break;\n     }\n     </getCommand>\n\n     return obj; \n}\n"], ["sortObject", "\nfunction sortObject(originalSrc, options, done) {\n  var callback\n\n  <determineCallback>\n  if (options === undefined) {\n    \n  } else if (typeof options === \"function\") {\n    callback = options\n  } else {\n    callback = done\n  }\n  </determineCallback>\n\n  if (callback) {\n    <processAsynchronously>\n    process.nextTick(function() {\n      done(work(originalSrc))\n    })\n    </processAsynchronously>\n    return\n  }\n\n  <work>\n  function work(obj) {\n    // ... function body doing the sorting work synchronously ...\n    return out\n  }\n  </work>\n\n  return work(originalSrc)\n}\n"], ["tailLines", "\nfunction(maxLines) {\n    var cbs = [];\n    var lines = [];\n    var current = null;\n    var closed = false\n    var max = maxLines - 1;\n\n    <emitFunction>\n    function emit(line) {\n      // ... short function to emit a line to all callbacks ...\n    }\n    </emitFunction>\n\n    return {\n      // ... various related methods handling lines ...\n    };\n}\n"], ["restrictPointsToArc", "\nfunction restrictPointsToArc(intersections, center, radiusX, radiusY, startRadians, endRadians) {\n    // ... function body to restrict points to a certain arc ...\n    return result;\n}\n"], ["loopgen", "\nfunction loopgen(dom, sel, loop, fns) {\n    var already = false, ls, sorter, filter, prop;\n    <loopPropertyExtraction>\n    for (prop in loop) {\n      if (loop.hasOwnProperty(prop)) {\n        // ... extracting properties from loop ...\n      }\n    }\n    </loopPropertyExtraction>\n    \n    <directiveSelection>\n    if (!ls) {\n      error('Error in the selector: ' + sel + '\\nA directive action must be a string, a function or a loop(<-)');\n    }\n    var dsel = loop[ls];\n    </directiveSelection>\n\n    <loopPreparation>\n    if (typeof(dsel) === 'string' || typeof(dsel) === 'function') {\n      loop = {};\n      loop[ls] = {root: dsel};\n      return loopgen(dom, sel, loop, fns);\n    }\n    var spec = parseloopspec(ls),\n      itersel = dataselectfn(spec.sel),\n      target = gettarget(dom, sel, true),\n      nodes = target.nodes;\n    </loopPreparation>\n\n    for (i = 0; i < nodes.length; i++) {\n      <nodeProcessing>\n      var node = nodes[i],\n        inner = compiler(node, dsel);\n      fns[fns.length] = wrapquote(target.quotefn, loopfn(spec.name, itersel, inner, sorter, filter));\n      target.nodes = [node];\n      setsig(target, fns.length - 1);\n      </nodeProcessing>\n    }\n}\n"], "```\n\nAnnotation Key Points:\n\n- SRP compliance is denoted with outer tags such as `<buildGrammar>`, `<structureEquals>`, etc., showcasing the overarching cohesive responsibility of each function.\n- Within functions, where there is a mixture of multiple distinct responsibilities, nested tags are used, such as `<semanticOperations>`, `<split>`, `<emitFunction>`, and `<loopPropertyExtraction>`, to indicate these different cohesive blocks of code. \n- SRP violations are not explicitly marked; instead, we highlight where the function contains separate responsibilities to imply that those areas might present a potential violation of the SRP, depending on the context and granularity considered.\n- Simple returns, variable assignments, or one-line statements are not considered separate responsibilities."]