[["createCaretContainer", "\nfunction createCaretContainer(fill) {\n  var caretContainer = dom.create('span', { id: caretContainerId, 'data-mce-bogus': true, style: debug ? 'color:red' : '' });\n\n  if (fill) {\n    caretContainer.appendChild(ed.getDoc().createTextNode(INVISIBLE_CHAR));\n  }\n\n  return caretContainer;\n}\n"], ["compile", "\nfunction compile(){\n    debug('compiling module ' + mod.name);\n\n    var refs = deps.map(function(d){\n        return d.module.out;\n    });\n    mod.refs = Array.isArray(mod.refs) ? mod.refs.concat(refs) : refs;\n\n    compile_core();\n}\n"], ["getDirectoriesInURL", "\nfunction getDirectoriesInURL()\n{\n\tvar trail = document.location.pathname.split( PATH_SEPARATOR );\n\n\tvar lastcrumb = trail[trail.length-1];\n\tfor( var i = 0; i < FILE_EXTENSIONS.length; i++ )\n\t{\n\t\tif( lastcrumb.indexOf( FILE_EXTENSIONS[i] ) )\n\t\t{\n\t\t\treturn trail.slice( 1, trail.length-1 );\n\t\t}\n\t}\n\n\treturn trail.slice( 1, trail.length );\n}\n"], ["BoundingBox", "\nfunction (min, max) {\n    this.min = min || new Vector3(Infinity, Infinity, Infinity);\n    this.max = max || new Vector3(-Infinity, -Infinity, -Infinity);\n    this.vertices = null;\n}\n"], ["makeActionCreator", "\nfunction makeActionCreator(type) {\n  var payloadReducer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _lodash2.default.identity;\n  var metaReducer = arguments[2];\n\n  var actionType = completeActionType(type);\n  var hasMeta = _lodash2.default.isFunction(metaReducer);\n\n  return function () {\n    var action = {\n      type: actionType,\n      payload: payloadReducer.apply(undefined, arguments)\n    };\n\n    if (arguments.length === 1 && (arguments.length <= 0 ? undefined : arguments[0]) instanceof Error) {\n      action.error = true;\n    }\n\n    if (hasMeta) {\n      action.meta = metaReducer.apply(undefined, arguments);\n    }\n\n    return action;\n  };\n}\n"], ["CompoundDuplex", "\nfunction CompoundDuplex(writable, readable, options) {\n\tvar self = this;\n\tvar convertToZStream = require('../index');\t\n\n\tif(!readable || typeof readable.read !== 'function') {\n\t\toptions = readable;\n\t\treadable = writable;\n\t\twritable = null;\n\t}\n\n\tif(writable && !writable._isZStream) {\n\t\twritable = convertToZStream(writable);\n\t}\n\tif(!readable._isZStream) {\n\t\treadable = convertToZStream(readable);\n\t}\n\n\tif(!writable) {\n\t\tif(typeof readable.getStreamChain !== 'function') {\n\t\t\tthrow new Error('Can only use shorthand CompoundDuplex constructor if pipeline is all zstreams');\n\t\t}\n\t\twritable = readable.getStreamChain().getStreams()[0];\n\t}\n\n\tif(!options) options = {};\n\n\toptions.readableObjectMode = readable.isReadableObjectMode();\n\toptions.writableObjectMode = writable.isWritableObjectMode();\n\tDuplex.call(this, options);\n\n\tthis._compoundReadable = readable;\n\tthis._compoundWritable = writable;\n\n\tthis._waitingForReadableData = false;\n\n\twritable.on('chainerror', function(error) {\n\t\tthis.ignoreError();\n\t\tself.emit('error', error);\n\t});\n\n\treadable.on('readable', function() {\n\t\tif(self._waitingForReadableData) {\n\t\t\tself._waitingForReadableData = false;\n\t\t\tself._readSomeData();\n\t\t}\n\t});\n\n\treadable.on('end', function() {\n\t\tself.push(null);\n\t});\n}\n"], ["changeURLContent", "\nfunction (from_value, to_value) {\n    var type;\n\n    if (from_value instanceof RegExp) {\n        type = 'RegExp';\n    } else if (typeof from_value === 'string') {\n        type = 'String';\n    } else {\n        throw { type: 'changeURLContent', message: 'First argument must be RegExp of String' };\n    }\n\n    if (to_value === undefined) {\n        to_value = \"\";\n    } else if (typeof to_value !== 'string') {\n        throw { type: 'changeURLContent', message: 'Second argument must be String' };\n    }\n\n    urls.filter(function (value) {\n        if (type === \"RegExp\") {\n            return from_value.test(_getURLValue(value));\n        } else {\n            return _getURLValue(value).indexOf(from_value) !== -1;\n        }\n    }).forEach(function (value) {\n        var new_value = _getURLValue(value).replace(from_value, to_value);\n        _setURLValue(value, new_value);\n    });\n}\n"], ["start", "\nfunction start (startTiming) {\n  if (isStart) {\n    return\n  }\n  isStart = true\n  recordTiming('MIPStart', startTiming)\n  viewer.on('show', showTiming => {\n    recordTiming('MIPPageShow', showTiming)\n  })\n\n  document.addEventListener('DOMContentLoaded', domLoaded, false)\n  document.onreadystatechange = () => {\n    if (document.readyState === 'complete') {\n      domLoaded()\n    }\n  }\n}\n"], ["TextureAttach", "\nfunction( format, type, internal ){\n    var t = new Texture( this.gl, format, type, internal );\n    return this.attach( 0x8CE0, t );\n}\n"], ["findMatchingOptionIndex", "\nfunction (lastTypedKeys, newMatch) {\n    var LABEL_META = this.LABEL_META;\n    var options = this._dataModel.listContent;\n    var keyNbr = lastTypedKeys.length;\n    var index = this._dataModel.selectedIdx + (newMatch ? 1 : 0);\n    for (var ct = 0, optionsLength = options.length; ct < optionsLength; ct++, index++) {\n        if (index >= optionsLength) {\n            index = 0;\n        }\n        var opt = options[index];\n        var prefix = opt[LABEL_META].substr(0, keyNbr);\n        if (prefix == lastTypedKeys) {\n            return index;\n        }\n    }\n    return -1;\n}\n"], "```\n\nEach function is tagged according to its cohesive responsibility. These annotations are made assuming the surrounding context of these code segments is not available, and each function appears to have a single responsibility based on the provided content. If the context were available and showed that these functions had multiple responsibilities, additional annotations might be required."]