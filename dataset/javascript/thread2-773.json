[["getVisibleTodos", "\nfunction getVisibleTodos(model) {\n    switch (model.visible) {\n        case 'All':\n            return model.todos;\n        case 'Complete':\n            return model.todos.filter(x => x.completed);\n        case 'Incomplete':\n        default:\n            return model.todos.filter(x => !x.completed);\n    }\n}\n"], ["set", "\nfunction set(r) {\n    <findHtmlElement>\n    if (isString(r)) {\n        r = document.querySelector(r);\n    }\n    </findHtmlElement>\n\n    <checkElementAndSet>\n    if (exist(r)) {\n        Html._r = r;\n    } else {\n        warn('Root element must be a existing Html node');\n    }\n    </checkElementAndSet>\n}\n"], ["validateOptions", "\nasync function validateOptions(options) {\n    <checkPaths>\n    if (!options.paths.length) {\n        throw new ValidationError('No paths specified')\n    }\n    </checkPaths>\n\n    <checkOutputDir>\n    if (!options.outputDir) {\n        throw new ValidationError('Please specify an output directory with -o or --output')\n    }\n\n    if (!await fsAsync.exists(options.outputDir)) {\n        throw new ValidationError('Output directory doesn\\'t exist')\n    }\n\n    const outStat = await fsAsync.stat(options.outputDir)\n    if (!outStat.isDirectory()) {\n        throw new ValidationError('Output path must be a directory')\n    }\n    </checkOutputDir>\n\n    <checkCssTemplate>\n    if (options.cssTemplate && !await fsAsync.exists(options.cssTemplate)) {\n        throw new ValidationError('CSS template not found')\n    }\n    </checkCssTemplate>\n\n    <checkHtmlTemplate>\n    if (options.htmlTemplate && !await fsAsync.exists(options.htmlTemplate)) {\n        throw new ValidationError('HTML template not found')\n    }\n    </checkHtmlTemplate>\n\n    <checkCodepoints>\n    if (options.codepoints) {\n        if (!await fsAsync.exists(options.codepoints)) {\n            throw new ValidationError(`Cannot find json file @ ${options.codepoints}!`)\n        }\n\n        const codepointsStat = await fsAsync.stat(options.codepoints)\n        if (!codepointsStat.isFile() || path.extname(options.codepoints) !== '.json') {\n            throw new ValidationError([\n                'Codepoints file must be JSON',\n                `${options.codepoints} is not a valid file.`\n            ].join(' '))\n        }\n    }\n    </checkCodepoints>\n}\n"], ["constructor", "\nfunction(host, port, options) {\n    EventEmitter.call(this);\n\n    <parseArguments>\n    if(typeof host === \"object\") {\n        options = host;\n        host = port = undefined;\n    }\n    </parseArguments>\n\n    <setDefaultOptions>\n    options = options || {};\n    </setDefaultOptions>\n\n    <configureZookeeperOptions>\n    if(options.zookeeper) {\n        host = port = undefined;\n\n        this.zookeeperOptions = options.zookeeper || {};\n        this.zookeeperOptions.connectString = this.zookeeperOptions.connectString || \"127.0.0.1:2181\";\n        this.zookeeperOptions.root = this.zookeeperOptions.root || \"/illyria\";\n        this.zookeeperOptions.prefix = this.zookeeperOptions.prefix || \"/HB_\";\n\n        if(this.zookeeperOptions.connectString instanceof Array) {\n            this.zookeeperOptions.connectString = this.zookeeperOptions.connectString.join(\",\");\n        }\n\n        if(!this.zookeeperOptions.root.startsWith(\"/\")) {\n            this.zookeeperOptions.root = \"/\" + this.zookeeperOptions.root;\n        }\n\n        if(!this.zookeeperOptions.prefix.startsWith(\"/\")) {\n            this.zookeeperOptions.prefix = \"/\" + this.zookeeperOptions.prefix;\n        }\n    }\n    </configureZookeeperOptions>\n\n    <initializeConnection>\n    this.options = options;\n    this.socket = new ISocket(options);\n    this.status = \"NOT_CONNECTED\";\n\n    this.port = port;\n    this.host = host;\n\n    this.runTimeout = options.runTimeout || 10000;\n    this.msgId = 0;\n\n    this.socket.addListener(\"error\", this.emit.bind(this, \"error\"));\n    this.socket.addListener(\"close\", this.emit.bind(this, \"close\"));\n    this.socket.addListener(\"tryReconnect\", this.emit.bind(this, \"tryReconnect\"));\n    this.socket.addListener(\"connected\", this.emit.bind(this, \"connected\"));\n    </initializeConnection>\n    \n    <setupEventHandlers>\n    var self = this;\n    this.on(\"connected\", function() {\n        self.status = \"CONNECTED\";\n    });\n    this.on(\"tryReconnect\", function() {\n        self.status = \"RECONNECTING\";\n    });\n    this.on(\"close\", function(hadError) {\n        if(hadError) {\n            if(!process.env.ZK_NO_WARN) console.warn(\"Illyria client closed with an error.\");\n        }\n\n        self.status = \"DISCONNECTED\";\n    });\n\n    this.on(\"error\", function() {});\n    </setupEventHandlers>\n}\n"], ["drawSeriesGraph", "\nfunction () {\n    var series = this,\n        options = series.options,\n        chart = series.chart,\n        graph = series.graph,\n        graphPath = [],\n        fillColor,\n        area = series.area,\n        group = series.group,\n        color = options.lineColor || series.color,\n        lineWidth = options.lineWidth,\n        dashStyle =  options.dashStyle,\n        segmentPath,\n        renderer = chart.renderer,\n        translatedThreshold = series.yAxis.getThreshold(options.threshold || 0),\n        useArea = /^area/.test(series.type),\n        singlePoints = [],\n        areaPath = [],\n        attribs;\n\n    <segmentProcessing>\n    each(series.segments, function (segment) {\n        segmentPath = [];\n\n        each(segment, function (point, i) {\n            if (series.getPointSpline) {\n                segmentPath.push.apply(segmentPath, series.getPointSpline(segment, point, i));\n            } else {\n                segmentPath.push(i ? L : M);\n                if (i && options.step) {\n                    var lastPoint = segment[i - 1];\n                    segmentPath.push(\n                        point.plotX,\n                        lastPoint.plotY\n                    );\n                }\n                segmentPath.push(\n                    point.plotX,\n                    point.plotY\n                );\n            }\n        });\n\n        if (segment.length > 1) {\n            graphPath = graphPath.concat(segmentPath);\n        } else {\n            singlePoints.push(segment[0]);\n        }\n\n        if (useArea) {\n            var areaSegmentPath = [],\n                i,\n                segLength = segmentPath.length;\n            for (i = 0; i < segLength; i++) {\n                areaSegmentPath.push(segmentPath[i]);\n            }\n            if (segLength === 3) {\n                areaSegmentPath.push(L, segmentPath[1], segmentPath[2]);\n            }\n            if (options.stacking && series.type !== 'areaspline') {\n                for (i = segment.length - 1; i >= 0; i--) {\n                    areaSegmentPath.push(segment[i].plotX, segment[i].yBottom);\n                }\n            } else {\n                areaSegmentPath.push(\n                    L,\n                    segment[segment.length - 1].plotX,\n                    translatedThreshold,\n                    L,\n                    segment[0].plotX,\n                    translatedThreshold\n                );\n            }\n            areaPath = areaPath.concat(areaSegmentPath);\n        }\n    });\n    </segmentProcessing>\n\n    <updateGraphAndArea>\n    series.graphPath = graphPath;\n    series.singlePoints = singlePoints;\n\n    if (useArea) {\n        fillColor = pick(\n            options.fillColor,\n            Color(series.color).setOpacity(options.fillOpacity || 0.75).get()\n        );\n        if (area) {\n            area.animate({ d: areaPath });\n\n        } else {\n            series.area = series.chart.renderer.path(areaPath)\n                .attr({\n                    fill: fillColor\n                }).add(group);\n        }\n    }\n\n    if (graph) {\n        stop(graph);\n        graph.animate({ d: graphPath });\n\n    } else {\n        if (lineWidth) {\n            attribs = {\n                'stroke': color,\n                'stroke-width': lineWidth\n            };\n            if (dashStyle) {\n                attribs.dashstyle = dashStyle;\n            }\n\n            series.graph = renderer.path(graphPath)\n                .attr(attribs).add(group).shadow(options.shadow);\n        }\n    }\n    </updateGraphAndArea>\n}\n"], ["Quad", "\nfunction Quad(gl) {\n    <initializeQuadProperties>\n    this.gl = gl;\n    </initializeQuadProperties>\n\n    <defineVertices>\n    this.vertices = new Float32Array([\n        0,0,\n        200,0,\n        200,200,\n        0,200\n    ]);\n    </defineVertices>\n\n    <defineUvs>\n    this.uvs = new Float32Array([\n        0,0,\n        1,0,\n        1,1,\n        0,1\n    ]);\n    </defineUvs>\n\n    <defineColors>\n    this.colors = new Float32Array([\n        1,1,1,1,\n        1,1,1,1,\n        1,1,1,1,\n        1,1,1,1\n    ]);\n    </defineColors>\n\n    <defineIndices>\n    this.indices = new Uint16Array([\n        0, 1, 2, 0, 3, 2\n    ]);\n    </defineIndices>\n\n    <createAndSetBuffers>\n    this.vertexBuffer = gl.createBuffer();\n    this.indexBuffer = gl.createBuffer();\n\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);\n    gl.bufferData(gl.ARRAY_BUFFER, (8 + 8 + 16) * 4, gl.DYNAMIC_DRAW);\n\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\n    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.indices, gl.STATIC_DRAW);\n\n    this.upload();\n    </createAndSetBuffers>\n}\n"], ["OAuth2Strategy", "\nfunction OAuth2Strategy(options, verify) {\n    <validateAndInitializeOptions>\n    if (typeof options == 'function') {\n        verify = options;\n        options = undefined;\n    }\n    options = options || {};\n\n    if (!verify) { throw new TypeError('OAuth2Strategy requires a verify callback'); }\n    if (!options.authorizationURL) { throw new TypeError('OAuth2Strategy requires a authorizationURL option'); }\n    if (!options.tokenURL) { throw new TypeError('OAuth2Strategy requires a tokenURL option'); }\n    if (!options.clientID) { throw new TypeError('OAuth2Strategy requires a clientID option'); }\n    </validateAndInitializeOptions>\n\n    <inheritPassportStrategy>\n    passport.Strategy.call(this);\n    this.name = 'oauth2';\n    this._verify = verify;\n\n    this._oauth2 = new OAuth2(options.clientID,  options.clientSecret,\n                              '', options.authorizationURL, options.tokenURL, options.customHeaders);\n    </inheritPassportStrategy>\n\n    <configureStrategy>\n    this._callbackURL = options.callbackURL;\n    this._scope = options.scope;\n    this._scopeSeparator = options.scopeSeparator || ' ';\n    this._pkceMethod = (options.pkce === true) ? 'S256' : options.pkce;\n    this._key = options.sessionKey || ('oauth2:' + url.parse(options.authorizationURL).hostname);\n    </configureStrategy>\n\n    <setupStateStore>\n    if (options.store) {\n        this._stateStore = options.store;\n    } else {\n        if (options.state) {\n            this._stateStore = options.pkce ? new PKCESessionStateStore({ key: this._key }) : new SessionStateStore({ key: this._key });\n        } else {\n            if (options.pkce) { throw new TypeError('OAuth2Strategy requires `state: true` option when PKCE is enabled'); }\n            this._stateStore = new NullStateStore();\n        }\n    }\n    this._trustProxy = options.proxy;\n    this._passReqToCallback = options.passReqToCallback;\n    this._skipUserProfile = (options.skipUserProfile === undefined) ? false : options.skipUserProfile;\n    </setupStateStore>\n}\n"], ["Scheme", "\nfunction Scheme(title) {\n    <initializeScheme>\n    this.title = utils.isUndefined(title) ? \"\" : title;\n    </initializeScheme>\n\n    <setSchemeDefaults>\n    this.description = null;\n    this.useExternalValidation = true;\n    this.useSingleInstance = false;\n    this.streamingMode = Scheme.streamingModeXML;\n    </setSchemeDefaults>\n\n    <initializeArguments>\n    this.args = [];\n    </initializeArguments>\n}\n"], ["Requisition", "\nfunction Requisition(system, options) {\n    options = options || {};\n\n    <initializeEnvironmentAndDocument>\n    this.environment = options.environment || {};\n    this.document = options.document;\n    if (this.document == null) {\n        try {\n            this.document = document;\n        }\n        catch (ex) {\n        }\n    }\n    </initializeEnvironmentAndDocument>\n\n    <createOutputManager>\n    this.commandOutputManager = options.commandOutputManager || new CommandOutputManager();\n    </createOutputManager>\n\n    <initializeSystemAndShell>\n    this.system = system;\n    this.shell = {\n        cwd: '/',\n        env: {}\n    };\n    </initializeSystemAndShell>\n    \n    <initializeCommand>\n    this.commandAssignment = new CommandAssignment(this);\n    </initializeCommand>\n\n    <prepareAssignments>\n    this._assignments = {};\n    this.assignmentCount = 0;\n    this._args = [];\n    this._unassigned = [];\n    this._nextUpdateId = 0;\n    this.prefix = '';\n    </prepareAssignments>\n\n    <setupRequisitionEvent>\n    addMapping(this);\n    this._setBlankAssignment(this.commandAssignment);\n    this.onExternalUpdate = util.createEvent('Requisition.onExternalUpdate');\n    </setupRequisitionEvent>\n}\n"], ["getUriRaw", "\nfunction getUriRaw() {\n    <extractRawUri>\n    const startPos = pos;\n    const type = NodeType.RawType;\n    const token = tokens[startPos];\n    const line = token.ln;\n    const column = token.col;\n    let content = [];\n    let l;\n\n    while (pos < tokens[startPos].uri_raw_end) {\n        if (checkInterpolation(pos) || checkVariable(pos)) break;\n        else if (l = checkUriRawCharacters(pos)) pos += l;\n        else break;\n    }\n\n    content = joinValues(startPos, pos - 1);\n    </extractRawUri>\n    \n    <createUriRawNode>\n    return newNode(type, content, line, column);\n    </createUriRawNode>\n}\n"], "```"]