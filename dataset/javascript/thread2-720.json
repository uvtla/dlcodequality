[["timeSince", "\nfunction timeSince(date) {\n    const seconds = Math.floor((new Date().getTime() / 1000) - (date / 1000));\n    let interval = Math.floor(seconds / 31536000);\n\n    if (interval > 1) {\n        return interval + ' year';\n    }\n\n    interval = Math.floor(seconds / 2592000);\n    if (interval > 1) {\n        return interval + ' month';\n    }\n\n    interval = Math.floor(seconds / 86400);\n    if (interval >= 1) {\n        return interval + ' day';\n    }\n\n    interval = Math.floor(seconds / 3600);\n    if (interval >= 1) {\n        return interval + ' hour';\n    }\n\n    interval = Math.floor(seconds / 60);\n    if (interval > 1) {\n        return interval + ' min';\n    }\n\n    return Math.floor(seconds) + ' sec';\n}\n"], ["cloneSet", "\nfunction cloneSet(source, traversedValues) {\n  let clone = new Set()\n  traversedValues.set(source, clone)\n  \n  cloneStructure(\n    source.values(),\n    entry => undefined,\n    entry => clone.add(entry),\n    traversedValues\n  )\n  \n  return clone\n}\n"], ["match", "\nfunction match(test, options, configSetters) {\n  if (!configSetters && Array.isArray(options)) {\n    configSetters = options\n    options = {}\n  }\n\n  assertConfigSetters(configSetters)\n\n  if (options.test) {\n    throw new Error(\n      `match(): Setting 'test' in options is not supported; use the argument instead.`\n    )\n  }\n\n  const { inclusions, exclusions } = splitPatterns(toArray(test))\n  <defineMatchers>\n  const match = Object.assign({}, options, {\n    \n    test: stripArrayConditionally(normalizeMatchers(inclusions))\n  })\n\n  if (exclusions.length > 0) {\n    match.exclude = _.concat(\n      match.exclude ? toArray(match.exclude) : [],\n      normalizeMatchers(exclusions)\n    )\n  }\n  </defineMatchers>\n\n  <groupBlockDefinition>\n  const groupBlock = context => config =>\n    invokeConfigSetters(configSetters, deriveContextWithMatch(context, match), config)\n  </groupBlockDefinition>\n\n  <returnBlock>\n  return Object.assign(groupBlock, {\n    pre: context => invokePreHooks(configSetters, deriveContextWithMatch(context, match)),\n    post: context => config =>\n      invokePostHooks(configSetters, deriveContextWithMatch(context, match), config)\n  })\n  </returnBlock>\n}\n"], ["checkDocumentState", "\nfunction (tags) {\n    if (tags) {\n        for (var i = 0, ci; ci = tags[i++];) {\n            if (this.document.getElementsByTagName(ci).length > 0) {\n                return true;\n            }\n        }\n    }\n    if (!domUtils.isEmptyBlock(this.body)) {\n        return true\n    }\n    \n    tags = ['div'];\n    for (i = 0; ci = tags[i++];) {\n        var nodes = domUtils.getElementsByTagName(this.document, ci);\n        for (var n = 0, cn; cn = nodes[n++];) {\n            if (domUtils.isCustomeNode(cn)) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n"], ["namespace", "\nfunction namespace(ns) {\n  var names = ns.split('.');\n  var owner = window;\n  for (var i = 0; i < names.length; i++) {\n    var name = names[i];\n    owner[name] = owner[name] || {};\n    owner = owner[name];\n  }\n  return owner;\n}\n"], ["isRelevantRelation", "\nfunction( relation ) {\n    if ( relation.instance instanceof this.relatedModel && this.reverseRelation.key === relation.key\n            &&\tthis.key === relation.reverseRelation.key ) {\n        return true;\n    }\n    return false;\n}\n"], ["deleteLocationWithIdentifier", "\nfunction (identifier)  {\n    var path;\n    <validateIdentifier>\n    if (identifier) {\n      path = this.constructPath(constants.LOCATIONS, identifier);\n      return this.Core.DELETE(path);\n    } else {\n      return this.rejectRequest('Bad Request: A location identifier is required.');\n    }\n    </validateIdentifier>\n}\n"], ["validateRequestParams", "\nfunction validateRequestParams(req, resource, method, adapter) {\n        req = req || {};\n\n        <initializeParams>\n        var params = resource.params || {};\n        var methodParams = _.extend({}, params[method], params[adapter + '.' + method] );\n        var requiredParams = methodParams.required || [];\n        var eitherorParams = methodParams.eitheror || [];\n        var optional = methodParams.optional || [];\n        var eitherorExists, param;\n        <initializeParams>\n\n        <verifyRequiredParams>\n        for (var i = 0; i < requiredParams.length; i++) {\n            param = requiredParams[i];\n\n            if (req[param] === undefined || req[param] === null) {\n                reqObj = _.extend({}, req);\n                delete reqObj.resource;\n                err = new Error('Invalid request');\n                err.code = 'invalid_request_error';\n                err.message = resource.name + ' ' + method + ' missing ' + param +\n                    '. Required params: ' + JSON.stringify(requiredParams) +\n                    ' req is: ' + JSON.stringify(reqObj);\n                return Q.reject(err);\n            }\n        }\n        </verifyRequiredParams>\n\n        <validateEitherOrParams>\n        if (eitherorParams.length) {\n            eitherorExists = false;\n\n            _.each(eitherorParams, function (eitherorParam) {\n                if (req[eitherorParam]) { eitherorExists = true; }\n            });\n\n            if (!eitherorExists) {\n                delete req.caller;\n                delete req.resource;\n                err = new Error('Invalid request');\n                err.code = 'invalid_request_error';\n                err.message = resource.name + ' ' + method +\n                    ' must have one of the following params: ' + JSON.stringify(eitherorParams) +\n                    ' request is ' + JSON.stringify(req);\n                return Q.reject(err);\n            }\n        }\n        </validateEitherOrParams>\n\n        <checkInvalidParams>\n        var validParams = requiredParams.concat(eitherorParams, optional,\n            ['lang', 'caller', 'resource', 'method', 'auth', 'noemit']);\n        for (var key in req) {\n            if (req.hasOwnProperty(key)) {\n                if (validParams.indexOf(key) < 0) {\n                    delete req.caller;\n                    delete req.resource;\n                    err = new Error('Invalid request');\n                    err.code = 'invalid_request_error';\n                    err.message = 'For ' + resource.name + ' ' + method + ' the key ' +\n                        key + ' is not allowed. Valid params: ' + JSON.stringify(validParams) +\n                        ' request is ' + JSON.stringify(req);\n                    return Q.reject(err);\n                }\n            }\n        }\n        </checkInvalidParams>\n\n        <returnPromise>\n        return new Q();\n        </returnPromise>\n}\n"], ["GpIAMConstructor", "\nfunction GpIAM(credentials) {\n  this.credentials = credentials;\n  <validateCredentials>\n  if(!this.credentials || !this.credentials.apikey || !this.credentials.iam_endpoint) {\n    throw new Error('GpIAM: params need to be \"apikey, iam_endpoint\"');\n  }\n  </validateCredentials>\n  this.tokenUrl = new URL('/identity/token', this.credentials.iam_endpoint);\n\n  <apiKeyHandling>\n  if(!this.GP_USE_APIKEY) {\n    const now = new Date();\n    this.ourCacheKey = `${this.credentials.iam_endpoint}#${this.credentials.apikey}`;\n\n    this.updateToken = (async function updateToken(x) {\n      const apikey = this.credentials.apikey;\n      const cacheEntry = GpIAM.prototype.tokenCache[this.ourCacheKey] =\n       GpIAM.prototype.tokenCache[this.ourCacheKey] || {};\n      \n      <tokenCacheValidation>\n      if (!cacheEntry.validUntil ||        \n          (now > cacheEntry.validUntil)) { \n\n        delete this.access_token; \n        const tokenResponse = await fetchToken(this.tokenUrl, Buffer.from(querystring.stringify({\n          grant_type,\n          apikey\n        })));\n        \n        cacheEntry.tokenResponse = tokenResponse;\n        \n        const { expires_in } = tokenResponse;\n\n        cacheEntry.validUntil = new Date(now.getTime() + (1000 * expires_in * tokenExpiryThreshold));\n        if(this.VERBOSE) {\n          console.log('Fetched access token ');\n        }\n      }\n      </tokenCacheValidation>\n      <logTokenValidity>\n      if(this.VERBOSE) {\n        console.log(`Token valid until ${cacheEntry.validUntil}`);\n      }\n      </logTokenValidity>\n\n      <setAccessToken>\n      this.access_token = cacheEntry.tokenResponse.access_token;\n      </setAccessToken>\n\n      return x;\n    }).bind(this);\n  }\n  </apiKeyHandling>\n}\n"], ["padString", "\nfunction (string, size, character, begin) {\n    string = \"\" + string;\n    var length = string.length;\n    <padCalculation>\n    if (length < size) {\n        var padding = [];\n        for (var difference = size - length; difference > 0; difference -= 1) {\n            padding.push(character);\n        }\n    </padCalculation>\n\n    <applyPadding>\n    if (begin === true) {\n        string = padding.join(\"\") + string;\n    } else {\n        string = string + padding.join(\"\");\n    }\n    </applyPadding>\n    return string;\n}\n"], "```"]