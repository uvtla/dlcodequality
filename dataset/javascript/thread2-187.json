[["activateNav", "\nfunction activateNav(pos){\n  var offset = 100,\n  current, next, parent, isSub, hasSub;\n  win.unbind('hashchange', hashchange);\n  for(var i=sectionscount;i>0;i--){\n    if(sections[i-1].pos <= pos+offset){\n      navanchors.removeClass('current');\n      current = navanchors.eq(i-1);\n      current.addClass('current');\n\n      parent = current.parent().parent();\n      next = current.next();\n\n      hasSub = next.is('ul');\n      isSub = !parent.is('#documenter_nav');\n\n      nav.find('ol:visible').not(parent).slideUp('fast');\n      if(isSub){\n        parent.prev().addClass('current');\n        parent.stop().slideDown('fast');\n      }else if(hasSub){\n        next.stop().slideDown('fast');\n      }\n      win.bind('hashchange', hashchange);\n      break;\n    };\n  } \n}\n"], ["modifyTextBuffer", "\nfunction(text, start, end) {\n  if (text === undefined) { text = \"\"; }\n  if (start === undefined) { start = 0; }\n  if (end === undefined) { end = this.getCharCount(); }\n  if (start === end && text === \"\") { return; }\n  var startLine = this.getLineAtOffset(start);\n  var endLine = this.getLineAtOffset(end);\n  var eventStart = start;\n  var removedCharCount = end - start;\n  var removedLineCount = endLine - startLine;\n  var addedCharCount = text.length;\n  var addedLineCount = 0;\n  var lineCount = this.getLineCount();\n  \n  var cr = 0, lf = 0, index = 0;\n  var newLineOffsets = [];\n  while (true) {\n    if (cr !== -1 && cr <= index) { cr = text.indexOf(\"\\r\", index); } \n    if (lf !== -1 && lf <= index) { lf = text.indexOf(\"\\n\", index); } \n    if (lf === -1 && cr === -1) { break; }\n    if (cr !== -1 && lf !== -1) {\n      if (cr + 1 === lf) {\n        index = lf + 1;\n      } else {\n        index = (cr < lf ? cr : lf) + 1;\n      }\n    } else if (cr !== -1) {\n      index = cr + 1;\n    } else {\n      index = lf + 1;\n    }\n    newLineOffsets.push(start + index);\n    addedLineCount++;\n  }\n\n  var modelChangingEvent = {\n    type: \"Changing\", \n    text: text,\n    start: eventStart,\n    removedCharCount: removedCharCount,\n    addedCharCount: addedCharCount,\n    removedLineCount: removedLineCount,\n    addedLineCount: addedLineCount\n  };\n  this.onChanging(modelChangingEvent);\n  \n  var changedText = text;\n  \n  var SPLICE_LIMIT = 50000;\n  var limit = SPLICE_LIMIT, args;\n  if (newLineOffsets.length < limit) {\n    args = [startLine + 1, removedLineCount].concat(newLineOffsets);\n    Array.prototype.splice.apply(this._lineOffsets, args);\n  } else {\n    index = startLine + 1;\n    this._lineOffsets.splice(index, removedLineCount);\n    for (var k = 0; k < newLineOffsets.length; k += limit) {\n      args = [index, 0].concat(newLineOffsets.slice(k, Math.min(newLineOffsets.length, k + limit)));\n      Array.prototype.splice.apply(this._lineOffsets, args);\n      index += limit;\n    }\n  }\n\n  var offset = 0, chunk = 0, length;\n  while (chunk<this._text.length) {\n    length = this._text[chunk].length; \n    if (start <= offset + length) { break; }\n    offset += length;\n    chunk++;\n  }\n  var firstOffset = offset;\n  var firstChunk = chunk;\n  while (chunk<this._text.length) {\n    length = this._text[chunk].length; \n    if (end <= offset + length) { break; }\n    offset += length;\n    chunk++;\n  }\n  var lastOffset = offset;\n  var lastChunk = chunk;\n  var firstText = this._text[firstChunk];\n  var lastText = this._text[lastChunk];\n  var beforeText = firstText.substring(0, start - firstOffset);\n  var afterText = lastText.substring(end - lastOffset);\n  var params = [firstChunk, lastChunk - firstChunk + 1];\n  if (beforeText) { params.push(beforeText); }\n  if (text) { params.push(text); }\n  if (afterText) { params.push(afterText); }\n  Array.prototype.splice.apply(this._text, params);\n  if (this._text.length === 0) { this._text = [\"\"]; }\n  \n  var modelChangedEvent = {\n    type: \"Changed\", \n    start: eventStart,\n    text: changedText,\n    removedCharCount: removedCharCount,\n    addedCharCount: addedCharCount,\n    removedLineCount: removedLineCount,\n    addedLineCount: addedLineCount\n  };\n  this.onChanged(modelChangedEvent);\n}\n"], ["removeSeriesPoint", "\nfunction (redraw, animation) {\n  var point = this,\n    series = point.series,\n    chart = series.chart,\n    data = series.data;\n\n  setAnimation(animation, chart);\n  redraw = pick(redraw, true);\n\n  \n  point.firePointEvent('remove', null, function () {\n\n    erase(data, point);\n\n    point.destroy();\n\n    \n    series.isDirty = true;\n    if (redraw) {\n      chart.redraw();\n    }\n  });\n}\n"], ["collapseFormattedProperties", "\nfunction collapseFormattedProperties (stateObject, formatManifests) {\n  Tweenable.each(formatManifests, function (prop) {\n    var currentProp = stateObject[prop];\n    var formatChunks = extractPropertyChunks(\n      stateObject, formatManifests[prop].chunkNames);\n    var valuesList = getValuesList(\n      formatChunks, formatManifests[prop].chunkNames);\n    currentProp = getFormattedValues(\n      formatManifests[prop].formatString, valuesList);\n    stateObject[prop] = sanitizeRGBChunks(currentProp);\n  });\n}\n"], ["filterTransform", "\nfunction filterTransform (args, math, scope) {\n  let x, callback\n\n  if (args[0]) {\n    x = args[0].compile().evaluate(scope)\n  }\n\n  if (args[1]) {\n    if (isSymbolNode(args[1]) || isFunctionAssignmentNode(args[1])) {\n      \n      callback = args[1].compile().evaluate(scope)\n    } else {\n      \n      callback = compileInlineExpression(args[1], math, scope)\n    }\n  }\n\n  return filter(x, callback)\n}\n"], ["loadFontNative", "\nfunction loadFontNative (fontFace, callback) {\n  var theFontFace;\n  \n  if (_loadedFonts[fontFace.id]) {\n    return callback(null);\n  }\n  \n  if (_failedFonts[fontFace.id]) {\n    return callback(_failedFonts[fontFace.id]);\n  }\n  \n  if (!fontFace.url) {\n    return callback(null);\n  }\n  \n  if (_pendingFonts[fontFace.id]) {\n    _pendingFonts[fontFace.id].callbacks.push(callback);\n    return;\n  }\n  _pendingFonts[fontFace.id] = {\n    startTime: Date.now(),\n    callbacks: [callback]\n  };\n  \n  theFontFace = new window.FontFace(fontFace.family,\n    'url(' + fontFace.url + ')', fontFace.attributes);\n\n  theFontFace.load().then(function () {\n    _loadedFonts[fontFace.id] = true;\n    callback(null);\n  }, function (err) {\n    _failedFonts[fontFace.id] = err;\n    callback(err);\n  });\n}\n"], ["viewManagerInstantiateView", "\nfunction(className, viewArgs) {\n  var self = this,\n      view = this.views[className],\n      dfd = $.Deferred();\n\n  if (view) {\n    view.undelegateEvents();\n  }\n\n  this.loader.load(className)\n      .then(function(Constructor) {\n        viewArgs.manager = self;\n        view = new Constructor(viewArgs);\n        self.views[className] = view;\n        dfd.resolve(view);\n      });\n\n  return dfd.promise();\n}\n"], ["composeMatchers", "\nfunction compose(patterns, options, matcher) {\n  let matchers;\n\n  return memoize('compose', String(patterns), options, function() {\n    return function(file) {\n      \n      if (!matchers) {\n        matchers = [];\n        for (var i = 0; i < patterns.length; i++) {\n          matchers.push(matcher(patterns[i], options));\n        }\n      }\n\n      let len = matchers.length;\n      while (len--) {\n        if (matchers[len](file) === true) {\n          return true;\n        }\n      }\n      return false;\n    };\n  });\n}\n"], ["configSet", "\nfunction set( keypath, value, options ) {\n  \n  var opts = {};\n  if ( arguments.length > 2 ) {\n    if ( !isObject( options ) ) {\n      throw new TypeError( 'invalid input argument. Options argument must be an object. Value: `' + options + '`.' );\n    }\n    if ( options.hasOwnProperty( 'sep' ) ) {\n      opts.sep = options.sep;\n    }\n    if ( options.hasOwnProperty( 'create' ) ) {\n      opts.create = options.create;\n    }\n  }\n  if ( opts.sep === void 0 ) {\n    opts.sep = this._opts.sep;\n  }\n  if ( opts.create === void 0 ) {\n    opts.create = this._opts.create;\n  }\n  return deepSet( this._db, keypath, value, opts );\n}\n"], ["recurseBookmarks", "\nfunction recurse_bookmarks(data, tree, path) {\n  if(tree.url) data.push({Name: tree.title, Location: tree.url, Path:path});\n  var T = path ? (path + \"::\" + tree.title) : tree.title;\n  (tree.children||[]).forEach(function(C) { recurse_bookmarks(data, C, T); });\n}\n"], "```\nAll of the functions above comply with the SRP, handling a single responsibility each. No further segmentation with nested tags is necessary."]