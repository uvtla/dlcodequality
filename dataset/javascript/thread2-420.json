[["function", "\nfunction (runtime, modNames, refModName) {\n    <normalizeModuleNames>\n    return Utils.unalias(runtime, Utils.normalizeModNamesWithAlias(runtime, modNames, refModName));\n    </normalizeModuleNames>\n}\n"], ["check", "\nfunction check(node) {\n    <analyzeNode>\n    if (\n        node.arguments.length !== 1 &&\n        node.callee.type === \"Identifier\" &&\n        node.callee.name === \"Array\" &&\n        !node.typeParameters\n    ) {\n        <reportProblem>\n        context.report({\n            node,\n            message: \"The array literal notation [] is preferable.\",\n            fix(fixer) {\n                <fixSyntax>\n                if (node.arguments.length === 0) {\n                    return fixer.replaceText(node, \"[]\");\n                }\n                const fullText = context.getSourceCode().getText(node);\n                const preambleLength = node.callee.range[1] - node.range[0];\n                return fixer.replaceText(node, `[${fullText.slice(preambleLength + 1, -1)}]`);\n                </fixSyntax>\n            },\n        });\n        </reportProblem>\n    }\n    </analyzeNode>\n}\n"], ["getMonthDays", "\nfunction getMonthDays(year, month) {\n    <calculateDays>\n    let NUM = 30;\n    if ([1, 3, 5, 7, 8, 10, 12].indexOf(month) !== -1) {\n        NUM = 31;\n    }\n    if (month === 2) {\n        NUM = isLeapYear(year) ? 29 : 28;\n    }\n    </calculateDays>\n    return NUM;\n}\n"], ["function", "\nfunction (options, callback) {\n    <setupVariables>\n    var self = this;\n    var events = options.events || ['all'];\n    var year = options.date.getFullYear();\n    var month = options.date.getMonth() + 1;\n    var day = options.date.getDate();\n    var direction = /^dep/i.test(options.direction) ? 'departing' : 'arriving';\n\n    var path = '/alerts/rest/v1/json/create/' +\n      options.airlineCode + '/' + options.flightNumber +\n      '/from/' + options.departureAirport +\n      '/to/' + options.arrivalAirport +\n      '/' + direction + '/' + year + '/' + month + '/' + day;\n\n    var extensions = ['includeNewFields', 'useInlinedReferences'];\n    if (Array.isArray(options.extendedOptions)) {\n        extensions = extensions.concat(options.extendedOptions);\n    }\n\n    var query = {\n        name: options.name,\n        desc: options.desc,\n        codeType: options.codeType,\n        events: events.join(),\n        deliverTo: options.deliverTo,\n        type: options.type || 'JSON',\n    };\n    </setupVariables>\n\n    <processAdditionalData>\n    if (options.data != null) {\n        Object.keys(options.data).forEach(function (k) {\n            query['_' + k] = options.data[k];\n        });\n    }\n    </processAdditionalData>\n\n    <makeApiCall>\n    return this.client._clientRequest({\n        url: path,\n        extendedOptions: extensions,\n        qs: query,\n    }, function (error, data) {\n        callback.call(self.client, error, data);\n    });\n    </makeApiCall>\n}\n"], ["function", "\nfunction (coordsArr) {\n    <checkDisabledState>\n    if (this.disabled) {\n        return;\n    }\n    </checkDisabledState>\n\n    <calculateHandlePosition>\n    var $td, tdOffset, containerOffset, top, left, height, width;\n    var corners = this.instance.getCornerCoords(coordsArr);\n    $td = $(this.instance.getCell(corners.BR.row, corners.BR.col));\n    tdOffset = $td.offset();\n    containerOffset = this.$container.offset();\n    top = tdOffset.top - containerOffset.top + this.$container.scrollTop() - 1;\n    left = tdOffset.left - containerOffset.left + this.$container.scrollLeft() - 1;\n    height = $td.outerHeight();\n    width = $td.outerWidth();\n    </calculateHandlePosition>\n\n    <updateHandleStyle>\n    this.handle.style.top = top + height - 3 + 'px';\n    this.handle.style.left = left + width - 3 + 'px';\n    this.handle.style.display = 'block';\n    </updateHandleStyle>\n}\n"], ["strToNumber", "\nfunction strToNumber(value) {\n    <convertStringToNumber>\n    if (typeof value === 'string' && !isNaN(Number(value) - parseFloat(value))) {\n        return Number(value);\n    }\n    </convertStringToNumber>\n    \n    <validateNumberType>\n    if (typeof value !== 'number') {\n        throw new Error(value + \" is not a number\");\n    }\n    </validateNumberType>\n    \n    return value;\n}\n"], ["luPack", "\nfunction luPack() {\n    <performLuDecomposition>\n    var lu = lapack$1.lu(this.elements);\n    </performLuDecomposition>\n    \n    <packageResults>\n    return {\n        L: $M(lu.L),\n        U: $M(lu.U),\n        P: $M(lu.P)\n    };\n    </packageResults>\n}\n"], ["camelToKebab", "\nfunction camelToKebab(str) {\n    <convertCase>\n    return str.replace(/([a-zA-Z])([A-Z][a-z])/g, (match, before, after) =>\n        `${before.toLowerCase()}-${after.toLowerCase()}`\n    ).toLowerCase();\n    </convertCase>\n}\n"], ["isStage1ClassDescriptor", "\nfunction isStage1ClassDescriptor(possibleDesc) {\n    <analyzeDescriptor>\n    let [target] = possibleDesc;\n    return (\n        possibleDesc.length === 1 &&\n        typeof target === 'function' &&\n        'prototype' in target &&\n        !target.__isComputedDecorator\n    );\n    </analyzeDescriptor>\n}\n"], ["function", "\nfunction (name) {\n    <constructIdentifier>\n    if (isString(name)) {\n        var parts = this._splitString(name),\n            schema = parts[0], table = parts[1], alias = parts[2],\n            identifier;\n        if (schema && table && alias) {\n            identifier = new AliasedExpression(new QualifiedIdentifier(schema, table), alias);\n        } else if (schema && table) {\n            identifier = new QualifiedIdentifier(schema, table);\n        } else if (table && alias) {\n            identifier = new AliasedExpression(new Identifier(table), alias);\n        } else {\n            identifier = new Identifier(table);\n        }\n        return identifier;\n    } else {\n        return name;\n    }\n    </constructIdentifier>\n}\n"], ""]