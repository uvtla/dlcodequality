[["success", "\nfunction success(result, ignore) {\n    return ((typeof result.error === 'undefined' &&\n        typeof result.status === 'undefined' &&\n        typeof result.success === 'undefined') ||\n        (result.status && result.status === 'success') ||\n        (result.success && result.success === true) ||\n        (ignore && result.error && !ignore.test(result.error))) ? true : false;\n}\n"], ["convertBreakpointsToEm", "\nfunction convertBreakpointsToEm(breakpointsInPx) {\n    var breakpointsInEm = {};\n    var breakpointNames = Object.keys(breakpointsInPx);\n    <convertEachBreakpoint>\n    breakpointNames.forEach(function (breakpointName) {\n        breakpointsInEm[breakpointName] = px2em(breakpointsInPx[breakpointName]);\n    });\n    </convertEachBreakpoint>\n    return breakpointsInEm;\n}\n"], ["processString", "\nfunction( str, rules, skip, override ){\n      if( override ){\n        str = override;\n      }else{\n        <determineIgnorance>\n        var ignore = ( this.indexOf( skip, str.toLowerCase()) > -1 );\n        </determineIgnorance>\n\n        if( !ignore ){\n          <applyRules>\n          var i = 0;\n          var j = rules.length;\n\n          for( ; i < j; i++ ){\n            if( str.match( rules[ i ][ 0 ])){\n              if( rules[ i ][ 1 ] !== undefined ){\n                str = str.replace( rules[ i ][ 0 ], rules[ i ][ 1 ]);\n              }\n              break;\n            }\n          }\n          </applyRules>\n        }\n      }\n\n      return str;\n}\n"], ["DOMWalker_prepareTargetWindows", "\nfunction DOMWalker_prepareTargetWindows(ids) {\n    var doc = this._controller.window.document;\n\n    <processEachId>\n    for (var i = 0; i < ids.length; i++) {\n        <getNode>\n        var node = this._getNode(ids[i]);\n        </getNode>\n\n        if (node) {\n            var idSet = ids[i];\n\n            <processNodeBasedOnTarget>\n            switch (idSet.target) {\n              case DOMWalker.WINDOW_CURRENT:\n                this._processNode(node, idSet);\n                break;\n              case DOMWalker.WINDOW_MODAL:\n                <prepareModalInfo>\n                var modalInfos = {ids : idSet.subContent,\n                                  callbackFilter :  this._callbackFilter,\n                                  callbackNodeTest : this._callbackNodeTest,\n                                  callbackResults : this._callbackResults,\n                                  waitFunction : idSet.waitFunction}\n                persisted.modalInfos = modalInfos;\n                </prepareModalInfo>\n\n                <startAndWaitForModal>\n                var md = new modalDialog.modalDialog(this._controller.window);\n                md.start(this._modalWindowHelper);\n                this._processNode(node, idSet);\n                md.waitForDialog();\n                </startAndWaitForModal>\n                break;\n              case DOMWalker.WINDOW_NEW:\n                this._processNode(node, idSet);\n                <handleNewWindow>\n                var controller = utils.handleWindow('title', idSet.title,\n                                               false, true);\n                </handleNewWindow>\n\n                <initiateDOMWalker>\n                let domWalker = new DOMWalker(controller, this._callbackFilter,\n                                              this._callbackNodeTest,\n                                              this._callbackResults);\n                </initiateDOMWalker>\n                <walkAndClose>\n                domWalker.walk(idSet.subContent,\n                               controller.window.document.documentElement,\n                               idSet.waitFunction);\n                controller.window.close();\n                </walkAndClose>\n                break;\n              default:\n                <throwError>\n                throw new Error(\"Node does not exist: \" + ids[i][ids[i].getBy]);\n                </throwError>\n            }\n            </processNodeBasedOnTarget>\n        }\n    }\n    </processEachId>\n}\n"], ["constructOptionValuesString", "\nfunction(option, values) {\n    var opts = [];\n\n    <assembleOptionString>\n    if (!_.isEmpty(values)) {\n        _.forEach(values, function(value) {\n            opts.push(option);\n            opts.push(value);\n        });\n    }\n    </assembleOptionString>\n\n    return opts.join(';');\n}\n"], ["SubClassConstructor", "\nfunction Sub(rawSentences, options) {\n    var self = this;\n    <setDefaultOptions>\n    var opts = options || {};\n    self.settings = {\n      containerId: opts.containerId || \"sub\",\n      namespace: opts.namespace || \"sub\",\n      interval: opts.interval || 5000,\n      speed: opts.speed || 200,\n      mobileWidth: opts.mobileWidth || null,\n      verbose: (opts.verbose !== undefined) ? opts.verbose : false,\n      random: (opts.random !== undefined) ? opts.random : false,\n      best: (opts.best !== undefined) ? opts.best : true,\n      clearOriginalContent: (opts.clearOriginalContent !== undefined) ? opts.clearOriginalContent : true,\n      _testing: (opts._testing !== undefined) ? opts._testing : false,\n    };\n    </setDefaultOptions>\n    <initializeWrapper>\n    self.wrapper = document.getElementById(self.settings.containerId);\n    var wrapperStyle = window.getComputedStyle(self.wrapper);\n    </initializeWrapper>\n\n    <injectStyle>\n    _injectStyle(\n      self.settings.namespace,\n      self.settings.speed / 1000,\n      wrapperStyle.height,\n      wrapperStyle.fontFamily);\n    </injectStyle>\n\n    <setUpSub>\n    self.highestTimeoutId = 0;\n    self.currentState = null;\n    self.actions = [];\n    self.invisibleClass = \" .\" + self.settings.namespace + \"-invisible\";\n    self.visibleClass = \" .\" + self.settings.namespace + \"-visible\";\n    self.fromClass = self.settings.namespace + \"-from-idx-\";\n    self.toClass = self.settings.namespace + \"-to-idx-\";\n    self.wrapperSelector = \"#\" + self.settings.namespace;\n    self.isEmpty = true;\n\n    self._setupContainer();\n    if (!self.settings._testing) {\n      self._setSentences(self._parseSentences(rawSentences));\n    }\n    </setUpSub>\n    return self;\n}\n"], ["getVerbHelp", "\nfunction getVerbHelp(verb, output) {\n    let targets = [];\n    <initializeOptions>\n    let options = {\n        head: `Available resources for ${chalk.bold(verb)}:`,\n        table: []\n    };\n    </initializeOptions>\n\n    let sections = [];\n\n    <defineQuerySection>\n    switch (verb) {\n    case \"query\":\n        <writeQueryHelp>\n        output.write(chalk.cyan.bold(\"luis query --query <querytext> [--appId | --endpoint | --nologging | --region | --spellCheck | --staging | --subscriptionKey | --timezoneOffset | --timing |  --verbose]\\n\\n\"))\n        </writeQueryHelp>\n        <pushQueryOptions>\n        options.table.push([chalk.cyan.bold(\"--query <query>\"), \"Query to analyze with LUIS prediction.\"]);\n        // ... more options pushed here for clarity's sake\n        </pushQueryOptions>\n        sections.push(options);\n        sections.push(configSection);\n        sections.push(globalArgs);\n        return sections;\n\n    case \"set\":\n        <writeSetHelp>\n        output.write(chalk.cyan.bold(\"luis set <appIdOrName> [--appId|--versionId|--authoringKey|--endpoint] <value>\\n\\n\"))\n        </writeSetHelp>\n        <pushSetOptions>\n        options.table.push([chalk.cyan.bold(\"<appIdOrName>\"), \"change the active application by looking it up by name or id\"]);\n        // ... more options pushed here for clarity's sake\n        </pushSetOptions>\n        sections.push(options);\n        sections.push(configSection);\n        sections.push(globalArgs);\n        return sections;\n    }\n    </defineQuerySection>\n\n    <prepareTargetsFromOperations>\n    for (let iOperation in operations) {\n        let operation = operations[iOperation];\n        if (operation.methodAlias == verb) {\n            let target = operation.target[0];\n            if (targets.indexOf(target) < 0) {\n                targets.push(target);\n            }\n        }\n    }\n    </prepareTargetsFromOperations>\n\n    <otherVerbsProcessing>\n    if (targets.length == 0)\n        return getGeneralHelpContents(output);\n\n    targets.sort();\n    for (let target of targets) {\n        options.table.push([chalk.cyan.bold(target), '']);\n    }\n    </otherVerbsProcessing>\n    sections.push(options);\n    sections.push(configSection);\n    sections.push(globalArgs);\n    return sections;\n}\n"], ["attachChangeEventToSelection", "\nfunction(hook, context){\n  var hs = $('#heading-selection');\n  <onChangeEvent>\n  hs.on('change', function(){\n    var value = $(this).val();\n    var intValue = parseInt(value,10);\n    if(!_.isNaN(intValue)){\n      <doInsertHeading>\n      context.ace.callWithAce(function(ace){\n        ace.ace_doInsertHeading(intValue);\n      },'insertheading' , true);\n      </doInsertHeading>\n      hs.val(\"dummy\");\n    }\n  })\n  </onChangeEvent>\n}\n"], ["getRefreshedSection", "\nfunction (args) {\n    <validateArgs>\n    var validatorParam = {\n        json : args,\n        beanName : \"aria.templates.CfgBeans.GetRefreshedSectionCfg\"\n    };\n    ariaCoreJsonValidator.normalize(validatorParam);\n    args = validatorParam.json;\n    </validateArgs>\n\n    var sectionId = args.section;\n\n    var sectionToReplace = null;\n    if (sectionId != null) {\n        <locateSectionById>\n        sectionToReplace = (this._mainSection ? this._mainSection.getSectionById(sectionId) : null);\n        if (sectionToReplace == null) {\n            <logSectionNotFoundError>\n            this.$logError(this.SECTION_OUTPUT_NOT_FOUND, [this.tplClasspath, sectionId]);\n            </logSectionNotFoundError>\n            return null;\n        }\n        </locateSectionById>\n\n        <prepareSectionForRefresh>\n        sectionToReplace.beforeRefresh(args);\n        </prepareSectionForRefresh>\n        <stopListeners>\n        sectionToReplace.stopListeners();\n        </stopListeners>\n    }\n    var writerCallback = args.writerCallback;\n    <setWriterCallback>\n    if (writerCallback == null) {\n        writerCallback = {\n            fn : this._callMacro,\n            args : args.macro,\n            scope : this\n        };\n    }\n    </setWriterCallback>\n    <createSection>\n    var section = this.createSection(writerCallback, {\n        ownIdMap : (sectionToReplace == null)\n    });\n    if (section == null) {\n        <returnNullForFailedSectionCreation>\n        return null;\n        </returnNullForFailedSectionCreation>\n    }\n    </createSection>\n    if (sectionToReplace == null) {\n        <handleMainSection>\n        if (this._mainSection) {\n            this._mainSection.$dispose();\n        }\n        this._mainSection = section;\n        </handleMainSection>\n    } else {\n        <replaceSectionContent>\n        sectionToReplace.removeContent();\n        sectionToReplace.removeDelegateIdsAndCallbacks();\n        sectionToReplace.disposeProcessingIndicator();\n        section.moveContentTo(sectionToReplace);\n        sectionToReplace.html = section.html;\n        section.$dispose();\n        section = sectionToReplace;\n        section.resumeListeners();\n        </replaceSectionContent>\n    }\n    return section;\n}\n"], ["_onClick", "\nfunction _onClick(d) {\n  <scheduleClick>\n  if(!_scheduledClickId) {\n    _scheduledClickId = setTimeout(_scheduledClick.bind(this, d, d3.event.target), 200);\n  }\n  </scheduleClick>\n}\n"], "```"]