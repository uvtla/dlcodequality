[["toc", "\nfunction toc(node, options) {\n    <setupOptionsAndVariables>\n    var settings = options || {};\n    var heading = settings.heading ? toExpression(settings.heading) : null;\n    var result = search(node, heading, settings.maxDepth || 6);\n    var map = result.map;\n    </setupOptionsAndVariables>\n\n    <generateTableOfContents>\n    result.map = map.length === 0 ? null : contents(map, settings.tight);\n    \n    if (!heading) {\n        result.index = null;\n        result.endIndex = null;\n    }\n    </generateTableOfContents>\n\n    return result;\n}\n"], ["process", "\nfunction process(configure, ret) {\n  <concatenateAndSplitBuffer>\n  ret = configure.buffer + ret;\n  var pos = ret.lastIndexOf('\\n');\n  configure.buffer = ret.slice(pos + 1);\n  ret = ret.slice(0, pos);\n  ret = ret.split(/\\n+/);\n  ret = ret.map(item => item && mapper(item.split(configure.separator), configure.map));\n  </concatenateAndSplitBuffer>\n\n  if(!ret.length) return;\n  <incrementCount>\n  configure.count += ret.length;\n  </incrementCount>\n\n  <initializeDestinationFile>\n  if(configure.first && typeof configure.dist === 'string' ) {\n    configure.first = 0;\n    fs.writeFileSync(configure.dist, '[');\n  }\n  </initializeDestinationFile>\n\n  <storeOrFlushCache>\n  if(configure.cacheArray.length > STOP) {\n    typeof configure.dist === 'string' ? append(configure) : configure.dist(configure.cacheArray.slice());\n    return configure.cacheArray.length = 0;\n  }\n  </storeOrFlushCache>\n\n  <cacheResults>\n  configure.cacheArray.push.apply(configure.cacheArray, ret);\n  </cacheResults>\n}\n"], ["createPart", "\nfunction createPart(name, content, options) {\n    <validateArguments>\n    if (!name || !options) { throw new Error('name and options are required.'); }\n    </validateArguments>\n\n    <assemblePartContent>\n    var digest = calculateMD5(content, options);\n    newContent     = autoStartLine(name);\n    newContent    += template.warning();\n    newContent    += content || '';\n    newContent    += template.md5({md5: digest});\n    newContent    += autoEndLine(name);\n    </assemblePartContent>\n\n    return newContent;\n}\n"], ["anonymousFunction", "\nfunction (data, options) {\n      <handleSuccessCallback>\n      var rdf = this,\n        options = options || {},\n        success = options.success;\n      if (success !== undefined) {\n        options.success = function () {\n          success.call(rdf);\n        }\n      }\n      </handleSuccessCallback>\n      <loadDataIntoDatabank>\n      this.databank.load(data, options);\n      </loadDataIntoDatabank>\n      return this;\n}\n"], ["ngramAnalysis", "\nfunction(sequence, n, startSymbol, endSymbol, stats) {\n    var result = [];\n    frequencies = {};\n    nrOfNgrams = 0;\n    \n    <convertSequenceToArray>\n    if (!_(sequence).isArray()) {\n        sequence = tokenizer.tokenize(sequence);\n    }\n    </convertSequenceToArray>\n\n    var count = _.max([0, sequence.length - n + 1]);\n\n    <handleStartSymbol>\n    if(typeof startSymbol !== \"undefined\" && startSymbol !== null) {\n        \n        var blanks = [];\n        for(var i = 0 ; i < n ; i++) {\n            blanks.push(startSymbol);\n        }\n\n        \n        for(var p = n - 1 ; p > 0 ; p--) {\n            \n          var ngram = blanks.slice(0, p).concat(sequence.slice(0, n - p));\n          result.push(ngram);\n          if (stats) {\n            countNgrams(ngram);\n          }\n        }\n    }\n    </handleStartSymbol>\n\n    <generateNgrams>\n    for (var i = 0; i < count; i++) {\n        var ngram = sequence.slice(i, i + n);\n        result.push(ngram);\n        if (stats) { \n          countNgrams(ngram);\n        }\n    }\n    </generateNgrams>\n\n    <handleEndSymbol>\n    if(typeof endSymbol !== \"undefined\" && endSymbol !== null) {\n        \n        var blanks = [];\n        for(var i = 0 ; i < n ; i++) {\n            blanks.push(endSymbol);\n        }\n\n        \n        for(var p = n - 1 ; p > 0 ; p--) {\n            \n          var ngram = sequence.slice(sequence.length - p, sequence.length).concat(blanks.slice(0, n - p));\n          result.push(ngram);\n          if (stats) {\n            countNgrams(ngram);\n          }\n        }\n    }\n    </handleEndSymbol>\n\n    <generateStatistics>\n    if (stats) {\n      \n      \n      var Nr = {};\n      Object.keys(frequencies).forEach(function(key) {\n        if (!Nr[frequencies[key]]) {\n          Nr[frequencies[key]] = 0;\n        }\n        Nr[frequencies[key]]++;\n      });\n      \n      \n      return {\n        \"ngrams\": result,\n        \"frequencies\": frequencies,\n        \"Nr\": Nr,\n        \"numberOfNgrams\": nrOfNgrams\n      };\n      \n    }\n    </generateStatistics>\n    else { \n      return result;\n    }\n}\n"], ["doWhilst", "\nfunction doWhilst(value, iterator, tester) {\n  <handleTester>\n  if (typeof tester !== 'function') {\n    tester = iterator;\n    iterator = value;\n    value = undefined;\n  }\n  </handleTester>\n  <performIteration>\n  return new DoWhilst(new WhilstTester(tester), iterator)._iterate(value);\n  </performIteration>\n}\n"], ["instanceApi", "\nfunction instanceApi(oboeBus, contentSource){\n\n  <initialize>\n  var oboeApi,\n      fullyQualifiedNamePattern = /^(node|path):./,\n      rootNodeFinishedEvent = oboeBus(ROOT_NODE_FOUND),\n      emitNodeDrop = oboeBus(NODE_DROP).emit,\n      emitNodeSwap = oboeBus(NODE_SWAP).emit,\n  </initialize>\n\n  <addListener>\n  addListener = varArgs(function( eventId, parameters ){\n\n    if( oboeApi[eventId] ) {\n\n      apply(parameters, oboeApi[eventId]);\n    } else {\n\n      var event = oboeBus(eventId),\n          listener = parameters[0];\n\n      if( fullyQualifiedNamePattern.test(eventId) ) {\n\n        addForgettableCallback(event, listener);\n      } else  {\n\n        event.on( listener);\n      }\n    }\n\n    return oboeApi; \n  }),\n  </addListener>\n\n  <removeListener>\n  removeListener = function( eventId, p2, p3 ){\n\n    if( eventId == 'done' ) {\n\n      rootNodeFinishedEvent.un(p2);\n\n    } else if( eventId == 'node' || eventId == 'path' ) {\n\n      oboeBus.un(eventId + ':' + p2, p3);\n    } else {\n\n      var listener = p2;\n\n      oboeBus(eventId).un(listener);\n    }\n\n    return oboeApi; \n  };\n  </removeListener>\n\n  <helperFunctions>\n  \n  function addProtectedCallback(eventName, callback) {\n    oboeBus(eventName).on(protectedCallback(callback), callback);\n    return oboeApi; \n  }\n  \n  function addForgettableCallback(event, callback, listenerId) {\n    listenerId = listenerId || callback;\n    var safeCallback = protectedCallback(callback);\n    event.on( function() {\n      var discard = false;\n      oboeApi.forget = function(){\n        discard = true;\n      };\n      apply( arguments, safeCallback );\n      delete oboeApi.forget;\n      if( discard ) {\n        event.un(listenerId);\n      }\n    }, listenerId);\n    return oboeApi; \n  }\n  \n  function protectedCallback( callback ) {\n    return function() {\n      try{\n        return callback.apply(oboeApi, arguments);\n      }catch(e)  {\n        setTimeout(function() {\n          throw new Error(e.message);\n        });\n      }\n    }\n  }\n  \n  function fullyQualifiedPatternMatchEvent(type, pattern) {\n    return oboeBus(type + ':' + pattern);\n  }\n\n  function wrapCallbackToSwapNodeIfSomethingReturned( callback ) {\n    return function() {\n      var returnValueFromCallback = callback.apply(this, arguments);\n      if( defined(returnValueFromCallback) ) {\n        if( returnValueFromCallback == oboe.drop ) {\n          emitNodeDrop();\n        } else {\n          emitNodeSwap(returnValueFromCallback);\n        }\n      }\n    }\n  }\n\n  function addSingleNodeOrPathListener(eventId, pattern, callback) {\n    var effectiveCallback;\n    if( eventId == 'node' ) {\n      effectiveCallback = wrapCallbackToSwapNodeIfSomethingReturned(callback);\n    } else {\n      effectiveCallback = callback;\n    }\n    addForgettableCallback(\n      fullyQualifiedPatternMatchEvent(eventId, pattern),\n      effectiveCallback,\n      callback\n    );\n  }\n\n  function addMultipleNodeOrPathListeners(eventId, listenerMap) {\n    for( var pattern in listenerMap ) {\n      addSingleNodeOrPathListener(eventId, pattern, listenerMap[pattern]);\n    }\n  }\n  \n  function addNodeOrPathListenerApi( eventId, jsonPathOrListenerMap, callback ){\n    if( isString(jsonPathOrListenerMap) ) {\n      addSingleNodeOrPathListener(eventId, jsonPathOrListenerMap, callback);\n    } else {\n      addMultipleNodeOrPathListeners(eventId, jsonPathOrListenerMap);\n    }\n    return oboeApi; \n  }\n  </helperFunctions>\n\n  <setupApiEvents>\n  \n  oboeBus(ROOT_PATH_FOUND).on( function(rootNode) {\n    oboeApi.root = functor(rootNode);\n  });\n  \n  oboeBus(HTTP_START).on( function(_statusCode, headers) {\n    oboeApi.header =  function(name) {\n      return name ? headers[name]\n        : headers\n      ;\n    }\n  });\n  </setupApiEvents>\n\n  <createApiObject>\n  return oboeApi = {\n    on             : addListener,\n    addListener    : addListener,\n    removeListener : removeListener,\n    emit           : oboeBus.emit,\n    node           : partialComplete(addNodeOrPathListenerApi, 'node'),\n    path           : partialComplete(addNodeOrPathListenerApi, 'path'),\n    done           : partialComplete(addForgettableCallback, rootNodeFinishedEvent),\n    start          : partialComplete(addProtectedCallback, HTTP_START ),\n    fail           : oboeBus(FAIL_EVENT).on,\n    abort          : oboeBus(ABORTING).emit,\n    header         : noop,\n    root           : noop,\n    source         : contentSource\n  };\n  </createApiObject>\n}\n"], ["registerEndpoint", "\nfunction registerEndpoint(url, handler) {\n        <handleRequestRegistration>\n        tchannel.register(url, function (req, res, arg2, arg3) {\n\n            <processMiddlewareStack>\n            self.middlewareStack.run(req, arg2, arg3,\n                function(req, arg2, arg3, callback) {\n                    handler(arg2, arg3, req.remoteAddr, callback);\n                },\n                function(req, err, res1, res2) {\n                    <setupResponseHeaders>\n                    res.headers.as = 'raw';\n                    </setupResponseHeaders>\n                    <respondBasedOnError>\n                    if (err) {\n                        res.sendNotOk(null, JSON.stringify(err));\n                    } else {\n                        <convertResponseIfNeeded>\n                        if (res2 && !Buffer.isBuffer(res2)) {\n                            res2 = new Buffer(res2);\n                        }\n                        </convertResponseIfNeeded>\n\n                        <sendResponse>\n                        res.sendOk(res1, res2);\n                        </sendResponse>\n                    }\n                    </respondBasedOnError>\n                });\n            </processMiddlewareStack>\n\n        });\n        </handleRequestRegistration>\n}\n"], ["handleKeyPress", "\nfunction (charCode, keyCode, currentText, caretPosStart, caretPosEnd, event) {\n            <initialize>\n            var dataModel = this._dataModel, domEvent = ariaDomEvent, report, selectionKey;\n            </initialize>\n\n            <handleListWidgetBehaviors>\n            if (this._listWidget) {\n                selectionKey = this.checkSelectionKeys(event);\n            }\n            </handleListWidgetBehaviors>\n\n            <handleNonNavigationKeyPress>\n            if (!domEvent.isNavigationKey(keyCode) && !selectionKey) {\n                \n                var nextValueObject;\n                <handleDeleteKeyPress>\n                var isDelKey = (keyCode == domEvent.KC_DELETE || keyCode == domEvent.KC_BACKSPACE);\n                if (isDelKey) {\n                    nextValueObject = this._getTypedValueOnDelete(keyCode, currentText, caretPosStart, caretPosEnd);\n                } else {\n                    nextValueObject = this._getTypedValue(charCode, currentText, caretPosStart, caretPosEnd);\n                }\n                </handleDeleteKeyPress>\n\n                <updateDataModel>\n                dataModel.initialInput = nextValueObject.nextValue;\n                </updateDataModel>\n\n                return this._checkInputKey(charCode, keyCode, nextValueObject.nextValue, nextValueObject.caretPosStart, nextValueObject.caretPosEnd);\n            }\n            </handleNonNavigationKeyPress>\n\n            <handleListWidgetSelection>\n            if (this._listWidget) {\n                if (!selectionKey && keyCode == domEvent.KC_ESCAPE) {\n                    report = this.checkText(dataModel.initialInput);\n                    if (!report) {\n                        report = new ariaWidgetsControllersReportsDropDownControllerReport();\n                    }\n                    report.displayDropDown = false; \n                    report.text = dataModel.initialInput;\n                    report.value = report.text;\n                    report.cancelKeyStroke = true;\n                    dataModel.value = null;\n                    return report;\n\n                } else if (selectionKey || keyCode == domEvent.KC_TAB) {\n                    if (dataModel.selectedIdx != -1) {\n                        if (dataModel.selectedIdx != null) {\n                            dataModel.text = this._getLabelFromListValue(dataModel.listContent[dataModel.selectedIdx]);\n                            dataModel.value = dataModel.listContent[dataModel.selectedIdx].value;\n                        }\n                        report = this.checkDropdownValue(dataModel.value);\n                    } else {\n                        var report = new ariaWidgetsControllersReportsDropDownControllerReport();\n                    }\n                    report.displayDropDown = false; \n                    if (keyCode != domEvent.KC_TAB) {\n                        report.cancelKeyStroke = true; \n                    }\n                    return report;\n                }\n                else {\n                    <handleArrowKeyNavigation>\n                    if (keyCode == domEvent.KC_ARROW_LEFT) {\n                        return;\n                    } else {\n                        report = new ariaWidgetsControllersReportsDropDownControllerReport();\n                        var oldIdx = dataModel.selectedIdx;\n                        this._listWidget.sendKey(0, keyCode);\n                        var newIdx = dataModel.selectedIdx;\n                        if (oldIdx != newIdx) {\n                            report.ok = true;\n                            if (newIdx == -1) {\n                                dataModel.value = null;\n                                dataModel.text = dataModel.initialInput;\n                            } else {\n                                dataModel.value = dataModel.listContent[newIdx].value;\n                                dataModel.text = this._getLabelFromListValue(dataModel.listContent[newIdx]);\n                            }\n                            report.text = dataModel.text;\n                        }\n                    }\n                    return report;\n                    </handleArrowKeyNavigation>\n                }\n            } else {\n                <handleDropdownWithoutListWidget>\n                if (keyCode == domEvent.KC_ARROW_DOWN) {\n                    report = this._checkInputKey(charCode, keyCode, currentText, caretPosStart, caretPosEnd);\n                } else {\n                    report = new ariaWidgetsControllersReportsDropDownControllerReport();\n                }\n                if (report && keyCode != domEvent.KC_TAB && keyCode != domEvent.KC_ARROW_DOWN) {\n                    report.cancelKeyStrokeDefaultBehavior = (keyCode == domEvent.KC_ESCAPE);\n                }\n                return report;\n                </handleDropdownWithoutListWidget>\n            }\n            </handleListWidgetSelection>\n}\n"], ["optionsFunction", "\nfunction(options) {\n    <createStream>\n    var stream = through.obj(function(file, enc, cb) {\n        var out = options.out;\n\n        <overrideOutFunction>\n        options.out = function(text) {\n            cb(null, new gutil.File({\n                path: out,\n                contents: new Buffer(text)\n            }));\n        };\n        </overrideOutFunction>\n\n        <runRequireJsOptimize>\n        requirejs.optimize(options, null, function(err) {\n            stream.emit('error', new gutil.PluginError('gulp-rjs', err.message));\n        });\n        </runRequireJsOptimize>\n    });\n    </createStream>\n\n    return stream;\n}\n"], "```"]