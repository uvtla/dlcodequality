[["TimeSeries", "\nfunction TimeSeries (source, column, options) {\n  this._initialize(source, column, options);\n  this._aggregation = this._options.aggregation;\n  this._offset = _hoursToSeconds(this._options.offset);\n  this._localTimezone = this._options.useLocalTimezone;\n}\n"], ["inherits", "\nfunction inherits(subClass, superClass) {\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true,\n    },\n  });\n}\n"], ["anonymousFunction", "\nfunction(options) {\n  options = options || {};\n  this.host = options.host || 'localhost';\n  this.port = options.port || 8125;\n\n  if (!statsdClients[this.host + ':' + this.port]) {\n    statsdClients[this.host + ':' + this.port] = new StatsD(options);\n  }\n\n  this.client = statsdClients[this.host + ':' + this.port];\n  this.sampleRate = options.sampleRate || 1;\n\n  Writable.call(this, {objectMode: true});\n}\n"], ["InternalOpenIDError", "\nfunction InternalOpenIDError(message, err) {\n  Error.call(this);\n  Error.captureStackTrace(this, arguments.callee);\n  this.name = 'InternalOpenIDError';\n  this.message = message;\n  this.openidError = err;\n}\n"], ["filterIcons", "\nfunction (iconsList, iconNames) {\n  if (iconNames && iconNames.length > 0) {\n    var icons = [];\n    ariaUtilsArray.forEach(iconsList, function (item, i) {\n      if (!ariaUtilsArray.contains(iconNames, iconsList[i])) {\n        icons.push(iconsList[i]);\n      }\n    });\n    return icons;\n  }\n  return iconsList;\n}\n"], ["buildSequence", "\nfunction() {\n  if (!builds.length) { return; } \n\n  var build = builds.shift();\n  var buildCallback = function(stats) {\n    cb(build.buildName, stats);\n    if (builds.length) {\n      runNextBuild();\n    }\n  };\n  console.log(colors.cyan('[Starting build]'), build.buildName);\n  executeBuild(build, buildCallback);\n}\n"], ["adjustDate", "\nfunction(parts, date, operation, reset) {\n  var currentDay = date.date();\n  \n  while (!parts[1].has(date.hour())) {\n    date[operation](1, 'hours')[reset]('hour');\n    \n    if (currentDay !== date.date()) {\n      return true;\n    }\n  }\n  return false;\n}\n"], ["generateOptions", "\nfunction options( opts ) {\n  var out = {};\n\n  out.method = opts.method;\n  debug( 'Method: %s', opts.method );\n\n  out.protocol = opts.protocol+':';\n  debug( 'Protocol: %s', opts.protocol );\n\n  out.hostname = opts.hostname;\n  debug( 'Hostname: %s', opts.hostname );\n\n  out.port = opts.port;\n  debug( 'Port: %d', opts.port );\n\n  out.headers = getHeaders( opts );\n\n  return out;\n}\n"], ["getDefaultSettings", "\nfunction() {\n  return Object.keys(defaults).sort().map(function(key) {\n    return {\n      name: key,\n      value: this.get(key),\n      type: typeof defaults[key].value,\n      description: defaults[key].description\n    };\n  }, this);\n}\n"], ["calculatePerspective", "\nfunction (farDistance, farResolution, depthBits) {\n  if (farDistance < 0) {\n    <throwNegativeDistanceError>\n    throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, \"WWMath\", \"perspectiveNearDistanceForFarDistance\",\n      \"The specified distance is negative.\"));\n    </throwNegativeDistanceError>\n  }\n\n  if (farResolution < 0) {\n    <throwNegativeResolutionError>\n    throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, \"WWMath\", \"perspectiveNearDistanceForFarDistance\",\n      \"The specified resolution is negative.\"));\n    </throwNegativeResolutionError>\n  }\n\n  if (depthBits < 1) {\n    <throwInvalidDepthBitsError>\n    throw new ArgumentError(Logger.logMessage(Logger.LEVEL_SEVERE, \"WWMath\", \"perspectiveNearDistanceForFarDistance\",\n      \"The specified depth bits is negative.\"));\n    </throwInvalidDepthBitsError>\n  }\n\n  var maxDepthValue = (1 << depthBits) - 1;\n\n  return farDistance / (maxDepthValue / (1 - farResolution / farDistance) - maxDepthValue + 1);\n}\n"], "```"]