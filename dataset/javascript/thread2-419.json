[["writeScriptPayToPubKeyHash", "\nfunction writeScriptPayToPubKeyHash(address, buffer, offset) {\n    offset = buffer.writeUInt8(25, offset); \n    offset = buffer.writeUInt8(OPS.OP_DUP, offset);\n    offset = buffer.writeUInt8(OPS.OP_HASH160, offset);\n    \n    offset = buffer.writeUInt8(20, offset); \n    offset += Buffer.from(base58check.decode(address, 'hex').data, 'hex').copy(buffer, offset);\n    \n    offset = buffer.writeUInt8(OPS.OP_EQUALVERIFY, offset);\n    offset = buffer.writeUInt8(OPS.OP_CHECKSIG, offset);\n    return offset;\n}\n"], ["genAssignmentCode", "\nfunction genAssignmentCode(\n  value,\n  assignment\n) {\n  <parseModel>\n  var modelRs = parseModel(value);\n  </parseModel>\n  if (modelRs.idx === null) {\n    return (value + \"=\" + assignment)\n  } else {\n    return \"var $$exp = \" + (modelRs.exp) + \", $$idx = \" + (modelRs.idx) + \";\" +\n      \"if (!Array.isArray($$exp)){\" +\n        value + \"=\" + assignment + \"}\" +\n      \"else{$$exp.splice($$idx, 1, \" + assignment + \")}\"\n  }\n}\n"], ["createShader", "\nfunction () {\n  <shaderCodeCacheAccess>\n  var code = shaderCodeCache[this._shaderID];\n  </shaderCodeCacheAccess>\n  <createNewShader>\n  var shader = new Shader(code.vertex, code.fragment);\n  </createNewShader>\n  return shader;\n}\n"], ["modifyVisibility", "\nfunction (oControl, bVisible) {\n  <getOldVisibility>\n  var bOldVisible = this.getVisible(oControl);\n  </getOldVisibility>\n\n  <setNewVisibility>\n  var vReturnValue = JsControlTreeModifier.setVisible.apply(this, arguments);\n  </setNewVisibility>\n\n  <saveUndoOperation>\n  if (bOldVisible !== this.getVisible(oControl)) {\n    this._saveUndoOperation(\"setVisible\", [oControl, bOldVisible]);\n  }\n  </saveUndoOperation>\n\n  return vReturnValue;\n}\n"], ["registerSnapshotTransformer", "\nfunction (meta, fn) {\n  <validateArguments>\n  if (!_.isObject(meta) || meta.version === undefined || meta.version === null || !_.isNumber(meta.version)) {\n    throw new Error('Please pass in a version');\n  }\n  if (!_.isFunction(fn)) {\n    throw new Error('Please pass in a function');\n  }\n  </validateArguments>\n\n  <wrapFunction>\n  var wrappedFn;\n  if (fn.length === 1) {\n    wrappedFn = function (s, cb) {\n      try {\n        cb(null, fn(s));\n      } catch (err) {\n        cb(err);\n      }\n    };\n  } else {\n    wrappedFn = fn;\n  }\n  </wrapFunction>\n\n  <registerTransformer>\n  this.loadingSnapshotTransformerRegistrations.push({ meta: meta, fn: wrappedFn });\n  </registerTransformer>\n  return this;\n}\n"], ["defineProp", "\nfunction defineProp(obj, key, get) {\n  <defineProperty>\n  Object.defineProperty(obj, key, { get, enumerable: true });\n  </defineProperty>\n}\n"], ["removeDuplicates", "\nfunction removeDuplicates(arr) {\n  <checkArrayAndReduce>\n  if (isArray(arr)) {\n    return reduce(arr, function (a, b) {\n      if (indexOf(a, b) === -1) {\n        return a.concat(b);\n      } else {\n        return a;\n      }\n    }, []);\n  }\n  </checkArrayAndReduce>\n}\n"], ["build", "\nfunction build(config) {\n  <normalizeConfigAndPrepareEnvironment>\n  \n  var options = command.norm(config);\n  var inputFilename = options.file;\n  var flow = new Flow(options, 'build');\n  var fconsole = flow.console;\n\n  flow.exitOnFatal = true;\n  flow.outputResourceDir = 'res/';\n\n  fconsole.enabled = options.verbose;\n  chalk.enabled = options.color && process.stdout.isTTY;\n\n  </normalizeConfigAndPrepareEnvironment>\n\n  <displayBuildInformation>\n  if (!options.silent) {\n    if (options.verbose) {\n      \n      fconsole.start('Build with ' + utils.getToolsId());\n      fconsole.log('Base path:  ', options.base);\n      fconsole.log('Index file: ', options.file);\n      fconsole.log('Output path:', options.output);\n      if (options.jsBundle) fconsole.log('Bundle:     ', options.jsBundleName + '.' + options.jsBundle);\n      fconsole.log('Plugins:    ', flow.plugins ? flow.plugins.join(', ') : 'NONE');\n      fconsole.endl();\n    } else {\n      \n      process.stdout.write(...);\n      // display build information in a different format\n    }\n  }\n  </displayBuildInformation>\n\n  <fileSystemChecks>\n  \n  if (!fs.existsSync(inputFilename) || !fs.statSync(inputFilename).isFile()) flow.exit('Input file ' + inputFilename + ' not found');\n  \n  if (options.output == path.dirname(inputFilename)) flow.exit('Output path shouldn't be the same as input file location');\n  </fileSystemChecks>\n\n  <initializeProcess>\n  fconsole.start('\\nInit\\n====\\n');\n  \n  flow.indexFile = flow.files.add({ ... });\n  </initializeProcess>\n\n  <handlerExecutionSetup>\n  \n  var handlers = extract.handlers({ ... }).concat([...]).filter(Boolean);\n  \n  var stdoutHandlerTitle;\n  var stdoutHandlerSilent = false;\n  var handlerCount = handlers.length;\n  var taskCount = 0;\n  var warningCount = 0;\n  var timing = [];\n  var time;\n  var stdoutPos;\n  var resolve = function () {};\n  var result = new Promise(function (resolve_) { ... });\n\n  flow.timing = timing;\n\n  // additional functions like repeat, asyncTaskStart, asyncTaskDone, nextHandler, and runHandler\n  // are defined here\n  \n  process.nextTick(runHandler);\n  </handlerExecutionSetup>\n\n  <postBuildProcessing>\n  \n  if (isChildProcess) {\n    // Handling results in child process\n  } else {\n    // Handling results in main process\n  }\n  </postBuildProcessing>\n\n  return result;\n}\n"], ["getTimeIntervalMeasurementUnits", "\nfunction getTimeIntervalMeasurementUnits(localeData, restrictedSetOfUnits) {\n  <extractUnits>\n  \n  let units = Object.keys(localeData)\n  </extractUnits>\n  \n  <filterByRestrictedSet>\n  \n  if (restrictedSetOfUnits) {\n    \n    units = restrictedSetOfUnits.filter(_ => units.indexOf(_) >= 0)\n  }\n  </filterByRestrictedSet>\n  \n  <includeNowUnit>\n  \n  if ((!restrictedSetOfUnits || restrictedSetOfUnits.indexOf('now') >= 0) && units.indexOf('now') < 0) {\n    if (localeData.second.current) {\n      units.unshift('now')\n    }\n  }\n  </includeNowUnit>\n\n  return units\n}\n"], ["runBench", "\nfunction run(id, iters) {\n  <benchSetup>\n  var bench = new Bench(id, \u0192)\n  </benchSetup>\n  \n  <runBenchmarkAndSendResults>\n  try { Result.when(bench.do(iters), send, error) }\n  catch (e) { error(e) }\n  </runBenchmarkAndSendResults>\n\n  <sendResult>\n  function send(result) {\n    process.send({ ... });\n  }\n  </sendResult>\n  \n  <sendError>\n  function error(e) {\n    process.send({ ... });\n  }\n  </sendError>\n}\n"], "```"]