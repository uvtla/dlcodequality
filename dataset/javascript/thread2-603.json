[["getUserRevealSize", "\nfunction getRevealSize() {\n    var carousel = this, isVertical, sz;\n\n    <isVerticalCalculation>\n    isVertical = carousel.get(\"isVertical\");</isVerticalCalculation>\n    <getSizeCalculation>\n    sz  = getCarouselItemSize.call(carousel,\n            isVertical ? \"height\" : \"width\");</getSizeCalculation>\n    return (sz * carousel.get(\"revealAmount\") / 100);\n}\n"], ["setServiceProperties", "\nfunction(properties) {\n    this._handle = null;\n    this._services = null;\n    this._characteristics = null;\n\n    this.device = null;\n    this.uuid = null;\n    this.isPrimary = false;\n\n    <mergeProperties>\n    mergeDictionary(this, properties);\n    </mergeProperties>\n    <dispatchEvent>\n    this.dispatchEvent({ type: \"serviceadded\", bubbles: true });\n    </dispatchEvent>\n}\n"], ["checkAssertion", "\nfunction check (expected, control) {\n    <assertIs>\n    return function assertIs (value, message) {\n        var actual = utils.kindOf(value)\n        var result = utils.is[expected](value)\n        var operator = control === false ? '===' : '!=='\n\n        if (utils.kindOf(message) === 'function') {\n            message = message(actual, expected, value)\n        }\n\n        message = utils.kindOf(message) === 'string'\n        ? utils.format(message, { expected: expected, actual: actual })\n        : actual + ' ' + operator + ' ' + expected\n\n        test(result === control, {\n            value: value,\n            actual: actual,\n            expected: expected,\n            operator: operator,\n            message: message,\n            stackStartFunction: assertIs\n        })\n    }\n    </assertIs>\n}\n"], ["validateManifest", "\nfunction validate (rootPath) {\n  var manifest;\n  var webextensionManifest;\n\n  var errors = {};\n\n  <parseManifest>\n  try {\n    manifest = JSON.parse(fs.readFileSync(join(rootPath, \"package.json\")));\n  } catch (e) {\n    errors.parsing = utils.getErrorMessage(\"COULD_NOT_PARSE\") + \"\\n\" + e.message;\n    return errors;\n  }\n  </parseManifest>\n\n  <validateSections>\n  if (!validateID(manifest)) {\n    errors.id = utils.getErrorMessage(\"INVALID_ID\");\n  }\n\n  if (!validateMain(rootPath)) {\n    errors.main = utils.getErrorMessage(\"MAIN_DNE\");\n  }\n\n  if (!validateTitle(manifest)) {\n    errors.title = utils.getErrorMessage(\"INVALID_TITLE\");\n  }\n\n  if (!validateName(manifest)) {\n    errors.name = utils.getErrorMessage(\"INVALID_NAME\");\n  }\n\n  if (!validateVersion(manifest)) {\n    errors.version = utils.getErrorMessage(\"INVALID_VERSION\");\n  }\n  </validateSections>\n\n  <checkWebextensionManifest>\n  if (fs.existsSync(join(rootPath, \"manifest.json\"))) {\n    errors.webextensionManifestFound = utils.getErrorMessage(\"WEBEXT_ERROR\");\n  }\n  </checkWebextensionManifest>\n\n  return errors;\n}\n"], ["quoteLiteralValue", "\nfunction quoteLiteral(value) {\n\n    var literal = null;\n    var explicitCast = null;\n\n    <handleSpecialCases>\n    if (value === undefined || value === null) {\n        return 'NULL';\n    } else if (value === false) {\n        return \"'f'\";\n    } else if (value === true) {\n        return \"'t'\";\n    } else if (value instanceof Date) {\n        return \"'\" + formatDate(value.toISOString()) + \"'\";\n    } else if (value instanceof Buffer) {\n        return \"E'\\\\\\\\x\" + value.toString('hex') + \"'\";\n    } else if (Array.isArray(value) === true) {\n        var temp = [];\n        for (var i = 0; i < value.length; i++) {\n            if (Array.isArray(value[i]) === true) {\n                temp.push(arrayToList(i !== 0, value[i], quoteLiteral))\n            } else {\n                temp.push(quoteLiteral(value[i]));\n            }\n        }\n        return temp.toString();\n    } else if (value === Object(value)) {\n        explicitCast = 'jsonb';\n        literal = JSON.stringify(value);\n    } else {\n        literal = value.toString().slice(0); \n    }\n    </handleSpecialCases>\n\n    <quoteAndEscape>\n    var hasBackslash = false;\n    var quoted = '\\'';\n\n    for (var i = 0; i < literal.length; i++) {\n        var c = literal[i];\n        if (c === '\\'') {\n            quoted += c + c;\n        } else if (c === '\\\\') {\n            quoted += c + c;\n            hasBackslash = true;\n        } else {\n            quoted += c;\n        }\n    }\n\n    quoted += '\\'';\n\n    if (hasBackslash === true) {\n        quoted = 'E' + quoted;\n    }\n    </quoteAndEscape>\n\n    <applyExplicitCast>\n    if (explicitCast) {\n        quoted += '::' + explicitCast;\n    }\n    </applyExplicitCast>\n\n    return quoted;\n}\n"], ["handleErrorLogging", "\nfunction handleError(during, e) {\n    \n    <logErrorHeader>\n    console.error(\"-------------------------------------------------\");\n    console.error(\"Exception found \" + during);\n    </logErrorHeader>\n    \n    <logErrorMessage>\n    console.error(\"Message: \" + e.message);\n    console.error(\"at     : \" + e.line);\n    var filename = e.sourceURL || \"unknown\";\n    </logErrorMessage>\n    \n    <processFilename>\n    filename = filename.replace(/.*generated-javascript/, '');\n    </processFilename>\n    \n    <logErrorDetails>\n    console.error(\"file   : \" + filename);\n    console.error(\"url    : \" + e.sourceURL);\n    </logErrorDetails>\n    \n    <logStackTrace>\n    var stack = e.stack || e.stacktrace;\n\n    if (stack) {\n        console.error(stack);\n    } else {\n        console.log(\"No stack trace\");\n    }\n    </logStackTrace>\n}\n"], ["buildStringFormat", "\nfunction buildFormat(format) {\n    return <constructFormatString>\n    format.v.map(x=> typeof x === 'string' ? x :\n               '{' + x.p + ('o' in x ? '>' + x.o : '') + '}').join('') +\n    (format.o ? '>>' + Object.keys(format.o).map(x => OPTIONS[x]).join('') : '');\n    </constructFormatString>\n}\n"], ["hideTahtaIhale", "\nfunction f_tahta_ihale_gizlenen_sil(_tahta_id, _ihale_id) {\n    <removeIhaleFromGizlenen>\n    return result.dbQ.srem(result.kp.tahta.ssetGizlenenIhaleleri(_tahta_id), _ihale_id)\n    </removeIhaleFromGizlenen>\n        <notifyIhaleHidden>\n        .then(function () {\n            emitter.emit(schema.SABIT.OLAY.IHALE_GIZLENDI, _ihale_id, _tahta_id);\n            return _ihale_id;\n        });\n        </notifyIhaleHidden>\n}\n"], ["getDisplayName", "\nfunction getComponentName(target: ComponentType<*>): string {\n    <checkDisplayName>\n    if (target.displayName && typeof target.displayName === 'string') {\n        return target.displayName;\n    }\n    </checkDisplayName>\n\n    <returnNameOrDefault>\n    return target.name || 'Component';\n    </returnNameOrDefault>\n}\n"], ["validateDependenciesInPackageJson", "\nfunction validateDependencies(configDir) {\n    const packageJsonPath = path.join(findup.sync(configDir, 'package.json'), 'package.json');\n    <loadPackageJson>\n    const packageJson = require(packageJsonPath);\n    </loadPackageJson>\n    <validateEachDependency>\n    DEPENDENCIES.forEach(validateDependency.bind(null, packageJson));\n    </validateEachDependency>\n}\n"], "```\n\nThis function is arguably SRP compliant because its sole purpose is to validate dependencies within a package.json file, despite the fact that it combines the task of finding and loading the package.json and validating the dependencies therein. These operations collectively serve the single overarching task of dependency validation."]