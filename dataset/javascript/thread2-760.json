[["_adjacentPieces", "\nfunction _adjacentPieces(piece, getAdjacent) {\n    <initializeLoop>\n    for (var i = 1; i <= 6; i++) {\n    </initializeLoop>\n        <getAdjacentPiece>\n        adjacent = getAdjacent(i);\n        if (typeof adjacent === 'undefined') {\n            return false;\n        } else if (i === 6) {\n            return adjacent;\n        }\n        </getAdjacentPiece>\n        \n        <comparePieces>\n        var samecolor = (adjacent.piece.color === piece.color);\n        var sameshape = (adjacent.piece.shape === piece.shape);\n        </comparePieces>\n        \n        <evaluatePiece>\n        if ((samecolor || sameshape) && !(samecolor && sameshape)) {\n            if (!game.turn_pieces.some(function(x) {\n                return x.equals(adjacent);\n            })) {\n                points += 1;\n            }\n            continue;\n        }\n        </evaluatePiece>\n        <returnLast>\n        return adjacent;\n        </returnLast>\n    }\n    <returnFalse>\n    return false;\n    </returnFalse>\n}\n"], ["mapBindings", "\nfunction() {\n    this._unbindModel();\n    <bindEvents>\n    this.map.bind('change:view_bounds_sw',  this._changeBounds, this);\n    this.map.bind('change:view_bounds_ne',  this._changeBounds, this);\n    this.map.bind('change:zoom',            this._setZoom, this);\n    this.map.bind('change:scrollwheel',     this._setScrollWheel, this);\n    this.map.bind('change:keyboard',        this._setKeyboard, this);\n    this.map.bind('change:center',          this._setCenter, this);\n    this.map.bind('change:attribution',     this.setAttribution, this);\n    </bindEvents>\n}\n"], ["setFocus", "\nfunction setFocus(hash) {\n    <retrieveElement>\n    var element = document.getElementById(hash.substring(1))\n    </retrieveElement>\n\n    <modifyAndFocusElement>\n    if (element) {\n        if (!/^(?:a|select|input|button|textarea)$/i.test(element.tagName)) {\n            element.tabIndex = -1;\n        }\n        element.focus();\n    }\n    </modifyAndFocusElement>\n}\n"], ["_checkRight", "\nfunction _checkRight(targetOffset, tooltipLayerStyleLeft, tooltipOffset, windowSize, tooltipLayer) {\n    <adjustPositioning>\n    if (targetOffset.left + tooltipLayerStyleLeft + tooltipOffset.width > windowSize.width) {\n        \n        tooltipLayer.style.left = windowSize.width - tooltipOffset.width - targetOffset.left + 'px';\n        return false;\n    }\n    tooltipLayer.style.left = tooltipLayerStyleLeft + 'px';\n    </adjustPositioning>\n    <returnTrue>\n    return true;\n    </returnTrue>\n}\n"], ["deriveKey", "\nfunction(password, salt) {\n    <configurations>\n    var cfg = this.cfg;\n    </configurations>\n\n    <initializeHmac>\n    var hmac = HMAC.create(cfg.hasher, password);\n    </initializeHmac>\n\n    <prepareDerivedKey>\n    var derivedKey = WordArray.create();\n    var blockIndex = WordArray.create([0x00000001]);\n    </prepareDerivedKey>\n\n    <defineVariables>\n    var derivedKeyWords = derivedKey.words;\n    var blockIndexWords = blockIndex.words;\n    var keySize = cfg.keySize;\n    var iterations = cfg.iterations;\n    </defineVariables>\n\n    <generateDerivedKey>\n    while (derivedKeyWords.length < keySize) {\n        var block = hmac.update(salt).finalize(blockIndex);\n        hmac.reset();\n        var blockWords = block.words;\n        var blockWordsLength = blockWords.length;\n        var intermediate = block;\n        for (var i = 1; i < iterations; i++) {\n            intermediate = hmac.finalize(intermediate);\n            hmac.reset();\n            var intermediateWords = intermediate.words;\n            for (var j = 0; j < blockWordsLength; j++) {\n                blockWords[j] ^= intermediateWords[j];\n            }\n        }\n        derivedKey.concat(block);\n        blockIndexWords[0]++;\n    }\n    </generateDerivedKey>\n    <finalizeDerivedKey>\n    derivedKey.sigBytes = keySize * 4;\n    </finalizeDerivedKey>\n    <returnDerivedKey>\n    return derivedKey;\n    </returnDerivedKey>\n}\n"], ["handleResponse", "\nfunction(err, data, response) {\n    <invokeComplete>\n    if (options.complete) {\n        options.complete.call(model, err, data, response, options);\n    }\n    </invokeComplete>\n    <triggerModelEvent>\n    model.trigger('complete', err, data, response, options);\n    </triggerModelEvent>\n}\n"], ["getPropWithFallback", "\nfunction(obj, name, Prop, fallback) {\n    <assignPropertyOrDefault>\n    return _.has(obj, name) ? (new Prop(obj[name])) : fallback;\n    </assignPropertyOrDefault>\n}\n"], ["propPathSatisfies", "\nfunction propPathSatisfies(keys, pred, x) {\n    <validateInputs>\n    if (!isArray(keys)) {\n        throw new TypeError('propPathSatisfies: Array of Non-empty Strings or Integers required for first argument')\n    }\n    if (!isPredOrFunc(pred)) {\n        throw new TypeError('propPathSatisfies: Pred or predicate function required for second argument')\n    }\n    if (isNil(x)) {\n        return false\n    }\n    </validateInputs>\n\n    <traverseObjectPath>\n    let target = x\n    for (let i = 0; i < keys.length; i++) {\n        const key = keys[i]\n        if (!(isString(key) && !isEmpty(key) || isInteger(key))) {\n            throw new TypeError('propPathSatisfies: Array of Non-empty Strings or Integers required for first argument')\n        }\n        if (isNil(target)) {\n            return false\n        }\n        target = target[key]\n    }\n    </traverseObjectPath>\n\n    <evaluatePredicate>\n    return !!predOrFunc(pred, target)\n    </evaluatePredicate>\n}\n"], ["promisifyObject", "\nfunction promisify_object(template, object_creator) {\n    <setDefaultCreator>\n    object_creator = object_creator || new_object;\n    </setDefaultCreator>\n    <createTransformerFunction>\n    var transformer = function (obj_promise) {\n        var res = object_creator(obj_promise);\n        for (var prop in template) {\n            res[prop] = template[prop].for_property(obj_promise, prop);\n        }\n        return res;\n    };\n    </createTransformerFunction>\n    <propertyTransformer>\n    transformer.for_property = function (parent_promise, prop) {\n        return transformer(when(parent_promise, function (obj) {\n            return obj[prop];\n        }));\n    };\n    </propertyTransformer>\n\n    <returnTransformer>\n    return transformer;\n    </returnTransformer>\n}\n"], ["formatBlockedUser", "\nfunction(messageContent) {\n    <createBlockedUserObject>\n    var blockedUser = {\n        blockId: messageContent.id,\n        firstName: messageContent.firstName,\n        lastName: messageContent.lastName,\n        nickName: messageContent.nickName\n    };\n    </createBlockedUserObject>\n    <returnBlockedUser>\n    return blockedUser;\n    </returnBlockedUser>\n}\n"], "\n```\n\nNote: Single Responsibility Principle (SRP) annotations identify areas of distinct responsibilities within the code. Here, each responsibility is either compliant or non-compliant with SRP based on whether it encapsulates a cohesive and singular concern within the function. If a code contains tightly related instructions that serve a single identifiable purpose, it is marked compliant, otherwise, violation sections are indicated."]