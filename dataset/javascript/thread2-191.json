[["createDocument", "\nfunction createDocument(root, namespace) {\n    if (!root)\n      return document.implementation.createHTMLDocument();\n    else\n      return document.implementation.createDocument(\n        namespace || null,\n        root,\n        null\n      );\n}\n"], ["processDocument", "\nfunction(newDoc, oldDoc, userContext, securityInfo) {\n  <defineHelperFunctions>\n  function isValueNullOrUndefined(value) {\n    return value === void 0 || value === null;\n  }\n  \n  function isDocumentMissingOrDeleted(candidate) {\n    return isValueNullOrUndefined(candidate) || candidate._deleted;\n  }\n  \n  var typeIdValidator = {\n    type: 'string',\n    required: true,\n    mustNotBeEmpty: true,\n    immutable: true\n  };\n  \n  function simpleTypeFilter(newDoc, oldDoc, candidateDocType) {\n    // implementation...\n  }\n  \n  function padRight(value, desiredLength, padding) {\n    // implementation...\n  }\n  \n  function isValueAnInteger(value) {\n    // implementation...\n  }\n  \n  function resolveDocumentConstraint(constraintDefinition) {\n    // implementation...\n  }\n  </defineHelperFunctions>\n\n  var utils = {\n    // Object containing helper functions\n  };\n\n  var authorizationModule = importValidationFunctionFragment('./authorization-module.js')(utils);\n  var validationModule = importValidationFunctionFragment('./validation-module.js')(utils, simpleTypeFilter, typeIdValidator);\n  \n  var rawDocDefinitions = $DOCUMENT_DEFINITIONS_PLACEHOLDER$;\n  var docDefinitions;\n  if (typeof rawDocDefinitions === 'function') {\n    docDefinitions = rawDocDefinitions();\n  } else {\n    docDefinitions = rawDocDefinitions;\n  }\n\n  function getDocumentType() {\n    // implementation...\n  }\n  \n  var theDocType = getDocumentType();\n\n  if (isValueNullOrUndefined(theDocType)) {\n    // Conditional block with different responsibilities...\n  }\n\n  var theDocDefinition = docDefinitions[theDocType];\n  var customActionMetadata = {\n    // Metadata related to actions...\n  };\n\n  <processTypeIdentification>\n  if (theDocDefinition.customActions && typeof theDocDefinition.customActions.onTypeIdentificationSucceeded === 'function') {\n    theDocDefinition.customActions.onTypeIdentificationSucceeded(newDoc, oldDoc, customActionMetadata, userContext, securityInfo);\n  }\n  </processTypeIdentification>\n\n  <processAuthorization>\n  customActionMetadata.authorization = authorizationModule.authorize(newDoc, oldDoc, userContext, securityInfo, theDocDefinition);\n  </processAuthorization>\n\n  <processAfterAuthorization>\n  if (theDocDefinition.customActions && typeof theDocDefinition.customActions.onAuthorizationSucceeded === 'function') {\n    theDocDefinition.customActions.onAuthorizationSucceeded(newDoc, oldDoc, customActionMetadata, userContext, securityInfo);\n  }\n  </processAfterAuthorization>\n\n  <validateDocument>\n  validationModule.validateDoc(newDoc, oldDoc, userContext, securityInfo, theDocDefinition, theDocType);\n  </validateDocument>\n\n  <processAfterValidation>\n  if (theDocDefinition.customActions && typeof theDocDefinition.customActions.onValidationSucceeded === 'function') {\n    theDocDefinition.customActions.onValidationSucceeded(newDoc, oldDoc, customActionMetadata, userContext, securityInfo);\n  }\n  </processAfterValidation>\n}\n"], ["toggleValidClass", "\nfunction() {\n    var self = this;\n\n    if (self.filter.get(\"valid\")) {\n      self.$el.removeClass(\"invalidvalid\");\n      self.$el.addClass(\"valid\");\n    }\n    else {\n      self.$el.removeClass(\"valid\");\n      self.$el.addClass(\"invalid\");\n    }\n}\n"], ["sendTips", "\nfunction (tips, channel) {\n    if (!this.api_key) throw new ChangeTipException(300);\n    \n    var deferred = Q.defer(),\n        params;\n    \n    params = {\n        tips: tips instanceof Array ? tips.join(\",\") : tips,\n        channel: channel || ''\n    };\n\n    this._send_request({}, 'tips', params, Methods.GET, deferred);\n    return deferred.promise;\n}\n"], ["createPrototypeFactory", "\nfunction proto() {\n    var args = arguments \n    // ... prototype creation logic ...\n    return ProtoObjectFactory;\n}\n"], ["applyTextDiff", "\nfunction(cnt, compareResult){\n    var splitter = compareResult.splitter,\n        diff = compareResult.diff,\n        result = cnt.split(splitter);\n    // ... text diff application logic ...\n    return result.join(splitter);\n}\n"], ["checkCookieAndUpdate", "\nfunction checkCookie() {\n  <parseCookieValues>\n  var checkCookieValues = // parsing logic ...\n  </parseCookieValues>\n\n  if (checkCookieValues) {\n    <splitCookieValues>\n    checkCookieValues = checkCookieValues.split('?');\n    var thisID = checkCookieValues[0];\n    var thisBtnPos = checkCookieValues[1];\n    </splitCookieValues>\n    \n    <updateCookieAndDataLayer>\n    updateCookie(thisID, thisBtnPos, 'remove');\n    dataLayer_updateBasket(thisID, thisBtnPos, 'remove');\n    </updateCookieAndDataLayer>\n  }\n}\n"], ["generateDeploymentMetadata", "\nfunction(changelogOptions) {\n    var self = this;\n    return this._generateChangeLog(changelogOptions)\n      .then(function(changelog) {\n        return {\n          deployMetaData: {\n            changelog: changelog,\n            summary: self.readConfig('summary'),\n            deployer: self.readConfig('deployer')\n          }\n        };\n      });\n}\n"], ["observeQueryResults", "\nfunction () {\n    var self = this;\n\n    if (self._stopped)\n      return;\n    \n    <initializeQueryObservation>\n    self._needToFetch = new LocalCollection._IdMap;\n    self._currentlyFetching = null;\n    ++self._fetchGeneration;\n    self._registerPhaseChange(PHASE.QUERYING);\n    </initializeQueryObservation>\n\n    <runQuery>\n    Meteor.defer(function () {\n      self._runQuery();\n      self._doneQuerying();\n    });\n    </runQuery>\n}\n"], ["loadFileAndProcess", "\nfunction(file, isCss) {\n    var defer = new $.Deferred();\n    $.ajax({\n      url: file.source,\n      dataType: 'text',\n      success: function(data) {\n        log('File Loaded:' + file.source);\n        onElementLoaded(file, data);\n        _bytesLoaded += file.size;\n        _files[_currentSegment].splice(0, 1);\n        updatePercentage();\n        \n        <processCSS>\n        if (isCss) {\n            if (document.createStyleSheet) {\n              try {\n                document.createStyleSheet(file.source);\n              } catch (e) {}\n            } else {\n              var css;\n              css = document.createElement('link');\n              css.rel = 'stylesheet';\n              css.type = 'text/css';\n              css.media = 'all';\n              css.href = file.source;\n              $head[0].appendChild(css);\n            }\n        }\n        </processCSS>\n\n        defer.resolve(data);\n      }\n    });\n\n    return defer.promise();\n}\n"], "```\nThough this function contains a nested condition for processing CSS files differently, the primary responsibility is still to load a file and handle the response, so it adheres to SRP."]