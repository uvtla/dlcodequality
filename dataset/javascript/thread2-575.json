[["baseClone", "\nfunction baseClone(value, bitmask, customizer, key, object, stack) {\n  \n  var result,\n      isDeep = bitmask & CLONE_DEEP_FLAG$1,\n      isFlat = bitmask & CLONE_FLAT_FLAG,\n      isFull = bitmask & CLONE_SYMBOLS_FLAG$1;\n\n  <customizerCheck>\n  if (customizer) {\n    result = object ? customizer(value, key, object, stack) : customizer(value);\n  }\n  if (result !== undefined) {\n    return result;\n  }\n  </customizerCheck>\n\n  <isObjectCheck>\n  if (!isObject_1(value)) {\n    return value;\n  }\n  </isObjectCheck>\n\n  <initClone>\n  var isArr = isArray_1(value);\n  if (isArr) {\n    result = _initCloneArray(value);\n    if (!isDeep) {\n      return _copyArray(value, result);\n    }\n  } else {\n    var tag = _getTag(value),\n        isFunc = tag == funcTag || tag == genTag;\n\n    if (isBuffer_1(value)) {\n      return _cloneBuffer(value, isDeep);\n    }\n    if (tag == objectTag || tag == argsTag || (isFunc && !object)) {\n      result = (isFlat || isFunc) ? {} : _initCloneObject(value);\n      if (!isDeep) {\n        return isFlat\n          ? _copySymbolsIn(value, _baseAssignIn(result, value))\n          : _copySymbols(value, _baseAssign(result, value));\n      }\n    } else {\n      if (!cloneableTags[tag]) {\n        return object ? value : {};\n      }\n      result = _initCloneByTag(value, tag, baseClone, isDeep);\n    }\n  }\n  </initClone>\n\n  <stackInitialization>\n  stack || (stack = new _Stack);\n  var stacked = stack.get(value);\n  if (stacked) {\n    return stacked;\n  }\n  stack.set(value, result);\n  </stackInitialization>\n\n  <keysFunctionSetup>\n  var keysFunc = isFull\n    ? (isFlat ? _getAllKeysIn : _getAllKeys)\n    : (isFlat ? keysIn : keys_1);\n  </keysFunctionSetup>\n\n  <propsSetup>\n  var props = isArr ? undefined : keysFunc(value);\n  </propsSetup>\n\n  <cloneProperties>\n  _arrayEach(props || value, function(subValue, key) {\n    if (props) {\n      key = subValue;\n      subValue = value[key];\n    }\n    \n    _assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));\n  });\n  </cloneProperties>\n\n  return result;\n}\n"], ["destroyDropdown", "\nfunction() {\n  <dropdownExistenceCheck>\n  if (this._dropdownTriggerButton) {\n    <destroyDropdownIfExists>\n    if (this._dropdownTriggerButton.dropdown) {\n      this._dropdownTriggerButton.dropdown.destroy();\n      this._dropdownTriggerButton.dropdown = null;\n    }\n    </destroyDropdownIfExists>\n    this._dropdownTriggerButton = null;\n  }\n  </dropdownExistenceCheck>\n}\n"], ["concatMiddlewareNames", "\nfunction concatMiddlewareNames(routes) {\n  <initializeOutput>\n  var output = [];\n  </initializeOutput>\n\n  <iterateAndConcatMiddleware>\n  for (var i = 0; i < routes.length; i++) {\n    output = output.concat(getMiddlewareNames(routes[i]));\n  }\n  </iterateAndConcatMiddleware>\n\n  return output;\n}\n"], ["addContext", "\nfunction addContext(el, tagData, insertionElementTagData) {\n  <preventDataBindings>\n  domData.set(el, \"preventDataBindings\", true);\n  </preventDataBindings>\n\n  <createViewModel>\n  var teardown = stacheBindings.behaviors.viewModel(el, insertionElementTagData,\n    function createViewModel(initialData, hasDataBinding, bindingState) {\n      if(bindingState && bindingState.isSettingOnViewModel === true) {\n        newScope = tagData.scope.addLetContext(initialData);\n        return newScope._context;\n      } else {\n        return vm = new SimpleObservable(initialData);\n      }\n    }, undefined, true);\n  </createViewModel>\n\n  <handleTeardown>\n  if(!teardown) {\n    return tagData;\n  } else {\n    return assign(assign({}, tagData), {\n      teardown: teardown,\n      scope: newScope || tagData.scope.add(vm)\n    });\n  }\n  </handleTeardown>\n}\n"], ["isDebug", "\nfunction isDebug(debugging) {\n  <checkDebuggingValue>\n  if (isValue(debugging))\n      return debugging;\n  </checkDebuggingValue>\n\n  <processCheck>\n  var eargv = process && process.execArgv;\n  </processCheck>\n\n  <chkDebug>\n  function chkDebug() {\n    return (eargv.filter(function (v) { return /^(--debug|--inspect)/.test(v); }).length ||\n        isValue(v8debug));\n  }\n  </chkDebug>\n\n  <wrapAndReturnDebugCheck>\n  return function_1.tryWrap(chkDebug)(false);\n  </wrapAndReturnDebugCheck>\n}\n"], ["getPrototypeOfExpression", "\nfunction getPrototypeOfExpression(objectRef, isStatic, file, isPrivateMethod) {\n  <cloneObjectRef>\n  objectRef = t.cloneNode(objectRef);\n  </cloneObjectRef>\n\n  <defineTargetRef>\n  const targetRef =\n    isStatic || isPrivateMethod\n      ? objectRef\n      : t.memberExpression(objectRef, t.identifier(\"prototype\"));\n  </defineTargetRef>\n\n  <generateCallExpression>\n  return t.callExpression(file.addHelper(\"getPrototypeOf\"), [targetRef]);\n  </generateCallExpression>\n}\n"], ["Tri", "\nfunction Tri() {\n  <applyTriangleSuperConstructor>\n  Triangle.apply(this, arguments);\n  </applyTriangleSuperConstructor>\n\n  <initializeProperties>\n  this.target = {vec: null, t: 0};\n  this.vertices = [\"p0\",\"p1\",\"p2\"];\n  this.colorId = 1 + (colorToggle % 3);\n  </initializeProperties>\n}\n"], ["reportRunningTask", "\nfunction reportRunningTask(taskname) {\n  <requireIconModule>\n  const icon = require('./ci-icon');\n  </requireIconModule>\n\n  <defineDoneFunction>\n  function done(success) {\n      success\n          ? console.log(`${icon.success()} ${taskname}`)\n          : console.log(`${icon.error()} ${taskname}`);\n  }\n  </defineDoneFunction>\n\n  return done;\n}\n"], ["innerFill", "\nfunction innerFill(order, proc, body) {\n  <initializeVariables>\n  var dimension = order.length,\n      nargs = proc.arrayArgs.length,\n      has_index = proc.indexArgs.length>0,\n      code = [],\n      vars = [],\n      idx=0, pidx=0, i, j;\n  </initializeVariables>\n\n  <setupLoopVariables>\n  for(i=0; i<dimension; ++i) { \n    vars.push([\"i\",i,\"=0\"].join(\"\"));\n  }\n  </setupLoopVariables>\n\n  <setupStrideVariables>\n  for(j=0; j<nargs; ++j) {\n    for(i=0; i<dimension; ++i) {\n      pidx = idx;\n      idx = order[i];\n      if(i === 0) { \n        vars.push([\"d\",j,\"s\",i,\"=t\",j,\"p\",idx].join(\"\"));\n      } else { \n        vars.push([\"d\",j,\"s\",i,\"=(t\",j,\"p\",idx,\"-s\",pidx,\"*t\",j,\"p\",pidx,\")\"].join(\"\"));\n      }\n    }\n  }\n  </setupStrideVariables>\n\n  <declareVariables>\n  if (vars.length > 0) {\n    code.push(\"var \" + vars.join(\",\"));\n  }\n  </declareVariables>\n\n  <generateLoops>\n  for(i=dimension-1; i>=0; --i) { \n    idx = order[i];\n    code.push([\"for(i\",i,\"=0;i\",i,\"<s\",idx,\";++i\",i,\"){\"].join(\"\"));\n  }\n  </generateLoops>\n\n  <insertBodyCode>\n  code.push(body);\n  </insertBodyCode>\n\n  <closeLoopsAndHandleIndex>\n  for(i=0; i<dimension; ++i) {\n    pidx = idx;\n    idx = order[i];\n    for(j=0; j<nargs; ++j) {\n      code.push([\"p\",j,\"+=d\",j,\"s\",i].join(\"\"));\n    }\n    if(has_index) {\n      if(i > 0) {\n        code.push([\"index[\",pidx,\"]-=s\",pidx].join(\"\"));\n      }\n      code.push([\"++index[\",idx,\"]\"].join(\"\"));\n    }\n    code.push(\"}\");\n  }\n  </closeLoopsAndHandleIndex>\n\n  return code.join(\"\\n\");\n}\n"], ["scaleNodeBreadths", "\nfunction scaleNodeBreadths(nodes, kx, orient) {\n  <iterateNodesAndSetLayout>\n  zrUtil.each(nodes, function (node) {\n    var nodeDepth = node.getLayout().depth * kx;\n    orient === 'vertical'\n        ? node.setLayout({y: nodeDepth}, true)\n        : node.setLayout({x: nodeDepth}, true);\n  });\n  </iterateNodesAndSetLayout>\n}\n"], ""]