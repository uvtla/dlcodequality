[["setValue", "\nfunction setValue(value) {\n    <beforeSetValueHook>\n    value = this.beforeSetValue(value);\n    </beforeSetValueHook>\n    <formattingValue>\n    this.trueValue = this.formater ? this.formater.format(value) : value;\n    this.showValue = this.masker ? this.masker.format(this.trueValue).value : this.trueValue;\n    </formattingValue>\n    <updatingUI>\n    this.setShowValue(this.showValue);\n    </updatingUI>\n    <updateDataModel>\n    this.slice = true;\n    if (parseInt(this.options.rowIndex) > -1) {\n        if ((this.options.rowIndex + '').indexOf('.') > 0) {\n            var childObj = this.getChildVariable();\n            var lastRow = childObj.lastRow;\n            var lastField = childObj.lastField;\n            if (lastRow) lastRow.setValue(lastField, this.trueValue);\n        } else {\n            var rowObj = this.dataModel.getRow(this.options.rowIndex);\n            if (rowObj) rowObj.setValue(this.field, this.trueValue, undefined, undefined, this.validType); \n        }\n    } else {\n        this.dataModel.setValue(this.field, this.trueValue, undefined, undefined, this.validType); \n    }\n    this.slice = false;\n    </updateDataModel>\n}\n"], ["eventBindings", "\nfunction () {\n    <bindingTimeNavEvents>\n    this._timenav.on('change', this._onTimeNavChange, this);\n    this._timenav.on('zoomtoggle', this._onZoomToggle, this);\n    </bindingTimeNavEvents>\n    \n    <bindingStorySliderEvents>\n    this._storyslider.on('change', this._onSlideChange, this);\n    this._storyslider.on('colorchange', this._onColorChange, this);\n    this._storyslider.on('nav_next', this._onStorySliderNext, this);\n    this._storyslider.on('nav_previous', this._onStorySliderPrevious, this);\n    </bindingStorySliderEvents>\n    \n    <bindingMenuBarEvents>\n    this._menubar.on('zoom_in', this._onZoomIn, this);\n    this._menubar.on('zoom_out', this._onZoomOut, this);\n    this._menubar.on('back_to_start', this._onBackToStart, this);\n    </bindingMenuBarEvents>\n}\n"], ["getterFunction", "\nfunction() {\n    var val = this.value;\n    <customGetterLogic>\n    if (this.getter) {\n        val = this.getter.call(this.owner, this.name, val);\n    }\n    </customGetterLogic>\n    return val;\n}\n"], ["resizerStyleSetting", "\nfunction() {\n    var resizerStyle = YAHOO.util.Dom.get(this.handleElId).style;\n    resizerStyle.left = \"auto\";\n    resizerStyle.right = 0;\n    resizerStyle.top = \"auto\";\n    resizerStyle.bottom = 0;\n    resizerStyle.height = this.headCell.offsetHeight+\"px\";\n}\n"], ["initVivaGraph", "\nfunction initVivaGraph(){\n    <setupInitialVariables>\n    g = Viva.Graph.graph();\n    isPaused = false;\n    divGraph = document.getElementById('divGraph');\n    </setupInitialVariables>\n    <appendLoadingMessage>\n    $('#divGraph').append(\"<div id='loadingText' class='hero-body has-text-centered'><h1 class='title'>Loading...</h1></div>\");\n    </appendLoadingMessage>\n    <processNodesFromGraph>\n    console.time(\"nodesFromMWG\");\n    graph.indexes(WORLD, TIME, function (indexNames) {\n        <processIndexNames>\n        var defer = graph.newCounter(indexNames.length);\n        for (var i = 0; i < indexNames.length; ++i) {\n            const indexName = indexNames[i];\n            graph.findAll(WORLD, TIME, indexName, function (nodes) {\n                <addToGlobalNodesProcess>\n                for (var j = 0; j < nodes.length; ++j){\n                    addToGlobalNodes(nodes[j]);\n                }\n                </addToGlobalNodesProcess>\n                defer.count();\n            });\n        }\n        </processIndexNames>\n        </processIndexNames>\n        defer.then(function() {\n            console.timeEnd(\"nodesFromMWG\");\n            console.time(\"nodesToVivagraph\");\n            <addNodesToGraph>\n            var nbNodesToDisplay = (gAllNodes.length > NB_NODES_TO_DISPLAY ? NB_NODES_TO_DISPLAY : gAllNodes.length);\n            for (var i = 0; i < nbNodesToDisplay; ++i){\n                addNodeToGraph(gAllNodes[i]);\n            }\n            for (var i = 0; i < gNodesWithRel.length; ++i){\n                addRelToGraph(gNodesWithRel[i]);\n            }\n            gRootNodes = _.difference(gAllNodes, gChildrenNodes);\n            createTree();\n            var maxChildNodes = getMaxChildNodes();\n            console.timeEnd(\"nodesToVivagraph\");\n            </addNodesToGraph>\n            console.time(\"rendering+loading\");\n            <setupGraphicsAndLayout>\n            graphics = Viva.Graph.View.webglGraphics();\n            graphics\n                .node(function(node){\n                    return Viva.Graph.View.webglSquare(NODE_SIZE, colorsByNodeType[node.data._type]);\n                })\n                .link(function(link) {\n                    return Viva.Graph.View.webglLine(colorsByLinkType[link.data]);\n                });\n            layout = Viva.Graph.Layout.forceDirected(g, {\n                springLength: 200, // default spring length\n                springCoeff: 0.0008,\n                dragCoeff: 0.02\n            });\n            </setupGraphicsAndLayout>\n            <initRendering>\n            renderer = Viva.Graph.View.renderer(g, {\n                graphics: graphics,\n                layout: layout,\n                container: divGraph,\n                prerender: 50\n            });\n            $('#loadingText').hide();\n            renderer.run();\n            </initRendering>\n            console.timeEnd(\"rendering+loading\");\n            console.time(\"table+events\");\n            <postRenderingSetup>\n            createTableLayout();\n            initJQueryEvents();\n            </postRenderingSetup>\n            console.timeEnd(\"table+events\");\n            console.timeEnd(\"all\");\n        });\n    });\n}\n"], ["normalizeVector", "\nfunction(n){\n    var mult = Math.sqrt(n*n/this.dot(this));\n    return new Vec2(this.x*mult, this.y*mult);\n}\n"], ["geometryModelToViewConverter", "\nfunction(geometryModel) {\n    if(geometryModel.isPoint()) {\n        return new cdb.geo.gmaps.PointView(geometryModel);\n    }\n    return new cdb.geo.gmaps.PathView(geometryModel);\n}\n"], ["normalizeAttributes", "\nfunction normalizeAttributes(selector) {\n    selector.walkAttributes((node) => {\n        if (node.value) {\n            <sanitizeAttributeValue>\n            node.value = node.value.replace(/'|\\\\'|\"|\\\\\"/g, '');\n            </sanitizeAttributeValue>\n        }\n    });\n}\n"], ["blockquoteFormat", "\nfunction blockquote(node) {\n    var self = this;\n    self.level++;\n    <combineBlockquoteContent>\n    value = self.all(node).join('\\n');\n    </combineBlockquoteContent>\n    self.level--;\n    <formatBlockquoteValue>\n    value = '.RS ' + (self.level ? 4 : 0) + '\\n' + value + '\\n.RE 0\\n';\n    </formatBlockquoteValue>\n    return value;\n}\n"], ["renderBilevelSunburstChart", "\nfunction() {\n    var self = this;\n    <clearChartContainer>\n    $('#' + self.getId('chart')).html('');\n    </clearChartContainer>\n    <initializeBilevelSunburst>\n    $('#' + self.getId('chart')).bilevelSunburst(\n        { date: self.options.date }, \n        self.treemapData\n    );\n    </initializeBilevelSunburst>\n}\n"], "```\n\nThese annotations identify distinct responsibilities within the provided JavaScript functions, thereby assessing their compliance or violation of the Single Responsibility Principle (SRP). Each annotated section is marked to show whether the functions contain multiple responsibilities or are compliant with SRP. Some functions were divided into annotations to highlight separate cohesive blocks that perform specific tasks, while others were not divided since they perform a single cohesive responsibility."]