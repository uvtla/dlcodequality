[["rayBoundingBoxIntersection", "\nfunction (bbox, out) {\n    var dir = this.direction.array;\n    var origin = this.origin.array;\n    var min = bbox.min.array;\n    var max = bbox.max.array;\n\n    var invdirx = 1 / dir[0];\n    var invdiry = 1 / dir[1];\n    var invdirz = 1 / dir[2];\n\n    var tmin, tmax, tymin, tymax, tzmin, tzmax;\n    if (invdirx >= 0) {\n        tmin = (min[0] - origin[0]) * invdirx;\n        tmax = (max[0] - origin[0]) * invdirx;\n    }\n    else {\n        tmax = (min[0] - origin[0]) * invdirx;\n        tmin = (max[0] - origin[0]) * invdirx;\n    }\n    if (invdiry >= 0) {\n        tymin = (min[1] - origin[1]) * invdiry;\n        tymax = (max[1] - origin[1]) * invdiry;\n    }\n    else {\n        tymax = (min[1] - origin[1]) * invdiry;\n        tymin = (max[1] - origin[1]) * invdiry;\n    }\n\n    if ((tmin > tymax) || (tymin > tmax)) {\n        return null;\n    }\n\n    if (tymin > tmin || tmin !== tmin) {\n        tmin = tymin;\n    }\n    if (tymax < tmax || tmax !== tmax) {\n        tmax = tymax;\n    }\n\n    if (invdirz >= 0) {\n        tzmin = (min[2] - origin[2]) * invdirz;\n        tzmax = (max[2] - origin[2]) * invdirz;\n    }\n    else {\n        tzmax = (min[2] - origin[2]) * invdirz;\n        tzmin = (max[2] - origin[2]) * invdirz;\n    }\n\n    if ((tmin > tzmax) || (tzmin > tmax)) {\n        return null;\n    }\n\n    if (tzmin > tmin || tmin !== tmin) {\n        tmin = tzmin;\n    }\n    if (tzmax < tmax || tmax !== tmax) {\n        tmax = tzmax;\n    }\n    if (tmax < 0) {\n        return null;\n    }\n\n    var t = tmin >= 0 ? tmin : tmax;\n\n    if (!out) {\n        out = new Vector3();\n    }\n    vec3.scaleAndAdd(out.array, origin, dir, t);\n    return out;\n}\n"], ["InitResponse", "\nfunction InitResponse(version, headers) {\n    this.type = InitResponse.TypeCode;\n    this.version = version || 0;\n    this.headers = headers || {};\n}\n"], ["sassLoader", "\nfunction sassLoader(content) {\n  const callback = this.async();\n  const isSync = typeof callback !== 'function';\n  const self = this;\n  const { resourcePath } = this;\n\n  <addNormalizedDependency>\n  function addNormalizedDependency(file) {\n    self.dependency(path.normalize(file));\n  }\n  </addNormalizedDependency>\n\n  if (isSync) {\n    throw new Error('Synchronous compilation is not supported anymore. See https:');\n  }\n\n  <resolveDependencies>\n  let resolve = pify(this.resolve);\n  if (this.getResolve) {\n    resolve = this.getResolve({\n      mainFields: ['sass', 'main'],\n      extensions: ['.scss', '.sass', '.css'],\n    });\n  }\n  </resolveDependencies>\n\n  <normalizeOptions>\n  const options = normalizeOptions(\n    this,\n    content,\n    webpackImporter(resourcePath, resolve, addNormalizedDependency)\n  );\n  </normalizeOptions>\n\n  if (options.data.trim() === '') {\n    callback(null, '');\n    return;\n  }\n\n  <renderSass>\n  const render = getRenderFuncFromSassImpl(\n    options.implementation || getDefaultSassImpl()\n  );\n\n  render(options, (err, result) => {\n    if (err) {\n      formatSassError(err, this.resourcePath);\n      if (err.file) {\n        this.dependency(err.file);\n      }\n      callback(err);\n      return;\n    }\n\n    <processSourceMap>\n    if (result.map && result.map !== '{}') {\n      result.map = JSON.parse(result.map);\n      delete result.map.file;\n      const stdinIndex = result.map.sources.findIndex(\n        (source) => source.indexOf('stdin') !== -1\n      );\n      if (stdinIndex !== -1) {\n        result.map.sources[stdinIndex] = path.relative(\n          process.cwd(), resourcePath\n        );\n      }\n      result.map.sourceRoot = path.normalize(result.map.sourceRoot);\n      result.map.sources = result.map.sources.map(path.normalize);\n    } else {\n      result.map = null;\n    }\n    </processSourceMap>\n\n    result.stats.includedFiles.forEach(addNormalizedDependency);\n\n    callback(null, result.css.toString(), result.map);\n  });\n  </renderSass>\n}\n"], ["_fnCheck", "\nfunction _fnCheck(callback, data) {\n  if (angular.isUndefinedOrNull(data) || angular.isArray(data)) {\n    return; \n  }\n\n  if (angular.isFunction(callback)) {\n    return callback(data, $filter);\n  } else {\n    if (typeof callback === 'boolean') {\n      data = !!data;\n      return data === callback;\n    } else if (angular.isDefined(callback)) {\n      try {\n        var _regex = new RegExp(callback);\n        return _regex.test(data);\n      }\n      catch (err) {\n        if (typeof data === 'string') {\n          return data.indexOf(callback) > -1;\n        } else {\n          return; \n        }\n      }\n    } else {\n      return; \n    }\n  }\n}\n"], ["updateBounds", "\nfunction(x, y) {\n    this.centerLonLat = null;\n\n    if ((this.left == null) || (x < this.left)) {\n        this.left = x;\n    }\n    if ((this.bottom == null) || (y < this.bottom)) {\n        this.bottom = y;\n    }\n    if ((this.right == null) || (x > this.right)) {\n        this.right = x;\n    }\n    if ((this.top == null) || (y > this.top)) {\n        this.top = y;\n    }\n}\n"], ["replacePath", "\nfunction(replace, count, callback) {\n  return pathmap.replace(\n    pathmap.dirname(this, count), replace, callback);\n}\n"], ["SourceCode", "\nfunction SourceCode(text, ast) {\n\n  <validateAst>\n  validate(ast);\n  </validateAst>\n\n  <handleBOM>\n  this.hasBOM = text.charCodeAt(0) === 0xFEFF;\n  this.text = this.hasBOM ? text.slice(1) : text;\n  </handleBOM>\n\n  this.ast = ast;\n  \n  <splitLines>\n  this.lines = SourceCode.splitLines(this.text);\n  </splitLines>\n\n  this.tokensAndComments = ast.tokens.concat(ast.comments).sort(function(left, right) {\n      return left.range[0] - right.range[0];\n  });\n\n  <createTokenStore>\n  var tokenStore = createTokenStore(ast.tokens);\n  Object.keys(tokenStore).forEach(function(methodName) {\n      this[methodName] = tokenStore[methodName];\n  }, this);\n  </createTokenStore>\n\n  <createTokensAndCommentsStore>\n  var tokensAndCommentsStore = createTokenStore(this.tokensAndComments);\n  this.getTokenOrCommentBefore = tokensAndCommentsStore.getTokenBefore;\n  this.getTokenOrCommentAfter = tokensAndCommentsStore.getTokenAfter;\n  </createTokensAndCommentsStore>\n\n  <freezeObjects>\n  Object.freeze(this);\n  Object.freeze(this.lines);\n  </freezeObjects>\n}\n"], ["decodeEntities", "\nfunction decodeEntities(value) {\n  if (!value) {\n    return '';\n  }\n\n  hiddenPre.innerHTML = value.replace(/</g, \"&lt;\");\n  \n  return hiddenPre.textContent;\n}\n"], ["processAttachmentNode", "\nfunction processAttachmentNode(node, options) {\n  options = options || {};\n\n  var data = [].concat(getBasicFields(node, options));\n\n  if (!options.body) {\n      data = data.concat(getExtensionFields(node, options));\n  }\n\n  data.node = node;\n  return data;\n}\n"], ["subclass", "\nfunction subclass(name, definition) {\n  if (typeof name == 'function') {\n    definition = name;\n    name = null;\n  }\n  var parent = constructorToClassMap.get(this);\n  if (parent.final) {\n    throw new Error('Cannot subclass constructors marked final.');\n  }\n\n  return new Class(name, definition, parent).construct();\n}\n"], "```"]