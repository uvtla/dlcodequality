[["getCallbackInfo", "\nfunction getCallbackInfo(node) {\n  <checkNodeCallbackAndLexicalThis>\n  const retv = { isCallback: false, isLexicalThis: false };\n  let currentNode = node;\n  let parent = node.parent;\n\n  while (currentNode) {\n    switch (parent.type) {\n      case \"LogicalExpression\":\n      case \"ConditionalExpression\":\n        break;\n      case \"MemberExpression\":\n        if (parent.object === currentNode &&\n          !parent.property.computed &&\n          parent.property.type === \"Identifier\" &&\n          parent.property.name === \"bind\" &&\n          parent.parent.type === \"CallExpression\" &&\n          parent.parent.callee === parent\n        ) {\n          retv.isLexicalThis = (\n            parent.parent.arguments.length === 1 &&\n            parent.parent.arguments[0].type === \"ThisExpression\"\n          );\n          parent = parent.parent;\n        } else {\n          return retv;\n        }\n        break;\n      case \"CallExpression\":\n      case \"NewExpression\":\n        if (parent.callee !== currentNode) {\n          retv.isCallback = true;\n        }\n        return retv;\n      default:\n        return retv;\n    }\n    currentNode = parent;\n    parent = parent.parent;\n  }\n  throw new Error(\"unreachable\");\n</checkNodeCallbackAndLexicalThis>\n}\n"], ["serialize", "\nfunction serialize(formEl, options, nodeCallback) {\n  <setupSerializationEnvironment>\n  var parent = makeElement(formEl),\n      opts = getOptions(options),\n      elements = getElements(parent, opts.skipDisabled, opts.skipReadOnly),\n      result = {},\n      el, key, textKey;\n  </setupSerializationEnvironment>\n  <processFormElements>\n  for (var i = 0, l = elements.length; i < l; i++) {\n      el = elements[i];\n      entry = null;\n      if (textKey = el.getAttribute(_defaults.attributeText)) {\n          var textEntry = getTextEntryFromInput(el, textKey);\n          if (isValidValue(textEntry.value, opts.skipFalsy))\n              saveEntryToResult(result, textEntry, opts.delimiter);\n      }\n      if (!isInput(el))\n          continue;\n      if (!(key = (el.name || opts.useIdOnEmptyName && el.id)))\n          continue;\n      var entry = getEntryFromInput(el, key);\n      if (nodeCallback)\n          entry = nodeCallback(el, entry);\n      if (entry && isValidValue(entry.value, opts.skipFalsy))\n          saveEntryToResult(result, entry, opts.delimiter);\n  }\n  </processFormElements>\n  return result;\n}\n"], ["calculateWeekNumber", "\n  var thursday = fidjDayOfSameWeek(date, 4);\n  var fourthJanuary = new Date(thursday.getFullYear(), 0, 4, 0, 0, 0, 0);\n  var thursdayOfWeek1 = fidjDayOfSameWeek(fourthJanuary, 4);\n  var nbDays = Math.round((thursday.getTime() - thursdayOfWeek1.getTime()) / 86400000);\n  "], ["injectManifest", "\nasync function injectManifest(config) {\n  <handleDeprecationsAndConfigValidation>\n  const deprecationWarnings = checkForDeprecatedOptions(config);\n  const options = validate(config, injectManifestSchema);\n  if (path.normalize(config.swSrc) === path.normalize(config.swDest)) {\n    throw new Error(errors['same-src-and-dest']);\n  }\n  </handleDeprecationsAndConfigValidation>\n\n  <prepareRegexAndEntries>\n  const globalRegexp = new RegExp(options.injectionPointRegexp, 'g');\n  const {count, size, manifestEntries, warnings} = await getFileManifestEntries(options);\n  </prepareRegexAndEntries>\n\n  <readAndInjectServiceWorker>\n  let swFileContents;\n  try {\n    swFileContents = await fse.readFile(config.swSrc, 'utf8');\n  } catch (error) {\n    throw new Error(`${errors['invalid-sw-src']} ${error.message}`);\n  }\n  const injectionResults = swFileContents.match(globalRegexp);\n  assert(injectionResults, errors['injection-point-not-found'] +\n    (options.injectionPointRegexp === defaults.injectionPointRegexp ? 'workbox.precaching.precacheAndRoute([])' : options.injectionPointRegexp));\n  assert(injectionResults.length === 1, errors['multiple-injection-points'] + ` ${options.injectionPointRegexp}`);\n  const entriesString = JSON.stringify(manifestEntries, null, 2);\n  swFileContents = swFileContents.replace(globalRegexp, `$1${entriesString}$2`);\n  </readAndInjectServiceWorker>\n\n  <writeServiceWorkerFile>\n  try {\n    await fse.mkdirp(path.dirname(options.swDest));\n  } catch (error) {\n    throw new Error(errors['unable-to-make-injection-directory'] + ` '${error.message}'`);\n  }\n  await fse.writeFile(config.swDest, swFileContents);\n  </writeServiceWorkerFile>\n\n  <aggregateWarnings>\n  warnings.push(...deprecationWarnings);\n  </aggregateWarnings>\n\n  return {count, size, warnings};\n}\n"], ["initializePropertiesArray", "\n  this.properties = []\n  for (var i = 0, j = arguments.length; i < j; i ++)\n    this.properties.push(arguments[i])\n  "], ["createNamespace", "\n  var parts = identifier.split('.');\n  var i = 0;\n  parent = parent || window;\n  while (i < parts.length) {\n      parent[parts[i]] = parent[parts[i]] || {};\n      parent = parent[parts[i]];\n      i++;\n  }\n  "], ["_cleanUpTOCChildren", "\nfunction _cleanUpTOCChildren(node) {\n  <removeInvalidChildren>\n  if (!Array.isArray(node.children)) {\n    return node;\n  }\n  if (_isExampleOrParameterLink(node)) {\n    return null;\n  }\n  const filteredChildren = node.children.reduce((accu, nd) => {\n    accu.push(_cleanUpTOCChildren(nd));\n    return accu;\n  }, []).filter(n => n);\n  if (!filteredChildren.length) {\n    return null;\n  }\n  </removeInvalidChildren>\n  \n  <returnCleanedNode>\n  return {\n    ...node,\n    children: filteredChildren\n  };\n  </returnCleanedNode>\n}\n"], ["chainNodeInitialization", "\n  this._parent = parent;\n  this._key = key;\n  this._watching = value === undefined;\n  this._chains = undefined;\n  this._object = undefined;\n  this.count = 0;\n  this._value = value;\n  this._paths = {};\n  "], ["setupWatching", "\n  if (this._watching) {\n    this._object = parent.value();\n    if (this._object) {\n      addChainWatcher(this._object, this._key, this);\n    }\n  }\n  "], ["findLayerByName", "\n  var layerName = opts.name,\n      layer = null\n  this.children.forEach(function (item) {\n      if (item instanceof TMXLayer && item.layerName == layerName) {\n          layer = item\n      }\n  })\n  "], "  if (layer !== null) {\n      return layer\n  }\n}\n```\nThis function seems compliant with SRP as its single responsibility is to find and return a layer by its name."]