[["pageHeight", "\nfunction pageHeight() {\n  return win.innerHeight != null ? win.innerHeight : doc.documentElement && doc.documentElement.clientHeight != null ? doc.documentElement.clientHeight : doc.body != null ? doc.body.clientHeight : null;\n}\n"], ["checkForMissingParams", "\nfunction(req, requiredParams) {\n\n  var missingParams = [];\n  _.forEach(requiredParams, function(requiredParam) {\n    if (\n      Mixins.isNullOrUndefined(req.params && req.params[requiredParam]) &&\n      Mixins.isNullOrUndefined(req.query && req.query[requiredParam]) &&\n      Mixins.isNullOrUndefined(req.body && req.body[requiredParam])\n    ) {\n      missingParams.push(requiredParam);\n    }\n  });\n  return missingParams;\n}\n"], ["modifyFeatureTransform", "\nfunction(mods) {\n  <validateModification>\n  if(!this._setfeature) {\n      this.scale *= (mods.scale || 1);\n      this.ratio *= (mods.ratio || 1);\n      var oldRotation = this.rotation;\n      this.rotation = (this.rotation + (mods.rotation || 0)) % 360;\n  </validateModification>\n  \n  <applyTransformationAndRedraw>\n  if(this.events.triggerEvent(\"beforetransform\", mods) !== false) {\n      var feature = this.feature;\n      var geom = feature.geometry;\n      var center = this.center;\n      geom.rotate(-oldRotation, center);\n      if(mods.scale || mods.ratio) {\n          geom.resize(mods.scale, center, mods.ratio);\n      } else if(mods.center) {\n          feature.move(mods.center.getBounds().getCenterLonLat());\n      }\n      geom.rotate(this.rotation, center);\n      this.layer.drawFeature(feature);\n      feature.toState(OpenLayers.State.UPDATE);\n      this.events.triggerEvent(\"transform\", mods);\n  }\n  </applyTransformationAndRedraw>\n\n  <finalizeModification>\n  this.layer.drawFeature(this.box, this.renderIntent);\n  this.drawHandles();\n  </finalizeModification>\n}\n"], ["helpCmdAliasesProcess", "\nfunction func_help_cmd_aliases(arg_terminal_feature, arg_response, cmd, opd1, opd2, opd3)\n{\n  <retrieveAliases>\n  arg_response.result.value = []\n  if ( arg_terminal_feature && arg_terminal_feature.is_terminal_feature && arg_terminal_feature._terminal)\n  {\n      const features = arg_terminal_feature._terminal.get_features()\n\n      const feature_name = opd1 ? opd1 : arg_terminal_feature._terminal.get_mode()\n      if (! feature_name)\n      {\n          arg_response.result.error = 'no selected feature for command :[' + cmd + ']'\n          return arg_response\n      }\n\n      const feature = (feature_name in features) ? features[feature_name] : undefined\n      if (! feature)\n      {\n          arg_response.result.error = 'no feature [' + feature_name + '] for command :[' + cmd + ']'\n          return arg_response\n      }\n\n      const aliases = feature.get_aliases()\n      console.log(context + ':eval aliases=', aliases)\n\n      \n      arg_response.result.value = aliases\n      </retrieveAliases>\n      <formatAliases>\n      arg_response.result.str = func_help_format_aliases(aliases)\n      </formatAliases>\n  }\n}\n"], ["cubeCreation", "\nfunction (options) {\n  <prepareParameters>\n  let c\n  let r\n  let corner1\n  let corner2\n  options = options || {}\n  if (('corner1' in options) || ('corner2' in options)) {\n    if (('center' in options) || ('radius' in options)) {\n      throw new Error('cube: should either give a radius and center parameter, or a corner1 and corner2 parameter')\n    }\n    corner1 = parseOptionAs3DVector(options, 'corner1', [0, 0, 0])\n    corner2 = parseOptionAs3DVector(options, 'corner2', [1, 1, 1])\n    c = corner1.plus(corner2).times(0.5)\n    r = corner2.minus(corner1).times(0.5)\n  } else {\n    c = parseOptionAs3DVector(options, 'center', [0, 0, 0])\n    r = parseOptionAs3DVector(options, 'radius', [1, 1, 1])\n  }\n  r = r.abs() \n  </prepareParameters>\n\n  <constructCube>\n  let result = fromPolygons([\n    // Polygon construction data,\n    // ...\n  ].map(function (info) {\n    let vertices = info[0].map(function (i) {\n      let pos = new Vector3(\n        c.x + r.x * (2 * !!(i & 1) - 1), c.y + r.y * (2 * !!(i & 2) - 1), c.z + r.z * (2 * !!(i & 4) - 1))\n      return new Vertex3(pos)\n    })\n    return new Polygon3(vertices, null )\n  }))\n  </constructCube>\n\n  <setProperties>\n  result.properties.cube = new Properties()\n  result.properties.cube.center = new Vector3(c)\n  \n  result.properties.cube.facecenters = [\n    // Connectors construction data,\n    // ...\n  ]\n  </setProperties>\n\n  return result\n}\n"], ["dynamicEntriesSetup", "\nfunction entries(lowestTier) {\n  const max = 3;\n  const obj = {\n    additionalProperties: {\n      type: 'object',\n      oneOf: [],\n    },\n    description: 'An object.',\n  };\n  for (let i = lowestTier; i <= max; i += 1) {\n    obj.additionalProperties.oneOf.push({\n      $ref: `#/definitions/entity-tier${i}`,\n    });\n  }\n  return obj;\n}\n"], ["initializerWithBroadcast", "\nfunction() {\n  <initializeAttributesAndStates>\n  this.attributes = [\"gui\"];\n  this._arrivals = Object.create(null);\n  this._channels = [];\n  this._spirits = {\n    incoming: [], \n    inside: Object.create(null), \n    outside: Object.create(null) \n  };\n  </initializeAttributesAndStates>\n\n  <setupBroadcastListener>\n  gui.Broadcast.add(gui.BROADCAST_TODOM, {\n    onbroadcast: function() {\n      gui._getready();\n      gui.Guide.$startGuiding();\n      gui._nowready();\n    }\n  });\n  </setupBroadcastListener>\n\n  return this;\n}\n"], ["createBlockTemplate", "\nfunction (data) {\n  <calculateRewards>\n  var reward = data.coinbasevalue;\n  var rewardToPool = reward;\n  var txOutputBuffers = [];\n\n  for (var i = 0; i < context.fees.recipients.length; i++) {\n    {\n      var recipient = context.fees.recipients[i];\n      var recipientReward = Math.floor(recipient.percent * reward);\n      rewardToPool -= recipientReward;\n      txOutputBuffers.push(Buffer.concat([\n          utils.packInt64LE(recipientReward),\n          utils.varIntBuffer(recipient.script.length),\n          recipient.script\n      ]));\n    }\n  </calculateRewards>\n\n  <preparePoolReward>\n  txOutputBuffers.unshift(Buffer.concat([\n          utils.packInt64LE(rewardToPool),\n          utils.varIntBuffer(context.wallet.central.script.length),\n          context.wallet.central.script\n      ]));\n  </preparePoolReward>\n\n  <assembleTransactionOutputs>\n  return Buffer.concat([\n    utils.varIntBuffer(txOutputBuffers.length),\n    Buffer.concat(txOutputBuffers)\n  ]);\n  </assembleTransactionOutputs>\n}\n"], ["pathMatching", "\nfunction isMatchingPath(parentIndex, indexOrKey) {\n  <evaluateMatchingPath>\n  var pane = lxSelect.choicesViewSize === 'large' ? lxSelect.panes[parentIndex] : lxSelect.openedPanes[parentIndex];\n\n  if (angular.isUndefined(pane)) {\n      return;\n  }\n\n  var key = indexOrKey;\n  if (angular.isObject(pane) && angular.isNumber(indexOrKey)) {\n      key = (Object.keys(pane) || [])[indexOrKey];\n  }\n\n  if (parentIndex === 0) {\n      return _findIndex(lxSelect.matchingPaths, key) !== -1;\n  }\n\n  var previous = toggledPanes[parentIndex - 1];\n  if (angular.isUndefined(previous)) {\n      return false;\n  }\n\n  return _findIndex(lxSelect.matchingPaths, previous.path + '.' + key) !== -1;\n  </evaluateMatchingPath>\n}\n"], ["compileQueryDefinition", "\nfunction queryDef(flags, id, bindings) {\n  <constructQueryDefinition>\n  var bindingDefs = [];\n  for (var propName in bindings) {\n      var bindingType = bindings[propName];\n      bindingDefs.push({ propName: propName, bindingType: bindingType });\n  }\n  return {\n      nodeIndex: -1,\n      parent: null,\n      renderParent: null,\n      bindingIndex: -1,\n      outputIndex: -1,\n      checkIndex: -1, flags: flags,\n      childFlags: 0,\n      directChildFlags: 0,\n      childMatchedQueries: 0,\n      ngContentIndex: -1,\n      matchedQueries: {},\n      matchedQueryIds: 0,\n      references: {},\n      childCount: 0,\n      bindings: [],\n      bindingFlags: 0,\n      outputs: [],\n      element: null,\n      provider: null,\n      text: null,\n      query: { id: id, filterId: filterQueryId(id), bindings: bindingDefs },\n      ngContent: null\n  };\n  </constructQueryDefinition>\n}\n"], "```"]