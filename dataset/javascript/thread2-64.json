[["unbind", "\nfunction unbind () {\n    _inbox.unbindSync(`tcp:\n    _inbox.removeListener('message', _onInboxMessage)\n    return resolver\n}\n"], ["createVertexBufferObjects", "\nfunction createVertexBufferObjects(renderState) {\n    <checkGeometryData>\n    if (m_geomData) {\n    </checkGeometryData>\n        <setupRenderContext>\n        if (renderState) {\n            m_context = renderState.m_context;\n        }\n        </setupRenderContext>\n        var numberOfSources = m_geomData.numberOfSources(),\n            i, j, k, bufferId = null, keys, ks, numberOfPrimitives, data;\n        \n        <createSourceBuffers>\n        for (i = 0; i < numberOfSources; i += 1) {\n            bufferId = m_context.createBuffer();\n            m_context.bindBuffer(vgl.GL.ARRAY_BUFFER, bufferId);\n            data = m_geomData.source(i).data();\n            if (!(data instanceof Float32Array)) {\n                data = new Float32Array(data);\n            }\n            m_context.bufferData(vgl.GL.ARRAY_BUFFER, data,\n                          m_dynamicDraw ? vgl.GL.DYNAMIC_DRAW :\n                          vgl.GL.STATIC_DRAW);\n\n            keys = m_geomData.source(i).keys();\n            ks = [];\n\n            for (j = 0; j < keys.length; j += 1) {\n                ks.push(keys[j]);\n            }\n\n            m_bufferVertexAttributeMap[i] = ks;\n            m_buffers[i] = bufferId;\n        }\n        </createSourceBuffers>\n\n        <createPrimitiveBuffers>\n        numberOfPrimitives = m_geomData.numberOfPrimitives();\n        for (k = 0; k < numberOfPrimitives; k += 1) {\n            bufferId = m_context.createBuffer();\n            m_context.bindBuffer(vgl.GL.ARRAY_BUFFER, bufferId);\n            m_context.bufferData(vgl.GL.ARRAY_BUFFER,\n              m_geomData.primitive(k).indices(), vgl.GL.STATIC_DRAW);\n            m_buffers[i] = bufferId;\n            i += 1;\n        }\n        </createPrimitiveBuffers>\n\n        <timestampModification>\n        m_glCompileTimestamp.modified();\n        </timestampModification>\n    }\n}\n"], ["updateChangelog", "\nfunction updateChangelog(pkgVersion, releaseNote) {\n    <retrievePackageData>\n    const [pkgPath, pkg] = getPackageObject();\n    const msg = getCommitTagMessage(pkg.version);\n    </retrievePackageData>\n    <updateChangelogFile>\n    return updateChangelogInternal(pkgVersion, releaseNote)\n        .then(output => {\n            return `updated CHANGELOG for version ${pkgVersion}`;\n        });\n    </updateChangelogFile>\n}\n"], ["removeClass", "\nfunction removeClass(elm, name) {\n    if (name) {\n        <processClassName>\n        var cls = className(elm),\n            names;\n\n        if (langx.isString(name)) {\n            names = name.split(/\\s+/g);\n        } else {\n            names = name;\n        }\n        </processClassName>\n\n        <removeClassNames>\n        names.forEach(function(klass) {\n            var re = classRE(klass);\n            if (cls.match(re)) {\n                cls = cls.replace(re, \" \");\n            }\n        });\n\n        className(elm, cls.trim());\n        </removeClassNames>\n    } else {\n        <clearClassName>\n        className(elm, \"\");\n        </clearClassName>\n    }\n\n    return this;\n}\n"], ["unnamedRedirectFunction", "\nfunction (code, location) {\n    <determineParameters>\n    if (arguments.length === 1) {\n        location = code;\n        code = 302;\n    }\n    </determineParameters>\n\n    <performRedirect>\n    render(code, EMPTY_STRING, location);\n    </performRedirect>\n}\n"], ["resolveReflectiveFactory", "\nfunction resolveReflectiveFactory(provider) {\n    var  factoryFn;\n    var  resolvedDeps;\n    <selectProviderType>\n    if (provider.useClass) {\n        var  useClass = resolveForwardRef(provider.useClass);\n        factoryFn = reflector.factory(useClass);\n        resolvedDeps = _dependenciesFor(useClass);\n    }\n    else if (provider.useExisting) {\n        factoryFn = function (aliasInstance) { return aliasInstance; };\n        resolvedDeps = [ReflectiveDependency.fromKey(ReflectiveKey.get(provider.useExisting))];\n    }\n    else if (provider.useFactory) {\n        factoryFn = provider.useFactory;\n        resolvedDeps = constructDependencies(provider.useFactory, provider.deps);\n    }\n    else {\n        factoryFn = function () { return provider.useValue; };\n        resolvedDeps = _EMPTY_LIST;\n    }\n    </selectProviderType>\n    <createResolvedFactory>\n    return new ResolvedReflectiveFactory(factoryFn, resolvedDeps);\n    </createResolvedFactory>\n}\n"], ["initialize", "\nfunction initialize (self) {\n    <logInitialization>\n    console.log(self.options.manline);\n    console.log(\"WEBSEED: \" + self.options.name + \" initialize ...\");\n    </logInitialization>\n    <processActionsForSelf>\n    processActions(self);\n    </processActionsForSelf>\n}\n"], ["unnamedElementTraversalFunction", "\nfunction(element, fn, all) {\n    <traverseElements>\n    return Y.DOM.elementByAxis(element, PREVIOUS_SIBLING, fn, all);\n    </traverseElements>\n}\n"], ["filterAccessKeys", "\nfunction filterAccessKeys(node) {\n    <filterNodeBasedOnConditions>\n    var notAllowedLocalNames = [\"menu\", \"menubar\", \"menupopup\", \"popupset\"];\n\n    if (!node.disabled && !node.collapsed && !node.hidden &&\n        notAllowedLocalNames.indexOf(node.localName) == -1) {\n        \n        \n        if (node.parentNode && (node.parentNode.localName == \"prefwindow\" &&\n                                node.parentNode.currentPane.id != node.id) ||\n            ((node.parentNode.localName == \"tabpanels\" ||\n            node.parentNode.localName == \"deck\") &&\n            node.parentNode.selectedPanel.id != node.id)) {\n        return domUtils.DOMWalker.FILTER_REJECT;\n        \n        } else if (node.accessKey) {\n        return domUtils.DOMWalker.FILTER_ACCEPT;\n        } else {\n        return domUtils.DOMWalker.FILTER_SKIP;\n        }\n    } else {\n        \n        return domUtils.DOMWalker.FILTER_REJECT;\n    }\n    </filterNodeBasedOnConditions>\n}\n"], ["createLayers", "\nfunction createLayers(sources) {\n    <initializeLayerArray>\n    const len = sources.length;\n    const layers = new Array(len);\n    </initializeLayerArray>\n    <populateLayers>\n    for (let i = 0; i < len; ++i) {\n        layers[i] = createLayer(sources[i]);\n    }\n    </populateLayers>\n    <returnLayers>\n    return layers;\n    </returnLayers>\n}\n"], ""]