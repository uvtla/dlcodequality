[["setUpReadable", "\nfunction setUpReadable(stream, deserialize) {\n  <setDeserialization>\n  stream.deserialize = common.wrapIgnoreNull(deserialize);\n  </setDeserialization>\n  <streamInitialization>\n  stream.finished = false;\n  stream.reading = false;\n  </streamInitialization>\n\n  <defineTerminateFunction>\n  stream.terminate = function() {\n    stream.finished = true;\n    stream.on('data', function() {});\n  };\n  </defineTerminateFunction>\n\n  <registerCancelEvent>\n  stream.on('cancelled', function() {\n    stream.terminate();\n  });\n  </registerCancelEvent>\n}\n"], ["setFontFamily", "\nfunction(){\n    <determineFontByConfig>\n    var isgothic = this.puzzle.getConfig('font')===1;\n    if(this.puzzle.pzpr.env.OS.Android){\n      this.fontfamily = (isgothic ? 'Helvetica, Verdana, Arial, ' : '\"Times New Roman\", ');\n    }\n    else{ this.fontfamily = '';}\n    </determineFontByConfig>\n    <appendToFontFamily>\n    this.fontfamily += (isgothic ? 'sans-serif' : 'serif');\n    </appendToFontFamily>\n}\n"], ["buildParam", "\nfunction buildParam(key: string, value: any, traditional?: boolean): Array<string> {\n  <validateInput>\n  let result = [];\n  if (value === null || value === undefined) {\n    return result;\n  }\n  </validateInput>\n  <handleArray>\n  if (Array.isArray(value)) {\n    for (let i = 0, l = value.length; i < l; i++) {\n      if (traditional) {\n        result.push(`${encodeKey(key)}=${encode(value[i])}`);\n      } else {\n        let arrayKey = key + '[' + (typeof value[i] === 'object' && value[i] !== null ? i : '') + ']';\n        result = result.concat(buildParam(arrayKey, value[i]));\n      }\n    }\n  } \n  </handleArray>\n  <handleObject>\n  else if (typeof (value) === 'object' && !traditional) {\n    for (let propertyName in value) {\n      result = result.concat(buildParam(key + '[' + propertyName + ']', value[propertyName]));\n    }\n  } \n  </handleObject>\n  <handlePrimitive>\n  else {\n    result.push(`${encodeKey(key) }=${encode(value) }`);\n  }\n  </handlePrimitive>\n  return result;\n}\n"], ["cylinder", "\nfunction cylinder (params) {\n  <setDefaultParameters>\n  const defaults = {\n    r: 1,\n    r1: 1,\n    r2: 1,\n    h: 1,\n    fn: 32,\n    round: false\n  }\n  let {r1, r2, h, fn, round} = Object.assign({}, defaults, params)\n  let offset = [0, 0, 0]\n  let a = arguments\n  </setDefaultParameters>\n\n  <parameterAdjustments>\n  if (params && params.d) {\n    r1 = r2 = params.d / 2\n  }\n  if (params && params.r) {\n    r1 = params.r\n    r2 = params.r\n  }\n  if (params && params.h) {\n    h = params.h\n  }\n  if (params && (params.r1 || params.r2)) {\n    r1 = params.r1\n    r2 = params.r2\n    if (params.h) h = params.h\n  }\n  if (params && (params.d1 || params.d2)) {\n    r1 = params.d1 / 2\n    r2 = params.d2 / 2\n  }\n\n  if (a && a[0] && a[0].length) {\n    a = a[0]\n    r1 = a[0]\n    r2 = a[1]\n    h = a[2]\n    if (a.length === 4) fn = a[3]\n  }\n  </parameterAdjustments>\n\n  <constructObject>\n  let object\n  if (params && (params.start && params.end)) {\n    object = round\n      ? _roundedCylinder({start: params.start, end: params.end, radiusStart: r1, radiusEnd: r2, resolution: fn})\n      : _cylinder({start: params.start, end: params.end, radiusStart: r1, radiusEnd: r2, resolution: fn})\n  } else {\n    object = round\n      ? _roundedCylinder({start: [0, 0, 0], end: [0, 0, h], radiusStart: r1, radiusEnd: r2, resolution: fn})\n      : _cylinder({start: [0, 0, 0], end: [0, 0, h], radiusStart: r1, radiusEnd: r2, resolution: fn})\n    let r = r1 > r2 ? r1 : r2\n    if (params && params.center && params.center.length) { \n      offset = [params.center[0] ? 0 : r, params.center[1] ? 0 : r, params.center[2] ? -h / 2 : 0]\n    } else if (params && params.center === true) {\n      offset = [0, 0, -h / 2]\n    } else if (params && params.center === false) {\n      offset = [0, 0, 0]\n    }\n    object = (offset[0] || offset[1] || offset[2]) ? translate(offset, object) : object\n  }\n  </constructObject>\n  \n  return object\n}\n"], ["Advisor", "\nfunction Advisor(type, advised, advisedFunc = null){\n  <assignValuesAndFreeze>\n    this.type = type;\n    this.advised = advised;\n    this.advisedMethod = advisedFunc;\n    Object.freeze(this);\n  </assignValuesAndFreeze>\n}\n"], ["storedPixelDataToImageData", "\nfunction storedPixelDataToImageData (image) {\n  <initializeVariables>\n  const minPixelValue = image.minPixelValue;\n  let canvasImageDataIndex = 0;\n  let storedPixelDataIndex = 0;\n  \n  const numStoredPixels = image.width * image.height * 4;\n  const numOutputPixels = image.width * image.height * 3;\n  const storedPixelData = image.getPixelData();\n  const data = new Uint8Array(numOutputPixels);\n  </initializeVariables>\n  \n  <convertData>\n  if (minPixelValue < 0) {\n    while (storedPixelDataIndex < numStoredPixels) {\n      data[canvasImageDataIndex++] = storedPixelData[storedPixelDataIndex++] + (-minPixelValue); \n      data[canvasImageDataIndex++] = storedPixelData[storedPixelDataIndex++] + (-minPixelValue); \n      data[canvasImageDataIndex++] = storedPixelData[storedPixelDataIndex++] + (-minPixelValue); \n      storedPixelDataIndex += 1; \n    }\n  } else {\n    while (storedPixelDataIndex < numStoredPixels) {\n      data[canvasImageDataIndex++] = storedPixelData[storedPixelDataIndex++]; \n      data[canvasImageDataIndex++] = storedPixelData[storedPixelDataIndex++]; \n      data[canvasImageDataIndex++] = storedPixelData[storedPixelDataIndex++]; \n      storedPixelDataIndex += 1; \n    }\n  }\n  </convertData>\n\n  return data;\n}\n"], ["replaceBuildVariables", "\nfunction replaceBuildVariables(fileContent, srcPath){\n  <fileProcessing>\n        grunt.verbose.writeln(\"Processing : \" + srcPath );\n\n        return fileContent\n            .replace( /@BUILD/g, buildId)\n            .replace( /@VERSION/g, grunt.template.process(\"<%= pkg.version %>\"))\n            .replace( /@DATE/g, buildDate )\n            .replace( /@YEAR/g, buildYear )\n            .replace( /@AUTHOR/g, grunt.template.process(\"<%= pkg.author %>\") );\n  </fileProcessing>\n}\n"], ["ElmRunner", "\nfunction ElmRunner(filename, baseDir, defaults) {\n  <pathCalculations>\n  var relativePath = path.relative(baseDir, filename);\n  var baseName = path.basename(filename, path.extname(filename));\n  </pathCalculations>\n\n  <assignVariables>\n  this.filename = filename;\n  this.defaults = defaults || {};\n\n  this.moduleName = resolveModuleName(relativePath);\n  this.outputPath = path.join(path.dirname(filename), baseName + \".js\");\n  </assignVariables>\n\n  <compileAndExecute>\n  var self = this;\n  withCheckedPath(this.outputPath, function() {\n    try {\n      compile.call(self);\n      execute.call(self);\n      wrap.call(self);\n    } catch (e) {\n      return e;\n    }\n\n    return true;\n  });\n  </compileAndExecute>\n}\n"], ["connect", "\nfunction connect() {\n  <logging>\n  log('debug', `Connecting to Postgres at ${POSTGRES_HOST}:${POSTGRES_PORT}`);\n  </logging>\n\n  <initializeKnex>\n  knex = knexLib({\n    client: 'pg',\n    connection: {\n      host: POSTGRES_HOST,\n      user: POSTGRES_USER,\n      password: POSTGRES_PASSWORD,\n      database: POSTGRES_DB,\n      port: POSTGRES_PORT\n    },\n    pool: { min: CONNECTION_POOL_MIN, max: CONNECTION_POOL_MAX }\n  });\n  </initializeKnex>\n\n  <handleDatabaseConnection>\n  \n  return knex.table('information_schema.tables').first()\n    .catch(createDBIfNotExists);\n  </handleDatabaseConnection>\n}\n"], ["parseStatements", "\nfunction parseStatements(lex, endTokens, isRoot) {\n  <prepareEndTokens>\n    endTokens = Array.isArray(endTokens) ? endTokens : [endTokens];\n  </prepareEndTokens>\n  <initializeVariables>\n    var statements = [];\n    var temp = lex.peek();\n  </initializeVariables>\n  <parseLoop>\n    while (endTokens.indexOf(temp) === -1 &&\n           (temp.type && endTokens.indexOf(temp.type) === -1)) {\n        var statement = parseStatement(lex, isRoot);\n        if (!statement) {\n            throw new Error('Invalid statement');\n        }\n        temp = lex.peek();\n        statements.push(statement);\n    }\n  </parseLoop>\n  return statements;\n}\n"], ""]