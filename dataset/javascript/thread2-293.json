[["safelyUnmountComponent", "\nfunction (safely) {\n  <tagSwitch>\n  switch (this._tag) {\n    case 'audio':\n    case 'form':\n    case 'iframe':\n    case 'img':\n    case 'link':\n    case 'object':\n    case 'source':\n    case 'video':\n      <removeListeners>\n      var listeners = this._wrapperState.listeners;\n      if (listeners) {\n        for (var i = 0; i < listeners.length; i++) {\n          listeners[i].remove();\n        }\n      }\n      </removeListeners>\n      break;\n    case 'html':\n    case 'head':\n    case 'body':\n      <handleUnremovableComponents>\n      true ?  false ? invariant(false, '<%s> tried to unmount. Because of cross-browser quirks it is impossible to unmount some top-level components (eg <html>, <head>, and <body>) reliably and efficiently. To fix this, have a single top-level component that never unmounts render these elements.', this._tag) : _prodInvariant('66', this._tag) : void 0;\n      </handleUnremovableComponents>\n      break;\n  }\n  </tagSwitch>\n\n  <cleanUpComponent>\n  this.unmountChildren(safely);\n  ReactDOMComponentTree.uncacheNode(this);\n  EventPluginHub.deleteAllListeners(this);\n  this._rootNodeID = 0;\n  this._domID = 0;\n  this._wrapperState = null;\n  </cleanUpComponent>\n\n  <devEnvironmentCleanup>\n  if (false) {\n    setAndValidateContentChildDev.call(this, null);\n  }\n  </devEnvironmentCleanup>\n}\n"], ["copyRuntimeFiles", "\nfunction () {\n  var outputDir = path.join(copyDir, jalangiRuntimeDir);\n  mkdirp.sync(outputDir);\n  var copyFile = function (srcFile) {\n    if (jalangiRoot) {\n      srcFile = path.join(jalangiRoot, srcFile);\n    }\n    var outputFile = path.join(outputDir, path.basename(srcFile));\n    fs.writeFileSync(outputFile, String(fs.readFileSync(srcFile)));\n  };\n  instUtil.headerSources.forEach(copyFile);\n  if (analyses) {\n    analyses.forEach(function (f) {\n      var outputFile = path.join(outputDir, path.basename(f));\n      fs.writeFileSync(outputFile, String(fs.readFileSync(f)));\n    });\n  }\n}\n"], ["setupShapeColor", "\nfunction setupShapeColor() {\n  var bgOpy = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : bgOpacity;\n  r.eleFillStyle(context, node, bgOpy);\n}\n"], ["setupContainerStyles", "\nfunction($container) {\n  <retrieveStyles>\n  var styles = window.getComputedStyle($container, null);\n  var position = styles.getPropertyValue(\"position\");\n  var overflow = styles.getPropertyValue(\"overflow\");\n  var display = styles.getPropertyValue(\"display\");\n  </retrieveStyles>\n\n  <modifyStyles>\n  if (!position || position === \"static\") {\n    $container.style.position = \"relative\";\n  }\n  if (overflow !== \"hidden\") {\n    $container.style.overflow = \"hidden\";\n  }\n  if (!display || display === \"inline\") {\n    $container.style.display = \"block\";\n  }\n  if ($container.clientHeight === 0) {\n    $container.style.height = \"100%\";\n  }\n  </modifyStyles>\n\n  <addClassToContainer>\n  if ($container.className.indexOf(\"object-fit-polyfill\") === -1) {\n    $container.className = $container.className + \" object-fit-polyfill\";\n  }\n  </addClassToContainer>\n}\n"], ["ScrapeErrorConstructor", "\nfunction ScrapeError(msg, response, bodyString) {\n  Error.call(this, msg);\n\n  this.response = response;\n  this.bodyString = bodyString;\n}\n"], ["processResponseSuggestions", "\nfunction (response) {\n  var that = this,\n      suggestions;\n\n  <validateResponse>\n  if (!response || !$.isArray(response.suggestions)) {\n      return false;\n  }\n  </validateResponse>\n\n  <verifyAndSetSuggestions>\n  that.verifySuggestionsFormat(response.suggestions);\n  that.setUnrestrictedValues(response.suggestions);\n  </verifyAndSetSuggestions>\n\n  <applyCustomFetchFunction>\n  if ($.isFunction(that.options.onSuggestionsFetch)) {\n      suggestions = that.options.onSuggestionsFetch.call(that.element, response.suggestions);\n      if ($.isArray(suggestions)) {\n          response.suggestions = suggestions;\n      }\n  }\n  </applyCustomFetchFunction>\n\n  return true;\n}\n"], ["NativePullQueueConstructor", "\nfunction NativePullQueue(obj) {\n  if (!(this instanceof NativePullQueue)) {\n    return new NativePullQueue(obj);\n  }\n  EventEmitter.call(this);\n\n  obj = obj || {};\n\n  this.name = obj.name || '';\n  this.type = 'pull';\n  this.queue = obj.queue || null;\n}\n"], ["getDomainKeys", "\nfunction() {\n  \"use strict\";\n\n  return this._domains.keys()\n    .map(function(d) { return parseInt(d, 10); })\n    .sort(function(a,b) { return a-b; });\n}\n"], ["initializeModbusSerial", "\nfunction(path, options) {\n  var modbus = this;\n\n  options = options || {};\n\n  <configureOptions>\n  options.autoOpen = false;\n  </configureOptions>\n\n  <initializeBufferAndCommands>\n  this._buffer = Buffer.from(\"\");\n  this._id = 0;\n  this._cmd = 0;\n  this._length = 0;\n  </initializeBufferAndCommands>\n\n  <createSerialPortClient>\n  this._client = new SerialPort(path, options);\n  </createSerialPortClient>\n\n  <setupClientDataHandler>\n  this._client.on(\"data\", function(data) {\n    modbus._buffer = Buffer.concat([modbus._buffer, data]);\n    modbusSerialDebug({ action: \"receive serial ascii port\", data: data, buffer: modbus._buffer });\n    var sdIndex = modbus._buffer.indexOf(0x3A); \n    if(sdIndex === -1) {\n      modbus._buffer = Buffer.from(\"\");\n      return;\n    }\n    if(sdIndex > 0) {\n      modbus._buffer = modbus._buffer.slice(sdIndex);\n    }\n    if(modbus._buffer.includes(\"\\r\\n\", 1, \"ascii\") === true) {\n      var edIndex = modbus._buffer.indexOf(0x0A); \n      if(edIndex !== modbus._buffer.length - 1) {\n        modbus._buffer = modbus._buffer.slice(0, edIndex + 1);\n      }\n      var _data = _asciiDecodeResponseBuffer(modbus._buffer);\n      if(_data !== null) {\n        if (_checkData(modbus, _data)) {\n          modbus.emit(\"data\", _data);\n        }\n      }\n      modbus._buffer = Buffer.from(\"\");\n    }\n  });\n  </setupClientDataHandler>\n\n  <defineIsOpenProperty>\n  Object.defineProperty(this, \"isOpen\", {\n      enumerable: true,\n      get: function() {\n          return this._client.isOpen;\n      }\n  });\n  </defineIsOpenProperty>\n\n  EventEmitter.call(this);\n}\n"], ["calculateWidth", "\nfunction w(d, outer) {\n  var width = self.options.cellSize*self._domainType[self.options.subDomain].column(d) + self.options.cellPadding*self._domainType[self.options.subDomain].column(d);\n  if (arguments.length === 2 && outer === true) {\n    return width += self.domainHorizontalLabelWidth + self.options.domainGutter + self.options.domainMargin[1] + self.options.domainMargin[3];\n  }\n  return width;\n}\n"], "```"]