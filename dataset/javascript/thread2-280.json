[["cssParseUri", "\nfunction cssParseUri(candidate) {\n  <regexDefinitions>\n  var string1 = /^\\s*[\"]([^\"]*)[\"]\\s*$/;\n  var string2 = /^\\s*[']([^']*)[']\\s*$/;\n  var url1 = /^\\s*url\\s*[(][\"]([^\"]*)[\"][)]\\s*$/;\n  var url2 = /^\\s*url\\s*[(][']([^']*)['][)]\\s*$/;\n  var url3 = /^\\s*url\\s*[(]([^)]*)[)]\\s*$/;\n  var match;\n  </regexDefinitions>\n  \n  <parseMatch>\n  if ((match = string1.exec(candidate))) {\n    return match[1];\n  } else if ((match = string2.exec(candidate))) {\n    return match[1];\n  } else if ((match = url1.exec(candidate))) {\n    return match[1];\n  } else if ((match = url2.exec(candidate))) {\n    return match[1];\n  } else if ((match = url3.exec(candidate))) {\n    return match[1];\n  }\n  return null;\n  </parseMatch>\n}\n"], ["SourceTextParser", "\nfunction SourceTextParser(sourceText, classes, methods) {\n  this.Comments = [];\n  this.sourceText = sourceText;\n  this.classes = classes;\n  this.methods = methods;\n}\n"], ["Protos", "\nfunction Protos() {\n  var self = this;\n  global.protos = this;\n\n  <extendSelf>\n  deepExtend(this, this.constructor);\n  </extendSelf>\n\n  <defineGlobalsGetter>\n  this.__defineGetter__('globals', function() {\n    return global;\n  });\n  </defineGlobalsGetter>\n\n  <setClusterConfig>\n  this.clusterConfig = {\n    listenPort: null,\n    multiProcess: 0,\n    singleProcess: 'node',\n    masterProcess: 'node [master]',\n    workerProcess: 'node [worker]'\n  };\n  </setClusterConfig>\n\n  <extendShortcutDefinitions>\n  this.extend = _.extend;\n  this.deepExtend = deepExtend;\n  </extendShortcutDefinitions>\n\n  <loadLibrariesAndModules>\n  this.drivers = {};\n  this.engines = {};\n  this.storages = {};\n  this.lib = {};\n  this.regex = require('./regex');\n  this.inflect = inflect;\n  this.path = pathModule.resolve(__dirname, '../');\n  </loadLibrariesAndModules>\n\n  <setClassNameAndEnvironment>\n  this.className = this.constructor.name;\n  Object.defineProperty(this, 'environment', {\n    value: this.config.environment,\n    writable: false,\n    enumerable: true,\n    configurable: false\n  });\n  </setClassNameAndEnvironment>\n\n  <initializeServerOptions>\n  this.serverOptions = null;\n  this.launchApplication();\n  this.util.onlySetEnumerable(this, [\n    'version', \n    'className', \n    'environment', \n    'path', \n    'config', \n    'apps', \n    'drivers', \n    'engines', \n    'storages'\n  ]);\n  </initializeServerOptions>\n}\n"], ["anonymousFunction", "\nfunction() {\n  var self = this;\n  var limit = self._pool;\n  var cnt = 0;\n  var i = 0;\n\n  <checkSoundLimit>\n  if (self._sounds.length < limit) {\n    return;\n  }\n  </checkSoundLimit>\n\n  <countEndedSounds>\n  for (i=0; i<self._sounds.length; i++) {\n    if (self._sounds[i]._ended) {\n      cnt++;\n    }\n  }\n  </countEndedSounds>\n\n  <cleanupEndedSounds>\n  for (i=self._sounds.length - 1; i>=0; i--) {\n    if (cnt <= limit) {\n      return;\n    }\n\n    if (self._sounds[i]._ended) {\n      <disconnectWebAudio>\n      if (self._webAudio && self._sounds[i]._node) {\n        self._sounds[i]._node.disconnect(0);\n      }\n      </disconnectWebAudio>\n\n      <removeEndedSound>\n      self._sounds.splice(i, 1);\n      cnt--;\n      </removeEndedSound>\n    }\n  }\n  </cleanupEndedSounds>\n}\n"], ["callbackFunction", "\nfunction(resp) { \n  <findCurrentBranch>\n  var branches = resp.Children;\n  var currentBranch;\n  for (var i = 0; i < branches.length; i++) {\n    if (branches[i].Current) {\n      currentBranch = branches[i];\n      break;\n    }\n  }\n  </findCurrentBranch>\n  \n  <resetDataFields>\n  data.command = undefined;\n  data.targetBranch = undefined;\n  data.parameters = undefined;\n  </resetDataFields>\n\n  <setDataItems>\n  data.items.LocalBranch = currentBranch;\n  data.items.Remote = currentBranch.RemoteLocation[0].Children[0];\n  </setDataItems>\n\n  <invokePushCallback>\n  pushCallback(data).then(function() {\n    refresh();\n  });\n  </invokePushCallback>\n}\n"], ["objectSortByKey", "\nfunction objectSortByKey(data, key, reverse) {\n  <sortKeys>\n  let keys = Object.keys(data);\n  keys.sort((a, b) => {\n      const aw = data[a][key] !== undefined ? parseInt(data[a][key], 10) : 0;\n      const bw = data[b][key] !== undefined ? parseInt(data[b][key], 10) : 0;\n      if (aw === bw) {\n          return 0;\n      }\n      return reverse !== true && aw < bw ? -1 : 1;\n  });\n  </sortKeys>\n\n  <rearrangeData>\n  keys.forEach((key) => {\n      const value = data[key];\n      delete data[key];\n      data[key] = value;\n  });\n  </rearrangeData>\n}\n"], ["XMLHttpRequest", "\nfunction XMLHttpRequest() {\n  var scope = ctorEvent();\n  goog.base(this, descriptor);\n  \n  <initializeXhr>\n  this.handle_ = new originalXhr();\n  </initializeXhr>\n\n  <initializeTrackersAndProps>\n  this.trackers_ = {};\n  this.props_ = {\n    'method': null,\n    'url': null,\n    'async': true,\n    'user': null,\n    'headers': {},\n    'timeout': 0,\n    'withCredentials': false,\n    'overrideMimeType': null,\n    'responseType': ''\n  };\n  </initializeTrackersAndProps>\n\n  <attachReadyStateChangeEventListener>\n  this.flow_ = null;\n  var self = this;\n  var handle = this.handle_;\n  var props = this.props_;\n  this.handle_.addEventListener('readystatechange', function(e) {\n    var flow = self.flow_;\n    if (!flow) {\n      return;\n    }\n\n    <parseHeadersOnReadyState2>\n    var value = undefined;\n    if (handle.readyState == 2) {\n      var headers = {};\n      var allHeaders = handle.getAllResponseHeaders().split('\\r\\n');\n      for (var n = 0; n < allHeaders.length; n++) {\n        if (allHeaders[n].length) {\n          var parts = allHeaders[n].split(':');\n          headers[parts[0]] = parts[1].substr(1);\n        }\n      }\n      value = {\n        'status': this.status,\n        'statusText': this.statusText,\n        'headers': headers\n      };\n    }\n    </parseHeadersOnReadyState2>\n\n    <recordTraceOnReadyStateChange>\n    if (handle.readyState < 4) {\n      wtf.trace.Flow.extend(flow, 'readyState: ' + handle.readyState, value);\n    } else {\n      wtf.trace.Flow.terminate(flow, 'readyState: ' + handle.readyState);\n    }\n    </recordTraceOnReadyStateChange>\n  }, false);\n  </attachReadyStateChangeEventListener>\n\n  <setEventHooks>\n  this.setEventHook('readystatechange', function(e) {\n    wtf.trace.appendScopeData('url', props['url']);\n    wtf.trace.appendScopeData('readyState', handle['readyState']);\n  });\n  this.setEventHook('load', function(e) {\n    wtf.trace.appendScopeData('url', props['url']);\n  });\n  </setEventHooks>\n\n  wtf.trace.Scope.leave(scope);\n}\n"], ["setValueFunction", "\nfunction(value) {\n  <validateAndTransformValue>\n  if (Lang.isNumber(value)) {\n    value += 'px';\n  }\n  </validateAndTransformValue>\n\n  <setStyleAndFixEdges>\n  this.setStyle(HEIGHT,value);\n  this._fixEdges();\n  this.redraw();\n  </setStyleAndFixEdges>\n}\n"], ["cssFunction", "\nfunction css() {\n  <findCssElement>\n  const cssElement = findChild(libraryAppData, \"css\");\n  if (cssElement != null) {\n    const css = cssElement._;\n    if (css === \"false\") {\n      log.verbose(\"  sap.ui5/library/css property taken from .library appData: '%s'\", false);\n      return false;\n    }\n  } else if (libraryJSInfo.noLibraryCSS) {\n    log.verbose(\"  sap.ui5/library/css property extracted from library.js: '%s'\", false);\n    return false;\n  }\n  </findCssElement>\n}\n"], ["countGroupsFunction", "\nfunction () {\n  <lastGroupCheck>\n  if (this._lastGroup && typeof this._lastGroup.index === \"number\") {\n    return Promise.wrap(this._count);\n  } else {\n  </lastGroupCheck>\n    \n  <initializeCountPromise>\n  var that = this;\n  var countPromise = new Promise(function (complete) {\n    var fetch = {\n      initialBatch: function () {\n        that._fetchNextIndex();\n      },\n      getGroup: function () { return null; },\n      countBefore: 0,\n      countAfter: 0,\n      complete: function (failed) {\n        if (failed) {\n          that._count = 0;\n        }\n        \n        var count = that._count;\n        if (typeof count === \"number\") {\n          complete(count);\n          return true;\n        } else {\n          return false;\n        }\n      }\n    };\n    \n    that._fetchQueue.push(fetch);\n    \n    if (!that._itemBatch) {\n      that._continueFetch(fetch);\n    }\n  });\n  </initializeCountPromise>\n\n  <returnOrExecuteCountPromise>\n  return (typeof this._count === \"number\" ? Promise.wrap(this._count) : countPromise);\n  </returnOrExecuteCountPromise>\n}\n"], "```\n\nNote: The tags reflect distinct responsibilities and coherent blocks of instructions within each JavaScript function according to the SRP. Simple statements and variable assignments are not individually tagged unless they form part of an identifiable responsibility."]