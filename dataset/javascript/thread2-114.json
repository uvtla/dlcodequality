[["DragControlMethod", "\nfunction DragControlMethod(element, pointerType, opts) {\n  this._element = element;\n\n  this._opts = defaults(opts || {}, defaultOptions);\n\n  this._startEvent = null;\n  this._lastEvent = null;\n\n  this._active = false;\n\n  this._dynamics = {\n    x: new Dynamics(),\n    y: new Dynamics()\n  };\n\n  this._hammer = HammerGestures.get(element, pointerType);\n\n  this._hammer.on(\"hammer.input\", this._handleHammerEvent.bind(this));\n\n  this._hammer.on('panstart', this._handleStart.bind(this));\n  this._hammer.on('panmove', this._handleMove.bind(this));\n  this._hammer.on('panend', this._handleEnd.bind(this));\n  this._hammer.on('pancancel', this._handleEnd.bind(this));\n}\n"], ["function", "\nfunction(){\n                \n                var tokenStream = this._tokenStream,\n                    line,\n                    col,\n                    marginSym   = this._margin_sym();\n\n                <startNode>\n                if (marginSym){\n                    var node = this.startNode('Margin', tokenStream.curr().range[0], 'body'); \n                </startNode>\n\n                <declarations>\n                    node.declarations = [];\n                </declarations>\n                \n                line = tokenStream.token().startLine;\n                col = tokenStream.token().startCol;\n\n                <startPageMarginEvent>\n                this.fire({\n                    type: \"startpagemargin\",\n                    margin: marginSym,\n                    line:   line,\n                    col:    col\n                });\n                </startPageMarginEvent>\n\n                this._readDeclarations(true);\n\n                <endPageMarginEvent>\n                this.fire({\n                    type: \"endpagemargin\",\n                    margin: marginSym,\n                    line:   line,\n                    col:    col\n                });\n                </endPageMarginEvent>\n\n                <endNode>\n                this.endNode(node, tokenStream.curr().range[1]); \n                </endNode>\n\n                return true;\n                } else {\n                    return false;\n                }\n            }\n"], ["doFilter", "\nfunction doFilter(id, type, name, navName) {\n            var $shower = $('#show-' + type),\n                att;\n            \n            <filterSetup>\n            curFilter[type] = id;\n\n            if (id === 0) {\n                $shower.addClass('default');\n            } else {\n                $shower.removeClass('default');\n            }\n            </filterSetup>\n\n            <setText>\n            $shower.text(name);\n            </setText>\n\n            <flagNavInfoForReload>\n            for (att in navInfo) {\n                if (navInfo.hasOwnProperty(att)) {\n                    navInfo[att].reload = true;\n                }\n            }\n            </flagNavInfoForReload>\n            \n            <searchInitiation>\n            search();\n            </searchInitiation>\n        }\n"], ["renderBlock", "\nfunction renderBlock(block, index, rawDraftObject, options) {\n  <declarations>\n  var openInlineStyles = [],\n      markdownToAdd = [];\n  var markdownString = '',\n      customStyleItems = options.styleItems || {},\n      customEntityItems = options.entityItems || {},\n      escapeMarkdownCharacters = options.hasOwnProperty('escapeMarkdownCharacters') ? options.escapeMarkdownCharacters : true;\n  var type = block.type;\n  var markdownStyleCharactersToEscape = [];\n  </declarations>\n\n  <handleEmptyBlocks>\n  if (isEmptyBlock(block) && !options.preserveNewlines) {\n    type = 'unstyled';\n  }\n  </handleEmptyBlocks>\n\n  <processBlockStyle>\n  if (customStyleItems[type] || StyleItems[type]) {\n\n    //omitting internal logic here due to complexity\n  }\n  </processBlockStyle>\n\n  <processText>\n  Array.from(block.text).some(function (character, characterIndex) {\n\n    //omitting internal logic here due to complexity\n  });\n  </processText>\n\n  <processEntityRanges>\n  block.entityRanges.forEach(function (range, rangeIndex) {\n    //omitting internal logic here due to complexity\n  });\n  </processEntityRanges>\n\n  <processOpenInlineStyles>\n  openInlineStyles.reverse().forEach(function (style) {\n    //omitting internal logic here due to complexity\n  });\n  </processOpenInlineStyles>\n\n  <finalizeMarkdownString>\n  if (customStyleItems[type] || StyleItems[type]) {\n    markdownString += (customStyleItems[type] || StyleItems[type]).close(block);\n  }\n\n  if (SingleNewlineAfterBlock.indexOf(type) !== -1 && rawDraftObject.blocks[index + 1] && SingleNewlineAfterBlock.indexOf(rawDraftObject.blocks[index + 1].type) !== -1) {\n    markdownString += '\\n';\n  } else if (rawDraftObject.blocks[index + 1]) {\n    //omitting internal logic here due to complexity\n  }\n  </finalizeMarkdownString>\n\n  return markdownString;\n}\n"], ["renderTemplate", "\nfunction renderTemplate(contents, data, filename) {\n    <templateCaching>\n    if (!templateCache.hasOwnProperty(contents)) {\n      var jadeOptions = merge.recursive({}, options.jadeOptions, {filename: filename});\n      templateCache[contents] = options.jade.compile(contents, jadeOptions);\n    }\n    </templateCaching>\n\n    <prepareData>\n    var locals = merge.recursive({}, data, {locals: locals});\n    </prepareData>\n\n    <renderWithData>\n    return templateCache[contents](data);\n    </renderWithData>\n  }\n"], ["function", "\nfunction(type, value) {\n    <typeValidation>\n    if (type !== 'attribute' && type !== 'text') {\n      throw new TypeError('isBound must provide type \"attribute\" or \"text\"');\n    }\n    </typeValidation>\n\n    <checkBinding>\n    var expr = this.binders[type]._expr;\n    return Boolean(expr && value && value.match(expr));\n    </checkBinding>\n  }\n"], ["interpret_events", "\nfunction interpret_events() {\n\n        <interpretInitialEvent>\n        var handled_event = interpret_event();\n        </interpretInitialEvent>\n        if (!handled_event)\n            return false;\n\n        <interpretSubsequentEvents>\n        var last_event;\n        do {\n            last_event = handled_event;\n            handled_event = interpret_event();\n        } while (handled_event !== null);\n        </interpretSubsequentEvents>\n\n        return last_event.defaultPrevented;\n    }\n"], ["getAbout", "\nfunction getAbout(db, callback) {\n  <checkCache>\n  let cacheKey = db.id + \"-\" + 'about';\n  let cache = cache_about.get(cacheKey);\n  if ( cache !== null ) {\n    return callback(null, cache);\n  }\n  </checkCache>\n\n  <prepareQuery>\n  let select = \"SELECT compile_date, gtfs_publish_date, start_date, \" +\n    \"end_date, version, notes FROM rt_about\";\n  </prepareQuery>\n\n  <executeQuery>\n  db.get(select, function(err, result) {\n  </executeQuery>\n\n    <handleError>\n    if ( err ) {\n      return callback(err);\n    }\n    </handleError>\n\n    <handleUndefinedResult>\n    if ( result === undefined ) {\n      return callback(\n        new Error('Could not get About info from Right Track DB')\n      );\n    }\n    </handleUndefinedResult>\n\n    <createAboutInstance>\n    let about = new About(\n      result.compile_date,\n      result.gtfs_publish_date,\n      result.start_date,\n      result.end_date,\n      result.version,\n      result.notes\n    );\n    </createAboutInstance>\n\n    <updateCache>\n    cache_about.put(cacheKey, about);\n    </updateCache>\n\n    return callback(null, about);\n\n  });\n\n}\n"], ["getNodeLength", "\nfunction getNodeLength(node) {\n\tswitch (node.nodeType) {\n\t\tcase Node.PROCESSING_INSTRUCTION_NODE:\n\t\tcase Node.DOCUMENT_TYPE_NODE:\n\t\t\treturn 0;\n\n\t\tcase Node.TEXT_NODE:\n\t\tcase Node.COMMENT_NODE:\n\t\t\treturn node.length;\n\n\t\tdefault:\n\t\t\treturn node.childNodes.length;\n\t}\n}\n"], ["GeometryCollection", "\nfunction GeometryCollection(geometryCollection) {\n        <crsAndBboxHandling>\n        crs(geometryCollection);\n        bbox(geometryCollection);\n        </crsAndBboxHandling>\n\n        <checkGeometriesProperty>\n        if (!requiredProperty(geometryCollection, 'geometries', 'array')) {\n            if (!everyIs(geometryCollection.geometries, 'object')) {\n                errors.push({\n                    message: 'The geometries array in a GeometryCollection must contain only geometry objects',\n                    line: geometryCollection.__line__\n                });\n            }\n            if (geometryCollection.geometries.length === 1) {\n                errors.push({\n                    message: 'GeometryCollection with a single geometry should be avoided in favor of single part or a single object of multi-part type',\n                    line: geometryCollection.geometries.__line__\n                });\n            }\n            geometryCollection.geometries.forEach(function(geometry) {\n                <validateNestedGeometryType>\n                if (geometry) {\n                    if (geometry.type === 'GeometryCollection') {\n                        errors.push({\n                            message: 'GeometryCollection should avoid nested geometry collections',\n                            line: geometryCollection.geometries.__line__\n                        });\n                    }\n                    root(geometry);\n                }\n                </validateNestedGeometryType>\n            });\n        }\n        </checkGeometriesProperty>\n    }\n"], "```\n\nPlease note that inline comments (e.g., \"omitting internal logic here due to complexity\") indicate areas where the logic was too complex for a basic annotation but should still be considered for SRP evaluation."]