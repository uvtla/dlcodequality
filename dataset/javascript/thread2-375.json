[["lookForExternalDependencies", "\nfunction lookForExternalDependencies(jsFiles) {\n  const\n    javascriptSources = [],\n    resources = {};\n\n  for (const jsFileName of Object.keys(jsFiles)) {\n    <Project.srcOrLibPath>\n    const depFileName = `${jsFileName}.dep`;\n    if (Project.srcOrLibPath(depFileName)) {\n    </Project.srcOrLibPath>\n      <SourceAndDependencies>\n      const depFile = new Source(Project, depFileName);\n      try {\n        const\n          json = depFile.read(),\n          dependencies = ToloframeworkPermissiveJson.parse(json);\n\n        lookForExternalDependenciesJS(dependencies.js, javascriptSources);\n\n        lookForExternalDependenciesRES(dependencies.res, resources, depFile);\n      } catch (ex) {\n        Fatal.fire(\n          `Unable to parse JSON file \"${depFile.getAbsoluteFilePath()}\"!\\n${ex}`,\n          Project.srcOrLibPath(jsFileName)\n        );\n      }\n      </SourceAndDependencies>\n    }\n  }\n\n  return {\n    js: javascriptSources,\n    res: resources\n  };\n}\n"], ["recursiveMerge", "\nfunction recursiveMerge(target, src) {\n    for (var prop in src) {\n        if (src.hasOwnProperty(prop)) {\n            if (target.prototype && target.prototype.constructor === target) {\n                \n                clobber(target.prototype, prop, src[prop]);\n            } else {\n                <objectMerge>\n                if (typeof src[prop] === 'object' && typeof target[prop] === 'object') {\n                    recursiveMerge(target[prop], src[prop]);\n                } else {\n                    clobber(target, prop, src[prop]);\n                }\n                </objectMerge>\n            }\n        }\n    }\n}\n"], ["anonymousHideElement", "\nfunction (element) {\n        element = $(element);\n\n        this.fireEvent('hiding', [element]);\n\n        element.transitionend(function () {\n            element.remove();\n            this.fireEvent('hidden');\n        }.bind(this)).conceal();\n    }\n"], ["getTrackableFunction", "\nfunction getTrackableFunction(obj, name, trackedFunctions) {\n  var debugName = obj.getDebugName();\n  var originalFn = obj[name];\n  var fnName = `${debugName}.${name}`;\n  var instrumentedFn = instrumentFunction(fnName, originalFn);\n  var fn = function tungstenTrackingPassthrough() {\n    \n    if (trackedFunctions[name]) {\n      return instrumentedFn.apply(this, arguments);\n    } else {\n      return originalFn.apply(this, arguments);\n    }\n  };\n  fn.original = originalFn;\n  return fn;\n}\n"], ["createProgram", "\nfunction createProgram(\ngl, shaders, opt_attribs, opt_locations, opt_errorCallback) {\n  const progOptions = getProgramOptions(opt_attribs, opt_locations, opt_errorCallback);\n  const realShaders = [];\n  const newShaders = [];\n  for (let ndx = 0; ndx < shaders.length; ++ndx) {\n    <processShaderInputs>\n    let shader = shaders[ndx];\n    if (typeof (shader) === 'string') {\n      const elem = getElementById(shader);\n      const src = elem ? elem.text : shader;\n      let type = gl[defaultShaderType[ndx]];\n      if (elem && elem.type) {\n        type = getShaderTypeFromScriptType(gl, elem.type) || type;\n      }\n      shader = loadShader(gl, src, type, progOptions.errorCallback);\n      newShaders.push(shader);\n    }\n    if (helper.isShader(gl, shader)) {\n      realShaders.push(shader);\n    }\n    </processShaderInputs>\n  }\n\n  if (realShaders.length !== shaders.length) {\n    <handleShaderError>\n    progOptions.errorCallback(\"not enough shaders for program\");\n    deleteShaders(gl, newShaders);\n    return null;\n    </handleShaderError>\n  }\n\n  <linkAndValidateProgram>\n  const program = gl.createProgram();\n  realShaders.forEach(function (shader) {\n    gl.attachShader(program, shader);\n  });\n  if (progOptions.attribLocations) {\n    Object.keys(progOptions.attribLocations).forEach(function (attrib) {\n      gl.bindAttribLocation(program, progOptions.attribLocations[attrib], attrib);\n    });\n  }\n  let varyings = progOptions.transformFeedbackVaryings;\n  if (varyings) {\n    if (varyings.attribs) {\n      varyings = varyings.attribs;\n    }\n    if (!Array.isArray(varyings)) {\n      varyings = Object.keys(varyings);\n    }\n    gl.transformFeedbackVaryings(program, varyings, progOptions.transformFeedbackMode || gl.SEPARATE_ATTRIBS);\n  }\n  gl.linkProgram(program);\n\n  \n  const linked = gl.getProgramParameter(program, gl.LINK_STATUS);\n  if (!linked) {\n    \n    const lastError = gl.getProgramInfoLog(program);\n    progOptions.errorCallback(\"Error in program linking:\" + lastError);\n\n    gl.deleteProgram(program);\n    deleteShaders(gl, newShaders);\n    return null;\n  }\n  </linkAndValidateProgram>\n\n  return program;\n}\n"], ["collisionComponentInitialization", "\nfunction (params) {\n        params = _.extend({\n            anchor: {\n                x: 0.5,\n                y: 0.5\n            }\n        }, params);\n\n        this.$id = 'collision';\n        this.$deps = ['position'];\n\n        this.width = params.width;\n        this.height = params.height;\n        this.anchor = params.anchor;\n    }\n"], ["aqPrepareAndSubscribe", "\nfunction main() {\n    aqParseOptions();\n\n    aq_queuename = 'amqpsnoop.' + Math.random() * 10000000;\n    aq_amqp = mod_amqp.createConnection(aq_broker);\n    aq_amqp.on('ready', function () {\n        aq_queue = aq_amqp.queue(aq_queuename,\n            { exclusive: true }, function () {\n                aq_queue.bind(aq_exchange, aq_routekey);\n                aq_queue.subscribe(aqReceiveMessage);\n            });\n    });\n}\n"], ["buildPack", "\nfunction buildPack(webpackConfig, cb, spinnerText) {\n  var spinner = ora(spinnerText || 'building for uncompressed files...')\n  spinner.start()\n  webpack(webpackConfig, function (err, stats) {\n    spinner.stop()\n    if (err) {\n      throw err\n    }\n    process.stdout.write(stats.toString({\n      colors: true,\n      modules: false,\n      children: false,\n      chunks: false,\n      chunkModules: false\n    }) + '\\n')\n    <callCallback>\n    cb && cb()\n    </callCallback>\n  })\n}\n"], ["run", "\nfunction run(how) {\n  <validateParameters>\n  if (!how || (how != \"ping\" && how != \"pong\")) {\n    console.log(\"must enter `ping` or `pong` as parameter\")\n    process.exit(1)\n  }\n  </validateParameters>\n\n  <setPingPong>\n  ping = how\n  pong = (ping == \"ping\") ? \"pong\" : \"ping\"\n  </setPingPong>\n  <createSession>\n  ragents.createSession(options, sessionCreated)\n  </createSession>\n}\n"], ["clickOutsideHandler", "\nfunction handler(e) {\n      if (!vNode.context) return\n\n      \n      var elements = e.path || (e.composedPath && e.composedPath())\n      elements && elements.length > 0 && elements.unshift(e.target)\n      \n      if (el.contains(e.target) || isPopup(vNode.context.popupItem, elements)) return\n\n      <callbackInvocation>\n      el.__vueClickOutside__.callback(e)\n      </callbackInvocation>\n    }\n"], "```"]