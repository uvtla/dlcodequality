[["expandBranch", "\nfunction(li,maxLevel) {\n  <expandElement>\n  this.expandElement(li);\n  </expandElement>\n  <subElementProcessing>\n  var sub = Dom.getChildrenBy(li, function(c) {return c.tagName == \"UL\";})[0].childNodes;\n  for(var j = 0 ; j < sub.length ; j++) {\n     var s = sub[j];\n     if(Dom.hasClass(s,\"collapsed\") && maxLevel != 0) {\n        this.expandBranch(s,maxLevel-1);\n     }\n  }\n  </subElementProcessing>\n}\n"], ["mxTerminalChange", "\nfunction mxTerminalChange(model, cell, terminal, source)\n{\n\tthis.model = model;\n\tthis.cell = cell;\n\tthis.terminal = terminal;\n\tthis.previous = terminal;\n\tthis.source = source;\n}\n"], ["verifySize", "\nfunction verifySize(correctSize, filepath) {\n    return calculateSize(filepath).then(size => {\n        <sizeCheck>\n        if (size !== correctSize) {\n            throw new Error(`Incorrect file size: expected ${correctSize}, got ${size}`);\n        }\n        </sizeCheck>\n        return true;\n    });\n}\n"], ["buildSymbolDisplay", "\nfunction buildSymbolDisplay(symbol, writer, enclosingDeclaration, meaning, flags, typeFlags) {\n                var parentSymbol;\n                \n                function appendParentTypeArgumentsAndSymbolName(symbol) {\n                    <appendParentType>\n                    if (parentSymbol) {\n                        \n                        if (flags & 1 ) {\n                            if (symbol.flags & 16777216 ) {\n                                buildDisplayForTypeArgumentsAndDelimiters(getTypeParametersOfClassOrInterface(parentSymbol), symbol.mapper, writer, enclosingDeclaration);\n                            }\n                            else {\n                                buildTypeParameterDisplayFromSymbol(parentSymbol, writer, enclosingDeclaration);\n                            }\n                        }\n                        appendPropertyOrElementAccessForSymbol(symbol, writer);\n                    }\n                    else {\n                        appendSymbolNameOnly(symbol, writer);\n                    }\n                    </appendParentType>\n                    parentSymbol = symbol;\n                }\n                \n                <trackSymbol>\n                writer.trackSymbol(symbol, enclosingDeclaration, meaning);\n                </trackSymbol>\n                \n                function walkSymbol(symbol, meaning) {\n                    <walkSymbolLogic>\n                    if (symbol) {\n                        var accessibleSymbolChain = getAccessibleSymbolChain(symbol, enclosingDeclaration, meaning, !!(flags & 2 ));\n                        if (!accessibleSymbolChain ||\n                            needsQualification(accessibleSymbolChain[0], enclosingDeclaration, accessibleSymbolChain.length === 1 ? meaning : getQualifiedLeftMeaning(meaning))) {\n                            \n                            walkSymbol(getParentOfSymbol(accessibleSymbolChain ? accessibleSymbolChain[0] : symbol), getQualifiedLeftMeaning(meaning));\n                        }\n                        if (accessibleSymbolChain) {\n                            for (var _i = 0, accessibleSymbolChain_1 = accessibleSymbolChain; _i < accessibleSymbolChain_1.length; _i++) {\n                                var accessibleSymbol = accessibleSymbolChain_1[_i];\n                                appendParentTypeArgumentsAndSymbolName(accessibleSymbol);\n                            }\n                        }\n                        else {\n                            \n                            if (!parentSymbol && ts.forEach(symbol.declarations, hasExternalModuleSymbol)) {\n                                return;\n                            }\n                            \n                            if (symbol.flags & 2048  || symbol.flags & 4096 ) {\n                                return;\n                            }\n                            appendParentTypeArgumentsAndSymbolName(symbol);\n                        }\n                    }\n                    </walkSymbolLogic>\n                }\n                \n                var isTypeParameter = symbol.flags & 262144 ;\n                <typeFlagsCheck>\n                var typeFormatFlag = 128  & typeFlags;\n                </typeFlagsCheck>\n                <buildDisplay>\n                if (!isTypeParameter && (enclosingDeclaration || typeFormatFlag)) {\n                    walkSymbol(symbol, meaning);\n                    return;\n                }\n                </buildDisplay>\n                return appendParentTypeArgumentsAndSymbolName(symbol);\n}\n"], ["_update", "\nfunction _update(s, w, bytes) {\n  \n  <initialization>\n  var t, a, b, c, d, e, f, i;\n  </initialization>\n  \n  <lenCalculation>\n  var len = bytes.length();\n  </lenCalculation>\n  \n  <processChunks>\n  while(len >= 64) {\n    <initializeWorkingVariables>\n    a = s.h0;\n    b = s.h1;\n    c = s.h2;\n    d = s.h3;\n    e = s.h4;\n    </initializeWorkingVariables>\n    \n    <mainLoop1>\n    for(i = 0; i < 16; ++i) {\n      // Processing code omitted for brevity\n    }\n    </mainLoop1>\n    \n    <mainLoop2>\n    for(; i < 20; ++i) {\n      // Processing code omitted for brevity\n    }\n    </mainLoop2>\n    \n    <mainLoop3>\n    for(; i < 32; ++i) {\n      // Processing code omitted for brevity\n    }\n    </mainLoop3>\n    \n    <mainLoop4>\n    for(; i < 40; ++i) {\n      // Processing code omitted for brevity\n    }\n    </mainLoop4>\n    \n    <mainLoop5>\n    for(; i < 60; ++i) {\n      // Processing code omitted for brevity\n    }\n    </mainLoop5>\n    \n    <mainLoop6>\n    for(; i < 80; ++i) {\n      // Processing code omitted for brevity\n    }\n    </mainLoop6>\n    \n\n    <updateStateHash>\n    s.h0 = (s.h0 + a) | 0;\n    s.h1 = (s.h1 + b) | 0;\n    s.h2 = (s.h2 + c) | 0;\n    s.h3 = (s.h3 + d) | 0;\n    s.h4 = (s.h4 + e) | 0;\n    </updateStateHash>\n    \n    len -= 64;\n  }\n  </processChunks>\n}\n"], ["removeFromCollectionView", "\nfunction (key, preserveElems) {\n            var subViews = (key && (typeof key === \"string\" || key.cid)) ? this.get(key) : key;\n            \n            <determineLength>\n            var len;\n            len = subViews ? subViews.length : 0;\n            </determineLength>\n            \n            <removeElems>\n            if (!preserveElems) {\n                this.removeElems(subViews);\n            }\n            </removeElems>\n            \n            <triggerRemoveEvent>\n            if (len) {\n                this.trigger('remove', subViews);\n            }\n            </triggerRemoveEvent>\n            \n            <processRemoval>\n            while (subViews && subViews.length) {\n                this._remove(subViews.shift());\n            }\n            </processRemoval>\n            \n            return this;\n}\n"], ["cloneWithRaws", "\nfunction cloneWithRaws(node) {\n  if (node.nodes) {\n    <prepareNodesForClone>\n    const oldNodes = node.nodes;\n    node.nodes = [];\n    </prepareNodesForClone>\n    \n    <performClone>\n    const clone = node.clone({ raws: node.raws });\n    node.nodes = oldNodes;\n    </performClone>\n    \n    <appendClonedChildren>\n    for (const clonedChild of oldNodes.map(cloneWithRaws)) {\n      clone.append(clonedChild);\n    }\n    </appendClonedChildren>\n    \n    return clone;\n  } else {\n    return node.clone({ raws: node.raws });\n  }\n}\n"], ["StreamFormatter", "\nfunction StreamFormatter(loggerManager, options) {\n        if (!(this instanceof StreamFormatter)) {\n            return new StreamFormatter(loggerManager, options);\n        }\n\n        <initializeStream>\n        stream.Readable.call(this, options);\n        this._buffer = [];\n        this._pushable = false;\n        this._ended = false;\n        </initializeStream>\n        \n        <handleMessageRegistration>\n        loggerManager.on(\"message\", this._handleMessage.bind(this));\n        loggerManager.on(\"end\", function () { this._handleMessage(\"END\"); }.bind(this));\n        </handleMessageRegistration>\n}\n"], ["genAuthorizationHeaderValue", "\nfunction genAuthorizationHeaderValue (options) {\n    <logging>\n    log(options.verbose,\"Now generating Authorization header value ...\");\n    </logging>\n\n    <headerParams>\n    var authHeaderParams = [];\n    authHeaderParams.push(createEncodedParam(\"oauth_consumer_key\",options.oAuthConsumerKey));\n    authHeaderParams.push(createEncodedParam(\"oauth_nonce\",options.oAuthNonce));\n    authHeaderParams.push(createEncodedParam(\"oauth_signature\",options.oAuthSignature));\n    authHeaderParams.push(createEncodedParam(\"oauth_signature_method\",options.oAuthSignatureMethod));\n    authHeaderParams.push(createEncodedParam(\"oauth_timestamp\",options.oAuthTimestamp));\n    authHeaderParams.push(createEncodedParam(\"oauth_token\",options.oAuthToken));\n    authHeaderParams.push(createEncodedParam(\"oauth_version\",options.oAuthVersion));\n    </headerParams>\n    \n    <assemblyAuthHeaderValue>\n    var authHeaderValue = \"OAuth \";\n    for ( var i=0; i<authHeaderParams.length; i++ ) {\n        authHeaderValue += authHeaderParams[i].key+\"=\\\"\"+authHeaderParams[i].value+\"\\\"\";\n        if ( authHeaderParams[i+1] ) {\n            authHeaderValue += \", \";\n        }\n    }\n    </assemblyAuthHeaderValue>\n    \n    <loggingAuthHeaderValue>\n    log(options.verbose,\"Authorization header value is: \"+authHeaderValue);\n    </loggingAuthHeaderValue>\n\n    return authHeaderValue;\n}\n"], ["ParseOfflineRequest", "\nfunction ParseOfflineRequest (requestType, options) {\n\tif (!(this instanceof ParseOfflineRequest)) {\n\t\treturn new ParseOfflineRequest(requestType, options);\n\t}\n\n\t<initializeProperties>\n\tthis.requestType = requestType;\n\tthis.options = options;\n\t</initializeProperties>\n\t\n\t<setRequestMethod>\n\tthis.requestMethod = this.httpGETPUTorPOST(requestType);\n\t</setRequestMethod>\n\tthis.params = '';\n\n\treturn this;\n}\n"], ""]