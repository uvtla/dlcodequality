[["maybeImportNode", "\nfunction maybeImportNode(state, node, doc) {\n  return node.ownerDocument === doc ? node : doc.importNode(node, true);\n}\n"], ["trashOrUntrashPages", "\nfunction trashOrUntrashPages(cb) {\n  const ids = tree.map(p => p._id);\n  return self.apos.docs.db.update({ _id: { $in: ids } }, action, {\n    multi: true\n  }, (err, res) => {\n    cb(err);\n  });\n}\n"], ["decode", "\nfunction decode(str, keepSlashes) {\n  <decodeAndReplace>\n  if (isEncoded) {\n    str = str.replace(/\\uFEFF[0-9]/g, function (str) {\n      return encodingLookup[str];\n    });\n  }\n  </decodeAndReplace>\n  <removeEscapedCharacters>\n  if (!keepSlashes) {\n    str = str.replace(/\\\\([\\'\\\";:])/g, \"$1\");\n  }\n  </removeEscapedCharacters>\n  \n  return str;\n}\n"], ["getSelectedValue", "\nfunction getSelectedValue(customSelect) {\n  var hiddenSelect = this.UI.getHiddenSelect(customSelect);\n  <checkAndReturnMultiple>\n  if (this.isMultiple(customSelect)) {\n    var selectedOptions = [];\n    [].forEach.call(hiddenSelect.options, function (option) {\n      if (option.selected) {\n        selectedOptions.push(option.value);\n      }\n    });\n    return selectedOptions;\n  </checkAndReturnMultiple>\n  <returnSingle>\n  else {\n    return hiddenSelect.options[hiddenSelect.selectedIndex].value;\n  }\n  </returnSingle>\n}\n"], ["contentOverlapping", "\nfunction contentOverlapping(targetElement, bgNode) {\n  var targetRect = targetElement.getClientRects()[0];\n  <findOverlappingElements>\n  var obscuringElements = dom.shadowElementsFromPoint(\n    targetRect.left,\n    targetRect.top\n  );\n  if (obscuringElements) {\n    for (var i = 0; i < obscuringElements.length; i++) {\n      if (\n        obscuringElements[i] !== targetElement &&\n        obscuringElements[i] === bgNode\n      ) {\n        return true;\n      }\n    }\n  }\n  </findOverlappingElements>\n  return false;\n}\n"], ["treegridCheckFirstNode", "\nfunction() {\n  if ($(this).treegrid('isNode')) {\n    <getParentAndCheck>\n    var parentNode = $(this).treegrid('getParentNode');\n    if (parentNode === null) {\n      if ($(this).treegrid('getNodeId') === $(this).treegrid('getRootNodes').first().treegrid('getNodeId')) {\n        return true;\n      }\n    } else {\n      if ($(this).treegrid('getNodeId') === parentNode.treegrid('getChildNodes').first().treegrid('getNodeId')) {\n        return true;\n      }\n    }\n    </getParentAndCheck>\n  }\n  return false;\n}\n"], ["createModuleReducer", "\nfunction createModuleReducer(reducers) {\n  return reducers ? combineReducers(reducers) : function () {\n    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    return state;\n  };\n}\n"], ["makeAs", "\nfunction makeAs(input, model) {\n  return model._isUTC ? moment(input).zone(model._offset || 0) :\n    moment(input).local();\n}\n"], ["intFromNumbers", "\nfunction intFromNumbers(numbers) {\n  if (numbers.length === 0) { return }\n\n  <findMaximum>\n  let max = numbers[0]\n  let maxi = 0  \n  numbers.forEach((n, i) => {if (max < n) { max = n; maxi = i }})\n  </findMaximum>\n\n  <calcPriorNumber>\n  let priorNumber = intFromNumbers(numbers.slice(0, maxi))\n  if (priorNumber === undefined) { priorNumber = 1 }\n  </calcPriorNumber>\n  <calcPosteriorNumber>\n  let posteriorNumber = intFromNumbers(numbers.slice(maxi + 1))\n  if (posteriorNumber === undefined) { posteriorNumber = 0 }\n  </calcPosteriorNumber>\n\n  return priorNumber * max + posteriorNumber\n}\n"], ["getMockForRequest", "\nfunction getMockForRequest(handler, requestSettings) {\n  <handleRequestFunction>\n  if ($.isFunction(handler)) {\n    return handler(requestSettings);\n  }\n  </handleRequestFunction>\n\n  <handleUrlMatching>\n  if ($.isFunction(handler.url.test)) {\n    if (!handler.url.test(requestSettings.url)) {\n      return null;\n    }\n  } else {\n    var star = handler.url.indexOf('*');\n    if (handler.url !== requestSettings.url && star === -1 ||\n      !new RegExp(handler.url.replace(/[-[\\]{}()+?.,\\\\^$|#\\s]/g, \"\\\\$&\").replace(/\\*/g, '.+')).test(requestSettings.url)) {\n      return null;\n    }\n  }\n  </handleUrlMatching>\n  \n  <checkDataEquality>\n  if (handler.data) {\n    if (!requestSettings.data || !isMockDataEqual(handler.data, requestSettings.data)) {\n      return null;\n    }\n  }\n  </checkDataEquality>\n\n  <checkRequestType>\n  if (handler && handler.type &&\n    handler.type.toLowerCase() != requestSettings.type.toLowerCase()) {\n    return null;\n  }\n  </checkRequestType>\n\n  return handler;\n}\n"], "```"]