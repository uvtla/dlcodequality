[["generateAndDisplayPuzzle", "\nfunction (words, puzzleEl, wordsEl, options, colorHash) {\n                wordList = words.slice(0).sort();\n                var puzzle = wordfind.newPuzzle(words, options);\n                \n                drawPuzzle(puzzleEl, puzzle);\n                var list = drawWords(wordsEl, wordList);\n                $('.puzzleSquare').on(\"mousedown.spl touchstart.spl\", { puzzleEl: puzzleEl, colorHash: colorHash }, startTurn)\n                    .on(\"touchmove.spl\", { puzzleEl: puzzleEl, colorHash: colorHash }, touchMove)\n                    .on(\"mouseup.spl touchend.spl\", { puzzleEl: puzzleEl, wordsEl: list, colorHash: colorHash }, endTurn)\n                    .on(\"mousemove.spl\", { puzzleEl: puzzleEl, colorHash: colorHash }, mouseMove);\n                return puzzle;\n            }\n"], ["createVersionListElement", "\nfunction createVersionLi(m, v, n) {\n        var li, span;\n        li = document.createElement('li');\n        span = document.createElement('span');\n        span.className = 'version-module';\n        if (n) span.style['margin-top'] = '12px';\n        span.innerHTML = m;\n        li.appendChild(span);\n        li.appendChild(document.createTextNode(': ' + v));\n        return li;\n    }\n"], ["setUpvalue", "\nfunction getupval (a, b) {\n\t\t\n\t\tvar value = (this._upvalues[b] === undefined)? undefined : this._upvalues[b].getValue();\n\t\tthis._register.setItem(a, value);\n\t}\n"], ["calculateScaling", "\nfunction _calcScaling() {\n        var $sb = _getScrollbar(editor);\n\n        trackHt = $sb[0].offsetHeight;\n\n        if (trackHt > 0) {\n            trackOffset = getScrollbarTrackOffset();\n            trackHt -= trackOffset * 2;\n        } else {\n            \n            var codeContainer = $(editor.getRootElement()).find(\"> .CodeMirror-scroll > .CodeMirror-sizer > div > .CodeMirror-lines > div\")[0];\n            trackHt = codeContainer.offsetHeight;\n            trackOffset = codeContainer.offsetTop;\n        }\n    }\n"], ["ReactDOMComponentConstructor", "\nfunction ReactDOMComponent(tag) {\n  validateDangerousTag(tag);\n  this._tag = tag;\n  this._renderedChildren = null;\n  this._previousStyleCopy = null;\n  this._rootNodeID = null;\n}\n"], ["getOptionsFromUrl", "\nfunction getFromUrl(args) {\n    if (!args || typeof args.url !== 'string') {\n      return args;\n    }\n\n    try {\n      var options = redisUrl.parse(args.url);\n      \n      return applyOptionsToArgs(args, options);\n    } catch (e) {\n      \n      return args;\n    }\n\n  }\n"], ["vueRenderFunction", "\nfunction(module, exports, __webpack_require__) {\n\n\tmodule.exports={render:function (){with(this) {\n\t  return _h('div', {\n\t    staticClass: \"container-fluid m-a-1\"\n\t  }, [_m(0), \" \", (ok) ? _h('p', [\"ok\"]) : _e(), \" \", (even) ? _h('p', [\"even\"]) : _h('p', [\"odd\"]), \" \", \" \", (ok) ? [_m(1), \" \", _m(2), \" \", _m(3)] : _e(), \" \", _h('p', {\n\t    directives: [{\n\t      name: \"show\",\n\t      rawName: \"v-show\",\n\t      value: (ok),\n\t      expression: \"ok\"\n\t    }]\n\t  }, [\"ok\"]), \" \", _h('p', {\n\t    directives: [{\n\t      name: \"show\",\n\t      rawName: \"v-show\",\n\t      value: (even),\n\t      expression: \"even\"\n\t    }]\n\t  }, [\"even\"]), \" \", _h('p', {\n\t    directives: [{\n\t      name: \"show\",\n\t      rawName: \"v-show\",\n\t      value: (!even),\n\t      expression: \"!even\"\n\t    }]\n\t  }, [\"odd\"]), \" \", _m(4)])\n\t}},staticRenderFns: [function (){with(this) {\n\t  return _h('h1', [\"if show else\"])\n\t}},function (){with(this) {\n\t  return _h('p', [\"Title\"])\n\t}},function (){with(this) {\n\t  return _h('p', [\"Paragraph 1\"])\n\t}},function (){with(this) {\n\t  return _h('p', [\"Paragraph 2\"])\n\t}},function (){with(this) {\n\t  return _h('hr')\n\t}}]}\n\tif (false) {\n\t  module.hot.accept()\n\t  if (module.hot.data) {\n\t     require(\"vue-hot-reload-api\").rerender(\"data-v-d9ab51b8\", module.exports)\n\t  }\n\t}\n\n }\n"], ["getElementPosition", "\nfunction getPosition(el) {\n\tvar p = { left: el.offsetLeft, top: el.offsetTop };\n\tel = el.offsetParent;\n\twhile (el) {\n\t\tp.left += el.offsetLeft;\n\t\tp.top += el.offsetTop;\n\t\tif (el !== doc.body && el !== doc.documentElement) {\n\t\t\tp.left -= el.scrollLeft;\n\t\t\tp.top -= el.scrollTop;\n\t\t}\n\t\tel = el.offsetParent;\n\t}\n\treturn p;\n}\n"], ["reportNoLineBreakViolation", "\nfunction reportNoLineBreak(token) {\n            const tokenBefore = sourceCode.getTokenBefore(token, { includeComments: true });\n\n            context.report({\n                loc: {\n                    start: tokenBefore.loc.end,\n                    end: token.loc.start\n                },\n                messageId: \"unexpectedLineBreak\",\n                fix(fixer) {\n                    if (astUtils.isCommentToken(tokenBefore)) {\n                        return null;\n                    }\n\n                    if (!astUtils.isTokenOnSameLine(tokenBefore, token)) {\n                        return fixer.replaceTextRange([tokenBefore.range[1], token.range[0]], \" \");\n                    }\n\n                    \n                    const twoTokensBefore = sourceCode.getTokenBefore(tokenBefore, { includeComments: true });\n\n                    if (astUtils.isCommentToken(twoTokensBefore)) {\n                        return null;\n                    }\n\n                    return fixer.replaceTextRange([twoTokensBefore.range[1], tokenBefore.range[0]], \"\");\n\n                }\n            });\n        }\n"], ["convertToDragItem", "\nfunction origin2DragItem (liTable) {\n  css(liTable, { 'table-layout': 'fixed', width: 'initial', height: 'initial', padding: 0, margin: 0 });\n  ['width', 'height', 'id'].forEach((p) => {\n    liTable.removeAttribute(p);\n  });\n  liTable.classList.remove(classes.originTable);\n  Array.from(liTable.querySelectorAll('col')).forEach((col) => {\n    col.removeAttribute('width');\n    css(col, { width: 'initial' });\n  });\n}\n"], "```\n\nEach function was evaluated for its responsibilities. The <tags> denote the primary purpose of the functions without over-segmenting them. This provides clear annotations for SRP compliance."]