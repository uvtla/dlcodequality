[["getCookieToken", "\nfunction getCookieToken(res) {\n  <parseCookieValue>\n  var value = res.req.cookies[cookieName(res.req)];\n  if (!value)\n    return false;\n\n  var parts = value.split('|');\n  if (parts.length !== 3)\n    return false;\n  </parseCookieValue>\n\n  <validateUser>\n  if (parts[1] !== getUserData(res.req))\n    return false;\n  </validateUser>\n\n  <cryptoVerification>\n  var hasher = crypto.createHmac(options.algorithm, cookieKey);\n  hasher.update(parts[0]);\n  hasher.update(\"|\");  \n  hasher.update(parts[1]);\n\n  if (parts[2] !== hasher.digest('base64'))\n    return false;\n  </cryptoVerification>\n\n  return parts[0];\n}\n"], ["indentation", "\nfunction indentation(value, maximum) {\n  var values = value.split(lineFeed)\n  var position = values.length + 1\n  var minIndent = Infinity\n  var matrix = []\n  var index\n  var indentation\n  var stops\n  var padding\n\n  <initializeMatrix>\n  values.unshift(repeat(space, maximum) + exclamationMark)\n\n  while (position--) {\n    indentation = getIndent(values[position])\n    matrix[position] = indentation.stops\n    if (trim(values[position]).length === 0) {\n      continue\n    }\n\n    if (indentation.indent) {\n      if (indentation.indent > 0 && indentation.indent < minIndent) {\n        minIndent = indentation.indent\n      }\n    } else {\n      minIndent = Infinity\n\n      break\n    }\n  }\n  </initializeMatrix>\n\n  <applyIndentation>\n  if (minIndent !== Infinity) {\n    position = values.length\n\n    while (position--) {\n      stops = matrix[position]\n      index = minIndent\n\n      while (index && !(index in stops)) {\n        index--\n      }\n\n      if (\n        trim(values[position]).length !== 0 &&\n        minIndent &&\n        index !== minIndent\n      ) {\n        padding = tab\n      } else {\n        padding = ''\n      }\n\n      values[position] =\n        padding + values[position].slice(index in stops ? stops[index] + 1 : 0)\n    }\n  }\n\n  values.shift()\n\n  return values.join(lineFeed)\n  </applyIndentation>\n}\n"], ["retrieveIndexValue", "\nfunction (indexName, key) {\n  return new Promise((resolve, reject) => {\n    <checkIndexCache>\n    if (index[indexName]) {\n      resolve(index[indexName][key] || null);\n    } else {\n    </checkIndexCache>\n      <openIndex>\n      debug(\"opening index %s\", indexName);\n      storage.openIndex(indexName).then(index => {\n        index[indexName] = index;\n        resolve(index[indexName][key] || null);\n      });\n      </openIndex>\n    }\n  });\n}\n"], ["partitionObject", "\nfunction (obj, pred) {\n  var t = {};\n  var f = {};\n  <partitionLogic>\n  each(obj, function(x, i) {\n    var branch = pred(x, i) ? t : f;\n    branch[i] = x;\n  });\n  </partitionLogic>\n  return {\n    t: t,\n    f: f\n  };\n}\n"], ["generateArtifact", "\nfunction generate (generatorName, name, flags) {\n  let generator\n\n  <generatorSelection>\n  switch (generatorName) {\n    case 'app':\n      generator = new generators.App(name)\n      break;\n    case 'controller':\n      generator = new generators.Controller(name, flags)\n      break;\n    case 'model':\n      generator = new generators.Model(name, flags)\n      break;\n    case 'view':\n      console.log(`generating view ${name} ...`)\n      console.log('NotImplemented. View generation not yet available')\n      break;\n    case 'migration':\n      generator = new generators.Migration(name, flags)\n      break;\n    case 'scaffold':\n      console.log(`generating scaffold ${name} ...`)\n      console.log('NotImplemented. Scaffold generation not yet available')\n      break;\n    case 'user':\n      console.log(`generating user ${name} ...`)\n      console.log('NotImplemented. User generation not yet available')\n      break;\n    default:\n      if (!name) {\n        return generate('app', generatorName)\n      }\n  }\n  </generatorSelection>\n\n  <runGenerator>\n  if (!generator) {\n    return cli.showHelp(0)\n  }\n  return generator.run()\n  </runGenerator>\n}\n"], ["BaseTexture", "\nfunction BaseTexture(source, scaleMode, resolution)\n{\n  EventEmitter.call(this);\n\n  <initialization>\n  this.uuid = utils.uuid();\n  this.resolution = resolution || 1;\n  this.width = 100;\n  this.height = 100;\n  this.realWidth = 100;\n  this.realHeight = 100;\n  this.scaleMode = scaleMode || CONST.SCALE_MODES.DEFAULT;\n  this.hasLoaded = false;\n  this.isLoading = false;\n  this.source = null; \n  this.premultipliedAlpha = true;\n  this.imageUrl = null;\n  this.isPowerOfTwo = false;\n  this.mipmap = false;\n  this._glTextures = [];\n  </initialization>\n\n  <loadSource>\n  if (source)\n  {\n      this.loadSource(source);\n  }\n  </loadSource>\n}\n"], ["initializeTracker", "\nfunction(config) {\n    <initialSetup>\n    this._timerID = null;\n    this._timerDuration = 0;\n    this.config = this._initializeConfig(config);\n    this.requestOptions = this._initializeRequestOptions();\n    this.serializedContextQueue = [];\n    this.eventsBatchSize = 0;\n    this.eventFormatter = _defaultEventFormatter;\n    this.error = _err;\n    </initialSetup>\n\n    <bindMethods>\n    this._enableTimer = utils.bind(this, this._enableTimer);\n    this._disableTimer = utils.bind(this, this._disableTimer);\n    this._initializeConfig = utils.bind(this, this._initializeConfig);\n    this._initializeRequestOptions = utils.bind(this, this._initializeRequestOptions);\n    this._validateMessage = utils.bind(this, this._validateMessage);\n    this._initializeMetadata = utils.bind(this, this._initializeMetadata);\n    this._initializeContext = utils.bind(this, this._initializeContext);\n    this._makeBody = utils.bind(this, this._makeBody);\n    this._post = utils.bind(this, this._post);\n    this._sendEvents = utils.bind(this, this._sendEvents);\n    this.send = utils.bind(this, this.send);\n    this.flush = utils.bind(this, this.flush);\n    </bindMethods>\n}\n"], ["installExtensions", "\nfunction installExtensions(extensions, dir, opt_excludeWebDriverExt) {\n  var hasWebDriver = !!opt_excludeWebDriverExt;\n  var next = 0;\n  var extensionDir = path.join(dir, 'extensions');\n  var done = promise.defer();\n\n  <ensureExtensionDirExists>\n  return io.exists(extensionDir).then(function(exists) {\n    if (!exists) {\n      return promise.checkedNodeCall(fs.mkdir, extensionDir);\n    }\n  }).then(function() {\n    installNext();\n    return done.promise;\n  });\n  </ensureExtensionDirExists>\n\n  <installExtensionLogic>\n  function installNext() {\n    if (!done.isPending()) {\n      return;\n    }\n\n    if (next >= extensions.length) {\n      if (hasWebDriver) {\n        done.fulfill(dir);\n      } else {\n        install(WEBDRIVER_EXTENSION_PATH);\n      }\n    } else {\n      install(extensions[next++]);\n    }\n  }\n\n  function install(ext) {\n    extension.install(ext, extensionDir).then(function(id) {\n      hasWebDriver = hasWebDriver || (id === WEBDRIVER_EXTENSION_NAME);\n      installNext();\n    }, done.reject);\n }\n </installExtensionLogic>\n}\n"], ["onProgressEvent", "\nfunction ( type, text, numericalValue ) {\n  var content = THREE.LoaderSupport.Validator.isValid( text ) ? text: '';\n  var event = {\n    detail: {\n      type: type,\n      modelName: this.modelName,\n      instanceNo: this.instanceNo,\n      text: content,\n      numericalValue: numericalValue\n    }\n  };\n\n  <dispatchEvent>\n  if ( THREE.LoaderSupport.Validator.isValid( this.callbacks.onProgress ) ) this.callbacks.onProgress( event );\n  </dispatchEvent>\n\n  <debugLog>\n  if ( this.logging.enabled && this.logging.debug ) console.debug( content );\n  </debugLog>\n}\n"], ["initializeRealtime", "\nasync function initializeRealtime({ getApp, onCreate, onDelete, url, token }) {\n  const realtimeConfig = { token, url }\n\n  <setRealtimeSubscription>\n  try {\n    realtime\n      .subscribe(realtimeConfig, APPS_DOCTYPE)\n      <onRealtimeCreate>\n      .onCreate(async app => {\n        \n        let fullApp\n        try {\n          fullApp = await getApp(app.slug)\n        } catch (error) {\n          throw new Error(`Cannot fetch app ${app.slug}: ${error.message}`)\n        }\n\n        if (typeof onCreate === 'function') {\n          onCreate(fullApp)\n        }\n      })\n      </onRealtimeCreate>\n      <onRealtimeDelete>\n      .onDelete(app => {\n        if (typeof onDelete === 'function') {\n          onDelete(app)\n        }\n      })\n      </onRealtimeDelete>\n  } catch (error) {\n    console.warn(`Cannot initialize realtime in Cozy-bar: ${error.message}`)\n  }\n  </setRealtimeSubscription>\n}\n"], "```"]