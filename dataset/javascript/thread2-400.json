[["set", "\nfunction set(target, path, value) {\n    if (path.length === 0) {\n        return value;\n    }\n    return assign(Array.isArray(target) ? [] : {}, target, (_a = {},\n        _a[path[0]] = path.length > 1 ? set(target[path[0]] || {}, path.slice(1), value) : value,\n        _a));\n    var _a;\n}\n"], ["rank", "\nfunction rank (competingCombinations) {\n  let exequoCount = -1;\n\n  return competingCombinations\n    .map((cards, i) => {\n      <getHandRank>\n      const rank = getHandRank(cards);\n      </getHandRank>\n      cards.index = i;\n      cards.rank = rank;\n      return cards;\n    })\n    .sort(function sortByRank (comb1, comb2) {\n      <sortByStrength>\n      const rank1 = comb1.rank;\n      const rank2 = comb2.rank;\n      if (rank1.strength !== rank2.strength) {\n        return rank2.strength - rank1.strength;\n      }\n      </sortByStrength>\n\n      <sortByRank>\n      const val1 = getCardRank(rank1.rank);\n      const val2 = getCardRank(rank2.rank);\n      if (val1 !== val2) {\n        return val2 - val1;\n      }\n      </sortByRank>\n\n      <sortByKickers>\n      for (let i = 0; i < rank1.kickers.length; i++) {\n        const kicker1 = getCardRank(rank1.kickers[i]);\n        const kicker2 = getCardRank(rank2.kickers[i]);\n        if (kicker1 !== kicker2) {\n          return kicker2 - kicker1;\n        }\n      }\n      </sortByKickers>\n\n      <resolveExequo>\n      const label = comb1.exequo || comb2.exequo || \"#\" + (++exequoCount);\n      comb1.exequo = comb2.exequo = label;\n      </resolveExequo>\n    });\n}\n"], ["cleanRedundantCode", "\nfunction cleanRedundantCode(str, opts){\n    opts = opts || {};\n    var minimize = def(opts.minimize, true);\n    var comments = opts.comments || {};\n    var htmlComments = comments.html,\n        rglComments = comments.rgl;\n\n    if(minimize && typeof str === 'string'){\n        var SINGLE_SPACE = ' ';\n        var EMPTY = '';\n\n        <removeHtmlComments>\n        str = !htmlComments ? str.replace(/<!-[\\s\\S]*?-->/g, EMPTY) : str;\n        </removeHtmlComments>\n\n        <removeRglComments>\n        str = !rglComments ? str.replace(/{![\\s\\S]*?!}/g, EMPTY) : str;\n        </removeRglComments>\n\n        <replaceWhitespace>\n        str = str.replace(/[\\f\\t\\v]{2,}/g, SINGLE_SPACE);\n        </replaceWhitespace>\n\n        <trimString>\n        str = str.trim();\n        </trimString>\n    }\n    return str;\n}\n"], ["getNewlineStr", "\nfunction getNewlineStr(sample) {\n\tvar candidates = [\"\\r\\n\", \"\\n\\r\", \"\\n\", \"\\r\"];\n\tvar nrLines = {};\n\tvar lineLengths = {};\n\tvar threshold = 5; \n\n    <countNewlines>\n\tcandidates.forEach(function(newlineStr) {\n\t\tnrLines[newlineStr] = 1;\n\t\tvar l = [];\n\t\tvar curPos = 0;\n\t\twhile((newlinePos = sample.indexOf(newlineStr, curPos)) > -1) {\n\t\t\t++nrLines[newlineStr];\n\t\t\tvar lineLength = newlinePos - curPos;\n\t\t\tl.push(lineLength);\n\t\t\tcurPos = newlinePos + newlineStr.length;\n\t\t}\n\t\tlineLengths[newlineStr] = l;\n\t});\n    </countNewlines>\n\n    <eliminateImpossibleCandidates>\n\t[\"\\r\\n\", \"\\n\\r\"].forEach(function(newlineStr) {\n\t\tvar nr = nrLines[newlineStr];\n\t\tif(nr > 1) {\n\t\t\t[\"\\n\", \"\\r\"].forEach(function(newlineStr) {\n\t\t\t\tif(nrLines[newlineStr] == nr) {\n\t\t\t\t\tnrLines[newlineStr] = 1;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t});\n    </eliminateImpossibleCandidates>\n\n    <chooseRemainingCandidates>\n\tvar remainingCandidates = [];\n\tcandidates.forEach(function(newlineStr) {\n\t\tif(nrLines[newlineStr] > 1) {\n\t\t\tremainingCandidates.push(newlineStr);\n\t\t}\n\t});\n    </chooseRemainingCandidates>\n\n    <selectNewlineCandidate>\n\tif(remainingCandidates.length == 0) {\n\t\treturn null;\n\t}\n\tif(remainingCandidates.length == 1) {\n\t\treturn remainingCandidates[0];\n\t}\n\n\tvar finalRemainers = [];\n\tvar maxNrLines = 0;\n\tremainingCandidates.forEach(function(newlineStr) {\n\t\tvar curNrLines = nrLines[newlineStr];\n\t\tmaxNrLines = Math.max(maxNrLines, curNrLines);\n\t\tif(curNrLines > threshold) {\n\t\t\tfinalRemainers.push(newlineStr);\n\t\t}\n\t});\n\n\tif(finalRemainers.length == 0) {\n\t\tvar winner = null;\n\t\tremainingCandidates.some(function(newlineStr) {\n\t\t\tif(nrLines[newlineStr] == maxNrLines) {\n\t\t\t\twinner = newlineStr;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t});\n\t\treturn winner;\n\t}\n\tif(finalRemainers.length == 1) {\n\t\treturn finalRemainers[0];\n\t}\n\n\tvar winner = null;\n\tvar winnerScore = Infinity;\n\tfinalRemainers.forEach(function(newlineStr) {\n\t\tvar l = lineLengths[newlineStr];\n\t\tvar sum = 0;\n\t\tl.forEach(function(d) { sum += d; });\n\t\tvar avg = sum / l.length;\n\n\t\tvar absSum = 0;\n\t\tl.forEach(function(d) { absSum += Math.abs(d - avg); });\n\t\tvar score = absSum / l.length / avg; \n\n\t\tif(score < winnerScore) {\n\t\t\twinnerScore = score;\n\t\t\twinner = newlineStr;\n\t\t}\n\t});\n\treturn winner;\n    </selectNewlineCandidate>\n}\n"], ["getTransactionSuccess", "\nfunction getTransactionSuccess(eth, txHash, timeout = 800000, callback) {\n  const cb = callback || function cb() {};\n  let count = 0;\n  return new Promise((resolve, reject) => {\n    const txInterval = setInterval(() => {\n      <getTransactionReceipt>\n      eth.getTransactionReceipt(txHash, (err, result) => {\n        if (err) {\n          clearInterval(txInterval);\n          cb(err, null);\n          reject(err);\n        }\n\n        if (!err && result) {\n          clearInterval(txInterval);\n          cb(null, result);\n          resolve(result);\n        }\n      });\n      </getTransactionReceipt>\n\n      <checkTimeout>\n      if (count >= timeout) {\n        clearInterval(txInterval);\n        const errMessage = `Receipt timeout waiting for tx hash: ${txHash}`;\n        cb(errMessage, null);\n        reject(errMessage);\n      }\n      </checkTimeout>\n      \n      count += 7000;\n    }, 7000);\n  });\n}\n"], ["debugLogging", "\nfunction (smth) {\n    <conditionalDebug>\n    if (typeof debug !== \"undefined\") {\n        debug(smth);\n    }\n    </conditionalDebug>\n    <conditionalConsoleLog>\n    else if (global.console && global.console.log) {\n        global.console.log(smth);\n    }\n    </conditionalConsoleLog>\n}\n"], ["dataViewInitialization", "\nfunction(data_source) {\n    <debugCheck>\n\t\tif (Lava.schema.DEBUG && !data_source.isCollection) Lava.t(\"Wrong argument supplied for DataView constructor\");\n    </debugCheck>\n\t\tthis._data_source = data_source;\n}\n"], ["extract", "\nfunction() {\n        var l_sFile = arguments[0],\n            l_sOutputDir = arguments[1],\n            l_oOptions,\n            l_oCallback,\n            l_aUnrarredFiles = [],\n            l_sError;\n\n        <argumentProcessing>\n        \n        \n        \n        \n\n        if (typeof(arguments[2]) === \"function\") {\n            l_oOptions = {};\n            l_oCallback = arguments[2];\n        } else {\n            l_oOptions = arguments[2] || {};\n            l_oCallback = arguments[3];\n        }\n\n        if (!l_sFile || typeof(l_sFile) !== \"string\") {\n            throw (\"Unrar::Error, missing file argument.\");\n        }\n\n        if (!l_sOutputDir || typeof(l_sOutputDir) !== \"string\") {\n            throw (\"Unrar::Error, missing output directory argument.\");\n        }\n\n        if (!l_oCallback) {\n            throw (\"Unrar::Error, missing callback argument.\");\n        }\n        </argumentProcessing>\n\n        <unrarProcess>\n        childProcess = child_process.fork(path.join(__dirname, \"js/UnrarSubprocess.js\"), [l_sFile, l_sOutputDir]);\n\n        childProcess.on('message', (m) => {\n            if (m.event === \"progress\") {\n                if (l_oOptions.onProgress) {\n                    l_oOptions.onProgress(m.data);\n                }\n            } else if (m.event === \"finish\") {\n                l_aUnrarredFiles = m.data;\n                childProcess.kill();\n            } else if (m.event === \"error\") {\n                l_sError = m.data;\n                childProcess.kill(\"SIGKILL\");\n            } else if (m.event === \"abort\") {\n                l_sError = m.data;\n                childProcess.kill(\"SIGKILL\");\n            }\n\n        });\n\n        childProcess.on('close', function() {\n            l_oCallback(l_sError, l_aUnrarredFiles);\n        });\n        </unrarProcess>\n    }\n"], ["checkCombinator3", "\nfunction checkCombinator3(i) {\n    <identifyCombinator>\n    const type = tokens[i].type;\n    if (type === TokenType.PlusSign ||\n        type === TokenType.GreaterThanSign ||\n        type === TokenType.Tilde) return 1;\n    else return 0;\n    </identifyCombinator>\n}\n"], ["_onInboxMessage", "\nfunction _onInboxMessage (sender, _, msgBuffer) {\n    let message = JSON.parse(msgBuffer)\n    <setIP>\n    masterBroker.setIP(message.toAddress)\n    </setIP>\n\n    switch (message.type) {\n      case 'voteRequest':\n        <handleVoteRequest>\n        debug(`sending vote to ${node.name === message.from ? 'myself' : message.from}`)\n        _inbox.send([sender, _, JSON.stringify({\n          id: _advertiseId || node.id,\n          name: node.name,\n          endpoints: masterBroker.endpoints,\n          isMaster: masterBroker.isMaster,\n          candidate: !_advertiseId\n        })])\n        </handleVoteRequest>\n        break\n      case 'masterRequest':\n        <handleMasterRequest>\n        let connectedMaster = node.master\n        if (connectedMaster) {\n          debug(`sending master coordinates to ${message.from}`)\n          _inbox.send([sender, _, JSON.stringify(connectedMaster)])\n        } else {\n          debug(`unable to send master coordinates to ${message.from}`)\n          _inbox.send([sender, _, JSON.stringify(false)])\n        }\n        </handleMasterRequest>\n        break\n      case 'masterElected':\n        <handleMasterElected>\n        _inbox.send([sender, _, ''])\n        debug(`received notice of master election: ${message.data.name}`)\n        resolver.emit('newmaster', message.data)\n        </handleMasterElected>\n    }\n  }\n"], "```"]