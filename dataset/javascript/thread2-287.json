[["to_kwargs", "\nfunction to_kwargs(args, sortedKeys) {\n    var s = '';\n    if (!sortedKeys) {\n        var sortedKeys = keys(args).sort();\n    }\n    for (var i = 0; i < sortedKeys.length; ++i) {\n        var k = sortedKeys[i];\n        if (args[k] != undefined) {\n            if (s) {\n                s += ', ';\n            }\n            s += k + '=' + args[k];\n        }\n    }\n    return s;\n}\n"], ["hasAttribute", "\nfunction hasAttribute(element, attrName) {\n    if (typeof element.hasAttribute === 'function') {\n        return element.hasAttribute(attrName)\n    }\n    return element.getAttribute(attrName) !== null\n}\n"], ["getElementCoordinates", "\nfunction(element) {\n    var c = {};\n    try {\n        var rect = element.getBoundingClientRect();\n        c.x = Math.floor((rect.left + rect.right) / 2);\n        c.y = Math.floor((rect.top + rect.bottom) / 2);\n    } catch (e) {\n        c.x = 1;\n        c.y = 1;\n    }\n    return c;\n}\n"], ["manipulateStylesAndAttributes", "\nfunction (node, tagName, attrs) {\n    var list = domUtils.getElementsByTagName(node, node.tagName.toLowerCase());\n    for (var i = 0, ci; ci = list[i++];) {\n        // Not annotating because this is also part of manipulating styles and attributes for nodes\n        if (!ci.parentNode || domUtils.isBookmarkNode(ci)) {\n            continue;\n        }\n        \n        // Not annotating because this is also part of manipulating styles and attributes for nodes\n        if (ci.tagName.toLowerCase() == 'span') {\n            // Not annotating because this is also part of manipulating styles and attributes for nodes\n            ...\n            // The whole block inside this 'if' condition deals with style and attribute manipulation\n        }\n        // Not annotating because this is also part of manipulating styles and attributes for nodes\n        if (domUtils.isSameElement(node, ci)) {\n            domUtils.remove(ci, true);\n        }\n    }\n}\n"], ["generateCodeHandlerJs", "\nfunction generateCodeHandlerJs(config) {\n    \n    var handler_js = null;\n    // Read and setup handler code\n    try {\n        <readHandlerJs>\n        handler_js = fs.readFileSync(HANDLER_FILENAME).toString();\n        </readHandlerJs>\n    } catch (e) {\n        <fallbackToTemplateRead>\n        handler_js = fs.readFileSync(__dirname + '/../templates/' + HANDLER_FILENAME + '.tmpl').toString();\n        </fallbackToTemplateRead>\n    }\n\n    // Add command functions to handler\n    for (var cmd_name in config.commands) {\n        <checkCommandNameValidity>\n        if (!cmd_name.match(/^[a-zA-Z][a-zA-Z0-9]+$/)) {\n            throw new Error('Defined method name is invalid format: ' + cmd_name);\n        }\n        </checkCommandNameValidity>\n\n        <checkIfCommandExists>\n        if (handler_js.indexOf(cmd_name) != -1) { \n            continue; \n        }\n        </checkIfCommandExists>\n\n        //...\n        // Several steps are involved in generating the JS functions\n        // This is still part of the responsibility to add command functions to the handler\n    }\n\n    // Replace placeholders with respective config values\n    <replacePlaceholders>\n    for (var config_key in config) {\n        handler_js = handler_js.replace(new RegExp('\\\\%' + config_key + '\\\\%', 'g'), config[config_key]);\n    }\n    </replacePlaceholders>\n\n    // Ensure module export is set\n    <ensureModuleExport>\n    if (!handler_js.match(/module\\.exports = CommandsHandler;/)) {\n        handler_js += '\\n\\nmodule.exports = CommandsHandler;\\n';\n    }\n    </ensureModuleExport>\n\n    return handler_js;\n}\n"], ["formatAttributes", "\nfunction formatAttributes(attrObj) {\n    var attributes = [];\n\n    for (var attribute in attrObj) {\n        attributes.push(attribute + '=\"' + attrObj[attribute] + '\"');\n    }\n\n    return attributes.join(' ');\n}\n"], ["renderView", "\nfunction() {\n    this.isClosed = false;\n\n    this.triggerMethod(\"before:render\", this);\n    this.triggerMethod(\"item:before:render\", this);\n\n    var data = this.serializeData();\n    data = this.mixinTemplateHelpers(data);\n\n    var template = this.getTemplate();\n    var html = Marionette.Renderer.render(template, data);\n\n    this.$el.html(html);\n    this.bindUIElements();\n\n    this.triggerMethod(\"render\", this);\n    this.triggerMethod(\"item:rendered\", this);\n\n    return this;\n}\n"], ["App", "\nfunction App() {\n    // React component rendering logic with embedded JSX is considered as a single responsibility\n    // Annotations within JSX or React component render functions are typically unnecessary unless there's explicit mix of responsibilities (like API calls, complex data processing, etc.)\n    // This App function doesn't seem to require internal annotations\n    ...\n}\n"], ["isCandidate", "\nfunction isCandidate(modulePath) {\n    modulePath = modulePath || '';\n    var pathParts = modulePath.split(delim);\n    return (pathParts.length === 4 &&\n            pathParts[0] === 'app' &&\n            uiTypes.indexOf(pathParts[2]) >= 0);\n}\n"], ["wheelOn", "\nfunction wheelOn(options, callback) {\n    if (typeof options === 'function') {\n        callback = options;\n        options = {};\n    }\n    this.logger('RollingSpider#wheelOn');\n    this.writeTo(\n        'fa0b',\n        new Buffer([0x02, ++this.steps.fa0b & 0xFF, 0x02, 0x01, 0x02, 0x00, 0x01])\n    );\n\n    if (callback) {\n        callback();\n    }\n}\n"], "```\nCompliant with SRP - It enables the wheel mode on a Rolling Spider drone and triggers a callback."]