[["stripExtension", "\nfunction stripExtension(url) {\n  var lastDotPos = url.lastIndexOf('.');\n  return (lastDotPos <= 0)? url:\n    url.substring (0, lastDotPos - 1);\n}\n"], ["Client", "\nfunction Client(options) {\n    <checkOptionsType>\n    if (typeof options === 'object') </checkOptionsType> {\n      <checkOptionsKeys>\n      if (options.AccessKeyId && options.AccessKeySecret) </checkOptionsKeys> {\n        <assignOptions>\n        _.assign(this.options, options);\n        </assignOptions>\n      } else {\n        <throwAccessKeysError>\n        throw new Error('\u8bf7\u8bbe\u7f6eAccessKeyId\u548cAccessKeySecret');\n        </throwAccessKeysError>\n      }\n    } else {\n      <throwTypeError>\n      throw new Error('\u5b9e\u4f8b\u5316\u53c2\u6570\u7c7b\u578b\u4e0d\u6b63\u786e');\n      </throwTypeError>\n    }\n  }\n"], ["anonymousFunction", "\nfunction() {\n          <setupContext>\n          var ctx = u.context(SMALL);\n          </setupContext>\n\n          <logDebug>\n          logger.debugf('Invoke iterator.close(msgId=%d,iteratorId=%s) on %s', ctx.id, iterId, conn.toString());\n          </logDebug>\n\n          <returnFuturePinned>\n          return futurePinned(\n              ctx, 0x35, p.encodeIterId(iterId), p.complete(p.hasSuccess), conn);\n          </returnFuturePinned>\n        }\n"], ["Wysiwyg", "\nfunction Wysiwyg( element, userOptions ) {\n        <initialize>\n        this.selectedRange = null;\n        this.editor = $( element );\n        var editor = $( element );\n        </initialize>\n\n        <defineDefaults>\n        var defaults = {\n            // definition...\n        };\n        </defineDefaults>\n\n        <extendOptions>\n        var options = $.extend( true, {}, defaults, userOptions );\n        </extendOptions>\n\n        <setToolbarSelector>\n        var toolbarBtnSelector = \"a[data-\" + options.commandRole + \"],button[data-\" + options.commandRole + \"],input[type=button][data-\" + options.commandRole + \"]\";\n        </setToolbarSelector>\n\n        <bindHotkeys>\n        this.bindHotkeys( editor, options, toolbarBtnSelector );\n        </bindHotkeys>\n\n        <initDragDrop>\n        if ( options.dragAndDropImages ) {\n            this.initFileDrops( editor, options, toolbarBtnSelector );\n        }\n        </initDragDrop>\n\n        <bindToolbar>\n        this.bindToolbar( editor, $( options.toolbarSelector ), options, toolbarBtnSelector );\n        </bindToolbar>\n\n        <configureEditor>\n        editor.attr( \"contenteditable\", true )\n            .on( \"mouseup keyup mouseout\", function() {\n                this.saveSelection();\n                this.updateToolbar( editor, toolbarBtnSelector, options );\n            }.bind( this ) );\n        </configureEditor>\n\n        <handleTouchEnd>\n        $( window ).bind( \"touchend\", function( e ) {\n            // ...\n        } );\n        </handleTouchEnd>\n     }\n"], ["APIRequest", "\nfunction APIRequest(method, url) {\n\t<initialization>\n    var data, callback, opts, req, headers = messageHeaders(this);\n\tcallback = ( typeof(arguments[2]) === 'function' ? arguments[2] : (data = arguments[2], arguments[3]) );\n    </initialization>\n\n    <handleNode>\n\tif (isNode) {\n\t\t// ... node-specific logic ...\n\t}\n    </handleNode>\n\n    <handleBrowser>\n\treq = new XMLHttpRequest();\n\t// ... XMLHttpRequest-specific logic ...\n\tif (data) return req.send( data.result ? data.result : JSON.stringify(data) );\n\treq.send(null);\n    </handleBrowser>\n}\n"], ["nanquantiles", "\nfunction nanquantiles( arr, num, opts ) {\n\t<variableDeclarations>\n\tvar sorted,\n\t\t// ...\n\t\ti;\n    </variableDeclarations>\n\n    <inputValidation>\n    // ... throw error conditions ...\n\t</inputValidation>\n\n\t<filterNonNumbers>\n\td = [];\n\tfor ( i = 0; i < arr.length; i++ ) {\n\t\t// ... filtering logic ...\n\t}\n    </filterNonNumbers>\n\n    <sortCheck>\n\tif ( !sorted ) {\n\t\td.sort( ascending );\n\t}\n\t</sortCheck>\n\n\t<calculateQuantiles>\n\tqValues = new Array( num+1 );\n\t// ...\n\t</calculateQuantiles> \n\n\treturn qValues;\n}\n"], ["Cache", "\nfunction Cache(opts) {\n    <initializeProperties>\n    this.assoc = opts.assoc;\n    this.size = opts.size;\n    if (opts.serialize !== undefined)\n        this.serialize = opts.serialize;\n    var algo = opts.algorithm || opts.evict || 'lru';\n    this.algorithm = typeof algo == 'string'\n                      ? algorithms[algo]\n                      : algo;\n\n    this.sets = new Array(this.size);\n    this.stat = {\n        hits: 0,\n        misses: 0\n    };\n    </initializeProperties>\n}\n"], ["children", "\nfunction children(selector) {\n  <initializeArray>\n  var arr = [], slice = this.slice, nodes, matches;\n  </initializeArray>\n  \n  <loopEachElement>\n  this.each(function(el) {\n    <collectChildNodes>\n    nodes = slice.call(el.childNodes);\n    </collectChildNodes>\n    \n    <filterElementsByType>\n    nodes = nodes.filter(function(n) {\n      if(n instanceof Element) { return n;}\n    })\n    </filterElementsByType>\n    \n    <applySelector>\n    if(selector) {\n      matches = slice.call(el.querySelectorAll(selector));\n      for(var i = 0;i < nodes.length;i++) {\n        if(~matches.indexOf(nodes[i])) {\n          arr.push(nodes[i]);\n        }\n      }\n    } else {\n      arr = arr.concat(nodes);\n    }\n    </applySelector>\n  });\n  </loopEachElement>\n\n  <returnWrappedArray>\n  return this.air(arr);\n  </returnWrappedArray>\n}\n"], ["unexpectedStyleEntries", "\nfunction(style)\n\t{\n\t\t<declareResultArray>\n\t\tvar result = [];\n\t\t</declareResultArray>\n\t\t\n\t\t<processStyle>\n\t\tif (style != null)\n\t\t{\n\t\t\tvar pairs = style.split(';');\n\t\t\t\n\t\t\tfor (var i = 0; i < pairs.length; i++)\n\t\t\t{\n\t\t\t\tif (pairs[i].indexOf('=') < 0)\n\t\t\t\t{\n\t\t\t\t\tresult.push(pairs[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t</processStyle>\n\n\t\t<returnResult>\n\t\treturn result;\n\t\t</returnResult>\n\t}\n"], ["LSTM", "\nfunction LSTM(linalg, params) {\n  <declareDependencies>\n  const Vector = linalg.Vector;\n  </declareDependencies>\n\n  <defineStateFunctions>\n  function makeState() {\n    return new Vector(params.nNodes * params.nLayers * 2);\n  }\n\n  function resetState(state) {\n    linalg.zero(state, state);\n    return state;\n  }\n\n  function copyState(state) {\n    return new Vector(state);\n  }\n  </defineStateFunctions>\n\n  <defineForwardFunction>\n  function forward(inState, byte, outState) {\n    var input = byteToVector(byte);\n    for (var n = 0; n < params.nLayers; n++) {\n      input = forwardLayer(\n          // ...\n      );\n    }\n    return outState;\n  }\n  </defineForwardFunction>\n\n  <definePredictFunction>\n  function predict(state) {\n    var topH = indexState(state, 2 * params.nLayers - 1);\n    var probs = params.affines[2 * params.nLayers](topH);\n    linalg.exp(probs, probs);\n    normalize(probs, probs);\n    return probs;\n  }\n  </definePredictFunction>\n\n  <defineForwardLayerFunction>\n  function forwardLayer(prevC, prevH, x, i2h, h2h, nextC, nextH) {\n    // ...\n    return nextH;\n  }\n  </defineForwardLayerFunction>\n\n  <utilityFunctions>\n  function indexState(state, n) {\n    return state.subarray(n * params.nNodes, (n + 1) * params.nNodes);\n  }\n\n  function normalize(inVec, outVec) {\n    var sum = inVec.reduce((x, y) => x + y);\n    return linalg.scalarMult(inVec, 1 / sum, outVec);\n  }\n\n  function byteToIndex(byte) {\n    return params.vocab[byte];\n  }\n\n  function indexToByte(index) {\n    return params.ivocab[index];\n  }\n\n  function byteToVector(byte) {\n    var vec = new Vector(params.affines[0].inLength);\n    vec[byteToIndex(byte)] = 1.;\n    return vec;\n  }\n  </utilityFunctions>\n\n  <returnAPI>\n  return {\n    makeState: makeState,\n    copyState: copyState,\n    resetState: resetState,\n    forward: forward,\n    predict: predict,\n    indexToByte: indexToByte,\n    byteToIndex: byteToIndex,\n  };\n  </returnAPI>\n}\n"], ""]