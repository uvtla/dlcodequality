[["getItem", "\nfunction getItem(tableName, key, opts, desc, context) {\n  try {\n    <constructParams>\n    const params = {\n      TableName: tableName,\n      Key: key\n    };\n    if (opts) <mergeOptions>merge(opts, params, mergeOpts);</mergeOptions>\n    </constructParams>\n\n    <traceLoadingStart>\n    if (context.traceEnabled) context.trace(`Loading ${desc} from ${tableName} using params (${JSON.stringify(params)})`);\n    </traceLoadingStart>\n\n    <databaseOperation>\n    return context.dynamoDBDocClient.get(params).promise()\n      .then(result => {\n        <traceLoadingResult>\n        if (context.traceEnabled) context.trace(`Loaded ${desc} from ${tableName} - result (${JSON.stringify(result)})`);\n        </traceLoadingResult>\n        <checkResultType>\n        if (result && typeof result === 'object') {\n          return result;\n        } else {\n          throw new TypeError(`Unexpected result from get ${desc} from ${tableName} - result (${JSON.stringify(result)})`);\n        }\n        </checkResultType>\n      })\n      .catch(err => {\n        <errorHandling>\n        context.error(`Failed to load ${desc} from ${tableName}`, err);\n        throw err;\n        </errorHandling>\n      });\n    </databaseOperation>\n\n  } catch (err) {\n    <errorHandling>\n    context.error(`Failed to load ${desc} from ${tableName}`, err);\n    return Promise.reject(err);\n    </errorHandling>\n  }\n}\n"], ["functionNameMissing", "\nfunction(assert, mActual, mExpected, sMessage) {\n    var aUnexpectedElements = [];\n\n    <detectUnexpectedElements>\n    for (var sId in mActual) {\n        if (!mExpected[sId]) {\n            aUnexpectedElements.push(mActual[sId]);\n        }\n    }\n    </detectUnexpectedElements>\n\n    <formatFailureMessage>\n    for (var i = 0; i < aUnexpectedElements.length; i++) {\n        if (typeof aUnexpectedElements[i].getText === \"function\") {\n            aUnexpectedElements[i] += \" (text: '\" + aUnexpectedElements[i].getText() + \"')\";\n        }\n    }\n    </formatFailureMessage>\n\n    <assertTest>\n    sMessage = sMessage + (aUnexpectedElements.length > 0 ? \". LEFTOVERS: \" + aUnexpectedElements.join(\", \") : \"\");\n    assert.equal(aUnexpectedElements.length, 0, sMessage);\n    </assertTest>\n}\n"], ["handleEvent", "\nfunction(time) {\n    var self = this;\n    <recordEvent>\n    self.eventDetection.recordRelease(time);\n    </recordEvent>\n\n    if (self.eventDetection.isLongPress()) {\n      <resetAndNotifyLongPress>\n      self.eventDetection.reset();\n      self._notifyObservers(self.onLongPressCallbackRegistry);\n      </resetAndNotifyLongPress>\n      \n    } else {\n      if (self.eventDetection.onReleaseCount >= 2) {\n        <resetAndNotifyDoublePress>\n        self.eventDetection.reset();\n        self._notifyObservers(self.onDoublePressCallbackRegistry);\n        </resetAndNotifyDoublePress>\n      }\n\n      <delayedShortPressCheck>\n      setTimeout(function(){\n        if (self.eventDetection.onReleaseCount == 1) {\n          <resetAndNotifyShortPress>\n          self.eventDetection.reset();\n          self._notifyObservers(self.onShortPressCallbackRegistry);\n          </resetAndNotifyShortPress>\n        }\n      }, 300); \n      </delayedShortPressCheck>\n    }\n}\n"], ["Manager", "\nfunction Manager(options) {\n  <initializeProperties>\n  this.roleGetters_ = {};\n  this.entityGetters_ = {};\n  this.actionDefs_ = {};\n  </initializeProperties>\n  <setDefaultOptions>\n  this.options = {\n    pauseStream: true\n  };\n  </setDefaultOptions>\n  <overrideDefaultOptions>\n  if (options) {\n    for (var option in this.options) {\n      if (options.hasOwnProperty(option)) {\n        this.options[option] = options[option];\n      }\n    }\n  }\n  </overrideDefaultOptions>\n}\n"], ["LineMaker", "\nfunction LineMaker(options) {\n    <setInitialProperties>\n    this._tabSize = options.tabSize || 2;\n    this._styleMode = typeof options.styleMode === 'undefined' ? LineMaker.STYLE_ALL : options.styleMode;\n    this._continuation = options.continuation || '';\n    this._writeFunc = options.writeFunc || null;\n    </setInitialProperties>\n    \n    <initializeStyleMap>\n    this._styleMap = { \n        bold: '\\x1b[1m',\n        /* ... Other styles ... */\n    };\n    </initializeStyleMap>\n    <extendStyleMap>\n    if (options.styleMap) {\n        for (var styleName in options.styleMap)\n            this._styleMap[styleName] = options.styleMap[styleName];\n    }\n    </extendStyleMap>\n\n    <setColorMode>\n    if (this._styleMode > LineMaker.STYLE_MONOCHROME) {\n        // Code to determine color support and set style mode accordingly\n    }\n    </setColorMode>\n\n    <finalizeLineMakerSetup>\n    this._lineIsClear = true;\n    this._upLineCount = 0;\n    this._blanksInARow = 0;\n    </finalizeLineMakerSetup>\n}\n"], ["getUserFromOrganization", "\nfunction (orgIdOrSlug, userId, params) {\n      var path;\n      <validateAndConstructPath>\n      if (orgIdOrSlug) {\n        path = this.constructPath(constants.ORGANIZATIONS, orgIdOrSlug, constants.USERS, userId);\n        return this.Core.GET(path);\n      } else {\n        return this.rejectRequest('Bad Request: An organization id or slug is required.');\n      }\n      </validateAndConstructPath>\n}\n"], ["supportsFeature", "\nfunction(){\n    var feature = this.supportsFeature()\n      , op\n      , expr;\n    <buildExpression>\n    if (feature) {\n      expr = new nodes.Expression;\n      expr.push(feature);\n      while (op = this.accept('&&') || this.accept('||')) {\n        expr.push(new nodes.Literal('&&' == op.val ? 'and' : 'or'));\n        expr.push(this.supportsFeature());\n      }\n      return expr;\n    }\n    </buildExpression>\n}\n"], ["generateRandomString", "\nfunction () {\n            <createRandomString>\n            var rand = '' + Math.random() * 1000 * new Date().getTime();\n            return rand.replace('.', '').split('').sort(function () {\n                return 0.5 - Math.random();\n            }).join('');\n            </createRandomString>\n}\n"], ["invokeMethodOnEachItem", "\nfunction (name) {\n        var self = this, args = Tools.toArray(arguments).slice(1);\n\n        <executeMethodOnEach>\n        self.each(function (item) {\n          if (item[name]) {\n            item[name].apply(item, args);\n          }\n        });\n        </executeMethodOnEach>\n\n        return self;\n}\n"], ["filterIgnored", "\nfunction filterIgnored(files, ignore, fn) {\n  <filterFiles>\n  fn(null, files.filter(function(file) {\n    \n    return !~ignore.indexOf(file) && !~ignore.indexOf(file + '/');\n  }));\n  </filterFiles>\n}\n"], "```\n\n- Note: The function `getNameMissing` and the block `<buildExpression>` had their names or contents assumed as the actual function name/content was not provided, so it has been annotated with respective containers indicating the missing parts and other operations. The function should be properly labeled if its name is provided."]