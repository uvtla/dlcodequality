[["Bitimports", "\nfunction Bitimports(options) {\n  <mergeSettings>\n  var settings = utils.merge({}, defaults, options);\n  </mergeSettings>\n  \n  <configureResolve>\n  if (!settings.resolve) {\n    var resolver = factory.create(\"resolver\", settings);\n    settings.resolve = resolver.resolve.bind(resolver);\n  }\n  </configureResolve>\n  \n  <configureFetch>\n  if (!settings.fetch) {\n    var fetcher = factory.create(\"fetcher\", settings);\n    settings.fetch = fetcher.fetch.bind(fetcher);\n  }\n  </configureFetch>\n\n  <initBitloader>\n  Bitloader.call(this, settings);\n  </initBitloader>\n  \n  <pluginConfiguration>\n  this.plugin(\"js\", {\n    \"dependency\": dependency\n  });\n  </pluginConfiguration>\n\n  <optionalNodeModuleIgnored>\n  if (settings.doNotIgnoreNodeModules !== true) {\n    this.services.transform.ignore(\"path\", /node_modules/);\n    this.services.dependency.ignore(\"path\", /node_modules/);\n  }\n  </optionalNodeModuleIgnored>\n}\n"], ["getOrDefault", "\nfunction getOrDefault (source, path, defaultVal) {\n  var isAlreadySplitted = isArray(path);\n\n  if (!isDefined(source)) return defaultVal;\n  if (!isString(path) && !isAlreadySplitted) return defaultVal;\n\n  var tokens = isAlreadySplitted ? path : path.split('.');\n  var idx, key;\n\n  for (idx in tokens) {\n    key = tokens[idx];\n\n    if (isDefined(source[key])) \n      source = source[key];\n    else \n      return defaultVal;\n  }\n\n  return source;\n}\n"], ["moveOrCollapseCursor", "\nfunction (node, offset) {\n  var self = this, rng = self.dom.createRng();\n\n  <moveCursorToBody>\n  if (!node) {\n    self._moveEndPoint(rng, self.editor.getBody(), true);\n    self.setRng(rng);\n  } \n  </moveCursorToBody>\n  <setCursor>\n  else {\n    rng.setStart(node, offset);\n    rng.setEnd(node, offset);\n    self.setRng(rng);\n    self.collapse(false);\n  }\n  </setCursor>\n}\n"], ["handleEvent", "\nfunction (evt, callback) {\n  <checkAggregateIdAndRevision>\n  if (!this.definition.aggregateId || !dotty.exists(evt, this.definition.aggregateId) ||\n      !this.definition.revision || !dotty.exists(evt, this.definition.revision)) {\n    var err = new Error('Please define an aggregateId!');\n    debug(err);\n    return callback(err);\n  }\n  </checkAggregateIdAndRevision>\n\n  var self = this;\n\n  <eventHandlingImplementation>\n  // ... The rest of the function which includes detailed event handling logic ...\n  // This example is trimmed down for brevity as the function is too long.\n  </eventHandlingImplementation>\n}\n"], ["getNextMatch", "\nfunction _getNextMatch(editor, searchBackwards, pos, wrap) {\n  var cm = editor._codeMirror;\n  var state = getSearchState(cm);\n  var cursor = getSearchCursor(cm, state, pos || editor.getCursorPos(false, searchBackwards ? \"start\" : \"end\"));\n\n  <findNextMatch>\n  state.lastMatch = cursor.find(searchBackwards);\n  </findNextMatch>\n  <wrapSearch>\n  if (!state.lastMatch && wrap !== false) {\n    cursor = getSearchCursor(cm, state, searchBackwards ? {line: cm.lineCount() - 1} : {line: 0, ch: 0});\n    state.lastMatch = cursor.find(searchBackwards);\n  }\n  </wrapSearch>\n  <searchFailure>\n  if (!state.lastMatch) {\n    cm.setCursor(editor.getCursorPos());\n    return null;\n  }\n  </searchFailure>\n\n  <matchSuccess>\n  return {start: cursor.from(), end: cursor.to()};\n  </matchSuccess>\n}\n"], ["parse", "\nfunction parse(signature) {\n  var pattern = /^(?:void|([a-zA-Z]+!?|\\.{3})(?:[:\\s]+([a-zA-Z]+)(?:(=)(@)?(.*))?)?)?$/;\n\n  <splitAndMapSignature>\n  return signature.split(/\\s*,\\s*/).map(function(argument, index, all) {\n    var result = prepareArgument(argument.match(pattern), 'var' + (index + 1));\n\n    <signatureErrorHandling>\n    if (result.type === false) {\n      throw new Error('polymorphic: invalid argument \"' + argument + '\" in signature \"' + signature + '\"');\n    }\n    else if (result.type === '...' && index < all.length - 1) {\n      throw new Error('polymorphic: variadic argument must be at end of signature \"' + signature + '\"');\n    }\n    </signatureErrorHandling>\n\n    return result;\n  })\n  </splitAndMapSignature>\n  <filterUndefinedArguments>\n  .filter(function(argument) {\n    return argument.type !== undefined;\n  });\n  </filterUndefinedArguments>\n}\n"], ["loadFunction", "\nfunction loadFunction (js, resolver) {\n  <immediateJsCall>\n  immediate(function () {\n    <tryExecutingFunction>\n    try {\n      js.call(null, resolver);\n    }\n    catch (e) {\n      resolver.reject(e);\n    }\n    </tryExecutingFunction>\n  });\n  </immediateJsCall>\n}\n"], ["getConfigForStyleGuide", "\nfunction getConfigForStyleGuide(guide) {\n  <guideDefinitions>\n  const guides = {\n    google: { extends: \"google\" },\n    airbnb: { extends: \"airbnb\" },\n    \"airbnb-base\": { extends: \"airbnb-base\" },\n    standard: { extends: \"standard\" }\n  };\n  </guideDefinitions>\n\n  <validateGuide>\n  if (!guides[guide]) {\n    throw new Error(\"You referenced an unsupported guide.\");\n  }\n  </validateGuide>\n\n  <returnGuideConfig>\n  return guides[guide];\n  </returnGuideConfig>\n}\n"], ["Service", "\nfunction Service(args) {\n  <createRpcService>\n  const obj = createRpcService(args);\n  </createRpcService>\n  <attachProperties>\n  Object.getOwnPropertyNames(obj).forEach(k => {\n    if (typeof obj[k] !== 'function') {\n      this[k] = obj[k];\n    }\n  });\n  </attachProperties>\n}\n"], ["normalizeLinks", "\nfunction normalizeLinks(base, input) {\n  <inputValidation>\n  if (!input) return;\n  </inputValidation>\n  <convertToArray>\n  if (!Array.isArray(input)) input = [input];\n  </convertToArray>\n\n  <normalizeMap>\n  return flatten(input).filter(Boolean).map(function (link) {\n    return normalizeLink(base, link);\n  });\n  </normalizeMap>\n}\n"], "```"]