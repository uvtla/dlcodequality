[["function", "\nfunction(id, key) {\n  <validation>\n  if (typeof id === 'string') {\n    if (typeof key === 'string') </validation> {\n      <memStoreAccess>\n      if (memStore[id] && memStore[id][key]) {\n        let deletedKey = _.cloneDeep(memStore[id][key]);\n        delete memStore[id][key];\n        return when(deletedKey);\n      } else {\n        return when.reject(new Error('bot.forget() could not find the value referenced by id/key'));\n      } </memStoreAccess>\n    <validation>\n    } else if (typeof key === 'undefined') </validation> { \n      <memStoreAccess>\n      if (memStore[id]) {\n        let deletedId = _.cloneDeep(memStore[id]);\n        delete memStore[id];\n        return when(deletedId);\n      } else {\n        return when.reject(new Error('bot.forget() has no key/values defined'));\n      } </memStoreAccess>\n    <validation>\n    } else {\n      return when.reject(new Error('bot.forget() key must be of type \"string\"'));\n    }\n  } else {\n    return when.reject(new Error('bot.forget() Storage module must include a \"id\" argument of type \"string\"'));\n  }</validation>\n}\n"], ["attacher", "\nfunction attacher(destination, options) {\n  var settings\n  <configuration>\n  if (destination && !destination.process) {\n    settings = destination\n    destination = null\n  }\n\n  settings = settings || options || {}\n\n  if (settings.document === undefined || settings.document === null) {\n    settings.document = true\n  }\n  </configuration>\n  <attachOrMutate>\n  return destination ? bridge(destination, settings) : mutate(settings)\n  </attachOrMutate>\n}\n"], ["compose", "\nfunction compose() {\n        <defineCompose>\n        var fns = arguments;\n        </defineCompose>\n        <executionCompose>\n        return function() {\n            var result = void 0;\n\n            for (var i = fns.length - 1; i > -1; i--) {\n                if (i === fns.length - 1) {\n                    result = fns[i].apply(fns[i], arguments);\n                } else {\n                    result = fns[i].call(this, result);\n                }\n            }\n\n            return result;\n        };\n        </executionCompose>\n    }\n"], ["function", "\nfunction(clusterCriteria, subClusterCriteria, numClusters, isReversed){\n    <sortClusters>\n\t\tvar sorted = this.colors.slice(0),\n\t\t\tclusters = [],\n\t\t\td = 1,\n\t\t\ti = 0,\n\t\t\tnum = sorted.length,\n\t\t\tslice;\n\n\t\tsorted.sort(clusterCriteria.compare).reverse();\n\t\tfor (var j = 0; j < num; j++) {\n\t\t\tvar c = sorted[j];\n\t\t\tif (c.getComponentValue(clusterCriteria) < d) {\n\t\t\t\tslice = sorted.slice(i, j);\n\t\t\t\tslice.sort(subClusterCriteria.compare);\n\t\t\t\tclusters.push.apply(clusters, slice);\n\t\t\t\td -= 1.0 / numClusters;\n\t\t\t\ti = j;\n\t\t\t}\n\t\t}\n\t\tslice = [];\n\t\tArray.prototype.push.apply(slice, sorted.slice(i, sorted.length));\n\t\tslice.sort(subClusterCriteria.compare);\n\t\tclusters.push.apply(clusters, slice);\n\t\tif (isReversed) {\n\t\t\tclusters.reverse();\n\t\t}\n\t\tthis.colors = clusters;\n\t\treturn this;\n    </sortClusters>\n}\n"], ["validateOptions", "\nfunction validateOptions(options) {\n  <nullCheck>\n  if (_.isNil(options)) {\n    return null;\n  }\n  </nullCheck>\n  <validateObject>\n  if (!_.isPlainObject(options)) {\n    return new TypeError('Expected `options` to be an object or not defined.');\n  }\n  </validateObject>\n  <validateTime>\n  if (!isOptionalIntAbove(options.time, 0)) {\n    return new TypeError('Expected `options.time` to be an integer that is 0 or greater.');\n  }\n  </validateTime>\n  <validateCount>\n  if (!isOptionalIntAbove(options.count, 1)) {\n    return new TypeError('Expected `options.count` to be an integer greater than 0.');\n  }\n  </validateCount>\n  return null;\n}\n"], ["github", "\nfunction github(url, destination) {\n  <downloadRepository>\n  return new Promise((resolve, reject) => {\n    (0, _downloadGithubRepo2.default)(url, destination, err => {\n      if (err) {\n        reject(err);\n      } else {\n        resolve();\n      }\n    });\n  });\n  </downloadRepository>\n}\n"], ["lintCss", "\nfunction lintCss() {\n  <linting>\n  return gulp\n    .src([appSrc + '*.less'])\n    .pipe(stylelint({\n      failAfterError: true,\n      reporters: [\n        {formatter: 'string', console: true}\n      ]\n    }));\n  </linting>\n}\n"], ["validStore", "\nfunction validStore(store) {\n    <checkStoreFunctions>\n    return store &&\n      typeof store.getNodes === 'function' &&\n      typeof store.getNode === 'function' &&\n      typeof store.getDevices === 'function' &&\n      typeof store.getDevice === 'function' &&\n      typeof store.getSources === 'function' &&\n      typeof store.getSource === 'function' &&\n      typeof store.getSenders === 'function' &&\n      typeof store.getSender === 'function' &&\n      typeof store.getReceivers === 'function' &&\n      typeof store.getReceiver === 'function' &&\n      typeof store.getFlows === 'function' &&\n      typeof store.getFlow === 'function';\n    </checkStoreFunctions>  \n}\n"], ["condor_classads_stream", "\nfunction condor_classads_stream(cmd, opts, cb) {\n    <setup>\n    var deferred = Q.defer();\n    var p = spawn(cmd, opts, { env: get_condor_env() });\n    var buffer = \"\";\n    var items = [];\n    var parser = new xml2js.Parser();\n    </setup>\n    <parseXmlBlock>\n    function getblock() {\n        var s = buffer.indexOf(\"\\n<c>\\n\");\n        var e = buffer.indexOf(\"\\n</c>\\n\");\n        if (s != -1 && e != -1) {\n            xml = buffer.substring(s, e + 5);\n            buffer = buffer.substring(e + 5);\n            parser.parseString(xml, function (err, attrs) {\n                if (err) {\n                    console.log(\"failed to parse job xml (skipping)\");\n                    console.error(err);\n                    console.log(xml);\n                } else {\n                    var event = {};\n                    if (!attrs.c || !attrs.c.a) {\n                        event._no_attributes = true;\n                    } else {\n                        if (!attrs.c.a.forEach) {\n                            attrs.c.a = [attrs.c.a];\n                        }\n                        attrs.c.a.forEach(function (attr) {\n                            var name = attr.$.n;\n                            event[name] = parse_attrvalue(attr);\n                        });\n                    }\n                    if (cb) {\n                        cb(null, event);\n                    }\n                    items.push(event);\n                }\n            });\n            return true;\n        } else {\n            return false;\n        }\n    }\n    </parseXmlBlock>\n    <handleStreamData>\n    p.stdout.on('data', function (data) {\n        buffer += data.toString();\n        while (getblock());\n    });\n    </handleStreamData>\n    <handleStreamError>\n    var stderr = \"\";\n    p.stderr.on('data', function (data) {\n        stderr += data;\n    });\n    p.on('error', function (err) {\n        console.error(err);\n        deferred.reject(err);\n        cb(err);\n    });\n    </handleStreamError>\n    <handleProcessClose>\n    p.on('close', function (code, signal) {\n        while (getblock());\n        if (signal) {\n            deferred.reject(cmd + \" was killed by signal \" + signal);\n            if (cb) {\n                cb({ code: code, signal: signal, stdout: buffer, stderr: stderr });\n            }\n        } else if (code !== 0) {\n            deferred.reject(cmd + \" failed with exit code \" + code + \"\\nSTDERR:\" + stderr + \"\\nbuffer:\" + buffer);\n            if (cb) {\n                cb({ code: code, signal: signal, stdout: buffer, stderr: stderr });\n            }\n        } else {\n            deferred.resolve(items);\n        }\n    });\n    </handleProcessClose>\n    return deferred.promise;\n}\n"], ["clone", "\nfunction clone(obj, deep) {\n    <checkSimpleCases>\n    if (!obj || typeof obj !== \"object\" || isFunction(obj)) {\n        return obj;\n    }\n    if (obj instanceof Date) {\n        return new Date(obj.getTime());\n    }\n    </checkSimpleCases>\n    var result, index, length, value;\n    <cloneArray>\n    if (isArray(obj)) {\n        result = [];\n        <deepCloneArray>\n        if (deep) {\n            for (index = 0, length = obj.length; index < length; index += 1) {\n                if (index in obj) {\n                    value = obj[index];\n                    value = value.clone ? value.clone(true) : clone(value);\n                    result.push(clone(value));\n                }\n            }\n        </deepCloneArray> \n        <shallowCloneArray>\n        else {\n            for (index = 0, length = obj.length; index < length; index += 1) {\n                if (index in obj) {\n                    result.push(value);\n                }\n            }\n        }\n        </shallowCloneArray>\n        return result;\n    }\n    </cloneArray>\n\n    <cloneObjectWithCloneMethod>\n    if (obj.clone) {\n        return obj.clone(obj, deep);\n    }\n    </cloneObjectWithCloneMethod>\n\n    <cloneObject>\n    result = obj.constructor ? new obj.constructor() : {};\n\n    for (index in obj) {\n        if (true) {\n            value = obj[index];\n            if (\n                !(index in result) ||\n                (result[index] !== value && (!(index in EMPTY) || EMPTY[index] !== value))\n            ) {\n                result[index] = clone(value);\n            }\n        }\n    }\n    </cloneObject>\n\n    return result;\n}\n"], ""]