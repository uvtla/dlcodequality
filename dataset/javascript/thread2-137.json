[["iter", "\nfunction iter (block) {\n    <createHash_and_update>\n    var hash = crypto.createHash(opts.digest || 'md5')\n    hash.update(block)\n    hash.update(data)\n    hash.update(salt)\n    block = hash.digest()\n    </createHash_and_update>\n\n    <iterativeHashing>\n    for (var i = 1; i < (opts.count || 1); i++) {\n      hash = crypto.createHash(opts.digest || 'md5')\n      hash.update(block)\n      block = hash.digest()\n    }\n    </iterativeHashing>\n\n    return block\n}\n"], ["ResourceStream", "\nfunction ResourceStream(collection) {\n  <streamSetup>\n  var me = this;\n  BufferedReadable.call(me, {\n    objectMode: true\n  });\n  me._collection = collection;\n  me._fetching = false;\n  </streamSetup>\n\n  <initiateStream>\n  me._pushCollection();\n  </initiateStream>\n}\n"], ["createGRPCError", "\nfunction createGRPCError (message, code, metadata) {\n  const err = new Error()\n  return applyCreate(err, message, code, metadata)\n}\n"], ["prototypeAssertions", "\nfunction () {\n\n        var Proto = $prototype (),  \n            dummy = function () {}\n\n        <assertions>\n        $assert ($prototype.isConstructor (Proto), true)\n        $assert ($prototype.isConstructor (dummy), false)\n        $assert ($prototype.isConstructor (null),  false) \n\n        $assert ([Proto, dummy].map ($prototype.isConstructor), [true, false])\n        </assertions>\n}\n"], ["getMarkerLines", "\nfunction getMarkerLines(\n  loc: NodeLocation,\n  source: Array<string>,\n  opts: Object,\n): { start: number, end: number, markerLines: Object }\n"], ["classNamesManipulation", "\nfunction(class_names, cancel_sync) {\n\n    <debugCheck>\n\t\tif (Lava.schema.DEBUG && typeof(class_names) == 'string') Lava.t();\n    </debugCheck>\n\n    <addClassLoop>\n\t\tfor (var i = 0, count = class_names.length; i < count; i++) {\n\t\t\tthis.addClass(class_names[i], cancel_sync);\n\t\t}\n    </addClassLoop>\n\n}\n"], ["convertObjectToNameValueArray", "\nfunction convertObjectToNameValueArray(parameters) {\n  return Object.keys(parameters).reduce((result, key) => {\n    var values = parameters[key];\n    if (!Array.isArray(values)) {\n      values = [values];\n    }\n    return result.concat(\n      values.map(value => {\n        return {\n          name: key,\n          value: value\n        };\n      })\n    );\n  }, []);\n}\n"], ["normalizeFields", "\nfunction normalizeFields (options) {\n    <determineFieldsToReturn>\n    const fields = options.fields || options.outFields\n    const idField = _.get(options, 'collection.metadata.idField')\n    if (options.returnIdsOnly === true && idField) return [idField]\n    else if (options.returnIdsOnly === true) return ['OBJECTID']\n    if (fields === '*') return undefined\n    if (typeof fields === 'string' || fields instanceof String) return fields.split(',')\n    if (fields instanceof Array) return fields\n    </determineFieldsToReturn>\n    return undefined\n}\n"], ["observableElementAtExtension", "\nfunction(module, exports, __webpack_require__) {\n\t\"use strict\";\n\t<attachElementAtToObservable>\n\tvar Observable_1 = __webpack_require__(5);\n\tvar elementAt_1 = __webpack_require__(455);\n\tObservable_1.Observable.prototype.elementAt = elementAt_1.elementAt;\n\t</attachElementAtToObservable>\n}\n"], ["removeSubstringsFromObjectProperties", "\nfunction(obj, keys, remove) {\n    <removeLoops>\n    var i = 0,\n      l = keys.length;\n    for (i = 0; i < l; i++) {\n      if (obj[keys[i]] && obj[keys[i]].toString().indexOf(remove) > -1) {\n      obj[keys[i]] = obj[keys[i]].toString().replace(remove, '');\n      }\n    }\n    </removeLoops>\n    return obj;\n}\n"], ""]