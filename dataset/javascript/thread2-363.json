[["functionMirrorObject", "\nfunction(obj) {\n    var key;\n    var mirrored = {};\n\n    if (obj && typeof obj === 'object') {\n        for (key in obj) {\n            <checkHasOwnProperty>\n            if (obj.hasOwnProperty(key)) {\n                mirrored[key] = key;\n            }\n            </checkHasOwnProperty>\n        }\n    }\n    return mirrored;\n}\n"], ["functionParseBarsComment", "\nfunction parseBarsComment(mode, code, tokens, flags, scope, parseMode) {\n    var index = code.index + 2,\n        length = code.length;\n\n    <checkSpecialCharacters>\n    if (\n        code.codePointAt(index) === 0x0021\n    ) {\n        if (\n            code.codePointAt(++index) === 0x002d &&\n            code.codePointAt(++index) === 0x002d\n        ) {\n            index++;\n\n            <parseLongComment>\n            for (; index < length; index++) {\n                if (\n                    code.codePointAt(index) === 0x002d &&\n                    code.codePointAt(index + 1) === 0x002d &&\n                    code.codePointAt(index + 2) === 0x007d &&\n                    code.codePointAt(index + 3) === 0x007d\n                ) {\n                    index += 4;\n                    code.index = index;\n\n                    <closeParseMode>\n                    parseMode.close();\n                    </closeParseMode>\n\n                    if (flags.keepComments) {\n                        // No specific operation here\n                    }\n\n                    return true;\n                }\n            }\n            </parseLongComment>\n\n            throw code.makeError(\n                'Unclosed Comment: Expected \"--}}\" to fallow \"{{!--\".',\n                5\n            );\n        }\n\n        index++;\n\n        <parseShortComment>\n        for (; index < length; index++) {\n\n            if (\n                code.codePointAt(index) === 0x007d &&\n                code.codePointAt(index + 1) === 0x007d\n            ) {\n                index += 2;\n                code.index = index;\n\n                <closeParseMode>\n                parseMode.close();\n                </closeParseMode>\n\n                if (flags.keepComments) {\n                    // No specific operation here\n                }\n\n                return true;\n            }\n        }\n        </parseShortComment>\n\n        throw code.makeError(\n            code.index, code.index + 3,\n            'Unclosed Comment: Expected \"}}\" to fallow \"{{!\".'\n        );\n    }\n    </checkSpecialCharacters>\n\n    return null;\n}\n"], ["functionTextureTile", "\nfunction (sector, level, row, column) {\n    <callSuperConstructor>\n    TextureTile.call(this, sector, level, row, column);\n    </callSuperConstructor>\n\n    <initializeProperties>\n    this.surfaceShapes = [];\n    this.surfaceShapeStateKeys = [];\n    this.asRenderedSurfaceShapeStateKeys = [];\n    this.sector = sector;\n    this.cacheKey = null;\n    this.pickSequence = 0;\n    </initializeProperties>\n\n    <createCtx2D>\n    this.createCtx2D();\n    </createCtx2D>\n}\n"], ["functionEditDataSource", "\nfunction() {\n    <getPropertyAssignments>\n    var editDataSource = this.getProperty('editDataSource');\n    var destinationDataSource = this.getProperty('destinationDataSource');\n    var destinationProperty = this.getProperty('destinationProperty');\n    </getPropertyAssignments>\n\n    <handleEditDataSource>\n    if (this._isObjectDataSource(editDataSource)) {\n        var editedItem = editDataSource.getSelectedItem();\n        var originItem = destinationDataSource.getProperty(destinationProperty);\n\n        if (this._isRootElementPath(destinationProperty)) {\n            <overrideOriginItem>\n            this._overrideOriginItem(originItem, editedItem);\n            destinationDataSource._includeItemToModifiedSet(originItem);\n            destinationDataSource.saveItem(originItem, function() {\n                destinationDataSource.updateItems();\n            });\n            </overrideOriginItem>\n        } else {\n            <setEditedProperty>\n            destinationDataSource.setProperty(destinationProperty, editedItem);\n            </setEditedProperty>\n        }\n\n    } else {\n        <updateDestinationItems>\n        destinationDataSource.updateItems();\n        </updateDestinationItems>\n    }\n    </handleEditDataSource>\n}\n"], ["functionEndpoint", "\nfunction Endpoint(spec, resourcePath, method) {\n    <initializeEndpoint>\n    this.method = method;\n    this.resourcePath = resourcePath || '/';\n    this.spec = spec;\n    </initializeEndpoint>\n}\n"], ["functionGetMaskComponents", "\nfunction getMaskComponents() {\n    var maskPlaceholderChars = maskPlaceholder.split(''),\n        maskPlaceholderCopy, components;\n\n    <setPlaceholderChars>\n    if (maskCaretMap && !isNaN(maskCaretMap[0])) {\n        angular.forEach(maskCaretMap, function(value) {\n            maskPlaceholderChars[value] = '_';\n        });\n    }\n    </setPlaceholderChars>\n    maskPlaceholderCopy = maskPlaceholderChars.join('');\n    components = maskPlaceholderCopy.replace(/[_]+/g, '_').split('_');\n    components = components.filter(function(s) {\n        return s !== '';\n    });\n\n    <mapComponents>\n    var offset = 0;\n    return components.map(function(c) {\n        var componentPosition = maskPlaceholderCopy.indexOf(c, offset);\n        offset = componentPosition + 1;\n        return {\n            value: c,\n            position: componentPosition\n        };\n    });\n    </mapComponents>\n}\n"], ["functionEscapeString", "\nfunction escapeString(str) {\n    <checkStringValidity>\n    if (str === undefined) {\n        throw new Error('\\'str\\' is required');\n    }\n    if (str === null) {\n        throw new Error('\\'str\\' must not be null');\n    }\n    if (typeof str !== 'string') {\n        throw new Error('\\'str\\' must be a string');\n    }\n    </checkStringValidity>\n\n    <escapeCharacters>\n    var escaped_str = str;\n    escaped_str = escaped_str.replace(/\\\\/g, '\\\\\\\\');\n    escaped_str = escaped_str.replace(/'/g, '\\\\\\'');\n    escaped_str = escaped_str.replace(/\"/g, '\\\\\"');\n    </escapeCharacters>\n\n    return escaped_str;\n}\n"], ["functionAxisRotate", "\nfunction axisRotate(m, axis, angleInRadians, dst) {\n    <calculateAxisRotation>\n    dst = dst || new MatType(16);\n    let x = axis[0];\n    let y = axis[1];\n    let z = axis[2];\n    const n = Math.sqrt(x * x + y * y + z * z);\n    x /= n;\n    y /= n;\n    z /= n;\n    const xx = x * x;\n    const yy = y * y;\n    const zz = z * z;\n    const c = Math.cos(angleInRadians);\n    const s = Math.sin(angleInRadians);\n    const oneMinusCosine = 1 - c;\n    </calculateAxisRotation>\n\n    <computeRotationMatrix>\n    // Calculation of the rotation matrix elements...\n    </computeRotationMatrix>\n\n    <applyRotationToMatrix>\n    // Application of the rotation matrix to 'm' and assigning to 'dst'...\n    </applyRotationToMatrix>\n\n    <copyRemainingElements>\n    if (m !== dst) {\n        dst[12] = m[12];\n        dst[13] = m[13];\n        dst[14] = m[14];\n        dst[15] = m[15];\n    }\n    </copyRemainingElements>\n\n    return dst;\n}\n"], ["functionTiledImageLayer", "\nfunction (sector, levelZeroDelta, numLevels, imageFormat, cachePath,\n                                                tileWidth, tileHeight) {\n    <callSuperConstructor>\n    TiledImageLayer.call(this,\n        sector, levelZeroDelta, numLevels, imageFormat, cachePath, tileWidth, tileHeight);\n    </callSuperConstructor>\n\n    <initializeProperties>\n    this.detectBlankImages = false;\n    this.testPixels = [\n        new Vec2(20, 20),\n        new Vec2(235, 20),\n        new Vec2(20, 235),\n        new Vec2(235, 235)\n    ];\n    this.destCanvas = document.createElement(\"canvas\");\n    this.destContext = this.destCanvas.getContext(\"2d\");\n    </initializeProperties>\n}\n"], ["functionFilter", "\nfunction filter(data, route) {\n    var res = this,\n        statusCode = res.statusCode,\n        validator = route.Router.App.getValidator(),\n        schemaId,\n        schema;\n\n    <determineStatusCode>\n    if (!statusCode) {\n        statusCode = 200;\n    }\n    </determineStatusCode>\n\n    <checkResponseSchema>\n    if (!route.description.responses.hasOwnProperty(statusCode) ||\n        !route.description.responses[statusCode].length ||\n        !route.description.responses[statusCode][0].schema\n    ) {\n        throw new Error(`There is no response data format set for status code: ${statusCode}. Can't filter response data`);\n    }\n    </checkResponseSchema>\n\n    <handleDataToJson>\n    if (!_.isPlainObject(data) && data && data.toJSON instanceof Function) {\n        data = data.toJSON();\n    }\n    </handleDataToJson>\n\n    <setupValidationSchema>\n    schema = route.description.responses[statusCode][0].schema;\n    if (typeof schema === 'string') {\n        schemaId = schema;\n    } else {\n        schemaId = route.uid + '-RES';\n        if (!validator.getSchema(schemaId)) {\n            validator.addSchema(schema, schemaId);\n        }\n    }\n    </setupValidationSchema>\n\n    <validateData>\n    if (!validator.validate(schemaId, data)) {\n        let err = validator.errors.shift();\n        if (err && !err.dataPath) {\n            err.dataPath = '<response>';\n        }\n        throw new Response.ValidationError(err);\n    }\n    </validateData>\n\n    <createProxy>\n    return new Proxy(res, {\n        get: function(target, name, receiver) {\n            if (proxyResponsePrototypeProps.hasOwnProperty(name)) {\n                if (proxyResponsePrototypeProps[name]) {\n                    return function() {\n                        target[name](data);\n                        return receiver;\n                    };\n                }\n\n                return Reflect.get(target, name, receiver);\n            }\n        }\n    });\n    </createProxy>\n}\n"], ""]