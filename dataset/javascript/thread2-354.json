[["downscaleType", "\nfunction downscaleType(fromType, toType) {\n\t<searchDownscaleMapping>\n\tfor (var i = 0; i < NUMTYPE_DOWNSCALE.FROM.length; ++i) {\n\t\tif ((NUMTYPE_DOWNSCALE.FROM[i] === fromType) &&\n\t\t\t(NUMTYPE_DOWNSCALE.TO[i] === toType))\n\t\t\treturn i;\n\t}\n\t</searchDownscaleMapping>\n\n\treturn undefined;\n}\n"], ["getTypeProperties", "\nfunction(type, $prime, parameters, args, callback, this_arg) {\n            <parseType>\n            var params = {};\n            parse_type(type, params);\n            if (!params.name)\n                throw new SyntaxError('Invalid node name!');\n            </parseType>\n            <returnPropertyOrCreate>\n            return this[params.name] || this.create.apply(this, arguments);\n            </returnPropertyOrCreate>\n        }\n"], ["validateAppVersionAndMode", "\nfunction (sAppVersion, bDeveloperMode, sScenario) {\n\t<conditionalReturn>\n\treturn !!sAppVersion\n\t\t&& !!bDeveloperMode\n\t\t&& sScenario !== sap.ui.fl.Scenario.AdaptationProject\n\t\t&& sScenario !== sap.ui.fl.Scenario.AppVariant;\n\t</conditionalReturn>\n}\n"], ["createUserInOrganization", "\nfunction (orgIdOrSlug, data) {\n      <checkArgumentsAndAct>\n      var path,\n          rejectMsg;\n      if (orgIdOrSlug && data) {\n        path = this.constructPath(constants.ORGANIZATIONS, orgIdOrSlug, constants.USERS);\n        return this.Core.POST(path, data);\n      } else {\n        rejectMsg = 'Bad Request: An organization id or slug and data is required.';\n        return this.rejectRequest(rejectMsg);\n      }\n      </checkArgumentsAndAct>\n    }\n"], ["getGrantsFor", "\nasync function getGrantsFor(permissionModel, roleId, stateMachineName) {\n  <fetchPermissions>\n  const permissions = await permissionModel.findOne({\n    where: {\n      roleId: { equals: roleId },\n      stateMachineName: { equals: stateMachineName }\n    }\n  })\n  </fetchPermissions>\n  <returnPermissions>\n  return permissions ? permissions.allows : [];\n  </returnPermissions>\n}\n"], ["renderField", "\nfunction () {\n    <prepareFieldConfiguration>\n            var css = this._css()\n              , fldConf = this._field()\n              , fldMeta = fldConf.meta;\n    </prepareFieldConfiguration>\n\n    <conditionalReturn>\n            if (!fldMeta || fldMeta.isHidden)\n                return null;\n    </conditionalReturn>\n    \n    <createFieldElement>\n            return (\n                React.createElement(\"div\", { className: css.wrapper, key: this.props.key },\n                    React.createElement(\"label\", { className: css.label,\n                           htmlFor: fldConf.fieldID },\n                      this._spec().label\n                    ),\n\n                    React.createElement(\"div\", { className: css.field }, this.props.children),\n                    React.createElement(\"div\", { className: css.errors }, this.renderErrors())\n                )\n            );\n    </createFieldElement>\n        }\n"], ["restoreCryptoKeyVersion", "\nasync function restoreCryptoKeyVersion(\n  projectId = 'your-project-id',\n  keyRingId = 'my-key-ring',\n  cryptoKeyId = 'my-key',\n  version = 1234\n) {\n  <importAndInitializeKMSClient>\n  const kms = require('@google-cloud/kms');\n  const client = new kms.KeyManagementServiceClient();\n  </importAndInitializeKMSClient>\n\n  <defineLocation>\n  const locationId = 'global';\n  </defineLocation>\n\n  <generateCryptoKeyVersionName>\n  const name = client.cryptoKeyVersionPath(\n    projectId,\n    locationId,\n    keyRingId,\n    cryptoKeyId,\n    version\n  );\n  </generateCryptoKeyVersionName>\n\n  <performRestoreOperation>\n  const [result] = await client.restoreCryptoKeyVersion({ name });\n  console.log(`Crypto key version ${result.name} restored.`);\n  </performRestoreOperation>\n}\n"], ["parseOptionsAndProcessArrays", "\nfunction(arrays, options, callback) {\n      <parseOptions>\n      var options = (options !== undefined ? options : {});\n      var config = {};\n      config.callback = ((callback !== undefined && typeof(callback) === 'function') ? callback : false);\n      config.separator = 'separator' in options ? options.separator : $.csv.defaults.separator;\n      config.delimiter = 'delimiter' in options ? options.delimiter : $.csv.defaults.delimiter;\n      config.escaper = 'escaper' in options ? options.escaper : $.csv.defaults.escaper;\n      config.experimental = 'experimental' in options ? options.experimental : false;\n      </parseOptions>\n\n      <rejectNonExperimental>\n      if (!config.experimental) {\n        throw new Error('not implemented');\n      }\n      </rejectNonExperimental>\n\n      <processArrays>\n      var output = [];\n      for (i in arrays) {\n        output.push(arrays[i]);\n      }\n      </processArrays>\n\n      <returnOrCallback>\n      if (!config.callback) {\n        return output;\n      } else {\n        config.callback('', output);\n      }\n      </returnOrCallback>\n    }\n"], ["FileInfoConstructor", "\nfunction FileInfo(options) {\n  <initializeFileInfo>\n  this.src = options.src\n  this.resolved = options.resolved\n  this.base = options.base\n  this.dest = options.dest\n  this.destBase = options.destBase\n  this.watch = options.watch\n  </initializeFileInfo>\n}\n"], ["regenerateBundleGraph", "\nfunction regenerate(moduleName, done) {\n\t<cloneConfig>\n\t\tvar cfg = clone(config, true);\n\t</cloneConfig>\n\n\t<configureModuleName>\n\t\tif (moduleName && !cachedData.graph[moduleName]) {\n\t\t\tcfg.main = moduleName;\n\t\t}\n\t</configureModuleName>\n\n\t<generateAndCacheBundleGraph>\n\t\tmakeBundleGraph(cfg, options).then(function (data) {\n\t\t\tvar graph = data.graph;\n\t\t\tvar oldGraph = cachedData ? cachedData.graph : {};\n\t\t\tfor (var name in graph) {\n\t\t\t\tif (name !== moduleName && oldGraph[name]) {\n\t\t\t\t\tgraph[name].transforms = oldGraph[name].transforms;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcachedData = cloneData(data);\n\t\t\tdone(null, data);\n\t\t}, done);\n\t</generateAndCacheBundleGraph>\n}\n"], "```"]