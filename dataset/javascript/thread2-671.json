[["initializeSet", "\nfunction (items) {\n        this.items = [];\n\tthis.bindings = {};\n        this.length = 0;\n        this.type = \"set\";\n        if (items) {\n            for (var i = 0, ii = items.length; i < ii; i++) {\n                if (items[i]) {\n                    this[this.items.length] = this.items[this.items.length] = items[i];\n                    this.length++;\n                }\n            }\n        }\n    }\n"], ["applyFunctionToLisWithSelector", "\nfunction (list, func, args, selector) {\n\t\t\t\tfor (var i = 0, j = list.length; i < j; i++) {\n\t\t\t\t\tlist[i][func].apply(list[i], args);\n\t\t\t\t}\n\t\t\t\treturn selector(list);\n\t\t\t}\n"], ["setModelAttributes", "\nfunction(key, value, options) {\n      var attrs, attr, val;\n\n      <normalizeAttributes>\n      if (_.isObject(key) || key == null) {\n        attrs = key;\n        options = value;\n      } else {\n        attrs = {};\n        attrs[key] = value;\n      }\n      </normalizeAttributes>\n\n      <defaultOptions>\n      \n      options || (options = {});\n      </defaultOptions>\n      <guardClauses>\n      if (!attrs) return this;\n      if (attrs instanceof Model) attrs = attrs.attributes;\n      if (options.unset) for (attr in attrs) attrs[attr] = void 0;\n      </guardClauses>\n\n      <validateAttributes>\n      if (!this._validate(attrs, options)) return false;\n      </validateAttributes>\n\n      <updateId>\n      if (this.idAttribute in attrs) this.id = attrs[this.idAttribute];\n      </updateId>\n\n      <trackChanges>\n      var changes = options.changes = {};\n      var now = this.attributes;\n      var escaped = this._escapedAttributes;\n      var prev = this._previousAttributes || {};\n      </trackChanges>\n\n      <applyChangesAndHandleUpdates>\n      for (attr in attrs) {\n        val = attrs[attr];\n\n        \n        if (!_.isEqual(now[attr], val) || (options.unset && _.has(now, attr))) {\n          delete escaped[attr];\n          (options.silent ? this._silent : changes)[attr] = true;\n        }\n\n        \n        options.unset ? delete now[attr] : now[attr] = val;\n\n        \n        \n        if (!_.isEqual(prev[attr], val) || (_.has(now, attr) != _.has(prev, attr))) {\n          this.changed[attr] = val;\n          if (!options.silent) this._pending[attr] = true;\n        } else {\n          delete this.changed[attr];\n          delete this._pending[attr];\n        }\n      }\n      </applyChangesAndHandleUpdates>\n\n      <triggerChangeIfNotSilent>\n      if (!options.silent) this.change(options);\n      </triggerChangeIfNotSilent>\n      return this;\n    }\n"], ["markInstance", "\nfunction mark (instance) {\n  <registerInstance>\n  if (!instanceMap.has(instance.__VUE_DEVTOOLS_UID__)) {\n    instanceMap.set(instance.__VUE_DEVTOOLS_UID__, instance)\n    </registerInstance>\n    <registerBeforeDestroyHook>\n    instance.$on('hook:beforeDestroy', function () {\n      instanceMap.delete(instance.__VUE_DEVTOOLS_UID__)\n    })\n    </registerBeforeDestroyHook>\n  }\n}\n"], ["decomposeFloatingPointValue", "\nfunction frexp( x ) {\n\t<handleSpecialCases>\n\tvar exp;\n\tvar w;\n\tif (\n\t\tx === 0 ||    \n\t\tx !== x ||\n\t\tx === pinf ||\n\t\tx === ninf\n\t) {\n\t\treturn [ x, 0 ];\n\t}\n\t</handleSpecialCases>\n\t\n\t<normalizeAndExtractBase>\n\tx = normalize( x );\n\t</normalizeAndExtractBase>\n\n\t<calculateExponent>\n\texp = floatExp( x[0] ) + x[ 1 ] + 1;\n\t</calculateExponent>\n\n\t<extractAndManipulateSignificand>\n\tw = toWord( x[ 0 ] );\n\n\t\n\tw &= CLEAR_EXP_MASK;\n\n\t\n\tw |= SET_EXP_MASK;\n\t</extractAndManipulateSignificand>\n\n\t<returnDecomposedValue>\n\treturn [ fromWord(w), exp ];\n\t</returnDecomposedValue>\n}\n"], ["createPlatformApplication", "\nfunction(name, platform, attributes) {\n        <buildParams>\n        var params = {\n            Name: name,\n            Platform: platform,\n            Attributes: attributes\n        };\n        </buildParams>\n\n        <APICall>\n        return this.svc.createPlatformApplication(params);\n        </APICall>\n    }\n"], ["executeAction", "\nfunction execute(_ref7) {\n      <extractParameters>\n      var actionName = _ref7.actionName;\n      var isPaused = _ref7.isPaused;\n      </extractParameters>\n\n      <determineNextAction>\n      var nextActionName = getNextActionName(actionName);\n      var wasPaused = stores.redux.isPaused;\n      </determineNextAction>\n\n      <scheduleNextAction>\n      var timeoutID = nextActionName && !isPaused ? schedule(nextActionName) : null;\n      </scheduleNextAction>\n\n      <handlePauseOrResumeDetection>\n      if (isPaused && !wasPaused) {\n        log.info('pausing activity detection');\n        detection.stop();\n      }\n      if (!isPaused && wasPaused) {\n        log.info('unpausing activity detection');\n        detection.start();\n      }\n      </handlePauseOrResumeDetection>\n\n      <updateState>\n      setState(actionName, { actionName: actionName,\n        isIdle: typeof nextActionName === 'undefined',\n        isPaused: isPaused,\n        timeoutID: timeoutID\n      });\n      </updateState>\n\n      <dispatchAction>\n      getAction(actionName)(dispatch, getState, _getChildContext(context));\n      </dispatchAction>\n    }\n"], ["promiseForCustomElementCreation", "\nfunction renderNode(rootNode) {\n    let createdPromises = [];\n\n    <retrieveDocument>\n    var document = getDocument(rootNode);\n    </retrieveDocument>\n\n    <applyCustomElementPrototype>\n    recurseTree(rootNode, (foundNode) => {\n        if (foundNode.tagName) {\n            let nodeType = foundNode.tagName.toLowerCase();\n            let customElement = registeredElements[nodeType];\n            if (customElement) {\n                \n                Object.setPrototypeOf(foundNode, customElement);\n                if (customElement.createdCallback) {\n                    <handleCreatedCallback>\n                    createdPromises.push(new Promise((resolve) => {\n                        resolve(customElement.createdCallback.call(foundNode, document));\n                    }));\n                    </handleCreatedCallback>\n                }\n            }\n        }\n    });\n    </applyCustomElementPrototype>\n\n    <resolvePromisesAndReturnNode>\n    return Promise.all(createdPromises).then(() => rootNode);\n    </resolvePromisesAndReturnNode>\n}\n"], ["createNodeByPath", "\nfunction create_node_by_path(context, path, len, tracker) {\n    <initializeRootNode>\n\tlet node = context.state.rootNode;\n    </initializeRootNode>\n    <traverseAndCreate>\n\tfor (let i = 0; i < len; i++) {\n\t\tconst k = path[i];\n\t\tif (k == \"_\") continue;\n\t\tif (k == \"#\") {\n\t\t\tnode = context.state.rootNode;\n\t\t\tcontinue;\n\t\t}\n\t\tif (node_type(node[k]) != NodeTypes.NODE) {\n\t\t\t<commitNodeProperty>\n\t\t\tcommit_node_prop(context, node, k, create_node(), tracker);\n\t\t\t</commitNodeProperty>\n\t\t}\n\t\tnode = node[k];\n\t}\n    </traverseAndCreate>\n\treturn node;\n}\n"], ["combineDatabaseReducers", "\nfunction combineReducers (reducers) {\n  <createDatabaseReducers>\n  const databaseReducers = Object.keys(reducers)\n    .map((collectionName) => {\n      const reducer = reducers[ collectionName ]\n      return createDatabaseReducer(reducer, collectionName)\n    })\n  </createDatabaseReducers>\n\n  <applyReducersToDatabase>\n  return (database, event) => {\n    const changesets = databaseReducers.map((reducer) => reducer(database, event))\n    return combineChangesets(changesets)\n  }\n  </applyReducersToDatabase>\n}\n"], ""]