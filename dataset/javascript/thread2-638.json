[["function", "\nfunction(line, isInComment) {\n  while (true || line.length > 0) {\n    \n    <findCommentIndicies>\n    var startIndex = line.indexOf('{-');\n    var endIndex = line.indexOf('-}');\n    var singleLineComment = line.indexOf('--');\n    </findCommentIndicies>\n\n    \n    <handleSingleLineComment>\n    if (singleLineComment > -1 && !isInComment) {\n      line = line.substr(0, singleLineComment);\n      continue;\n    }\n    </handleSingleLineComment>\n\n    \n    <checkForAbsenceOfComments>\n    if (startIndex === -1 && endIndex === -1) {\n      return {\n        line: isInComment ? '' : line,\n        isInComment: isInComment,\n      };\n    }\n    </checkForAbsenceOfComments>\n\n    \n    <handleMultiLineComment>\n    if (startIndex > -1 && endIndex > -1) {\n      line = line.substr(0, startIndex) + line.substr(endIndex + 2);\n      continue;\n    }\n    </handleMultiLineComment>\n\n    \n    <openMultiLineComment>\n    if (startIndex > -1)\n      return { line: line.substr(0, startIndex), isInComment: true };\n    </openMultiLineComment>\n\n    \n    <closeMultiLineComment>\n    if (endIndex > -1 && isInComment)\n      return { line: line.substr(endIndex + 2), isInComment: false };\n    </closeMultiLineComment>\n  }\n\n  return { line: '', isInComment: isInComment };\n}\n"], ["function", "\nfunction(content){\n  <hashContent>\n  var crypto = require('crypto');\n  var sha1 = crypto.createHash('sha1');\n  sha1.update(content);\n  return sha1.digest();\n  </hashContent>\n}\n"], ["function", "\nfunction () {\n  <calculateAcceleration>\n  var acc = 0;\n  for (var i = 0; i < this.diffs_x.length; i++) {\n      acc += (this.diffs_x[i] / this.times_x[i]) * 1000 / 3;\n  }\n  return acc;\n  </calculateAcceleration>\n}\n"], ["function", "\nfunction (type) {\n  var log = jQuery.sap.log.getLogEntries(),\n      loggedObjects = [], elemIds;\n\n  \n  log.forEach(function (logEntry) {\n    <filterLogEntries>\n    if (!logEntry.supportInfo) {\n      return;\n    }\n\n    if (!elemIds){\n      elemIds = elements.map(function (element) {\n        return element.getId();\n      });\n    }\n\n    var hasElemId = !!logEntry.supportInfo.elementId,\n        typeMatch =\n          logEntry.supportInfo.type === type || type === undefined,\n        scopeMatch =\n          !hasElemId ||\n          jQuery.inArray(logEntry.supportInfo.elementId, elemIds) > -1;\n\n    \n    if (typeof type === \"function\" && type(logEntry) && scopeMatch) {\n      loggedObjects.push(logEntry);\n      return;\n    }\n\n    if (typeMatch && scopeMatch) {\n      loggedObjects.push(logEntry);\n    }\n    </filterLogEntries>\n  });\n\n  return loggedObjects;\n}\n"], ["initialise", "\nfunction initialise (config, log, defaults) {\n  const { interval, redis: redisConfig } = config;\n\n  <checkValidInterval>\n  if (! (interval > 0 && interval < Infinity)) {\n    throw new TypeError('Invalid interval');\n  }\n  </checkValidInterval>\n\n  <checkValidLogArgument>\n  if (! log) {\n    throw new TypeError('Missing log argument');\n  }\n  </checkValidLogArgument>\n\n  <setupRedisConfig>\n  const redis = require('../redis')({\n    ...redisConfig,\n    enabled: true,\n    prefix: FLAGS_PREFIX,\n  }, log);\n  </setupRedisConfig>\n\n  let cache, timeout;\n\n  <initializeRefresh>\n  refresh();\n  </initializeRefresh>\n\n  <returnPublicAPI>\n  return { get, terminate };\n  </returnPublicAPI>\n\n  async function refresh () {\n    try {\n      <refreshCache>\n      if (cache) {\n        const result = await redis.get(FLAGS_KEY);\n        cache = Promise.resolve(JSON.parse(result));\n      } else {\n        cache = redis.get(FLAGS_KEY).then(result => JSON.parse(result));\n        await cache;\n      }\n      </refreshCache>\n    } catch (error) {\n    }\n\n    <resetTimeout>\n    timeout = setTimeout(refresh, interval);\n    </resetTimeout>\n  }\n\n  <getCache>\n  async function get () {\n    try {\n      return await cache || defaults || {};\n    } catch (error) {\n      if (defaults) {\n        return defaults;\n      }\n\n      throw error;\n    }\n  }\n  </getCache>\n\n  <terminateRefresh>\n  function terminate () {\n    if (timeout) {\n      clearTimeout(timeout);\n      timeout = null;\n    }\n\n    return redis.close();\n  }\n  </terminateRefresh>\n}\n"], ["getObjectByGroup", "\nfunction(group,bx,by){\n\t<retrieveObject>\n\tvar obj = this.nullobj;\n\tif     (group==='cell')  { obj = this.getc(bx,by);}\n\telse if(group==='cross') { obj = this.getx(bx,by);}\n\telse if(group==='border'){ obj = this.getb(bx,by);}\n\telse if(group==='excell'){ obj = this.getex(bx,by);}\n\telse if(group==='obj')   { obj = this.getobj(bx,by);}\n\t</retrieveObject>\n\treturn obj;\n}\n"], ["putMeta", "\nfunction putMeta(key, value) {\n  <findSchemaAndMapColumn>\n  const { schema, table } = findSchemaAndTable(key),\n    map = columnToValueMap('id', key);\n  </findSchemaAndMapColumn>\n\n  <updateColumnValue>\n  columnToValueMap('meta', parseOrNot(value), map);\n  </updateColumnValue>\n\n  <onConflictResolution>\n  return onConflictPut(map, schema, table).then(() => map.meta);\n  </onConflictResolution>\n}\n"], ["function", "\nfunction(connect) {\n  var t = this,\n      triggeredBy = t.get('triggeredBy'),\n      onTrigger = t.onTrigger.bind(t);\n\n  \n  <toggleMonitorListeners>\n  if (!triggeredBy) {\n    for (var monitorName in t.monitors) {\n      t.monitors[monitorName][connect ? 'on' : 'off']('change', t.onTrigger, t);\n    }\n    return;\n  }\n  </toggleMonitorListeners>\n\n  \n  <processTriggeredBy>\n  for (var name in triggeredBy) {\n    var value = triggeredBy[name];\n\n    \n    <handleCronTriggers>\n    if (name === 'cron') {\n      if (connect) {\n        t.cronJob = new Cron.CronJob(value, onTrigger);\n      }\n      else {\n        if (t.cronJob.initiated) {\n          clearInterval(t.CronJob.timer);\n        }\n        else {\n          setTimeout(function(){clearInterval(t.cronJob.timer);}, 1000);\n        }\n      }\n    }\n    </handleCronTriggers>\n\n    \n    <handleIntervalTriggers>\n    else if (name === 'interval') {\n      if (connect) {\n        t.interval = setInterval(onTrigger, value);\n      }\n      else {\n        clearInterval(t.interval);\n        t.interval = null;\n      }\n    }\n    </handleIntervalTriggers>\n\n    \n    <handleOtherTriggers>\n    else {\n      t.monitors[name][connect ? 'on' : 'off'](value, onTrigger);\n    }\n    </handleOtherTriggers>\n  }\n  </processTriggeredBy>\n}\n"], ["createInterpolatedTag", "\nfunction() {\n  <createTagObject>\n  var tok = this.advance();\n  var tag = {\n    type: 'InterpolatedTag',\n    expr: tok.val,\n    selfClosing: false,\n    block: this.emptyBlock(tok.line),\n    attrs: [],\n    attributeBlocks: [],\n    isInline: false,\n    line: tok.line,\n    filename: this.filename\n  };\n  </createTagObject>\n\n  <finalizeTag>\n  return this.tag(tag, {selfClosingAllowed: true});\n  </finalizeTag>\n}\n"], ["startThaliMobile", "\nfunction start (router, pskIdToSecret, networkType) {\n  <checkIfAlreadyStarted>\n  if (thaliMobileStates.started === true) {\n    return Promise.reject(new Error('Call Stop!'));\n  }\n  </checkIfAlreadyStarted>\n  \n  <setNetworkType>\n  thaliMobileStates.started = true;\n  thaliMobileStates.networkType =\n    networkType || global.NETWORK_TYPE || thaliMobileStates.networkType;\n  </setNetworkType>\n\n  <startNetwork>\n  return getWifiOrNativeMethodByNetworkType('start',\n    thaliMobileStates.networkType)(router, pskIdToSecret)\n    .then(function (result) {\n      if (result.wifiResult === null && result.nativeResult === null) {\n        return result;\n      }\n      return Promise.reject(result);\n    });\n  </startNetwork>\n}\n"], ""]