[["CacheDriver", "\nfunction CacheDriver(callContext, authority, resource, clientId, cache, refreshFunction) {\n  this._callContext = callContext;\n  this._log = new Logger('CacheDriver', callContext._logContext);\n  this._authority = authority;\n  this._resource = resource;\n  this._clientId = clientId;\n  this._cache = cache || nopCache;\n  this._refreshFunction = refreshFunction;\n}\n"], ["onResponse", "\nfunction onResponse( repo, idx ) {\n  return function onResponse( error, response, body ) {\n    <errorHandling>\n    if ( eFLG ) {\n      return;\n    }\n    debug( 'Response received for repository `%s` (%d).', repo, idx );\n    if ( arguments.length === 1 ) {\n      eFLG = true;\n      debug( 'Encountered an application-level error for repository `%s` (%d): %s', repo, idx, error.message );\n      return clbk( error );\n    }\n    if ( error ) {\n      debug( 'Failed to resolve file for repository `%s` (%d): %s', repo, idx, error.message );\n      out.failures[ repo ] = error.message;\n      fcount += 1;\n    } else {\n      debug( 'Successfully resolved file for repository `%s` (%d).', repo, idx );\n      out.data[ repo ] = body;\n      scount += 1;\n    }\n    count += 1;\n    </errorHandling>\n    debug( 'Request %d of %d complete.', count, len );\n    next();\n  }; \n}\n"], ["getCustomPropertiesFromObject", "\nfunction getCustomPropertiesFromObject(object) {\n  <mergeCustomProperties>\n  const customProperties = Object.assign(\n    {},\n    Object(object).customProperties,\n    Object(object)['custom-properties']\n  );\n  </mergeCustomProperties>\n\n  <parseCustomProperties>\n  for (const key in customProperties) {\n    customProperties[key] = parse(String(customProperties[key])).nodes;\n  }\n  </parseCustomProperties>\n\n  return customProperties;\n}\n"], ["anonymousFunction", "\nfunction (forms, serializeArray) {\n  return querystring.stringify(FormSerializer.getFormData(forms), undefined, undefined, serializeArray || false);\n}\n"], ["baseDifference", "\nfunction baseDifference(array, values) {\n  var index = -1,\n    indexOf = getIndexOf(),\n    length = array ? array.length : 0,\n    result = [];\n  \n  <optimizeDifferenceCalculation>\n  if (createCache && values && indexOf === baseIndexOf && values.length >= LARGE_ARRAY_SIZE) {\n    indexOf = cacheIndexOf;\n    values = createCache(values);\n  }\n  </optimizeDifferenceCalculation>\n\n  <calculateDifference>\n  while (++index < length) {\n    var value = array[index];\n    if (indexOf(values, value) < 0) {\n      result.push(value);\n    }\n  }\n  </calculateDifference>\n\n  return result;\n}\n"], ["Request_redirect", "\nfunction Request_redirect(url, isTemp) {\n  <logRedirection>\n  logger.info('Request.redirect:', {\n    url: url,\n    isTemp: isTemp\n  });\n  </logRedirection>\n\n  <setupRedirection>\n  this.addHeader('Location', url);\n  this.stopPromiseChain();\n  this.isRendered = true;\n  if (Type.isBoolean(isTemp) && !!isTemp) {\n    this.response.writeHead(302, this.headers);\n  } else {\n    this.response.writeHead(301, this.headers);\n  }\n  </setupRedirection>\n\n  this.response.end('Redirect to:' + url);\n}\n"], ["checkUriRaw", "\nfunction checkUriRaw(i) {\n  const start = i;\n  \n  <parseUriTokens>\n  let l;\n\n  while (i < tokensLength) {\n    if (checkInterpolation(i) || checkVariable(i)) break;\n    else if (l = checkUriRawCharacters(i)) i += l;\n    else break;\n  }\n  </parseUriTokens>\n\n  tokens[start].uri_raw_end = i;\n\n  return i - start;\n}\n"], ["loadFontChar", "\nfunction loadFontChar(png, x, fontColor, delimiter) {\n  <getWidth>\n  var width = getCharWidth(png, x, delimiter);\n  </getWidth>\n\n  var startX = x;\n  var startY = 0;\n  var endX = startX + width;\n  var endY = png.height - 1;\n\n  <readPixels>\n  var pixels = [];\n  for (var y = startY; y < endY; y++) {\n    for (var x = startX; x < endX; x++) {\n      var pixelColor = readPixel(png, x, y);\n      if (pixelColor != null && equalsColors(pixelColor, fontColor)) {\n        pixels.push([x - startX, y]);\n      }\n    }\n  }\n  </readPixels>\n\n  return {\n    width: width,\n    pixels: pixels\n  };\n}\n"], ["combineNumeratorsAboveCommonDenominator", "\nfunction combineNumeratorsAboveCommonDenominator(node) {\n  <prepareNode>\n  let newNode = clone(node);\n  </prepareNode>\n\n  const commonDenominator = newNode.args[0].args[1];\n  const numeratorArgs = [];\n\n  <accumulateNumerators>\n  newNode.args.forEach(fraction => {\n    numeratorArgs.push(fraction.args[0]);\n  });\n  </accumulateNumerators>\n\n  <createNewNumerator>\n  const newNumerator = Node.Creator.parenthesis(\n    Node.Creator.operator('+', numeratorArgs)\n  );\n  </createNewNumerator>\n\n  <reconstructFraction>\n  newNode = Node.Creator.operator('/', [newNumerator, commonDenominator]);\n  </reconstructFraction>\n\n  return Node.Status.nodeChanged(\n    ChangeTypes.COMBINE_NUMERATORS, node, newNode\n  );\n}\n"], ["decorateWithReadConcern", "\nfunction decorateWithReadConcern(command, coll, options) {\n  <earlyReturnForTransactionSessions>\n  if (options && options.session && options.session.inTransaction()) {\n    return;\n  }\n  </earlyReturnForTransactionSessions>\n  \n  <setupReadConcern>\n  let readConcern = Object.assign({}, command.readConcern || {});\n  if (coll.s.readConcern) {\n    Object.assign(readConcern, coll.s.readConcern);\n  }\n  </setupReadConcern>\n\n  <applyReadConcern>\n  if (Object.keys(readConcern).length > 0) {\n    Object.assign(command, { readConcern: readConcern });\n  }\n  </applyReadConcern>\n}\n"], ""]