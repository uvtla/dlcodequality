[["resolve", "\nfunction resolve(filePath, relativeTo) {\n    const fullPath = path.resolve(relativeTo || '', filePath);\n    return { filePath: fullPath, configFullName: fullPath };\n}\n"], ["_linkOrCreateUser", "\nfunction _linkOrCreateUser() {\n    if(this.userInfo){ \n        return _linkIdentity(this.userInfo._id, 'facebook', this.socialUserInfo, this.creds);\n    }\n    else {\n        return _createNewFacebookUser.call(this)\n                .then(function(user){\n                    this.userInfo = user;\n                }.bind(this));\n    }\n}\n"], ["stripSpace", "\nfunction stripSpace() {\n      if (hasTag && !nonSpace) {\n        while (spaces.length) {\n          tokens.splice(spaces.pop(), 1);\n        }\n      } else {\n        spaces = [];\n      }\n\n      hasTag = false;\n      nonSpace = false;\n}\n"], ["anonymized-function", "\nfunction(mu, uriString, filename) {\n    console.info('#green{[convert file]} ' + filename + ' #green{to data uri]}\\n');\n    return mu.replace(uriString, [\n        'data:',\n        mime.getType(filename),\n        ';base64,',\n        fs.readFileSync(filename).toString('base64')\n    ].join(''));\n}\n"], ["postJson", "\nfunction postJson({ url, payload, contentType, useBearer }) {\n  return ajax({\n    url,\n    method: 'post',\n    body: JSON.stringify( payload || {} ),\n    contentType,\n    useBearer\n  })\n}\n"], ["_handleWriteMultipleRegisters", "\nfunction _handleWriteMultipleRegisters(requestBuffer, vector, unitID, callback) {\n    <parse-request>\n    var address = requestBuffer.readUInt16BE(2);\n    var length = requestBuffer.readUInt16BE(4);\n\n    if (requestBuffer.length !== (7 + length * 2 + 2)) {\n        return;\n    }\n    </parse-request>\n\n    <build-response>\n    var responseBuffer = Buffer.alloc(8);\n    responseBuffer.writeUInt16BE(address, 2);\n    responseBuffer.writeUInt16BE(length, 4);\n    </build-response>\n\n    <handle-callbacks>\n    var callbackInvoked = false;\n    var cbCount = 0;\n    var buildCb = function() {\n        return function(err) {\n            if (err) {\n                if (!callbackInvoked) {\n                    callbackInvoked = true;\n                    callback(err);\n                }\n                return;\n            }\n            cbCount = cbCount + 1;\n            if (cbCount === length && !callbackInvoked) {\n                modbusSerialDebug({ action: \"FC16 response\", responseBuffer: responseBuffer });\n                callbackInvoked = true;\n                callback(null, responseBuffer);\n            }\n        };\n    };\n    </handle-callbacks>\n\n    <error-check>\n    if (length === 0) {\n        callback({\n            modbusErrorCode: 0x02, \n            msg: \"Invalid length\"\n        });\n    }\n    </error-check>\n\n    <set-registers>\n    if (vector.setRegister) {\n        var value;\n        for (var i = 0; i < length; i++) {\n            var cb = buildCb(i);\n            value = requestBuffer.readUInt16BE(7 + i * 2);\n            try {\n                if (vector.setRegister.length === 4) {\n                    vector.setRegister(address + i, value, unitID, cb);\n                }\n                else {\n                    var promiseOrValue = vector.setRegister(address + i, value, unitID);\n                    _handlePromiseOrValue(promiseOrValue, cb);\n                }\n            }\n            catch(err) {\n                cb(err);\n            }\n        }\n    } else if (vector.setRegisterArray) {\n        value = [];\n        for (i = 0; i < length; i++) {\n            cb = buildCb(i);\n            value.push(requestBuffer.readUInt16BE(7 + i * 2));\n            _handlePromiseOrValue(value, cb);\n        }\n        try {\n            if (vector.setRegisterArray.length === 6) {\n                vector.setRegisterArray(address, value, unitID, cb);\n            }\n            else {\n                vector.setRegisterArray(address, value, unitID);\n            }\n        }\n        catch (err) {\n            cb(err);\n        }\n    }\n    </set-registers>\n}\n"], ["doesStoreContainField", "\nfunction doesStoreContainField(store, fieldName) {\n      var model = store.first();\n      if (typeof model.get(fieldName) !== 'undefined') {\n        return true;\n      }\n      return model.getField(fieldName) != null;\n}\n"], ["handleRequest", "\nasync function handleRequest(url, request, response) {\n    <log-request>\n    if(logger) {\n        logger.trace(\"Received request body\");\n    }\n    </log-request>\n\n    <process-url>\n    var store = Store(tools.actions, tools.decorators);\n    var route = store.processURL(url);\n    </process-url>\n\n    <handle-route-null>\n    if(route === null) {\n      if(logger) {\n          logger.debug(\"No route for URL: \" + url);\n      }\n      response.writeHead(404);\n      response.end();\n      return;\n    }\n    </handle-route-null>\n\n    <parse-body>\n    if(request.method !== \"GET\") {\n        ...\n    }\n    </parse-body>\n\n    <prepare-and-send-response>\n    // The main logic of this block handles a lot of responsibilities related to rendering and responding.\n    // This is split into multiple sections, such as handling GET and POST requests differently,\n    // unlinking files, gzipping responses, and more. Therefore, the entire block is non-compliant.\n    ...\n    </prepare-and-send-response>\n}\n"], ["ngAnimateSwap", "\nfunction(scope, $element, attrs, ctrl, $transclude) {\n      <watch-and-animate>\n      var previousElement, previousScope;\n      scope.$watchCollection(attrs.ngAnimateSwap || attrs['for'], function(value) {\n        if (previousElement) {\n          $animate.leave(previousElement);\n        }\n        if (previousScope) {\n          previousScope.$destroy();\n          previousScope = null;\n        }\n        if (value || value === 0) {\n          previousScope = scope.$new();\n          $transclude(previousScope, function(element) {\n            previousElement = element;\n            $animate.enter(element, null, $element);\n          });\n        }\n      });\n      </watch-and-animate>\n}\n"], ["initLibraries", "\nfunction initLibraries(cfg = {}) {\n  <configure-libraries>\n\t_.each(configMap, (keys, libName) => {\n\t\tlet lib = libs[libName];\n\t\tlet options = {};\n\t\t_.each(keys, (key) => options[key] = cfg[key]);\n\t\tlib.setOptions && lib.setOptions(options);\n\t});\n  </configure-libraries>\n}\n"], "``` \n\nIn the example for `<handleRequest>`, instead of breaking down into more SRP tags since the function is quite large and handles several responsibilities which are not consecutively grouped in the code, I tagged the whole main response handling as non-compliant, indicating that ideally, it should be refactored into smaller, more focused functions."]