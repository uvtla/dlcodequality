[["waitForSelectorAndCallback", "\nfunction (selector, callbackFn, timeout) {\n    var self = this,\n        startTime = Date.now(),\n        timeoutInterval = 150,\n        testRunning = false,\n\n        <testForSelector>\n        testForSelector = function () {\n\n            var elapsedTime = Date.now() - startTime;\n\n            if (elapsedTime > timeout) {\n                self.options.debug && console.log('warning: timeout occurred while waiting for selector:\"%s\"'.yellow, selector);\n                callbackFn(false);\n                return;\n            }\n\n            self.evaluate(function (selectorToEvaluate) {\n                return document.querySelectorAll(selectorToEvaluate).length;\n            }, function (result) {\n                testRunning = false;\n                if (result > 0) {\n                    callbackFn(true);\n                }\n                else {\n                    setTimeout(testForSelector, timeoutInterval);\n                }\n            }, selector);\n        };\n        </testForSelector>\n\n        timeout = timeout || 10000;\n        setTimeout(testForSelector, timeoutInterval);\n}\n"], ["ToggleComponentSetup", "\nfunction Toggle({ children, ...props }) {\n    const { getLabelProps, ...fieldCtx } = useFieldContext();\n    const { getFocusProps, keyboardFocused } = useKeyboardFocus();\n\n    const { onMouseDown: onFocusMouseDown, ...keyboardFocusedProps } = getFocusProps(props);\n\n    const modifiedFieldCtx = {\n        getLabelProps: ({ onMouseUp, ...other }) =>\n            getLabelProps({ onMouseUp: composeEventHandlers(onMouseUp, onFocusMouseDown), ...other }),\n        ...fieldCtx\n    };\n\n    return (\n        <FieldContext.Provider value={modifiedFieldCtx}>\n            <ToggleContext.Provider value={{ isFocused: keyboardFocused }}>\n                <StyledToggle>\n                    <StyledToggleInput\n                        {...modifiedFieldCtx.getInputProps({\n                            'data-garden-id': 'forms.toggle',\n                            'data-garden-version': PACKAGE_VERSION,\n                            ...keyboardFocusedProps\n                        })}\n                    />\n                    {children}\n                </StyledToggle>\n            </ToggleContext.Provider>\n        </FieldContext.Provider>\n    );\n}\n"], ["parseTransforms", "\nfunction parseTransforms(value) {\n    return value\n    .match(/(rotate|translate|scale|skewX|skewY|matrix)\\s*\\(([^)]*)\\)\\s*/g)\n    .map(transform => transform.match(/[\\w.-]+/g));\n}\n"], ["renderTypesWithChildrenToc", "\nfunction renderTypesWithChildrenToc(types, tocTemplate, transformers) {\n   const tocString = types.map(type =>\n      ({\n         name: type.name + transformers._deprecationTitle(type),\n         link: `#${type.name}`,\n         children: (type.children || [])\n            .map(member => {\n               const commonPrefix = `${type.name}.${member.name}`;\n               return {\n                  link: `#${commonPrefix}`,\n                  name: commonPrefix + (isFunction(member) ? '()' : '') +\n                     transformers._deprecationTitle(member)\n               };\n            })\n      })\n   );\n\n   return tocTemplate({ entries: tocString }).trim();\n}\n"], ["simplifyWhitelist", "\nfunction simplifyWhitelist(whitelist) {\n    var results = [];\n\n    if (Array.isArray(whitelist)) {\n        for (var i = 0; i < whitelist.length; i++) {\n            results.push({\n                \"id\": whitelist[i]\n            });\n        }\n    } else {\n        for (var project in whitelist) {\n            var vlist = whitelist[project];\n            for (var i = 0; i < vlist.length; i++) {\n                var id = vlist[i].id;\n                results.push({\n                    \"id\": id,\n                    \"dependencyPaths\": vlist[i].dependencyPaths\n                });\n            }\n        }\n    }\n\n    return results;\n}\n"], ["flashCallbackSetup", "\nfunction callback(err, callbackId) {\n    <validateCallbackId>\n    if (callbackId !== imageId) {\n      return;\n    }\n    </validateCallbackId>\n\n    stage.removeFlashCallbackListener('imageLoaded', callback);\n\n    <handleCallbackResult>\n    if (err) {\n      done(new NetworkError('Network error: ' + url));\n    } else {\n      done(null, new FlashAsset(flashElement, imageId));\n    }\n    </handleCallbackResult>\n}\n"], ["prepareCoapMessage", "\nfunction(msg) {\n    msg.addOption(new Option(Message.Option.URI_PATH, new Buffer(\"c\")));\n    msg.addOption(new Option(Message.Option.URI_QUERY, encodedCrc));\n    if (includeIndex) {\n        var idxBin = messages.ToBinary(chunkIndex, \"uint16\");\n        msg.addOption(new Option(Message.Option.URI_QUERY, idxBin));\n    }\n    return msg;\n}\n"], ["removeElementFromDom", "\nfunction hide() {\n    var parent = el.parentNode;\n    if (!parent) { return; }\n    parent.removeChild(el);\n    parent.classList.remove(\"st-block--controls-active\");\n    return parent;\n}\n"], ["parseFunctionArguments", "\nfunction parseArguments() {\n    <initializeArgumentList>\n    var args = [], expr;\n    </initializeArgumentList>\n\n    expect('(');\n\n    if (!match(')')) {\n        while (startIndex < length) {\n            if (match('...')) {\n                <handleSpreadElement>\n                expr = new Node();\n                lex();\n                expr.finishSpreadElement(isolateCoverGrammar(parseAssignmentExpression));\n                </handleSpreadElement>\n            } else {\n                <parseIndividualArgument>\n                expr = isolateCoverGrammar(parseAssignmentExpression);\n                </parseIndividualArgument>\n            }\n            args.push(expr);\n            if (match(')')) {\n                break;\n            }\n            expectCommaSeparator();\n        }\n    }\n\n    expect(')');\n\n    return args;\n}\n"], ["executePreStepLeavePlugins", "\nfunction(event) {\n    for (var i = 0; i < preStepLeavePlugins.length; i++) {\n        var thisLevel = preStepLeavePlugins[i];\n        if (thisLevel !== undefined) {\n            for (var j = 0; j < thisLevel.length; j++) {\n                <pluginCallbackCheck>\n                if (thisLevel[j](event) === false) {\n                    return false;\n                }\n                </pluginCallbackCheck>\n            }\n        }\n    }\n}\n"], "```"]