[["isPlainObject", "\nfunction isPlainObject(value) {\n\tif (!isObjectLike(value) || getTag(value) != '[object Object]') {\n\t\treturn false\n\t}\n\tif (Object.getPrototypeOf(value) === null) {\n\t\treturn true\n\t}\n\tlet proto = value;\n\twhile (Object.getPrototypeOf(proto) !== null) {\n\t\tproto = Object.getPrototypeOf(proto);\n\t}\n\treturn Object.getPrototypeOf(value) === proto\n}\n"], ["isMimeType", "\nfunction isMimeType(str) {\n  (0, _assertString.default)(str);\n  return mimeTypeSimple.test(str) || mimeTypeText.test(str) || mimeTypeMultipart.test(str);\n}\n"], ["getSortedCollection", "\nfunction (query) {\n    if (query instanceof Query && query.query.sort) {\n        if (this.$.query) {\n            <mergeQueries>\n            query.query.where = this.$.query.query.where;\n            </mergeQueries>\n        }\n\n        <prepareOptions>\n        var options = _.defaults({}, {\n            query: query,\n            root: this.getRoot()\n        }, this.$);\n        </prepareOptions>\n\n        <sortCacheHandling>\n        var sortCacheId = query.sortCacheId();\n        if (!this.$sortCache[sortCacheId]) {\n            this.$sortCache[sortCacheId] = this._createSortedCollection(query, options);\n        }\n        </sortCacheHandling>\n\n        return this.$sortCache[sortCacheId];\n    }\n\n    return this;\n}\n"], ["keysFromPath", "\nfunction keysFromPath(path) {\n    var re = /\\[(\"|')(.+)\\1\\]|([^.\\[\\]]+)/g;\n    var elements = [];\n    var result;\n    while ((result = re.exec(path)) !== null) {\n      elements.push(result[2] || result[3]);\n    }\n    return elements;\n  }\n"], ["signMessage", "\nfunction(message, privateKey, cb = null)\n{\n\t<executeSigning>\n    var result\n    try {\n        result = secp256k1.sign(ethUtils.sha3(message), privateKey)\n    }\n    catch (err){\n        result = err\n    }\n    </executeSigning>\n\n    <handleCallback>\n    if(isFunction(cb)){\n        if(result instanceof Error){\n            return cb(result)\n        } else {\n            return cb(null, result)\n        }\n    }\n    else {\n        return result\n    }\n\t</handleCallback>\n}\n"], ["runPre", "\nfunction runPre (arr, argv, cb) {\n  const nw = arr.map(function (el) {\n    return el.bind(null, argv)\n  })\n  series(nw, cb)\n}\n"], ["fulfillName", "\nfunction fulfillName (name, ext, mask, lang) {\n    <parameterNormalization>\n    var shortname;\n    var params;\n    if (isPlainObject(name)) {\n        params = name;\n        name = params.name;\n        ext = params.ext;\n        mask = params.mask;\n        lang = params.lang;\n    }\n    </parameterNormalization>\n\n    <generateFullName>\n    shortname = basename(name);\n    if (mask) {\n        name = join(name, unmaskName(shortname, mask, lang));\n    }\n    var curext = extname(name);\n    if (curext) {\n        return name;\n    }\n    if (ext[0] !== '.') {\n        ext = '.' + ext;\n    }\n    return join(name, shortname + ext);\n    </generateFullName>\n}\n"], ["parseModelData", "\nfunction (model, data, action, options) {\n    var processor = this.$dataSource.getProcessorForModel(model);\n    return processor.parse(model, data, action, options);\n}\n"], ["getChannelsSchedule", "\nfunction getChannelsSchedule(channel,date){\n  <generatePath>\n  var p = '/ibl/v1/channels/{channel}/schedule/{date}';\n  p = p.replace('{channel}',channel);\n  p = p.replace('{date}',date);\n  return p;\n  </generatePath>\n}\n"], ["timeout", "\nfunction timeout(message) {\n    <logTimeoutWarning>\n    $log.warn('Plugin client request timeout: ' + serialize(message));\n    </logTimeoutWarning>\n\n    <findAndResolvePromise>\n    var promiseIndex = lodash.findIndex(promises, function(promise) {\n      return promise.id == message.header.id;\n    });\n    if (promiseIndex >= 0) {\n      var promise = lodash.pullAt(promises, promiseIndex);\n      message.response = {\n        statusCode: 408,\n        statusText: 'REQUEST_TIMED_OUT',\n        data: {\n          message: 'Request timed out.'\n        }\n      }\n      promise[0].onComplete(message);\n    } else {\n      $log.warn('Message request timed out but there is no promise to fulfill: ' + serialize(message));\n    }\n    </findAndResolvePromise>\n  }\n"], "```"]