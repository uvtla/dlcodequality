[["sendDrones", "\nfunction sendDrones(filter, res) {\n    droneModel.getProcessed(filter, function(err, result) {\n      if (err)\n        return haibu.sendResponse(res, 500, err);\n\n      haibu.sendResponse(res, 200, {drones: result});\n    });\n  }\n"], ["detectErrors", "\nfunction detectErrors (err, responseSpec, next) {\n      var callbackErr;\n      if (err) {\n        callbackErr = err;\n      }\n      else {\n        <handleResponseStatus>\n        var status = responseSpec.statusCode;\n        if (status == 403) {\n          callbackErr = new Charon.RequestForbiddenError(responseSpec);\n        }\n        else if (status == 404) {\n          callbackErr = new Charon.ResourceNotFoundError(responseSpec);\n        }\n        else if (status == 409) {\n          callbackErr = new Charon.ResourceConflictError(responseSpec);\n        }\n        else if (status >= 400 && status <= 499) {\n          callbackErr = new Charon.ConsumerError(responseSpec);\n        }\n        else if (status >= 500 && status <= 599) {\n          callbackErr = new Charon.ServiceError(responseSpec);\n        }\n        else if (! (status >= 200 && status <= 299)) {\n          callbackErr = new Charon.RuntimeError('Unrecognized HTTP status code', responseSpec);\n        }\n        </handleResponseStatus>\n      }\n      this.invokeNext(callbackErr, responseSpec, next);\n    }\n"], ["updateNodeHighlightedValue", "\nfunction updateNodeHighlightedValue(nodes, links, config, id, value = false) {\n    const highlightedNode = value ? id : \"\";\n    const node = Object.assign({}, nodes[id], { highlighted: value });\n    let updatedNodes = Object.assign({}, nodes, { [id]: node });\n\n    <updateHighlightRelatedNodes>\n    if (links[id] && config.highlightDegree !== 0) {\n        updatedNodes = Object.keys(links[id]).reduce((acc, linkId) => {\n            const updatedNode = Object.assign({}, updatedNodes[linkId], { highlighted: value });\n            return Object.assign(acc, { [linkId]: updatedNode });\n        }, updatedNodes);\n    }\n    </updateHighlightRelatedNodes>\n\n    return {\n        nodes: updatedNodes,\n        highlightedNode,\n    };\n}\n"], ["defaultData", "\nfunction defaultData(vars, now) {\n  // All lines here are configuring default values and is considered single responsibility\n  const duration = vars.duration || vars.duration === 0 ? vars.duration : DEFAULT_DURATION;\n  return {\n    duration: vars.type === 'set' ? 0 : duration,\n    delay: vars.delay || DEFAULT_DELAY,\n    ease: typeof vars.ease === 'function' ? vars.ease : easingTypes[vars.ease || DEFAULT_EASING],\n    onUpdate: vars.onUpdate || noop,\n    onComplete: vars.onComplete || noop,\n    onStart: vars.onStart || noop,\n    onRepeat: vars.onRepeat || noop,\n    repeat: vars.repeat || 0,\n    repeatDelay: vars.repeatDelay || 0,\n    yoyo: vars.yoyo || false,\n    type: vars.type === 'from' ? 'from' : 'to',\n    initTime: now,\n    appearTo: typeof vars.appearTo === 'number' ? vars.appearTo : null,\n    perTime: 0,\n    currentRepeat: 0,\n  };\n}\n"], ["BelongsToMany", "\nfunction BelongsToMany(model, related, pivot, foreignPivotKey, relatedPivotKey, parentKey, relatedKey) {\n        // All lines here are related to setting up a BelongsToMany relationship instance and is considered single responsibility\n        var _this = _super.call(this, model)  || this;\n        _this.related = _this.model.relation(related);\n        _this.pivot = _this.model.relation(pivot);\n        _this.foreignPivotKey = foreignPivotKey;\n        _this.relatedPivotKey = relatedPivotKey;\n        _this.parentKey = parentKey;\n        _this.relatedKey = relatedKey;\n        return _this;\n}\n"], ["format", "\nfunction format(str, ...args) {\n  return !args.length ? str : str.replace(/%[a-zA-Z]/, (match) => args.shift() || match);\n}\n"], ["function", "\nfunction( queryOptions, callback ) {\n    <handleFunctionOverload>\n    if ( typeof queryOptions === 'function' ) {\n        callback = queryOptions;\n        queryOptions = {};\n    }\n    </handleFunctionOverload>\n    <capabilities>\n    this.capabilities( queryOptions, function( err, capabilities ) {\n        if ( err ) {\n            debug( 'Error getting service metadata: %j', err );\n            return callback( err );\n        }\n        callback( null, capabilities.service );\n    } );\n    </capabilities>\n}\n"], ["events", "\nfunction events (obj, build, compare) {\n  var e = []\n  <forEachTime>\n  forEachTime(function (time, obj) {\n    e.push(build ? build(time, obj) : [time, obj])\n  }, null, obj)\n  </forEachTime>\n  return e.sort(compare || function (a, b) { return a[0] - b[0] })\n}\n"], ["function", "\nfunction(fn) {\n    var ret = null;\n    <processFunctionOrStringArgument>\n    if (fn) {\n        ret = (typeof fn === 'string') ?\n        function(n) {\n            return Y.Selector.test(n, fn);\n        } : \n        function(n) {\n            return fn(Y.one(n));\n        };\n    }\n    </processFunctionOrStringArgument>\n\n    return ret;\n}\n"], ["start", "\nfunction start(priv, callback) {\n  <checkPreconditions>\n  check(priv.started, 'slider.started').is.False();\n  check(callback, 'callback').is.aFunction.or.Undefined();\n  </checkPreconditions>\n  \n  <setupEventListeners>\n  priv.startCallback = callback || noop;\n\n  window.addEventListener('keydown', partial(keyBasedMove, priv), false);\n  priv.elem.addEventListener('click', partial(clickBasedMove, priv), false);\n\n  priv.upgrader.onSlideUpgraded = acceptSlide.bind(null, priv);\n  priv.upgrader.start();\n  priv.phaser.addPhaseListener(partial(onPhaseChange, priv));\n\n  on(priv, 'slideChange', changeDot.bind(null, priv));\n  </setupEventListeners>\n  priv.started = true;\n}\n"], ""]