[["removeTag", "\nfunction remove(tags, i) {\n  tags.splice(i, 1);\n  this.unmount();\n  arrayishRemove(this.parent, this, this.__.tagName, true);\n}\n"], ["oauthTokenRequest", "\nfunction(data, code, callback) {\n    var self = this;\n    var cconfig = this.config.client;\n    var sconfig = this.config.servers[data.oauth2_server_id];\n    request.post({uri: sconfig.server_token_endpoint,\n                  headers: {'content-type': 'application/x-www-form-urlencoded'},\n                  body: querystring.stringify({\n                    grant_type: \"authorization_code\",\n                    client_id: sconfig.client_id,\n                    code: code,\n                    client_secret: sconfig.client_secret,\n                    redirect_uri: cconfig.redirect_uri\n                  })\n                 }, function(error, response, body) {\n                   console.log(body);\n                   if (!error && response.statusCode == 200) {\n                     try {\n                       var methods = self.methods[data.oauth2_server_id];\n                       var token = methods.transform_token_response(body)\n                       callback(null, token);\n                     } catch(err) {\n                       callback(err);\n                     }\n                   } else {\n                     \n                     console.error(error, body);\n                     callback(error);\n                   }\n                 });\n  }\n"], ["initCloneByTag", "\nfunction initCloneByTag(object, tag, cloneFunc, isDeep) {\n        var Ctor = object.constructor;\n        switch (tag) {\n            case arrayBufferTag:\n                return cloneArrayBuffer(object);\n\n            case boolTag:\n            case dateTag:\n                return new Ctor(+object);\n\n            case dataViewTag:\n                return cloneDataView(object, isDeep);\n\n            case float32Tag:\n            case float64Tag:\n            case int8Tag:\n            case int16Tag:\n            case int32Tag:\n            case uint8Tag:\n            case uint8ClampedTag:\n            case uint16Tag:\n            case uint32Tag:\n                return cloneTypedArray(object, isDeep);\n\n            case mapTag:\n                return cloneMap(object, isDeep, cloneFunc);\n\n            case numberTag:\n            case stringTag:\n                return new Ctor(object);\n\n            case regexpTag:\n                return cloneRegExp(object);\n\n            case setTag:\n                return cloneSet(object, isDeep, cloneFunc);\n\n            case symbolTag:\n                return cloneSymbol(object);\n        }\n    }\n"], ["JavaScriptFileLoadErrorConstructor", "\nfunction JavaScriptFileLoadError(file, nestedError){\n  nestedError = nestedError || null;\n\n  var message = (nestedError)?\n        util.format('\"%s\" failed to load as JavaScript; VM error: %s', file, nestedError.toString()) :\n        util.format('\"%s\" failed to load as JavaScript.', file);\n\n  superError.call(this, 'JavaScriptFileLoadError', message);\n\n  this.fsPath = file;\n  this.nestedError = nestedError;\n}\n"], ["resolveDateString", "\nfunction $$core$$resolveDateString(data, ca, component, width, key) {\n        var obj = data[ca] && data[ca][component]\n                    ? data[ca][component]\n                    : data.gregory[component],\n            alts = {\n                narrow: ['short', 'long'],\n                short:  ['long', 'narrow'],\n                long:   ['short', 'narrow']\n            },\n            resolved = $$core$$hop.call(obj, width)\n                      ? obj[width]\n                      : $$core$$hop.call(obj, alts[width][0])\n                          ? obj[alts[width][0]]\n                          : obj[alts[width][1]];\n        return key != null ? resolved[key] : resolved;\n    }\n"], ["resolveScopedSlots", "\nfunction resolveScopedSlots (\n  fns, \n  hasDynamicKeys,\n  res\n) {\n  res = res || { $stable: !hasDynamicKeys };\n  for (var i = 0; i < fns.length; i++) {\n    var slot = fns[i];\n    if (Array.isArray(slot)) {\n      resolveScopedSlots(slot, hasDynamicKeys, res);\n    } else if (slot) {\n      if (slot.proxy) {\n        slot.fn.proxy = true;\n      }\n      res[slot.key] = slot.fn;\n    }\n  }\n  return res\n}\n"], ["maxPrerelease", "\nfunction maxPrerelease (versions, prerelease) {\n  return first(desc(versions), function (version) {\n    return isPrerelease(version, prerelease);\n  });\n}\n"], ["scanNode", "\nfunction scanNode(node, c){\n      if (node.nextSibling)\n        c = push(scanNode, node.nextSibling, c);\n\n      if (partNode(node)){\n        nodeQueue.push(node);\n        afterBR = false;\n        return yield(node.currentText, c);\n      }\n      else if (isBR(node)) {\n        if (afterBR && window.opera)\n          node.parentNode.insertBefore(makePartSpan(\"\", owner), node);\n        nodeQueue.push(node);\n        afterBR = true;\n        return yield(\"\\n\", c);\n      }\n      else {\n        var end = !node.nextSibling;\n        point = pointAt(node);\n        removeElement(node);\n        return writeNode(node, c, end);\n      }\n    }\n"], ["validStyles", "\nfunction validStyles(styleAttr) {\n      var result = '';\n      var styleArray = styleAttr.split(';');\n      angular.forEach(styleArray, function (value) {\n          var v = value.split(':');\n          if (v.length === 2) {\n              var key = trim(v[0].toLowerCase());\n              value = trim(v[1].toLowerCase());\n              result += sanitizeStyle(key, value);\n          }\n      });\n      return result;\n  }\n"], ["getPluginVersion", "\nfunction getVersion (plugin) {\n  return new Promise(function (resolve, reject) {\n    npm.commands.view([plugin, 'version'], function (err, data) {\n      if (err) return reject(err)\n      resolve(Object.keys(data)[0])\n    })\n  })\n}\n"], "```\n\nThe functions above are annotated following the Single Responsibility Principle. Each function is enclosed within tags that describe its responsibilities. There are no nested tags since each function, within the scope of this exercise, seems to exhibit a single cohesive behavior or purpose. Some functions combine several actions, but they are all contributing to a single responsibility within the context that the function operates."]