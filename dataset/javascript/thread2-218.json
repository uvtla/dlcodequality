[["getComments", "\nfunction getComments(id) {\n    <ajaxRequest>\n    $.ajax({\n     type: 'GET',\n     url: opts.getCommentsURL,\n     data: {node: id},\n     success: function(data, textStatus, request) {\n       var ul = $('#cl' + id);\n       var speed = 100;\n       $('#cf' + id)\n         .find('textarea[name=\"proposal\"]')\n         <handleData>\n         .data('source', data.source);\n\n       if (data.comments.length === 0) {\n         <displayEmptyMessage>\n         ul.html('<li>No comments yet.</li>');\n         ul.data('empty', true);</displayEmptyMessage>\n       } else {\n         \n         <processAndDisplayComments>\n         var comments = sortComments(data.comments);\n         speed = data.comments.length * 100;\n         appendComments(comments, ul);\n         ul.data('empty', false);\n         </processAndDisplayComments>\n       }\n       <animateComments>\n       $('#cn' + id).slideUp(speed + 200);\n       ul.slideDown(speed);</animateComments>\n     },\n     error: function(request, textStatus, error) {\n       <handleError>\n       showError('Oops, there was a problem retrieving the comments.');</handleError>\n     },\n     dataType: 'json'\n    });</ajaxRequest>\n  }"], ["simplifyObject", "\nfunction ( obj, arg ) {\n    if ( arg === undefined ) {\n        <getObjectInnerHTML>\n        return obj.innerHTML;</getObjectInnerHTML>\n    }\n    else {\n        <setObjectInnerHTML>\n        obj.innerHTML = arg;\n        return obj;</setObjectInnerHTML>\n    }\n}"], ["disableMinutesIfMidnight", "\nfunction(){\t\t\n        var endHours = this.inputs[2];\n        var endMinutes = this.inputs[3];\n        \n        if( endHours.getValue() == '24' ){ <setMinutesForMidnight>\n        endMinutes.setValue(\"00\"); endMinutes.disable();</setMinutesForMidnight>}\n        else{ <enableMinutes>\n        endMinutes.enable(); </enableMinutes>}\t\t\n    }"], ["prepareOptXhrToSend", "\nfunction(optXhr) {\n    <cacheBusting>\n    if (cacheBuster && qq.indexOf([\"GET\", \"DELETE\"], options.method) >= 0) {\n        params.qqtimestamp = new Date().getTime();\n    }</cacheBusting>\n\n    <prepareRequest>\n    return prepareToSend(id, optXhr, path, params, additionalQueryParams, headers, payload);</prepareRequest>\n}"], ["TypeVariable", "\nfunction TypeVariable(name) {\n    <initializeComponents>\n    var tuples = [];\n    var test = typeVarPred (tuples.length);</initializeComponents>\n    <createTypeVariable>\n    return _Type (VARIABLE, name, '', 0, always2 (name), [], test, tuples);</createTypeVariable>\n}"], ["mergeAll", "\nfunction mergeAll(concurrent) {\n    <defaultConcurrentValue>\n    if (concurrent === void 0) {\n        concurrent = Number.POSITIVE_INFINITY;\n    }</defaultConcurrentValue>\n    <invokeMergeMap>\n    return Object(_mergeMap__WEBPACK_IMPORTED_MODULE_0__[\"mergeMap\"])(_util_identity__WEBPACK_IMPORTED_MODULE_1__[\"identity\"], concurrent);</invokeMergeMap>\n}"], ["random", "\nfunction random(min, max) {\n  <generateRandomNumber>\n  var randomNumber = Math.random() * (max - min + 1) + min;</generateRandomNumber>\n\n  <integrityCheckAndReturn>\n  if (!Number.isInteger(min) || !Number.isInteger(max)) {\n    return randomNumber;\n  } else {\n    return Math.floor(randomNumber);\n  }</integrityCheckAndReturn>\n}"], ["filter", "\nfunction filter( node ) {\n    <parseNodeInformation>\n    var isNullable;\n    var isOptional;\n    var type;\n    var desc;\n    var val;\n\n    if ( node.type ) {\n        if ( node.type.names.length === 1 ) {\n            type = node.type.names[ 0 ];\n        } else {\n            type = node.type.names;\n        }\n    } else {\n        type = '';\n    }\n    desc = node.description || '';\n    if ( hasOwn.call( node, 'defaultvalue' ) ) {\n        val = node.defaultvalue;\n    } else {\n        val = '';\n    }\n    if ( typeof node.optional === 'boolean' ) {\n        isOptional = node.optional;\n    } else {\n        isOptional = '';\n    }\n    if ( typeof node.nullable === 'boolean' ) {\n        isNullable = node.nullable;\n    } else {\n        isNullable = '';\n    }</parseNodeInformation>\n    <returnFilteredObject>\n    return {\n        'name': node.name,\n        'type': type,\n        'description': desc,\n        'default': val,\n        'optional': isOptional,\n        'nullable': isNullable\n    };</returnFilteredObject>\n}"], ["initializeTimer", "\nfunction (config) {\n        \n        <initializeStartFlag>\n        this.started = false;</initializeStartFlag>\n        <assignOnStart>\n        this.onStart = core.FUNCTION_VOID;</assignOnStart>\n        <assignOnStop>\n        this.onStop = core.FUNCTION_VOID;</assignOnStop>\n        <initializeErrorHandlers>\n        this.errorHandlers = [];</initializeErrorHandlers>\n\n        <configureTimer>\n        this.configure(config);</configureTimer>\n    }"], ["groupBy", "\nfunction groupBy (obj, iterate, context) {\n    <initializeGrouping>\n    var groupKey\n    var result = {}</initializeGrouping>\n    <groupByProcessing>\n    if (obj) {\n        <establishContext>\n        context = this || context;</establishContext>\n        <prepareIterateFunction>\n        if (iterate && isObject(iterate)) {\n            iterate = createiterateEmpty(iterate)\n        } else if (!isFunction(iterate)) {\n            iterate = property(iterate)\n        }</prepareIterateFunction>\n        <performGrouping>\n        each(obj, function (val, key) {\n            groupKey = iterate ? iterate.call(context, val, key, obj) : val\n            if (result[groupKey]) {\n                result[groupKey].push(val)\n            } else {\n                result[groupKey] = [val]\n            }\n        });</performGrouping>\n    }</groupByProcessing>\n    <returnGroupedObject>\n    return result</returnGroupedObject>\n}"], ""]