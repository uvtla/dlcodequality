[["getConnection", "\nfunction getConnection(pool, scope){\n    return new Promise(function(resolve, reject){\n\n        <retrieveConnection>\n        pool.getConnection(function(err, connection){\n            \n            if (err){\n                reject(err);\n                return;\n            }\n        </retrieveConnection>\n\n        <exposeAPI>\n        const api = exposeAPI(connection);\n        </exposeAPI>\n\n        <executeScopeFunction>\n        if (typeof scope === 'function'){\n\n            scope.apply(api, [api, connection]).then(function(result){\n\n                <releaseConnection>\n                connection.release();\n                </releaseConnection>\n\n                resolve(result);\n            }).catch(function(e){\n                \n                <releaseConnection>\n                connection.release();\n                </releaseConnection>\n\n                reject(e);\n            });\n\n        }else{\n        </executeScopeFunction>\n        \n        <resolveAPI>\n        resolve(api);\n        </resolveAPI>\n        }\n    });\n});\n"], ["parseExpression", "\nfunction() {\n    var m, a, op, operation;\n    \n    m = $(this.operand);\n    \n    if (m) {\n        while ((op = ($('/') || $('*') || $('%'))) && (a = $(this.operand))) {\n            operation = new tree.Operation(op, [operation || m, a], memo, env.filename);\n        }\n        \n        return operation || m;\n    }\n}\n"], ["initializeObject", "\nfunction () {\n    const self = this;\n\n    self.initd = {};\n    self.native = null;\n    <setupConnectd>\n    self.connectd = {\n        data_in: function (paramd) {\n            _.extend(paramd.cookd, paramd.rawd);\n        },\n\n        data_out: function (paramd) {\n            _.extend(paramd.rawd, paramd.cookd);\n        },\n    };\n    </setupConnectd>\n}\n"], ["ThrowType", "\nfunction ThrowType(name, type, value, actual) {\n    console.log('THIS:', this)\n    let THS = this, pfx = (!!THS ? THS.Name||THS.Scheme : '');\n    \n    <throwTypeError>\n    throw new TypeError(\n        `${pfx} property, [${name}], must be one of the following, <${\n            type.join('> or <').toTitleCase()\n        }>. Got <${actual.toTitleCase()}> (${value}) instead.`\n    );\n    </throwTypeError>\n}\n"], ["onErr", "\nfunction onErr(err) {\n  \n  <handlePortInUseError>\n  if (err.code === 'EADDRINUSE') {\n    panic('Local port is in use \\nFailing...');\n  }\n  </handlePortInUseError>\n  \n  <handleUsbmuxdErrors>\n  if (err.code === 'ECONNREFUSED' || err.code === 'EADDRNOTAVAIL') {\n    panic('Usbmuxd not found at', usbmux.address, '\\nFailing...');\n  }\n  </handleUsbmuxdErrors>\n  \n  <handleGenericError>\n  panic('%s \\nFailing...', err);\n  </handleGenericError>\n}\n"], ["animateCharacter", "\nfunction() {\n    var hand = game.player.hand;\n    var steps = game.player.steps;\n    var scaleFactor = this.scale * 6;\n\n    <calculateScales>\n    var xScale = Math.cos(steps * 2);\n    var yScale = Math.sin(steps * 4);\n    var bobX = xScale * scaleFactor;\n    var bobY = yScale * scaleFactor;\n    </calculateScales>\n\n    <calculatePositions>\n    var x = (canvas.width - (hand.width * this.scale) + scaleFactor) + bobX;\n    var y = (canvas.height - (hand.height * this.scale) + scaleFactor) + bobY;\n    </calculatePositions>\n\n    <calculateDimensions>\n    var w = hand.width * this.scale;\n    var h = hand.height * this.scale;\n    </calculateDimensions>\n\n    <drawImage>\n    ctx.drawImage(hand.image, x, y, w, h);\n    </drawImage>\n  }\n"], ["OutlineRenderer", "\nfunction OutlineRenderer (options, explorer, title, inputManager) {\n    this.explorer = explorer;\n    <initializeOptions>\n    this._init(options);\n    </initializeOptions>\n    this.title = title;\n    this.inputManager = inputManager;\n}\n"], ["updateImageMetadata", "\nfunction(imageIdentifier, data, callback, method) {\n    var url = this.getMetadataUrl(imageIdentifier);\n\n    <metadataRequest>\n    request({\n        method: method || 'POST',\n        uri: this.getSignedResourceUrl(method || 'POST', url),\n        json: data,\n        onComplete: function(err, res, body) {\n            callback(err, body, res);\n        }\n    });\n    </metadataRequest>\n\n    return this;\n}\n"], ["clean", "\nfunction clean(args) {\n    return Array.prototype.filter.call(args, v => v !== INVALIDATE);\n}\n"], ["S", "\nfunction S(fn, value) {\n    <guardAgainstRootlessComputation>\n    if (Owner === null)\n        console.warn(\"computations created without a root or parent will never be disposed\");\n    </guardAgainstRootlessComputation>\n    \n    var _a = makeComputationNode(fn, value, false, false), node = _a.node, _value = _a.value;\n    \n    <returnComputationFunction>\n    if (node === null) {\n        return function computation() { return _value; };\n    }\n    else {\n        return function computation() {\n            return node.current();\n        };\n    }\n    </returnComputationFunction>\n}\n"], "```"]