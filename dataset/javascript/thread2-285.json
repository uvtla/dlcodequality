[["copyOwnProperties", "\nfunction copyOwnProperties(dst, src) {\n  for (var prop in src) {\n    <hasOwnPropertyCheck>\n    if (src.hasOwnProperty(prop)) {\n      dst[prop] = src[prop];\n    }\n    </hasOwnPropertyCheck>\n  }\n}\n"], ["isFunction", "\nfunction isFunction(value) {\n  <isObjectCheck>\n  if (!isObject$1(value)) {\n    return false;\n  }\n  </isObjectCheck>\n  \n  <tagRetrieval>\n  var tag = baseGetTag(value);\n  </tagRetrieval>\n  <isSpecificFunctionType>\n  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;\n  </isSpecificFunctionType>\n}\n"], ["anonymousFunction1", "\nfunction (key, fn) {\n    <handlerSetup>\n    if (typeof key === 'function') {\n      fn = key;\n      key = null;\n    }\n    if (typeof fn !== 'function') {\n      fn = this.pickOption('renameKey');\n    }\n    if (typeof fn !== 'function') {\n      fn = utils.identity;\n    }\n    </handlerSetup>\n    \n    <setRenameKeyOption>\n    this.options.renameKey = fn;\n    </setRenameKeyOption>\n    \n    <keyHandling>\n    if (arguments.length === 2) {\n      return fn(key);\n    }\n    if (typeof key === 'string') {\n      return fn(key);\n    }\n    </keyHandling>\n    \n    <returnFunction>\n    return fn;\n    </returnFunction>\n}\n"], ["anonymousFunction2", "\nfunction () {\n    <arithmeticProcess>\n    var t = this.dpop() | 0;\n    var n = this.dpop() | 0;\n    var m = this.dpop() | 0;\n    var ddd = Long.fromInt(m);\n    ddd = ddd.mul(Long.fromInt(n));\n    ddd = ddd.div(Long.fromInt(t));\n    ddd = ddd.toInt();\n    this.dpush(ddd | 0);\n    </arithmeticProcess>\n}\n"], ["setupPrompt", "\nfunction (local, opts, actions, m) {\n  <setActions>\n  local.context.ACTIONS = actions\n  </setActions>\n  <getAndSetPrompt>\n  local._prompt = getPrompt(opts, m[ 2 ])\n  </getAndSetPrompt>\n  <invokePrompt>\n  local.prompt()\n  </invokePrompt>\n}\n"], ["css", "\nfunction css() {\n  <gulpPipelineSetup>\n  return gulp\n    .src(\"./scss*.scss\")\n    .pipe(plumber())\n    .pipe(sass({\n      outputStyle: \"expanded\",\n      includePaths: \"./node_modules\",\n    }))\n    .on(\"error\", sass.logError)\n    .pipe(autoprefixer({\n      browsers: ['last 2 versions'],\n      cascade: false\n    }))\n    .pipe(header(banner, {\n      pkg: pkg\n    }))\n    .pipe(gulp.dest(\"./css\"))\n    .pipe(rename({\n      suffix: \".min\"\n    }))\n    .pipe(cleanCSS())\n    .pipe(gulp.dest(\"./css\"))\n    .pipe(browsersync.stream());\n    </gulpPipelineSetup>\n}\n"], ["moveSelection", "\nfunction moveSelection(\n    opts: Options,\n    change: Change,\n    x: number,\n    y: number\n): Change {\n    <retrieveValueAndPosition>\n    const { value } = change;\n    const { startKey } = value;\n    const pos = TablePosition.create(opts, value.document, startKey);\n    </retrieveValueAndPosition>\n\n    <validateCellPosition>\n    if (!pos.isInCell()) {\n        throw new Error('moveSelection can only be applied from within a cell');\n    }\n    </validateCellPosition>\n\n    <identifyDestination>\n    const { table } = pos;\n    const row = table.nodes.get(y);\n    const cell = row.nodes.get(x);\n    </identifyDestination>\n\n    <collapseChange>\n    return change.collapseToStartOf(cell);\n    </collapseChange>\n}\n"], ["parseJson", "\nfunction parseJson(data) {\n  <setupParseParameters>\n  const parseError = [];\n  const parseOptions = {\n    disallowComments: false,\n    allowTrailingComma: true\n  };\n  </setupParseParameters>\n  \n  <parseAttempt>\n  const jsonData = jsonc.parse(data, parseError, parseOptions);\n  </parseAttempt>\n  \n  <errorHandling>\n  if (parseError.length !== 0) {\n    return data;\n  }\n  </errorHandling>\n  \n  <stringifyParsedData>\n  return JSON.stringify(jsonData);\n  </stringifyParsedData>\n}\n"], ["showSnackbar", "\nfunction showsnackbar(y) {\n    <getElementAndShow>\n    var x = document.getElementById(y);\n    x.className = x.className.replace(\"snackbar\", \"snackbar show\");\n    </getElementAndShow>\n    <setHideTimeout>\n    setTimeout(function() {\n        x.className = x.className.replace(\"show\", \"\");\n    }, 3000);\n    </setHideTimeout>\n}\n"], ["expectSpaceAfter", "\nfunction expectSpaceAfter(token, pattern) {\n    <retrieveNextToken>\n    const nextToken = sourceCode.getTokenAfter(token);\n    </retrieveNextToken>\n\n    <checkSpacingAndReport>\n    if (nextToken &&\n        (CHECK_TYPE.test(nextToken.type) || pattern.test(nextToken.value)) &&\n        !isCloseParenOfTemplate(nextToken) &&\n        astUtils.isTokenOnSameLine(token, nextToken) &&\n        !sourceCode.isSpaceBetweenTokens(token, nextToken)\n    ) {\n        context.report({\n            loc: token.loc.start,\n            messageId: \"expectedAfter\",\n            data: token,\n            fix(fixer) {\n                return fixer.insertTextAfter(token, \" \");\n            }\n        });\n    }\n    </checkSpacingAndReport>\n}\n"], ""]