[["calculatePosition", "\nfunction (horiz, pos, tickmarkOffset, old) {\n    var axis = this.axis,\n        chart = axis.chart,\n        cHeight = (old && chart.oldChartHeight) || chart.chartHeight;\n\n    return {\n        x: horiz ?\n            axis.translate(pos + tickmarkOffset, null, null, old) + axis.transB :\n            axis.left + axis.offset + (axis.opposite ? ((old && chart.oldChartWidth) || chart.chartWidth) - axis.right - axis.left : 0),\n\n        y: horiz ?\n            cHeight - axis.bottom + axis.offset - (axis.opposite ? axis.height : 0) :\n            cHeight - axis.translate(pos + tickmarkOffset, null, null, old) - axis.transB\n    };\n}\n"], ["createEntityActions", "\nfunction createCreateEntityActions(action, getState) {\n    <getActionData>\n    const dataPath = get(action, 'meta.dataPath');\n    const schema = get(action, 'meta.schema');\n    const skipNormalization = get(action, 'meta.skipNormalization');\n    const data = skipNormalization ? get(action, dataPath) : normalizeData(schema, get(action, dataPath));\n    </getActionData>\n  \n    <mapEntitiesToActions>\n    return Object.keys(data.entities)\n        .map((key) => ({ entities: data.entities[key], key }))\n        .reduce((memo, entitiesAndKey) => [...memo, ...extractEntities(entitiesAndKey)], [])\n        .map((entity) => ({ ...entity, oldEntity: getFromState(getState(), entity.key, entity.entity.id) }))\n        .sort(sortMainFirst(schema))\n        .map((payload) => {\n            if (payload.oldEntity) {\n                return {\n                    type: `@@entman/UPDATE_ENTITY_${payload.key.toUpperCase()}`,\n                    payload,\n                };\n            }\n            return {\n                type: `@@entman/CREATE_ENTITY_${payload.key.toUpperCase()}`,\n                payload,\n            };\n        });\n    </mapEntitiesToActions>\n}\n"], ["convertToDataString", "\nfunction(oData) {\n    if (!lang.isValue(oData)) {\n        return null;\n    }\n\n    var string = oData + \"\";\n\n    if (lang.isString(string)) {\n        return string;\n    } else {\n        YAHOO.log(\"Could not convert data \" + lang.dump(oData) + \" to type String\", \"warn\", this.toString());\n        return null;\n    }\n}\n"], ["isDataAllowed", "\nfunction(elem) {\n    var noData = elem.nodeName && jQuery.noData[elem.nodeName.toLowerCase()];\n\n    return !noData || noData !== true && elem.getAttribute(\"classid\") === noData;\n}\n"], ["hideLoading", "\nfunction () {\n    var options = this.options,\n        loadingDiv = this.loadingDiv;\n\n    if (loadingDiv) {\n        animate(loadingDiv, {\n            opacity: 0\n        }, {\n            duration: options.loading.hideDuration || 100,\n            complete: function () {\n                css(loadingDiv, {\n                    display: NONE\n                });\n            }\n        });\n    }\n    this.loadingShown = false;\n}\n"], ["createDocumentElement", "\nfunction create(type, nameOrValue) {\n    if (type == 9) {\n        return document.implementation.createDocument(null, null);\n    } else if (type == 10) {\n        return document.implementation.createDocumentType(...nameOrValue);\n    } else if (type == 11) {\n        return document.createDocumentFragment();\n    } else if ((0, _type.isBranch)(type)) {\n        <createElement>\n        const name = type == 1 ? nameOrValue : \"l3-\" + constructors[type];\n        var elem = document.createElement(name);\n        if (type == 14) elem.name = nameOrValue;\n        return elem;\n        </createElement>\n    } else if (type == 2) {\n        return document.createAttribute(nameOrValue);\n    } else if (type == 3) {\n        return document.createTextNode(nameOrValue);\n    } else if (type == 4) {\n        <createLinkElement>\n        const node = document.createElement(\"link\");\n        node.setAttribute(\"rel\", \"import\");\n        node.setAttribute(\"href\", nameOrValue);\n        return node;\n        </createLinkElement>\n    } else if (type == 7) {\n        return document.createProcessingInstruction(...nameOrValue);\n    } else if (type == 8) {\n        return document.createComment(nameOrValue);\n    }\n}\n"], ["formatBeautifyWarnings", "\nfunction beautifyWarnings(configFilePath, warnings) {\n    if (warnings.length === 0) {\n        return;\n    }\n    const intro = `\u26a0\ufe0f ts-config-webpack-plugin found ${warnings.length} warning${\n    warnings.length ? 's' : ''\n    } in \"${configFilePath}\".`;\n    return intro + '\\n' + warnings.map((warning) => 'Warning: \\n   ' + warning.split('\\n').join('\\n   ')).join('\\n\\n');\n}\n"], ["updateDocumentOptions", "\nfunction(options) {\n    var baseTag,\n        href;\n\n    <updateBaseUrl>\n    try {\n        if (!options.baseUrl && this.document && this.document.location) {\n            this.options.baseUrl = this.document.location.href;\n        }\n    } catch (e) {}\n    </updateBaseUrl>\n\n    <setBaseTag>\n    baseTag = modules.domUtils.querySelector(this.document, 'base');\n    if (baseTag) {\n        href = modules.domUtils.getAttribute(baseTag, 'href');\n        if (href) {\n            this.options.baseUrl = href;\n        }\n    }\n    </setBaseTag>\n\n    var path,\n        newDocument,\n        newRootNode;\n\n    <updateDocumentRoot>\n    path = modules.domUtils.getNodePath(this.rootNode);\n    newDocument = modules.domUtils.cloneDocument(this.document);\n    newRootNode = modules.domUtils.getNodeByPath(newDocument, path);\n    </updateDocumentRoot>\n\n    <setNewDocumentAndRoot>\n    if (newDocument && newRootNode) {\n        this.document = newDocument;\n        this.rootNode = newRootNode;\n    }\n    </setNewDocumentAndRoot>\n\n    <includeAdditions>\n    if (this.addIncludes) {\n        this.addIncludes(this.document);\n    }\n    </includeAdditions>\n\n    return (this.rootNode && this.document);\n}\n"], ["validatorHelper", "\nfunction(attrName) {\n    return function(err, validationErrMsg) {\n        ranCount++\n        if (returned) return\n\n        <handleError>\n        if (err) {\n            returned = true\n            return done(err)\n        }\n        </handleError>\n\n        <handleValidationError>\n        if (validationErrMsg) {\n            self._merge(validationErrors, validationErrMsg, (prefix || '') + '.' + attrName)\n            isValid = false\n        }\n        </handleValidationError>\n\n        if (ranCount === attrNames.length) _runAfter()\n    }\n}\n"], ["lexerNextToken", "\nfunction() {\n    if (this.done) {\n        return this.EOF;\n    }\n    if (!this._input) {\n        this.done = true;\n    }\n\n    var token,\n        match,\n        tempMatch,\n        index;\n    if (!this._more) {\n        this.yytext = '';\n        this.match = '';\n    }\n    var rules = this._currentRules();\n    for (var i = 0; i < rules.length; i++) {\n        tempMatch = this._input.match(this.rules[rules[i]]);\n        if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {\n            match = tempMatch;\n            index = i;\n            if (this.options.backtrack_lexer) {\n                <backtrackMatching>\n                token = this.test_match(tempMatch, rules[i]);\n                if (token !== false) {\n                    return token;\n                } else if (this._backtrack) {\n                    match = false;\n                    continue;\n                } else {\n                    return false;\n                }\n                </backtrackMatching>\n            } else if (!this.options.flex) {\n                break;\n            }\n        }\n    }\n    if (match) {\n        <testTokenMatch>\n        token = this.test_match(match, rules[index]);\n        if (token !== false) {\n            return token;\n        }\n        return false;\n        </testTokenMatch>\n    }\n    if (this._input === \"\") {\n        return this.EOF;\n    } else {\n        <reportLexicalError>\n        return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. Unrecognized text.\\n' + this.showPosition(), {\n            text: \"\",\n            token: null,\n            line: this.yylineno\n        });\n        </reportLexicalError>\n    }\n}\n"], "```"]