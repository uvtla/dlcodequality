[["Compiler", "\nfunction Compiler(handleImportCall) {\n  var self = this;\n  <initializeEventManager>\n  this.event = new EventManager();\n  </initializeEventManager>\n\n  <initializeProperties>\n  var compileJSON;\n  var worker = null;\n  var currentVersion;\n  var optimize = false;\n  var compilationStartTime = null;\n  </initializeProperties>\n\n  <setOptimize>\n  this.setOptimize = function (_optimize) {\n    optimize = _optimize;\n  };\n  </setOptimize>\n\n  <registerEventHandlers>\n  this.event.register('compilationFinished', (success, data, source) => {\n    if (success && compilationStartTime) {\n      this.event.trigger('compilationDuration', [(new Date().getTime()) - compilationStartTime]);\n    }\n    compilationStartTime = null;\n  });\n\n  this.event.register('compilationStarted', () => {\n    compilationStartTime = new Date().getTime();\n  });\n  </registerEventHandlers>\n\n  <internalCompile>\n  var internalCompile = function (files, target, missingInputs) {\n    gatherImports(files, target, missingInputs, function (error, input) {\n      if (error) {\n        self.lastCompilationResult = null;\n        self.event.trigger('compilationFinished', [false, { 'error': { formattedMessage: error, severity: 'error' } }, files]);\n      } else {\n        compileJSON(input, optimize ? 1 : 0);\n      }\n    });\n  };\n  </internalCompile>\n\n  <compileFunction>\n  var compile = function (files, target) {\n    self.event.trigger('compilationStarted', []);\n    internalCompile(files, target);\n  };\n  this.compile = compile;\n  </compileFunction>\n\n  <setCompileJSON>\n  function setCompileJSON(_compileJSON) {\n    compileJSON = _compileJSON;\n  }\n  this.setCompileJSON = setCompileJSON;\n  </setCompileJSON>\n\n  <onCompilerLoaded>\n  function onCompilerLoaded(version) {\n    currentVersion = version;\n    self.event.trigger('compilerLoaded', [version]);\n  }\n  </onCompilerLoaded>\n\n  <onInternalCompilerLoaded>\n  function onInternalCompilerLoaded() {\n    if (worker === null) {\n      var compiler;\n      var userAgent = (typeof (navigator) !== 'undefined') && navigator.userAgent ? navigator.userAgent.toLowerCase() : '-';\n      if (typeof (window) === 'undefined' || userAgent.indexOf(' electron/') > -1) {\n        compiler = require('@dexon-foundation/dsolc');\n      } else {\n        compiler = solc(window.Module);\n      }\n\n      <setCompileJSON>\n      compileJSON = function (source, optimize, cb) {\n        <compileAndProcessResult>\n        var missingInputs = [];\n        var missingInputsCallback = function (path) {\n          missingInputs.push(path);\n          return { error: 'Deferred import' };\n        };\n\n        var result;\n        try {\n          var input = compilerInput(source.sources, { optimize: optimize, target: source.target });\n          result = compiler.compile(input, missingInputsCallback);\n          result = JSON.parse(result);\n        } catch (exception) {\n          result = { error: { formattedMessage: 'Uncaught JavaScript exception:\\n' + exception, severity: 'error', mode: 'panic' } };\n        }\n\n        compilationFinished(result, missingInputs, source);\n        </compileAndProcessResult>\n      };\n      </setCompileJSON>\n\n      onCompilerLoaded(compiler.version());\n    }\n  }\n  this.onInternalCompilerLoaded = onInternalCompilerLoaded;\n  </onInternalCompilerLoaded>\n\n  <initializeLastCompilationResult>\n  this.lastCompilationResult = {\n    data: null,\n    source: null\n  };\n  </initializeLastCompilationResult>\n\n  <contractInteractionMethods>\n  this.getContract = (name) => {\n    if (this.lastCompilationResult.data && this.lastCompilationResult.data.contracts) {\n      return txHelper.getContract(name, this.lastCompilationResult.data.contracts);\n    }\n    return null;\n  };\n\n  this.visitContracts = (cb) => {\n    if (this.lastCompilationResult.data && this.lastCompilationResult.data.contracts) {\n      return txHelper.visitContracts(this.lastCompilationResult.data.contracts, cb);\n    }\n    return null;\n  };\n\n  this.getContracts = () => {\n    if (this.lastCompilationResult.data && this.lastCompilationResult.data.contracts) {\n      return this.lastCompilationResult.data.contracts;\n    }\n    return null;\n  };\n\n  this.getSources = () => {\n    if (this.lastCompilationResult.source) {\n      return this.lastCompilationResult.source.sources;\n    }\n    return null;\n  };\n\n  this.getSource = (fileName) => {\n    if (this.lastCompilationResult.source) {\n      return this.lastCompilationResult.source.sources[fileName];\n    }\n    return null;\n  };\n\n  this.getSourceName = (index) => {\n    if (this.lastCompilationResult.data && this.lastCompilationResult.data.sources) {\n      return Object.keys(this.lastCompilationResult.data.sources)[index];\n    }\n    return null;\n  };\n  </contractInteractionMethods>\n\n  <compilationFinished>\n  function compilationFinished(data, missingInputs, source) {\n    <checkForFatalErrors>\n    var noFatalErrors = true;\n\n    function isValidError(error) {\n      if (/Deferred import/.exec(error.message)) {\n        return false;\n      }\n\n      return error.severity !== 'warning';\n    }\n\n    if (data['error'] !== undefined) {\n      if (isValidError(data['error'])) {\n        noFatalErrors = false;\n      }\n    }\n    if (data['errors'] !== undefined) {\n      data['errors'].forEach(function (err) {\n        if (isValidError(err)) {\n          noFatalErrors = false;\n        }\n      });\n    }\n    </checkForFatalErrors>\n\n    <finishCompilation>\n    if (!noFatalErrors) {\n      self.lastCompilationResult = null;\n      self.event.trigger('compilationFinished', [false, data, source]);\n    } else if (missingInputs !== undefined && missingInputs.length > 0) {\n      internalCompile(source.sources, source.target, missingInputs);\n    } else {\n      data = updateInterface(data);\n\n      self.lastCompilationResult = {\n        data: data,\n        source: source\n      };\n      self.event.trigger('compilationFinished', [true, data, source]);\n    }\n    </finishCompilation>\n  }\n  </compilationFinished>\n\n  <loadVersion>\n  this.loadVersion = function (usingWorker, url) {\n    console.log('Loading ' + url + ' ' + (usingWorker ? 'with worker' : 'without worker'));\n    self.event.trigger('loadingCompiler', [url, usingWorker]);\n\n    if (usingWorker) {\n      loadWorker(url);\n    } else {\n      loadInternal(url);\n    }\n  };\n  </loadVersion>\n\n  <loadInternal>\n  function loadInternal(url) {\n    delete window.Module;\n\n    window.Module = undefined;\n\n    setCompileJSON(function (source, optimize) {\n      compilationFinished({ error: { formattedMessage: 'Compiler not yet loaded.' } });\n    });\n\n    var newScript = document.createElement('script');\n    newScript.type = 'text/javascript';\n    newScript.src = url;\n    document.getElementsByTagName('head')[0].appendChild(newScript);\n    var check = window.setInterval(function () {\n      if (!window.Module) {\n        return;\n      }\n      window.clearInterval(check);\n      onInternalCompilerLoaded();\n    }, 200);\n  }\n  </loadInternal>\n\n  <loadWorker>\n  function loadWorker(url) {\n    if (worker !== null) {\n      worker.terminate();\n    }\n    worker = webworkify(require('./compiler-worker.js'));\n    var jobs = [];\n    worker.addEventListener('message', function (msg) {\n      var data = msg.data;\n      switch (data.cmd) {\n        case 'versionLoaded':\n          onCompilerLoaded(data.data);\n          break;\n        case 'compiled':\n          var result;\n          try {\n            result = JSON.parse(data.data);\n          } catch (exception) {\n            result = { 'error': 'Invalid JSON output from the compiler: ' + exception };\n          }\n          var sources = {};\n          if (data.job in jobs !== undefined) {\n            sources = jobs[data.job].sources;\n            delete jobs[data.job];\n          }\n          compilationFinished(result, data.missingInputs, sources);\n          break;\n      }\n    });\n    worker.onerror = function (msg) {\n      compilationFinished({ error: 'Worker error: ' + msg.data });\n    };\n    worker.addEventListener('error', function (msg) {\n      compilationFinished({ error: 'Worker error: ' + msg.data });\n    });\n    compileJSON = function (source, optimize) {\n      jobs.push({ sources: source });\n      worker.postMessage({ cmd: 'compile', job: jobs.length - 1, input: compilerInput(source.sources, { optimize: optimize, target: source.target }) });\n    };\n    worker.postMessage({ cmd: 'loadVersion', data: url });\n  }\n  </loadWorker>\n\n  <gatherImports>\n  function gatherImports(files, target, importHints, cb) {\n    importHints = importHints || [];\n\n    var importRegex = /^\\s*import\\s*[\\'\\\"]([^\\'\\\"]+)[\\'\\\"];/g;\n\n    for (var fileName in files) {\n      var match;\n      while ((match = importRegex.exec(files[fileName].content))) {\n        var importFilePath = match[1];\n        if (importFilePath.startsWith('./')) {\n          var path = /(.*\\/).*/.exec(fileName);\n          if (path !== null) {\n            importFilePath = importFilePath.replace('./', path[1]);\n          } else {\n            importFilePath = importFilePath.slice(2);\n          }\n        }\n\n        if (importHints.indexOf(importFilePath) === -1) {\n          importHints.push(importFilePath);\n        }\n      }\n    }\n\n    while (importHints.length > 0) {\n      var m = importHints.pop();\n      if (m in files) {\n        continue;\n      }\n\n      if (handleImportCall) {\n        handleImportCall(m, function (err, content) {\n          if (err) {\n            cb(err);\n          } else {\n            files[m] = { content };\n            gatherImports(files, target, importHints, cb);\n          }\n        });\n      }\n\n      return;\n    }\n\n    cb(null, { 'sources': files, 'target': target });\n  }\n  </gatherImports>\n\n  <truncateVersion>\n  function truncateVersion(version) {\n    var tmp = /^(\\d+.\\d+.\\d+)/.exec(version);\n    if (tmp) {\n      return tmp[1];\n    }\n    return version;\n  }\n  </truncateVersion>\n\n  <updateInterface>\n  function updateInterface(data) {\n    txHelper.visitContracts(data.contracts, (contract) => {\n      data.contracts[contract.file][contract.name].abi = solcABI.update(truncateVersion(currentVersion), contract.object.abi);\n    });\n    return data;\n  }\n  </updateInterface>\n}\n"], ["assignDeep", "\nfunction (target, source) {\n  var assignDeep = target[canSymbol.for(\"can.assignDeep\")];\n  if (assignDeep) {\n    assignDeep.call(target, source);\n  } else if (typeReflections.isMoreListLikeThanMapLike(source)) {\n    shapeReflections.assignDeepList(target, source);\n  } else {\n    shapeReflections.assignDeepMap(target, source);\n  }\n  return target;\n}\n"], ["update", "\nfunction update(element, name, oldValue, newValue) {\n  if (!TRIGGER_LIFE_CYCLE_METHODS) {\n    return false;\n  }\n  element = DOM.getNodeComponent(element) || element;\n  if (element[DNA_SYMBOL]) {\n    let attrs = element.constructor.observedAttributes || [];\n    if (attrs.indexOf(name) !== -1) {\n      element[DOM.UPDATED].call(element, name, oldValue, newValue);\n      return true;\n    }\n  }\n  return false;\n}\n"], ["CruxAngularIndex", "\nfunction CruxAngularIndex(config, name) {\n  Interface.apply(this, arguments);\n  this.name = name + ':index';\n\n  <modifyConfig>\n  this.config.output = this.config.output.replace('$module', this.config.module).replace('$environment', global['NODE_ENV']);\n  this.config.path = this.__fullPath(this.config.path);\n  </modifyConfig>\n}\n"], ["dispatch", "\nfunction dispatch(provider, req, res, next, options, callback) {\n  \n  <strategyInitialization>\n  var baseStrategy = strategies[provider];\n  if (!baseStrategy) {\n    var cb = callback || next;\n    return cb(new Error(\n      'No strategy defined for provider \\'' +\n      provider + '\\''\n    ));\n  }\n\n  if (!callback && typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n\n  var strategy = Object.create(baseStrategy);\n  </strategyInitialization>\n\n  <strategyMethods>\n  strategy.success = function (user, info) {\n    req.user = user;\n    if (callback) {\n      callback(null, user, info);\n    } else {\n      next();\n    }\n  };\n\n  strategy.fail = function (info, status) {\n    if (callback) {\n      callback(null, null, info);\n    } else {\n      setUserOnRequest(req, res, next);\n    }\n  };\n\n  strategy.pass = function () {\n    next();\n  };\n\n  strategy.error = function (err) {\n    if (callback) {\n      callback(err);\n    } else {\n      next(err);\n    }\n  };\n\n  strategy.redirect = function (url, status) {\n    res.redirect(status || 302, url);\n  };\n  </strategyMethods>\n\n  <strategyAuthenticate>\n  strategy.authenticate(req, options);\n  </strategyAuthenticate>\n}\n"], ["getVariantTechnicalParameter", "\nfunction (oComponent) {\n  <retrieveTechnicalParameters>\n  var aTechnicalParameters = flUtils.getTechnicalParametersForComponent(oComponent);\n  return aTechnicalParameters\n    && aTechnicalParameters[VariantUtil.variantTechnicalParameterName]\n    && Array.isArray(aTechnicalParameters[VariantUtil.variantTechnicalParameterName])\n    && aTechnicalParameters[VariantUtil.variantTechnicalParameterName][0];\n  </retrieveTechnicalParameters>\n}\n"], ["ifTemplate", "\nfunction (context, node, args, container) {\n  var xpr = args[0],\n    index = args[1],\n    templ = args[2],\n    val = xpr.__interpolable__ ? xpr.output(context) : xpr,\n    rest = new Template(templ._queue.slice(index)),\n    instance;\n  if (val)\n    rest.toDOM(node, context, container);\n  else if (xpr.__interpolable__)\n    instance = xpr.subscribeTo(context, function (value, type, path) {\n      if (value) {\n        instance.destroy();\n        rest.toDOM(node, context, container);\n      }\n    });\n}\n"], ["LogStream", "\nfunction LogStream(connection, id) {\n  Readable.call(this, {\n    objectMode: true\n  });\n\n  <initializeProperties>\n  this.connection = connection;\n  this.stopped = false;\n  this._id = id;\n  </initializeProperties>\n\n  <bindEventHandlers>\n  this._bindedOnlog = this._onlog.bind(this);\n  connection._peer.on('stream', this._bindedOnlog);\n  connection.once('close', this._stop.bind(this));\n  </bindEventHandlers>\n}\n"], ["isPromiseRejectCall", "\nfunction isPromiseRejectCall(node) {\n  <identifyPromiseReject>\n  return node.callee.type === \"MemberExpression\" &&\n    node.callee.object.type === \"Identifier\" && node.callee.object.name === \"Promise\" &&\n    node.callee.property.type === \"Identifier\" && node.callee.property.name === \"reject\";\n  </identifyPromiseReject>\n}\n"], ["calculateElementPosition", "\nfunction (elem, offsetParent) {\n  var offset, parentOffset;\n\n  if (window.jQuery) {\n    if (!offsetParent) {\n      return window.jQuery(elem).position();\n    }\n\n    offset = window.jQuery(elem).offset();\n    parentOffset = window.jQuery(offsetParent).offset();\n\n    \n    return {\n      top: offset.top - parentOffset.top,\n      left: offset.left - parentOffset.left\n    };\n  }\n\n  parentOffset = { top: 0, left: 0 };\n\n  \n  if (window.getComputedStyle(elem).position === 'fixed') {\n    \n    offset = elem.getBoundingClientRect();\n  }\n  else {\n    if (!offsetParent) {\n      \n      offsetParent = position.offsetParent(elem);\n    }\n\n    \n    offset = offsetFunc(elem);\n    if (offsetParent.nodeName !== 'HTML') {\n      parentOffset = offsetFunc(offsetParent);\n    }\n\n    \n    parentOffset.top += parseInt(window.getComputedStyle(offsetParent).borderTopWidth, 10);\n    parentOffset.left += parseInt(window.getComputedStyle(offsetParent).borderLeftWidth, 10);\n  }\n\n  \n  return {\n    top: offset.top - parentOffset.top - parseInt(window.getComputedStyle(elem).marginTop, 10),\n    left: offset.left - parentOffset.left - parseInt(window.getComputedStyle(elem).marginLeft, 10)\n  };\n}\n"], ""]