[["applyToClient", "\nfunction applyToClient(client, method) {\n  <getMethod>\n  var _method = '_' + method\n  if (client[_method]) {\n  </getMethod>\n    <executeMethod>\n    var arr = client[_method] || []\n    while (arr.length) {\n      client[method].apply(client, arr.shift())\n    }\n    </executeMethod>\n    <cleanup>\n    delete client[_method]\n    </cleanup>\n  }\n}\n"], ["toBufferGeometry", "\nfunction toBufferGeometry(geometry, doBuffer) {\n  <checkDoBuffer>\n  if (!doBuffer) { return geometry; }\n  </checkDoBuffer>\n  \n  <createBufferGeometry>\n  var bufferGeometry = new THREE.BufferGeometry().fromGeometry(geometry);\n  bufferGeometry.metadata = {type: geometry.type, parameters: geometry.parameters || {}};\n  </createBufferGeometry>\n\n  <disposeOriginalGeometry>\n  geometry.dispose();\n  </disposeOriginalGeometry>\n  \n  return bufferGeometry;\n}\n"], ["detectPoseInRealTime", "\nfunction detectPoseInRealTime(video, net) {\n  <setupCanvas>\n  const canvas = document.getElementById('output');\n  const ctx = canvas.getContext('2d');\n  \n  const flipHorizontal = true;\n\n  canvas.width = videoWidth;\n  canvas.height = videoHeight;\n  </setupCanvas>\n\n  <poseDetectionFrame>\n  async function poseDetectionFrame() {\n    <handleArchitectureChange>\n    if (guiState.changeToArchitecture) {\n      guiState.net.dispose();\n      guiState.net = await posenet.load(+guiState.changeToArchitecture);\n      guiState.changeToArchitecture = null;\n    }\n    </handleArchitectureChange>\n\n    <startStats>\n    stats.begin();\n    </startStats>\n\n    <estimatePoses>\n    const imageScaleFactor = guiState.input.imageScaleFactor;\n    const outputStride = +guiState.input.outputStride;\n\n    let poses = [];\n    let minPoseConfidence;\n    let minPartConfidence;\n    switch (guiState.algorithm) {\n      case 'single-pose':\n        const pose = await guiState.net.estimateSinglePose(\n            video, imageScaleFactor, flipHorizontal, outputStride);\n        poses.push(pose);\n        minPoseConfidence = +guiState.singlePoseDetection.minPoseConfidence;\n        minPartConfidence = +guiState.singlePoseDetection.minPartConfidence;\n        break;\n      case 'multi-pose':\n        poses = await guiState.net.estimateMultiplePoses(\n            video, imageScaleFactor, flipHorizontal, outputStride,\n            guiState.multiPoseDetection.maxPoseDetections,\n            guiState.multiPoseDetection.minPartConfidence,\n            guiState.multiPoseDetection.nmsRadius);\n        minPoseConfidence = +guiState.multiPoseDetection.minPoseConfidence;\n        minPartConfidence = +guiState.multiPoseDetection.minPartConfidence;\n        break;\n    }\n    </estimatePoses>\n\n    <drawCanvas>\n    ctx.clearRect(0, 0, videoWidth, videoHeight);\n    </drawCanvas>\n\n    <showVideo>\n    if (guiState.output.showVideo) {\n      ctx.save();\n      ctx.scale(-1, 1);\n      ctx.translate(-videoWidth, 0);\n      ctx.drawImage(video, 0, 0, videoWidth, videoHeight);\n      ctx.restore();\n    }\n    </showVideo>\n\n    <drawPoses>\n    poses.forEach(({score, keypoints}) => {\n      if (score >= minPoseConfidence) {\n        if (guiState.output.showPoints) {\n          drawKeypoints(keypoints, minPartConfidence, ctx);\n        }\n        if (guiState.output.showSkeleton) {\n          drawSkeleton(keypoints, minPartConfidence, ctx);\n        }\n        if (guiState.output.showBoundingBox) {\n          drawBoundingBox(keypoints, ctx);\n        }\n      }\n    });\n    </drawPoses>\n\n    <endStats>\n    stats.end();\n    </endStats>\n\n    requestAnimationFrame(poseDetectionFrame);\n  }\n  </poseDetectionFrame>\n\n  poseDetectionFrame();\n}\n"], ["configureCarousel", "\nfunction configureCarousel(clip, attr) {\n            <initializeVariables>\n            var carousel = this,\n                config   = carousel.CONFIG,\n                cssClass = carousel.CLASSES,\n                isVertical,\n                rows,\n                cols,\n                size;\n            </initializeVariables>\n\n            <determineContext>\n            isVertical = carousel.get(\"isVertical\");\n            rows       = carousel._rows;\n            cols       = carousel._cols;\n            clip       = clip || carousel._clipEl;\n            attr       = attr || (isVertical ? \"height\" : \"width\");\n            size       = parseFloat(Dom.getStyle(clip, attr), 10);\n            size = JS.isNumber(size) ? size : 0;\n            </determineContext>\n\n            <calculateSize>\n            if (isVertical) {\n                size += getDimensions(carousel._carouselEl, \"height\") +\n                        getStyle(carousel._navEl, \"height\");\n            } else {\n                size += getDimensions(carousel._carouselEl, \"width\");\n            }\n            </calculateSize>\n\n            <applyMinWidth>\n            if (!isVertical) {\n                if (size < config.HORZ_MIN_WIDTH) {\n                    size = config.HORZ_MIN_WIDTH;\n                    carousel.addClass(cssClass.MIN_WIDTH);\n                }\n            }\n            </applyMinWidth>\n\n            <setStyle>\n            carousel.setStyle(attr,  size + \"px\");\n            </setStyle>\n\n            <setSizeForDimension>\n            if (isVertical) {\n                size = getCarouselItemSize.call(carousel, \"width\"); \n                if(cols) { \n                    size = size * cols; \n                }\n                Dom.setStyle(carousel._carouselEl, \"width\", size + \"px\");\n                if (size < config.VERT_MIN_WIDTH) {\n                    size = config.VERT_MIN_WIDTH;\n                    carousel.addClass(cssClass.MIN_WIDTH);\n                }\n                carousel.setStyle(\"width\",  size + \"px\");\n            } else {\n                if(rows) { \n                    size = getCarouselItemSize.call(carousel, \"height\");\n                    size = size * rows;\n                    Dom.setStyle(carousel._carouselEl, \"height\", size + \"px\");\n                }\n            }\n            </setSizeForDimension>\n}\n"], ["_unquoteArgs", "\nfunction _unquoteArgs(args) {\n  <unquoteArrayArguments>\n  for (var i = 0; i < args.length; i++) {\n    if (_isQuoted(args[i])) args[i] = _unquote(args[i]);\n  }\n  </unquoteArrayArguments>\n}\n"], ["SemanticPopupDisplay", "\nfunction SemanticPopupDisplay(SemanticPopupDisplayLink) {\n  <configuration>\n  return {\n    restrict: 'A',\n    scope: {\n      \n      smPopupDisplay: '@',\n      \n      smPopupDisplaySettings: '=',\n      smPopupDisplayOnInit: '=',\n      \n      smPopupDisplayOnCreate: '=',\n      smPopupDisplayOnRemove: '=',\n      smPopupDisplayOnShow: '=',\n      smPopupDisplayOnVisible: '=',\n      smPopupDisplayOnHide: '=',\n      smPopupDisplayOnHidden: '='\n    },\n    link: SemanticPopupDisplayLink\n  };\n  </configuration>\n}\n"], ["serviceCall", "\nfunction serviceCall(req, res, next) {\n  <registerPushDevice>\n  Q(pushService.registerPushDevice(req.body)).then(res.json.bind(res), next).done();\n  </registerPushDevice>\n}\n"], ["generateSetupToken", "\nfunction generateSetupToken(tokenPath) {\n  <createDirectory>\n  mkdirp.sync(path.dirname(tokenPath))\n  </createDirectory>\n\n  <generateToken>\n  var token = crypto.randomBytes(256).toString('hex')\n  </generateToken>\n  \n  <writeTokenToFile>\n  try {\n    fs.writeFileSync(tokenPath, token, 'utf8')\n  } catch (e) {\n    throw new Error('Unable to save setup token to ' + tokenPath)\n  }\n  </writeTokenToFile>\n  \n  return token\n}\n"], ["formatter", "\nfunction formatter(options) {\n  <composeLogLine>\n  const line = [\n    new Date().toISOString(),\n    options.level\n  ]\n  </composeLogLine>\n\n  <appendMessage>\n  if (options.message !== undefined) line.push(options.message)\n  </appendMessage>\n\n  <appendMeta>\n  if (options.meta && Object.keys(options.meta).length) line.push(JSON.stringify(options.meta))\n  </appendMeta>\n\n  return line.join(' ')\n}\n"], ["UNavLayoutTab", "\nfunction UNavLayoutTab(tab, tabs, panels, layout) {\n\n  <selectTab>\n  function selectTab() {\n    var href = tab.href.split('#')[1];\n    var panel = layout._content.querySelector('#' + href);\n    layout._resetTabState(tabs);\n    layout._resetPanelState(panels);\n    u.addClass(tab, layout._CssClasses.IS_ACTIVE);\n    u.addClass(panel, layout._CssClasses.IS_ACTIVE);\n  }\n  </selectTab>\n\n  <setupRippleEffect>\n  var rippleContainer = document.createElement('span');\n  u.addClass(rippleContainer, 'u-ripple');\n  tab.appendChild(rippleContainer);\n  new URipple(tab)\n  </setupRippleEffect>\n  \n  <bindClickEvent>\n  u.on(tab,'click', function (e) {\n    if (tab.getAttribute('href').charAt(0) === '#') {\n      e.preventDefault();\n      selectTab();\n    }\n  });\n\n  tab.show = selectTab;\n  </bindClickEvent>\n\n  <activateOnClick>\n  u.on(tab,'click', function (e) {\n    e.preventDefault();\n    var href = tab.href.split('#')[1];\n    var panel = layout._content.querySelector('#' + href);\n    layout._resetTabState(tabs);\n    layout._resetPanelState(panels);\n    u.addClass(tab, layout._CssClasses.IS_ACTIVE);\n    u.addClass(panel, layout._CssClasses.IS_ACTIVE);\n  });\n  </activateOnClick>\n}\n"], ""]