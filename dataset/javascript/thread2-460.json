[["getResolvedJsxType", "\nfunction getResolvedJsxType(node, elemType, elemClassType) {\n    <checkElemType>\n    if (!elemType) {\n        elemType = checkExpression(node.tagName);\n    }\n    </checkElemType>\n    <handleUnionType>\n    if (elemType.flags & 524288 ) {\n        var types = elemType.types;\n        return getUnionType(types.map(function (type) {\n            return getResolvedJsxType(node, type, elemClassType);\n        }),  true);\n    }\n    </handleUnionType>\n    \n    <handleDifferentJsxTypes>\n    if (elemType.flags & 2 ) {\n        return anyType;\n    }\n    else if (elemType.flags & 32 ) {\n        \n        <lookupIntrinsicElements>\n        var intrinsicElementsType = getJsxType(JsxNames.IntrinsicElements);\n        if (intrinsicElementsType !== unknownType) {\n            var stringLiteralTypeName = elemType.text;\n            var intrinsicProp = getPropertyOfType(intrinsicElementsType, stringLiteralTypeName);\n            if (intrinsicProp) {\n                return getTypeOfSymbol(intrinsicProp);\n            }\n            var indexSignatureType = getIndexTypeOfType(intrinsicElementsType, 0 );\n            if (indexSignatureType) {\n                return indexSignatureType;\n            }\n            error(node, ts.Diagnostics.Property_0_does_not_exist_on_type_1, stringLiteralTypeName, \"JSX.\" + JsxNames.IntrinsicElements);\n        }\n        </lookupIntrinsicElements>\n        \n        return anyType;\n    }\n    </handleDifferentJsxTypes>\n    \n    <analyzeElemInstanceType>\n    var elemInstanceType = getJsxElementInstanceType(node, elemType);\n    if (!elemClassType || !isTypeAssignableTo(elemInstanceType, elemClassType)) {\n        <handleJsxElementType>\n        if (jsxElementType) {\n            <getCallSignatures>\n            var callSignatures = elemType && getSignaturesOfType(elemType, 0 );\n            var callSignature = callSignatures && callSignatures.length > 0 && callSignatures[0];\n            var callReturnType = callSignature && getReturnTypeOfSignature(callSignature);\n            var paramType = callReturnType && (callSignature.parameters.length === 0 ? emptyObjectType : getTypeOfSymbol(callSignature.parameters[0]));\n            </getCallSignatures>\n            <checkCallReturnType>\n            if (callReturnType && isTypeAssignableTo(callReturnType, jsxElementType)) {\n                <mergeIntrinsicAttributes>\n                var intrinsicAttributes = getJsxType(JsxNames.IntrinsicAttributes);\n                if (intrinsicAttributes !== unknownType) {\n                    paramType = intersectTypes(intrinsicAttributes, paramType);\n                }\n                </mergeIntrinsicAttributes>\n                return paramType;\n            }\n            </checkCallReturnType>\n        }\n        </handleJsxElementType>\n    }\n    </analyzeElemInstanceType>\n    \n    <checkElemClassType>\n    if (elemClassType) {\n        checkTypeRelatedTo(elemInstanceType, elemClassType, assignableRelation, node, ts.Diagnostics.JSX_element_type_0_is_not_a_constructor_function_for_JSX_elements);\n    }\n    </checkElemClassType>\n    <handleIsTypeAny>\n    if (isTypeAny(elemInstanceType)) {\n        return elemInstanceType;\n    }\n    </handleIsTypeAny>\n    <getPropsName>\n    var propsName = getJsxElementPropertiesName();\n    if (propsName === undefined) {\n        return anyType;\n    }\n    else if (propsName === \"\") {\n        return elemInstanceType;\n    }\n    </getPropsName>\n    <handleAttributesType>\n    else {\n        var attributesType = getTypeOfPropertyOfType(elemInstanceType, propsName);\n        if (!attributesType) {\n            return emptyObjectType;\n        }\n        else if (isTypeAny(attributesType) || (attributesType === unknownType)) {\n            return attributesType;\n        }\n        else if (attributesType.flags & 524288 ) {\n            error(node.tagName, ts.Diagnostics.JSX_element_attributes_type_0_may_not_be_a_union_type, typeToString(attributesType));\n            return anyType;\n        }\n        else {\n            <intersectAttributesTypes>\n            var apparentAttributesType = attributesType;\n            var intrinsicClassAttribs = getJsxType(JsxNames.IntrinsicClassAttributes);\n            if (intrinsicClassAttribs !== unknownType) {\n                var typeParams = getLocalTypeParametersOfClassOrInterfaceOrTypeAlias(intrinsicClassAttribs.symbol);\n                if (typeParams) {\n                    if (typeParams.length === 1) {\n                        apparentAttributesType = intersectTypes(createTypeReference(intrinsicClassAttribs, [elemInstanceType]), apparentAttributesType);\n                    }\n                }\n                else {\n                    apparentAttributesType = intersectTypes(attributesType, intrinsicClassAttribs);\n                }\n            }\n            var intrinsicAttribs = getJsxType(JsxNames.IntrinsicAttributes);\n            if (intrinsicAttribs !== unknownType) {\n                apparentAttributesType = intersectTypes(intrinsicAttribs, apparentAttributesType);\n            }\n            </intersectAttributesTypes>\n            return apparentAttributesType;\n        }\n    }\n    </handleAttributesType>\n}\n"], ["addText", "\nfunction addText(value, nodes) {\n    <appendToExistingOrAddNewTextNode>\n    var tail\n    if (value) {\n        tail = nodes[nodes.length - 1]\n        if (tail && tail.type === 'text') {\n            tail.value += value\n        } else {\n            nodes.push(buildText(value))\n        }\n    }\n    </appendToExistingOrAddNewTextNode>\n    return nodes\n}\n"], ["anonymous", "\nfunction (tasks, callback) {\n    <setupAndValidation>\n    var keys; var length; var i; var results; var kind;\n    var updated_tasks = [];\n    var is_object;\n    var counter = 0;\n    if (isArray(tasks)) {\n        length = tasks.length;\n        results = [];\n    } else if (isObject(tasks)) {\n        is_object = true;\n        keys = ObjectKeys(tasks);\n        length = keys.length;\n        results = {};\n    } else {\n        return callback();\n    }\n    </setupAndValidation>\n\n    <preprocessTasks>\n    for (i=0; i<length; i++) {\n        if (is_object) {\n            updated_tasks.push({ k: keys[i], t: tasks[keys[i]] });\n        } else {\n            updated_tasks.push({ k: i, t: tasks[i] });\n        }\n    }\n    </preprocessTasks>\n\n    <executeTasks>\n    updated_tasks.forEach(function(task_object) {\n        task_object.t(function(err, result) {\n            if (err) return callback(err);\n            results[task_object.k] = result;\n            counter++;\n            if (counter == length) callback(null, results);\n        });\n    });\n    </executeTasks>\n}\n"], ["anonymous2", "\nfunction (subpath) {\n    <getValueToJSConversion>\n    var value = this.sub(subpath).get();\n    return Imm.Iterable.isIterable(value) ? value.toJS() : value;\n    </getValueToJSConversion>\n}\n"], ["anonymous3", "\nfunction (driver, response, remote, options, deferred) {\n    <emitDriverResponseEvent>\n    this.events.emit('driver:webdriver:response', {\n        statusCode: response.statusCode,\n        method: response.req.method,\n        path: response.req.path,\n        data: this.data\n    });\n    </emitDriverResponseEvent>\n    <handleRemoteResponse>\n    if (remote.onResponse) {\n        remote.onResponse.call(this, response, remote, options, deferred, this.data);\n    } else {\n        deferred.resolve(this.data);\n    }\n    </handleRemoteResponse>\n    return this;\n}\n"], ["mergeExtraSegments", "\nfunction mergeExtraSegments(context, segments) {\n    <mergeUntilContextCount>\n    while (segments.length > context.count) {\n        var merged = [];\n        for (var i = 0, length = segments.length / 2 | 0; i < length; ++i) {\n            merged.push(CodePathSegment.newNext(\n                context.idGenerator.next(), [segments[i], segments[i + length]]\n            ));\n        }\n        segments = merged;\n    }\n    </mergeUntilContextCount>\n    return segments;\n}\n"], ["copySamples", "\nfunction copySamples(result) {\n    <setupFilePaths>\n    var sampleDir = path.resolve(__dirname, \"..\", \"sample\");\n    var srcFiles = [\"style.css\", \"index.pug\", \"index.md\", \"second.md\"];\n    var targFiles = [\n        path.resolve(result.css, \"style.css\"),\n        path.resolve(result.template, \"index.pug\"),\n        path.resolve(result.data, \"index.md\"),\n        path.resolve(result.data, \"second.md\"),\n    ];\n    var proms = [];\n    </setupFilePaths>\n\n    <copyFilesAndReturnPromises>\n    for (var i = 0; i < srcFiles.length; i++)\n        proms.push(util.copy(path.resolve(sampleDir, srcFiles[i]), targFiles[i]));\n    </copyFilesAndReturnPromises>\n    \n    return q(proms);\n}\n"], ["placeholder", "\nfunction placeholder (model, name, spec) {\n    <handleSpecialPlaceholders>\n    if (spec.type === 'id' && model.binaryIds) {\n        return `UNHEX(:${name})`\n    }\n    else if (spec.type === 'data' && model.compression) {\n        return `FROM_BASE64(:${name})`\n    }\n    </handleSpecialPlaceholders>\n    else {\n        return `:${name}`\n    }\n}\n"], ["off", "\nfunction off(evt, handler) {\n    var _this2 = this;\n    var thisArg = arguments[2] === undefined ? null : arguments[2];\n\n    <handleEventHandlerRemoval>\n    if (eachEvt(evt, handler, thisArg, function () {\n        for (var _len3 = arguments.length, _ = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n            _[_key3] = arguments[_key3];\n        }\n        return _this2.off.apply(_this2, _);\n    })) {\n        return this;\n    }\n    </handleEventHandlerRemoval>\n    <removeAllEventHandlers>\n    if (evt === undefined && handler === undefined && thisArg === null) {\n        this[_eventHandlers] = new core.Map();\n        return this;\n    }\n    </removeAllEventHandlers>\n\n    <manageSpecificEventHandlers>\n    var eH = this[_eventHandlers];\n    if (handler === undefined && thisArg === null) {\n        eH.set(evt, new core.Map());\n        return this;\n    }\n    var objMap = eH.get(evt);\n    if (objMap !== undefined) {\n        if (typeof handler === \"object\") {\n            objMap[\"delete\"](handler);\n            return this;\n        }\n        var handlerSet = objMap.get(thisArg);\n        if (handlerSet !== undefined) {\n            handlerSet[\"delete\"](handler);\n            if (handlerSet.size === 0) {\n                eH[\"delete\"](objMap);\n            }\n        }\n    }\n    </manageSpecificEventHandlers>\n\n    return this;\n}\n"], ["initializationForWMIC", "\nfunction (options) {\n    this.isWindows = process.platform === 'win32';\n    <setOptions>\n    this.options = options || {};\n    this.host = this.options.host || (this.isWindows ? '127.0.0.1' : null);\n    var user = getUsername(this.options.username);\n    this.username = user.username;\n    this.domain = user.domain;\n    this.password = this.options.password;\n    this.namespace = this.options.namespace || '\\\\\\\\root\\\\cimv2';\n    this.timeout = this.options.timeout || 90000;\n    this.delimiter = '^@^';\n    this.wmic = this.options.wmic || 'wmic';\n    this.isNeedNTLM2 = this.options.ntlm2 || false;\n    </setOptions>\n    <processCwdSetting>\n    this.cwd = this.options.cwd || path.join(__dirname, '..');\n    </processCwdSetting>\n    <parserOptionsSetting>\n    this.parserOptions = {\n        delimiter: this.delimiter,\n        trim: true,\n        auto_parse: true\n    };\n    </parserOptionsSetting>\n    \n    return this;\n}\n"], "```"]