[["getContainerNode", "\nfunction (start) {\n        var container, parent, sibling, siblingName, root;\n\n        <initializeVariables>\n        container = parent = start ? startContainer : endContainer;\n        siblingName = start ? 'previousSibling' : 'nextSibling';\n        root = dom.getRoot();\n        </initializeVariables>\n\n        <checkTextNodeNotWhitespace>\n        if (container.nodeType === 3 && !isWhiteSpaceNode(container)) {\n          if (start ? startOffset > 0 : endOffset < container.nodeValue.length) {\n            return container;\n          }\n        }\n        </checkTextNodeNotWhitespace>\n\n        <traverseDOM>\n        while (true) {\n          <checkBlockExpandAndIsBlock>\n          if (!format[0].block_expand && dom.isBlock(parent)) {\n            return parent;\n          }\n          </checkBlockExpandAndIsBlock>\n\n          <findValidSibling>\n          for (sibling = parent[siblingName]; sibling; sibling = sibling[siblingName]) {\n            if (!isBookmarkNode(sibling) && !isWhiteSpaceNode(sibling) && !isBogusBr(sibling)) {\n              return parent;\n            }\n          }\n          </findValidSibling>\n\n          <checkParentRootRelation>\n          if (parent === root || parent.parentNode === root) {\n            container = parent;\n            break;\n          }\n          </checkParentRootRelation>\n\n          parent = parent.parentNode;\n        }\n        </traverseDOM>\n\n        return container;\n      }\n"], ["validateStreamEventRecord", "\nfunction _validateStreamEventRecord(record) {\n  <validateRecordIsObject>\n  if (!record || typeof record !== 'object') {\n    throw new Error(`Invalid stream event record (${record}) - record must be a non-null object`);\n  }\n  </validateRecordIsObject>\n  <checkRequiredFields>\n  if (!record.eventID) {\n    throw new Error(`Missing eventID property for stream event record (${record.eventID})`);\n  }\n  if (!record.eventSourceARN) {\n    throw new Error(`Missing eventSourceARN property for stream event record (${record.eventID})`);\n  }\n  if (!record.eventSource) {\n    throw new Error(`Missing eventSource property for stream event record (${record.eventID})`);\n  }\n  if (!record.eventName) {\n    throw new Error(`Missing eventName property for stream event record (${record.eventID})`);\n  }\n  </checkRequiredFields>\n}\n"], ["chartRedraw", "\nfunction (animation) {\n            <getChartComponents>\n            var chart = this,\n              axes = chart.axes,\n              series = chart.series,\n              pointer = chart.pointer,\n              legend = chart.legend,\n              redrawLegend = chart.isDirtyLegend,\n              hasStackedSeries,\n              hasDirtyStacks,\n              hasCartesianSeries = chart.hasCartesianSeries,\n              isDirtyBox = chart.isDirtyBox, \n              seriesLength = series.length,\n              i = seriesLength,\n              serie,\n              renderer = chart.renderer,\n              isHiddenChart = renderer.isHidden(),\n              afterRedraw = [];\n            </getChartComponents>\n\n            <configureAnimation>\n            setAnimation(animation, chart);\n            </configureAnimation>\n\n            <handleHiddenChart>\n            if (isHiddenChart) {\n                chart.cloneRenderTo();\n            }\n            </handleHiddenChart>\n\n            <layoutChartTitles>\n            chart.layOutTitles();\n            </layoutChartTitles>\n\n            <markDirtyStacksAndSeries>\n            while (i--) {\n                serie = series[i];\n\n                <checkSeriesStackingAndDirtyStatus>\n                if (serie.options.stacking) {\n                    hasStackedSeries = true;\n\n                    if (serie.isDirty) {\n                        hasDirtyStacks = true;\n                        break;\n                    }\n                }\n                </checkSeriesStackingAndDirtyStatus>\n            }\n            if (hasDirtyStacks) { \n                i = seriesLength;\n                while (i--) {\n                    serie = series[i];\n                    <markStackingSeriesDirty>\n                    if (serie.options.stacking) {\n                        serie.isDirty = true;\n                    }\n                    </markStackingSeriesDirty>\n                }\n            }\n            </markDirtyStacksAndSeries>\n\n            <updateLegendAndRedraw>\n            each(series, function (serie) {\n                <checkSeriesDirtyForLegend>\n                if (serie.isDirty) {\n                    if (serie.options.legendType === 'point') {\n                        redrawLegend = true;\n                    }\n                }\n                </checkSeriesDirtyForLegend>\n            });\n\n            <redrawLegendIfNecessary>\n            if (redrawLegend && legend.options.enabled) {\n                <renderLegend>\n                legend.render();\n                </renderLegend>\n\n                chart.isDirtyLegend = false;\n            }\n            </redrawLegendIfNecessary>\n            </updateLegendAndRedraw>\n\n            <handleStackedSeries>\n            if (hasStackedSeries) {\n                chart.getStacks();\n            }\n            </handleStackedSeries>\n\n\n            <handleCartesianSeries>\n            if (hasCartesianSeries) {\n                <handleResizing>\n                if (!chart.isResizing) {\n                    <resetMaxTicks>\n                    chart.maxTicks = null;\n                    </resetMaxTicks>\n\n                    <setScaleOnAxes>\n                    each(axes, function (axis) {\n                        axis.setScale();\n                    });\n                    </setScaleOnAxes>\n                }\n                </handleResizing>\n\n                chart.adjustTickAmounts();\n            }\n\n            chart.getMargins();\n            </handleCartesianSeries>\n\n            <redrawAxesAndHandleExtremes>\n            if (hasCartesianSeries) {\n                <checkAxesDirtyStatusAndUpdate>\n                each(axes, function (axis) {\n                    if (axis.isDirty) {\n                        isDirtyBox = true;\n                    }\n                });\n\n                <handleAxisExtremes>\n                each(axes, function (axis) {\n                    <checkAxisDirtyExtremes>\n                    if (axis.isDirtyExtremes) {\n                        axis.isDirtyExtremes = false;\n                        afterRedraw.push(function () {\n                            fireEvent(axis, 'afterSetExtremes', extend(axis.eventArgs, axis.getExtremes()));\n                            delete axis.eventArgs;\n                        });\n                    }\n                    </checkAxisDirtyExtremes>\n\n                    <redrawAxisIfNecessary>\n                    if (isDirtyBox || hasStackedSeries) {\n                        axis.redraw();\n                    }\n                    </redrawAxisIfNecessary>\n                });\n                </handleAxisExtremes>\n                </checkAxesDirtyStatusAndUpdate>\n            }\n            </redrawAxesAndHandleExtremes>\n\n            <drawChartBoxIfDirty>\n            if (isDirtyBox) {\n                chart.drawChartBox();\n            }\n            </drawChartBoxIfDirty>\n\n            <redrawDirtySeries>\n            each(series, function (serie) {\n                <checkSeriesDirtyAndVisible>\n                if (serie.isDirty && serie.visible &&\n                  (!serie.isCartesian || serie.xAxis)) {\n                    serie.redraw();\n                }\n                </checkSeriesDirtyAndVisible>\n            });\n            </redrawDirtySeries>\n\n            <resetPointer>\n            if (pointer) {\n                pointer.reset(true);\n            }\n            </resetPointer>\n\n            <drawRenderer>\n            renderer.draw();\n            </drawRenderer>\n\n            <fireRedrawEvent>\n            fireEvent(chart, 'redraw');\n            </fireRedrawEvent>\n\n            <handleHiddenChartPostRedraw>\n            if (isHiddenChart) {\n                chart.cloneRenderTo(true);\n            }\n            </handleHiddenChartPostRedraw>\n\n            <callAfterRedrawCallbacks>\n            each(afterRedraw, function (callback) {\n                callback.call();\n            });\n            </callAfterRedrawCallbacks>\n        }\n"], ["ErrorMessage", "\nfunction ErrorMessage() {\n  <initializeErrorMessage>\n  this.eventTime = (new Date()).toISOString();\n  this.serviceContext = {service : 'node', version : undefined};\n  this.message = '';\n  this.context = {\n    httpRequest : {\n      method : '',\n      url : '',\n      userAgent : '',\n      referrer : '',\n      responseStatusCode : 0,\n      remoteIp : ''\n    },\n    user : '',\n    reportLocation : {filePath : '', lineNumber : 0, functionName : ''}\n  };\n  </initializeErrorMessage>\n}\n"], ["getValue", "\nfunction getValue($el) {\n    <deriveValueBasedOnElementType>\n    return $el.is('[type=\"checkbox\"]') ? $el.prop('checked')                                     :\n           $el.is('[type=\"radio\"]')    ? !!$('[name=\"' + $el.attr('name') + '\"]:checked').length :\n           $el.is('select[multiple]')  ? ($el.val() || []).length                                :\n                                         $el.val()\n    </deriveValueBasedOnElementType>\n  }\n"], ["runHTMLTaskStream", "\nfunction runHTMLTaskStream(gulp, s, config, startFun, endFun) {    \n    <resolvePaths>\n    var destPath = path.resolve(config.root, config.dest || '');\n    var jsDestPath = path.resolve(destPath, config.jsDest || ''); \n    var cssDestPath = path.resolve(destPath, config.cssDest || ''); \n    var htmlDestPath = path.resolve(destPath, config.htmlDest || ''); \n    var fileDestPath = path.resolve(destPath, config.fileDest || ''); \n    </resolvePaths>\n\n    <determineDestination>\n    if(s.__dest) {\n        var dest = s.__dest;\n    }\n    else {\n        var dest = path.resolve(destPath, config.htmlDest || '', s.dest || '');\n    }\n    </determineDestination>\n\n    <createGulpStream>\n    var stream = gulp.src(s.source || s, {cwd:config.root, base: s.base || ''});\n    </createGulpStream>\n    <invokeStartFunction>\n    if(startFun && typeof startFun == 'function') {\n        stream = startFun(stream, s);\n     }\n     </invokeStartFunction>\n\n     <pipeStreamToDestination>\n     stream = stream.pipe(gulp.dest(dest));\n     </pipeStreamToDestination>\n\n     <parseAndPipeStream>\n     stream = stream.pipe(parse.parse({\n            \"type\": 'html',\n            \"debug\": config.debug,\n            \"root\": config.root,\n            \"dest\": dest,\n            \"destPath\": destPath,\n            \"jsDestPath\": jsDestPath,\n            \"cssDestPath\": cssDestPath,\n            \"htmlDestPath\": htmlDestPath,\n            \"fileDestPath\": fileDestPath,\n            \"urlMaps\": config.urlMaps || [],\n            \"config\": s\n        })).pipe(gulp.dest(dest));\n     </parseAndPipeStream>\n\n     <handleRenameAndEndFunction>\n     if(s.rename) {\n        stream = stream.pipe(rename(s.rename));\n     }\n     if(endFun && typeof endFun == 'function') {\n        stream = endFun(stream, s);\n     }\n     </handleRenameAndEndFunction>\n     <finalPipeToDestination>\n     return stream.pipe(gulp.dest(dest));\n     </finalPipeToDestination>\n}\n"], ["inverseHelper", "\nfunction(expr, options) {\n    <swapFnAndInverse>\n    var fn = options.fn;\n    options.fn = options.inverse;\n    options.inverse = fn;\n    </swapFnAndInverse>\n    <applyInverseHelper>\n    return Mustache._helpers['if'].fn.apply(this, arguments);\n    </applyInverseHelper>\n}\n"], ["traverseObject", "\nfunction traverse(obj) {\n      <eachObjectPropOrIndex>\n      each(obj, (val, indexOrProp) => {\n        <getNextValue>\n        const next = obj[indexOrProp];\n        </getNextValue>\n\n        <recurseOrFilterArray>\n        if (MongoObject.isBasicObject(next)) {\n          traverse(next);\n        } else if (Array.isArray(next)) {\n          obj[indexOrProp] = without(next, REMOVED_MARKER);\n          traverse(obj[indexOrProp]);\n        }\n        </recurseOrFilterArray>\n      });\n      </eachObjectPropOrIndex>\n    }\n"], ["RingBuffer", "\nfunction RingBuffer(maxSize){\n    <initializeRingBuffer>\n    var data = [];\n    var cursor = 0;\n    var isFull = false;\n    </initializeRingBuffer>\n    <appendData>\n    this.append = function(x){\n        if (isFull){\n            data[cursor] = x;\n            cursor = (cursor + 1) % maxSize;\n        }\n        else{\n            data.push(x);\n            cursor++;\n            if (data.length === maxSize){\n                cursor = 0;\n                isFull = true;\n            }\n        }\n    };\n    </appendData>\n    <calculateAverage>\n    this.avg = function(){\n        var sum = data.reduce(function(a, b){ return a + b });\n        return sum / (isFull ? maxSize : cursor);\n    };\n    </calculateAverage>\n    <getSize>\n    this.size = function(){\n        return isFull ? maxSize : cursor;\n    };\n    </getSize>\n    <clearData>\n    this.clear = function(){\n        data = [];\n        cursor = 0;\n        isFull = false;\n    };\n    </clearData>\n}\n"], ["setElementPosition", "\nfunction(item) {\n    <checkValidItem>\n    if(!item || (item && !item.element) || (item && !item.position))\n        return;\n    </checkValidItem>\n\n    <classifyElementByPosition>\n    switch(item.position) {\n        case 'left':\n            <addClassTimelineMeLeft>\n            item.element\n            .removeClass('timeline-me-top')\n            .removeClass('timeline-me-right')\n            .removeClass('timeline-me-bottom')\n            .addClass('timeline-me-left');\n            </addClassTimelineMeLeft>\n            break;\n        case 'top':\n            <addClassTimelineMeTop>\n            item.element\n            .removeClass('timeline-me-left')\n            .removeClass('timeline-me-right')\n            .removeClass('timeline-me-bottom')\n            .addClass('timeline-me-top');\n            </addClassTimelineMeTop>\n            break;\n        case 'right':\n            <addClassTimelineMeRight>\n            item.element\n            .removeClass('timeline-me-top')\n            .removeClass('timeline-me-left')\n            .removeClass('timeline-me-bottom')\n            .addClass('timeline-me-right');\n            </addClassTimelineMeRight>\n            break;\n        case 'bottom':\n            <addClassTimelineMeBottom>\n            item.element\n            .removeClass('timeline-me-top')\n            .removeClass('timeline-me-right')\n            .removeClass('timeline-me-left')\n            .addClass('timeline-me-bottom');\n            </addClassTimelineMeBottom>\n            break;\n    }\n    </classifyElementByPosition>\n\n    return item;\n}\n"], "```\n\nEach function is annotated with the primary responsibility it holds and additional tags for subsidiary responsibilities where separate self-contained functionalities are realized. These annotations help maintain a clear structure for analysis of SRP principle compliance or violations."]