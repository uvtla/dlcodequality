[["parseVariableIdentifier", "\nfunction parseVariableIdentifier() {\n    var token, startToken;\n\n    <startTokenAssignment>\n    startToken = lookahead;\n    </startTokenAssignment>\n\n    <tokenAssignment>\n    token = lex();\n    </tokenAssignment>\n\n    <tokenTypeCheck>\n    if (token.type !== Token.Identifier) {\n        throwUnexpected(token);\n    }\n    </tokenTypeCheck>\n\n    <delegateOperation>\n    return delegate.markEnd(delegate.createIdentifier(token.value), startToken);\n    </delegateOperation>\n}\n"], ["unknownFunctionDurationSettings", "\nfunction (duration, settings) {\n    <swingRatioCalculation>\n    var ratio = settings && settings.swingRatio ? settings.swingRatio : 1;\n    </swingRatioCalculation>\n\n    <durationCalculation>\n    return Math.round(ticksPerBeat * duration.value(ratio));\n    </durationCalculation>\n}\n"], ["parseValidationString", "\nfunction(validationString) {\n    var validationParameters, validationMethod;\n\n    <validationStringCheck>\n    if (!validationString.contains(\":\")) {\n        return [validationString];\n    }\n    </validationStringCheck>\n\n    <splitValidationString>\n    validationParameters = validationString.split(\":\");\n    </splitValidationString>\n\n    <extractValidationMethod>\n    validationMethod = validationParameters.shift();\n    </extractValidationMethod>\n\n    <prepareParameters>\n    return [validationMethod, this.prepareParameters(validationParameters)];\n    </prepareParameters>\n}\n"], ["makeChange", "\nfunction makeChange(doc, change, selUpdate, ignoreReadOnly) {\n    <cmOperations>\n    if (doc.cm) {\n      if (!doc.cm.curOp) return operation(doc.cm, makeChange)(doc, change, selUpdate, ignoreReadOnly);\n      if (doc.cm.state.suppressEdits) return;\n    }\n    </cmOperations>\n\n    <beforeChangeHandlers>\n    if (hasHandler(doc, \"beforeChange\") || doc.cm && hasHandler(doc.cm, \"beforeChange\")) {\n        change = filterChange(doc, change);\n        if (!change) return;\n    }\n    </beforeChangeHandlers>\n\n    <readOnlyHandling>\n    var split = sawReadOnlySpans && !ignoreReadOnly && removeReadOnlyRanges(doc, change.from, change.to);\n    if (split) {\n      for (var i = split.length - 1; i >= 1; --i)\n        makeChangeNoReadonly(doc, {from: split[i].from, to: split[i].to, text: [\"\"]});\n      if (split.length)\n        makeChangeNoReadonly(doc, {from: split[0].from, to: split[0].to, text: change.text}, selUpdate);\n    } else {\n      makeChangeNoReadonly(doc, change, selUpdate);\n    }\n    </readOnlyHandling>\n}\n"], ["getListenersGlobal", "\nfunction(el, recurse, type) {\n    <querySelectorSetup>\n    var oEl = (Y.Lang.isString(el)) ?  Y.Selector.query(el, null, true) : el,\n        lis = this.getListeners(oEl, type), i, len, props, children, child;\n    </querySelectorSetup>\n\n    <recursiveListenerExtraction>\n    if (recurse && oEl) {\n        lis = lis || [];\n        children = Y.Selector.query('*', oEl);\n        i = 0;\n        len = children.length;\n        for (; i < len; ++i) {\n            child = this.getListeners(children[i], type);\n            if (child) {\n                lis = lis.concat(child);\n            }\n        }\n    }\n    </recursiveListenerExtraction>\n\n    <detachAndRemoveListeners>\n    if (lis) {\n        i = 0;\n        len = lis.length;\n        for (; i < len; ++i) {\n            props = lis[i];\n            props.detachAll();\n            remove(props.el, props.type, props.fn, props.capture);\n            delete _wrappers[props.key];\n            delete _el_events[props.domkey][props.key];\n        }\n    }\n    </detachAndRemoveListeners>\n}\n"], ["initSubject", "\nfunction init(subject) {  \n    <subjectMasterCheck>\n    if (subject.master) {\n        throw O.log.error(subject, 'Duplicit `subject.master`', {master: subject.master._lid});\n    }\n    </subjectMasterCheck>\n\n    <subjectMasterInit>\n    this.subject = subject;\n    subject.master = this;\n    </subjectMasterInit>\n\n    <onGwCallbackSetup>\n    this.subject.getGw(onGw.bind(null, subject));\n    </onGwCallbackSetup>\n}\n"], ["checkPackageJson", "\nfunction checkPackageJson () {\n    <requirePackageJson>\n    const pkg = requireFresh(path.join(project, 'package.json'));\n    </requirePackageJson>\n\n    <packageExpectations>\n    expect(pkg.name).toEqual(appId);\n    expect(pkg.displayName).toEqual(appName);\n    expect(pkg.version).toEqual(appVersion);\n    </packageExpectations>\n}\n"], ["anonymousEventHandlers", "\nfunction () {\n    <domElementSetup>\n    var dom = this.domElement;\n    </domElementSetup>\n\n    <addEventListenerTouchstart>\n    vendor.addEventListener(dom, 'touchstart', this._mouseDownHandler);\n    </addEventListenerTouchstart>\n\n    <addEventListenerMousedownWheel>\n    vendor.addEventListener(dom, 'mousedown', this._mouseDownHandler);\n    vendor.addEventListener(dom, 'wheel', this._mouseWheelHandler);\n    </addEventListenerMousedownWheel>\n\n    <timelineUpdateHandling>\n    if (this.timeline) {\n        this.timeline.on('frame', this.update, this);\n    }\n    </timelineUpdateHandling>\n\n    <decomposeTransformIfTarget>\n    if (this.target) {\n        this.decomposeTransform();\n    }\n    </decomposeTransformIfTarget>\n}\n"], ["PackageDependents", "\nfunction PackageDependents(name, version, callback) {\n    <versionCallbackCheck>\n    if (typeof version === \"function\") {\n        callback = version\n        version = \"latest\"\n    }\n    </versionCallbackCheck>\n\n    <GetDependentsCallback>\n    GetDependents(name, function(err, packages) {\n        if (err) { return callback(err) }\n        SameTime(packages.map(function (c) {\n            return function (fn) {\n                <PackageJsonPromise>\n                PackageJson(c, version).then(function (json) {\n                    fn(null, json)\n                }).catch(function (err) {\n                    fn(err)\n                })\n                </PackageJsonPromise>\n            }\n        }), function (err, packages) {\n            callback(err, packages || [])\n        })\n    })\n    </GetDependentsCallback>\n}\n"], ["accumulateTwoPhaseDispatchesSingle", "\nfunction accumulateTwoPhaseDispatchesSingle(event) {\n    <traverseTwoPhase>\n    if (event && event.dispatchConfig.phasedRegistrationNames) {\n        EventPluginUtils.traverseTwoPhase(event._targetInst, accumulateDirectionalDispatches, event);\n    }\n    </traverseTwoPhase>\n}\n"], "```"]