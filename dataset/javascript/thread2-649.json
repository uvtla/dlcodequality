[["function", "\nfunction(value) {\n    <updateValues>\n    this.lastValue = this.currentValue;\n    this.currentValue = value;\n    this.setter.call(this.target, this.target, value, this);\n    </updateValues>\n}\n"], ["function", "\nfunction(object, property, options) {\n\n    <initializeOptionsController>\n    OptionController.superclass.call(this, object, property);\n\n    var _this = this;\n    \n    this.__select = document.createElement('select');\n    </initializeOptionsController>\n\n    <populateSelectOptions>\n    if (common.isArray(options)) {\n      var map = {};\n      common.each(options, function(element) {\n        map[element] = element;\n      });\n      options = map;\n    }\n\n    common.each(options, function(value, key) {\n\n      var opt = document.createElement('option');\n      opt.innerHTML = key;\n      opt.setAttribute('value', value);\n      _this.__select.appendChild(opt);\n\n    });\n    </populateSelectOptions>\n\n    <bindChangeEventListenerAndUpdateDisplay>\n    this.updateDisplay();\n\n    dom.bind(this.__select, 'change', function() {\n      var desiredValue = this.options[this.selectedIndex].value;\n      _this.setValue(desiredValue);\n    });\n\n    this.domElement.appendChild(this.__select);\n    </bindChangeEventListenerAndUpdateDisplay>\n}\n"], ["updateBoundsPos", "\nfunction updateBoundsPos(newX, newY) {\n    <calculateNewBoundsPosition>\n    var bounds = this.getBounds();\n    bounds.pos.set(newX - this.anchorPoint.x * bounds.width, newY - this.anchorPoint.y * bounds.height); \n\n    if (this.ancestor instanceof me.Container && !this.floating) {\n      bounds.pos.add(this.ancestor._absPos);\n    }\n    </calculateNewBoundsPosition>\n\n    return bounds;\n}\n"], ["setMapAttributeValue", "\nfunction(attr, value, keepKey) {\n                    \n    var parts = can.Map.helpers.attrParts(attr, keepKey),\n                        \n    prop = parts.shift(),\n                        \n    current = this._init ? undefined : this.__get(prop);\n\n    if (parts.length && Map.helpers.isObservable(current)) {\n        \n        current._set(parts, value);\n    } else if (!parts.length) {\n        \n        if (this.__convert) {\n            \n            value = this.__convert(prop, value);\n        }\n        <setTypeAndSetAttributeValue>\n        this.__set(prop, this.__type(value, prop), current);\n        </setTypeAndSetAttributeValue>\n    } else {\n        throw \"can.Map: Object does not exist\";\n    }\n}\n"], ["renderVectorPath", "\nfunction(node, geometry) {\n    <setNodeDimensions>\n    this.setNodeDimension(node, geometry);\n    </setNodeDimensions>\n\n    <assemblePath>\n    var resolution = this.getResolution();\n    \n    var path = [];\n    var j, jj, points, area, first, second, i, ii, comp, pathComp, x, y;\n    for (j=0, jj=geometry.components.length; j<jj; j++) {\n        path.push(\"m\");\n        points = geometry.components[j].components;\n        \n        area = (j === 0);\n        first = null;\n        second = null;\n        for (i=0, ii=points.length; i<ii; i++) {\n            comp = points[i];\n            x = ((comp.x - this.featureDx) / resolution - this.offset.x) | 0;\n            y = (comp.y / resolution - this.offset.y) | 0;\n            pathComp = \" \" + x + \",\" + y;\n            path.push(pathComp);\n            if (i==0) {\n                path.push(\" l\");\n            }\n            if (!area) {\n                if (!first) {\n                    first = pathComp;\n                } else if (first != pathComp) {\n                    if (!second) {\n                        second = pathComp;\n                    } else if (second != pathComp) {\n                        area = true;\n                    }\n                }\n            }\n        }\n        path.push(area ? \" x \" : \" \");\n    }\n    path.push(\"e\");\n    node.path = path.join(\"\");\n    </assemblePath>\n    return node;\n}\n"], ["handleDotClick", "\nfunction handleDotClick(originalEvent, target) {\n    if (this.isMoving) {\n        return;\n    }\n    \n    <updateCarouselState>\n    const { state: { config, itemsPerSlide } } = this;\n    const slide = parseInt(target.getAttribute('data-slide'), 10);\n    config.preserveItems = true;\n    this.setState('index', slide * itemsPerSlide);\n    emitAndFire(this, 'carousel-slide', { slide: slide + 1, originalEvent });\n    </updateCarouselState>\n}\n"], ["validateVarName", "\nfunction validateVarName(regex, name, strict) {\n\n    if (strict) {\n        <checkStrictReservedNames>\n        if (name === 'eval') { return false; }\n        if (name === 'arguments') { return false; }\n        </checkStrictReservedNames>\n    }\n\n    <performRegexValidation>\n    var result = regex.test(name);\n    result = result && validateCommonReservedWords(name);\n    return result;\n    </performRegexValidation>\n}\n"], ["getExtensionException", "\nfunction(exceptionName)\n{\n    var app = this;\n    var exception = {};\n\n    <fetchOrCreateException>\n    try\n    {\n        if(app.exceptions.hasOwnProperty(exceptionName)){\n            exception = app.exceptions[exceptionName];\n        }else{                \n            throw \"not found\";\n        }\n    }\n    catch(e)\n    {\n        var objFilePath = path.join(app._path,\"exceptions\",exceptionName);\n        if(fs.existsSync(objFilePath+\".js\"))\n        {\n            var exceptionConfig = require(objFilePath);\n            if(typeof app.exceptions != \"object\") app.exceptions={};\n            app.exceptions[exceptionName]= exceptionConfig;                    \n            exception = exceptionConfig;\n        }\n    }\n    </fetchOrCreateException>\n\n    return exception;\n}\n"], ["SimpleCache", "\nfunction SimpleCache(options) {\n    var self = this;\n\n    options = options || {};\n\n    this.expireAfterSeconds = parseFloat(options.expireAfterSeconds || 0);\n    this._keyValueStore = {};\n\n    <configureExpirationCleanup>\n    if (this.expireAfterSeconds > 0) {\n        setInterval(function () {\n            Object.keys(self._keyValueStore).forEach(function (key) {\n                self.get(key).catch(function () {});\n            });\n\n            if (options.logger) {\n                options.logger.info('SimpleCache periodic cleanup after %s seconds', self.expireAfterSeconds);\n            }\n        }, this.expireAfterSeconds * 1000);\n    }\n    </configureExpirationCleanup>\n}\n"], ["setOnCommandHandle", "\nfunction (fn) {\n    if (!fn || !_.isFunction(fn)) {\n        <validateFunction>\n        var err = new Error('Please pass a valid function!');\n        debug(err);\n        throw err;\n        </validateFunction>\n    }\n\n    <wrapSingleArgumentFunction>\n    if (fn.length === 1) {\n      fn = _.wrap(fn, function(func, cmd, callback) {\n        func(cmd);\n        callback(null);\n      });\n    }\n    </wrapSingleArgumentFunction>\n\n    <assignOnCommandHandle>\n    this.onCommandHandle = fn;\n    </assignOnCommandHandle>\n\n    return this;\n}\n"], ""]