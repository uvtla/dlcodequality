[["subPubArg", "\nfunction subPubArg (topic, data, i) {\n      <subscribeToTopic>\n      var spy = sub(topic);</subscribeToTopic>\n      <publishToTopic>\n      pub(topic, data);</publishToTopic>\n\n      <processSpyCall>\n      var args = spy.calls.first().args;</processSpyCall>\n      return typeof i === 'undefined' ? args : args[i];\n}\n"], ["_fireReadFileCallbacks", "\nfunction _fireReadFileCallbacks(filename, data, error=false) {\n  <retrieveCallbacks>\n  const callbacks = readFileCallbacks.get(filename);</retrieveCallbacks>\n  if (callbacks) {\n    <invokeCallbacks>\n    if (callbacks.size) callbacks.forEach(callback=>error?callback(data, null):callback(null, data));</invokeCallbacks>\n    <cleanupCallbacks>\n    callbacks.clear();\n    readFileCallbacks.delete(filename);</cleanupCallbacks>\n  }\n}\n"], ["parseIframeQueryString", "\nfunction(iframe) {\n            <extractInformationFromIframe>\n            var doc = iframe.contentDocument || iframe.contentWindow.document,\n                queryString = doc.location.search,\n                match = /bucket=(.+)&key=(.+)&etag=(.+)/.exec(queryString);</extractInformationFromIframe>\n\n            if (match) {\n                return {\n                    bucket: match[1],\n                    key: match[2],\n                    etag: match[3].replace(/%22/g, \"\")\n                };\n            }\n}\n"], ["syncNpmrc", "\nfunction syncNpmrc(sourceNpmrcFolder, targetNpmrcFolder) {\n    <establishPaths>\n    const sourceNpmrcPath = path.join(sourceNpmrcFolder, '.npmrc');\n    const targetNpmrcPath = path.join(targetNpmrcFolder, '.npmrc');</establishPaths>\n    try {\n        <readSourceNpmrc>\n        if (fs.existsSync(sourceNpmrcPath)) {\n            let npmrcFileLines = fs.readFileSync(sourceNpmrcPath).toString().split('\\n');\n            npmrcFileLines = npmrcFileLines.map((line) => (line || '').trim());</readSourceNpmrc>\n            <processNpmrcFile>\n            const resultLines = [];\n            \n            <replaceEnvironmentVariables>\n            for (const line of npmrcFileLines) {\n                <matchEnvironmentVariables>\n                const regex = /\\$\\{([^\\}]+)\\}/g;\n                const environmentVariables = line.match(regex);\n                let lineShouldBeTrimmed = false;</matchEnvironmentVariables>\n                if (environmentVariables) {\n                    for (const token of environmentVariables) {\n                        <extractVariableNameAndCheck>\n                        const environmentVariableName = token.substring(2, token.length - 1);\n                        if (!process.env[environmentVariableName]) {\n                            lineShouldBeTrimmed = true;\n                            break;\n                        }</extractVariableNameAndCheck>\n                    }\n                }\n                if (lineShouldBeTrimmed) {\n                    <annotateMissingVariable>\n                    resultLines.push('; MISSING ENVIRONMENT VARIABLE: ' + line);</annotateMissingVariable>\n                }\n                else {\n                    resultLines.push(line);\n                }\n            }</replaceEnvironmentVariables></processNpmrcFile>\n            <writeTargetNpmrc>\n            fs.writeFileSync(targetNpmrcPath, resultLines.join(os.EOL));</writeTargetNpmrc>\n        </readSourceNpmrc>\n        <deleteTargetNpmrc>\n        else if (fs.existsSync(targetNpmrcPath)) {\n            fs.unlinkSync(targetNpmrcPath);\n        }</deleteTargetNpmrc>\n    }\n    catch (e) {\n        throw new Error(`Error syncing .npmrc file: ${e}`);\n    }\n}\n"], ["makeRequest", "\nfunction makeRequest(target) {\n    <transferRequestHeaders>\n    var headers = Object.keys(req.headers)\n      .reduce(function (all, key) {\n        all[key] = req.headers[key];\n        return all;\n      }, {});</transferRequestHeaders>\n\n    <resetTargetHostHeader>\n    headers.host = target.host;</resetTargetHostHeader>\n\n    <logRequest>\n    self.log.info('[merge] %s - %s %s %s %j', address, req.method, req.url, target.host, req.headers);</logRequest>\n    return hyperquest({\n      url:     url_.resolve(target.href, url),\n      method:  method,\n      headers: headers\n    });\n}\n"], ["handle", "\nasync function handle(sofar) {\n    try {\n        <authenticateUser>\n        if (!sofar.socket.user) {\n            if (sofar.msg.oemInfo.openkey == sofar.facade.options.admin.role[sofar.msg.oemInfo.openid]) {\n                sofar.socket.user = { domain: \"system\", stype: sofar.msg.stype, sid: sofar.msg.sid, socket: sofar.socket };\n            }\n        }\n        if (!sofar.socket.user) {\n            sofar.fn({ code: facade.const.ReturnCode.userIllegal });\n            sofar.recy = false;\n        }</authenticateUser>\n    }\n    catch (e) {\n        <handleError>\n        sofar.fn({ code: facade.const.ReturnCode.illegalData });\n        sofar.recy = false;</handleError>\n    }\n}\n"], ["clearDatabase", "\nfunction clearDatabase(tx, resultSet) {\n    <executeSqlDelete>\n    var sql = \"delete from clicks\"\n    tx.executeSql(sql, null, null, sqlError);</executeSqlDelete>\n}\n"], ["replaceLambdaVariables", "\nfunction replaceLambdaVariables(sPath, mLambdaVariableToPath) {\n\t\t\t<modifyPathSegments>\n\t\t\tvar aSegments = sPath.split(\"/\");\n\n\t\t\taSegments[0] = mLambdaVariableToPath[aSegments[0]];</modifyPathSegments>\n\t\t\treturn aSegments[0] ? aSegments.join(\"/\") : sPath;\n}\n"], ["prepareItem", "\nfunction prepareItem ( item, cleanUrls ) {\n\t<retrieveUrl>\n\tconst promise = cleanUrls ? got.head(item.url) : Promise.resolve({ url: item.url });</retrieveUrl>\n\treturn promise\n\t\t.then(( res ) => {\n\t\t\t<resolveUrl>\n\t\t\treturn res.url;</resolveUrl>\n\t\t}, () => {\n\t\t\t<useOriginalUrl>\n\t\t\treturn item.url;</useOriginalUrl>\n\t\t})\n\t\t.then(( url ) => {\n\t\t\t<formatItem>\n\t\t\treturn {\n\t\t\t\turl: cleanUrls ? stripMobileUrl(url) : url,\n\t\t\t\tdescription: item.title,\n\t\t\t\ttoread: 'yes'\n\t\t\t};</formatItem>\n\t\t});\n}\n"], ["handleFocusLoss", "\nfunction (domEvt) {\n            if (this._hasMouseOver === false && this._hasFocus === true) {\n                <removeFocus>\n                this._hasFocus = false;</removeFocus>\n                if (this._ellipsis) {\n                    <hideFullText>\n                    this._ellipsis._hideFullText(domEvt.relatedTarget);</hideFullText>\n                }\n            }\n}\n"], ""]