[["function", "\nfunction() {\n  var me = this;\n  var labels = me.getLabels();\n  me.minIndex = 0;\n  me.maxIndex = labels.length - 1;\n  var findIndex;\n  <setMinIndex>\n  if (me.options.ticks.min !== undefined) {\n    findIndex = helpers.indexOf(labels, me.options.ticks.min);\n    me.minIndex = findIndex !== -1 ? findIndex : me.minIndex;\n  }\n  </setMinIndex>\n  <setMaxIndex>\n  if (me.options.ticks.max !== undefined) {\n    findIndex = helpers.indexOf(labels, me.options.ticks.max);\n    me.maxIndex = findIndex !== -1 ? findIndex : me.maxIndex;\n  }\n  </setMaxIndex>\n  me.min = labels[me.minIndex];\n  me.max = labels[me.maxIndex];\n}\n"], ["reactRedata", "\nfunction reactRedata(loader, shouldReload, mapper) {\n  return _redataComponent2.default.bind(null, _redata2.default.bind(null, loader, shouldReload, mapper));\n}\n"], ["parseAll", "\nfunction parseAll(text) {\n  var urls = url_regex;\n  var emails = email_regex;\n  var hashTags = hashtag_regex;\n  text = text ? String(text).replace(/<[^>]+>/gm, '') : '';\n  <parseURLs>\n  if (text.match(urls)) {\n    text = text.replace(urls, \"<a href=\\\"$1\\\" target=\\\"_blank\\\">$1</a>\");\n  }\n  </parseURLs>\n  <parseEmails>\n  if (text.match(emails)) {\n    text = text.replace(emails, \"<a href=\\\"mailto:$1\\\">$1</a>\");\n  }\n  </parseEmails>\n  <parseHashtags>\n  if (text.match(hashTags)) {\n    text = text.replace(hashTags, \"<a href=\\\"javascript:;\\\" target=\\\"_blank\\\">$1</a>\");\n  }\n  </parseHashtags>\n  return text.replace(/\\n\\r?/g, '<br />');\n}\n"], ["stringifyArray", "\nfunction stringifyArray(arr, prefix) {\n  var ret = [];\n  if (!prefix) throw new TypeError('stringify expects an object');\n  for (var i = 0; i < arr.length; i++) {\n    ret.push(stringify(arr[i], prefix + '[]'));\n  }\n  return ret.join('&');\n}\n"], ["function", "\nfunction(name, value) {\n  <checkCondition>\n  if (Lava.schema.DEBUG && name == 'id') Lava.t();\n  if (Lava.schema.DEBUG && (name in this._property_bindings)) {\n    Lava.t(\"Property is bound to an argument and cannot be set directly: \" + name);\n  }\n  </checkCondition>\n  this._static_properties[name] = value;\n}\n"], ["wrap_sync", "\nfunction wrap_sync(fn) {\n  return function (params) {\n    var val = fn(params);\n    <checkIfNotPromise>\n    if (val && !isPromise(val)) throw val;\n    </checkIfNotPromise>\n    return val;\n  };\n}\n"], ["repeatTheNumber", "\nfunction repeatTheNumber(digit) {\n  return interval(inner).pipe(\n    take(digit),\n    map(() => \" \" + fruitCharacter[digit] + \" \"),\n    endWith(\" \u2705\\n\"),\n    tap(digit => {\n      append(digit)\n    })\n  )\n}\n"], ["function", "\nfunction() {\n  var evt = this.evt, detached = 0, i;\n  <detachEvents>\n  if (evt) {\n    if (Y.Lang.isArray(evt)) {\n      for (i = 0; i < evt.length; i++) {\n        detached += evt[i].detach();\n      }\n    } else { \n      evt._delete(this.sub);\n      detached = 1;\n    }\n  }\n  </detachEvents>\n  return detached;\n}\n"], ["unshift", "\nfunction unshift(arr) {\n  var items = [];\n  for (var _i = 1; _i < arguments.length; _i++) {\n    items[_i - 1] = arguments[_i];\n  }\n  <concatFlatten>\n  arr = arr.concat(flatten(items));\n  </concatFlatten>\n  return {\n    array: arr,\n    val: arr.length\n  };\n}\n"], ["function", "\nfunction() {\n  var OPERATORS = [\n    [Blockly.Msg.CONTROLS_FLOW_STATEMENTS_OPERATOR_BREAK, 'BREAK'],\n    [Blockly.Msg.CONTROLS_FLOW_STATEMENTS_OPERATOR_CONTINUE, 'CONTINUE']\n  ];\n  this.setHelpUrl(Blockly.Msg.CONTROLS_FLOW_STATEMENTS_HELPURL);\n  this.setColour(Blockly.Blocks.loops.HUE);\n  this.appendDummyInput()\n    .appendField(new Blockly.FieldDropdown(OPERATORS), 'FLOW');\n  this.setPreviousStatement(true);\n\n  var thisBlock = this;\n  <setTooltip>\n  this.setTooltip(function() {\n    var op = thisBlock.getFieldValue('FLOW');\n    var TOOLTIPS = {\n      'BREAK': Blockly.Msg.CONTROLS_FLOW_STATEMENTS_TOOLTIP_BREAK,\n      'CONTINUE': Blockly.Msg.CONTROLS_FLOW_STATEMENTS_TOOLTIP_CONTINUE\n    };\n    return TOOLTIPS[op];\n  });\n  </setTooltip>\n}\n"], ""]