[["validateAndHashProp", "\nfunction(prop) {\n    <updateHash>\n    cons.updateHash(prop)\n    </updateHash>\n\n    <validateMandatoryFields>\n    var fieldSig = _.prod(\n      _.map(cons.mandatoryFields, function(field) {\n        return _.has(prop, field) && !_.isUndefined(prop[field]) && !_.isNull(prop[field]) ? true : false;\n      }))\n    if (!fieldSig) throw new Error(\"Node constraints violated: incomplete mandatoryFields.\")\n    </validateMandatoryFields>\n\n    return true;\n}\n"], ["parseStream", "\nfunction parse (stream, options = {}) {\n  <setupParsing>\n  const Promise = promise(options)\n  try {\n    check.assert.maybe.function(options.reviver, 'Invalid reviver option')\n  } catch (err) {\n    return Promise.reject(err)\n  }\n  </setupParsing>\n\n  <initialization>\n  const errors = []\n  const scopes = []\n  const reviver = options.reviver\n  const shouldHandleNdjson = !!options.ndjson\n  let emitter, resolve, reject, scopeKey\n  </initialization>\n\n  <handleNdjson>\n  if (shouldHandleNdjson && NDJSON_STATE.has(stream)) {\n    const state = NDJSON_STATE.get(stream)\n    NDJSON_STATE.delete(stream)\n    emitter = state.emitter\n    setImmediate(state.resume)\n  } else {\n    emitter = walk(stream, options)\n  }\n  </handleNdjson>\n\n  <registerEventListeners>\n  [... multiple event listener registrations here ...]\n\n  return new Promise((res, rej) => {\n    resolve = res\n    reject = rej\n  })\n  </registerEventListeners>\n\n  [... helper functions for parsing here ...]\n}\n"], ["getShareData", "\nfunction getShareData(terria) {\n  const initSources = terria.initSources.slice();\n\n  <collectInitSources>\n  addUserAddedCatalog(terria, initSources);\n  addSharedMembers(terria, initSources);\n  addViewSettings(terria, initSources);\n  addFeaturePicking(terria, initSources);\n  addLocationMarker(terria, initSources);\n  </collectInitSources>\n\n  return {\n    version: \"0.0.05\",\n    initSources: initSources\n  };\n}\n"], ["envEval", "\nfunction envEval(state, script, data, frame) {\n  try {\n    <pushFrame>\n    state.stack.push(frame.replace(/\\s+/g, ' '));\n    </pushFrame>\n\n    <determineEvaluationType>\n    if (/^[_a-zA-Z0-9.]*$/.test(script)) {\n      return property(state, script, data);\n    } else {\n      </determineEvaluationType>\n      \n      <checkAllowEval>\n      if (!state.options.allowEval) {\n        handleError(state, 'allowEval is not set, however \\'' + script + '\\'' +\n            ' can not be resolved using a simple property path.');\n        return '${' + script + '}';\n      }\n      </checkAllowEval>\n\n      <prepareForEvaluation>\n      var keys = allKeys(data);\n      var func = Function.apply(null, keys.concat(\"return \" + script));\n      var values = keys.map(function(key) { return data[key]; });\n      </prepareForEvaluation>\n\n      <executeDynamicScript>\n      return func.apply(null, values);\n      </executeDynamicScript>\n      \n    }\n  }\n  catch (ex) {\n    <handleError>\n    handleError(state, 'Template error evaluating \\'' + script + '\\'', ex);\n    return '${' + script + '}';\n    </handleError>\n  }\n  finally {\n    <popFrame>\n    state.stack.pop();\n    </popFrame>\n  }\n}\n"], ["backgroundFunction", "\nfunction background(options) {\n    options = options || {};\n    \n    return function (config) {\n        var values = [];\n        \n        <accumulateBackgroundProperties>\n        [\n            'attachment',\n            'clip',\n            'color',\n            'image',\n            'origin',\n            'position',\n            'repeat',\n            'size'\n        ].forEach(function (prop) {\n            if (options.hasOwnProperty(prop)) {\n                values.push(options[prop]);\n            }\n        });\n        </accumulateBackgroundProperties>\n        \n        if (values.length) {\n            <generateBackgroundStyle>\n            return [['background', values.join(' ')]];\n            </generateBackgroundStyle>\n        }\n        return [];\n    };\n}\n"], ["convertJdToDate", "\nfunction(jd) {\n        var date = gregorianCalendar.fromJD(jd);\n        \n        <convertGregorianToLunar>\n        var lunar = toLunar(date.year(), date.month(), date.day());\n        </convertGregorianToLunar>\n        \n        <calculateMonthIndex>\n        var monthIndex = this.toMonthIndex(\n            lunar.year, lunar.month, lunar.isIntercalary);\n        </calculateMonthIndex>\n        \n        return this.newDate(lunar.year, monthIndex, lunar.day);\n    }\n"], ["addCommentToText", "\nfunction addComment( text, multiline ) {\n          if ( options.extractComments ) {\n              <captureCommentDetails>\n              const loc = location();\n              comments[ loc.start.offset ] = {\n                  text: text,\n                  multiline: multiline,\n                  location: loc,\n              };\n              </captureCommentDetails>\n          }\n          return text;\n      }\n"], ["rendererInitialization", "\nfunction renderer(parent, config){\n    this.parent = ( ( \"string\" == typeof parent )\n\t\t    ? document.getElementById(parent)\n\t\t    : parent );\n    if (this.parent === undefined) {\n        throw \"can't find parent element \" + parent;\n    }\n    \n    this.tree = new tree();\n    this.node_hidden = {};\n    this.children_hidden = {};\n    this._sort = \"ladderize_up\";\n    this._layout_dirty = true;\n    this._css_prefix = \"phylo_tree_\" + (id_counter++) + \"_\";\n\n    var self = this;\n    this.node_elem_click_handler = function(event) {\n        var node_elem = (event.currentTarget) ? event.currentTarget : event.srcElement;\n        var node = self.tree.nodes[node_elem.node_id];\n        if (node) return self.node_clicked(node, node_elem, event);\n    };\n\n    var default_config = {\n        ... default configuration values ...\n    };\n\n    this.config = (\"object\" == typeof config\n                   ? bbop.core.merge(default_config, config)\n                   : default_config);\n\n    <additionalConfig>\n    this.config.parent_padding = ( (this.config.parent_padding === undefined)\n                                   ? ((this.config.box_spacing / 2) | 0)\n                                   : this.config.parent_padding );\n\n    this.node_style = { ... styles for node ... };\n    this.leaf_style = { ... styles for leaf ... };\n    if (this.config.leaf_border > 0) {\n        this.leaf_style.border = this.config.leaf_border + \"px solid \" + this.config.leaf_border_color;\n    }\n    this.connection_style = { ... styles for connection ... };\n    </additionalConfig>\n}\n"], ["MongoStoreInitialization", "\nfunction MongoStore(options) {\n                if (typeof options === \"undefined\") { options = {}; }\n                <callSuper>\n                _super.call(this);\n                </callSuper>\n                this._logger = shared.utils.defaultLogger();\n                \n                <setupStore>\n                this._collection = null;\n                this._pending = [];\n                this._root = null;\n                this._cache = new shared.mtx.ObjectCache();\n                this._host = options.host || 'localhost';\n                this._port = options.port || 27017;\n                this._dbName = options.db || 'shared';\n                this._collectionName = options.collection || 'shared';\n                this._safe = options.safe || 'false';\n                </setupStore>\n                \n                <debugStoreCreation>\n                this._logger.debug('STORE', '%s: Store created', this.id());\n                </debugStoreCreation>\n            }\n"], ["unbindEventFromFunction", "\nfunction unbindToFunction(target, entity, evt, method){\n      <stopListening>\n      target.stopListening(entity, evt, method, target);\n      </stopListening>\n}\n"], "```\n\nEach function has been annotated with tags to identify distinct responsibilities, compliant or not compliant with the Single Responsibility Principle (SRP). In some of the functions, nested tags indicate different responsibilities within the function that may represent a violation of SRP."]