[["createIndexes", "\nfunction createIndexes(coll, indexSpecs, options, callback) {\n  <checkCapabilities>\n  const capabilities = coll.s.topology.capabilities();\n\n  \n  for (let i = 0; i < indexSpecs.length; i++) {\n    <buildIndexSpec>\n    if (indexSpecs[i].name == null) {\n      const keys = [];\n\n      \n      <checkCollationSupport>\n      if (indexSpecs[i].collation && capabilities && !capabilities.commandsTakeCollation) {\n        return callback(new MongoError('server/primary/mongos does not support collation'));\n      }</checkCollationSupport>\n\n      <generateIndexName>\n      for (let name in indexSpecs[i].key) {\n        keys.push(`${name}_${indexSpecs[i].key[name]}`);\n      }\n\n      \n      indexSpecs[i].name = keys.join('_');\n    }</generateIndexName>\n  }</buildIndexSpec>\n\n  <setDefaultReadPreference>\n  options = Object.assign({}, options, { readPreference: ReadPreference.PRIMARY });\n  </setDefaultReadPreference>\n\n  \n  <executeIndexCommand>\n  executeCommand(\n    coll.s.db,\n    {\n      createIndexes: coll.s.name,\n      indexes: indexSpecs\n    },\n    options,\n    callback\n  );\n  </executeIndexCommand>\n}\n"], ["loadNextDomain", "\nfunction(n) {\n\t\t\"use strict\";\n\n\t\t<checkDomainLimit>\n\t\tif (this._maxDomainReached || n === 0) {\n\t\t\treturn false;\n\t\t}\n\t\t</checkDomainLimit>\n\n\t\t<loadNewDomainAndAdjustBound>\n\t\tvar bound = this.loadNewDomains(this.NAVIGATE_RIGHT, this.getDomain(this.getNextDomain(), n));\n\t\t</loadNewDomainAndAdjustBound>\n\n\t\t<postLoadActions>\n\t\tthis.afterLoadNextDomain(bound.end);\n\t\tthis.checkIfMaxDomainIsReached(this.getNextDomain().getTime(), bound.start);\n\t\t</postLoadActions>\n\n\t\treturn true;\n\t}\n"], ["loadConfiguration", "\nfunction(config, environment) {\n  \n  <initialConfigSetup>\n  if (config == null)\n    config = process.cwd() + (windows ? '\\\\' : '/');\n  </initialConfigSetup>\n\n  <processConfigParameter>\n  if (typeof config == 'string') {\n    <checkIfConfigIsDirectory>\n    var isDir = (!windows && config.substr(config.length - 1, 1) == '/') || (windows && config.substr(config.length - 1, 1) == '\\\\');\n    </checkIfConfigIsDirectory>\n\n    <setDefaultAppDir>\n    defaultConfig.appDir = isDir ? path.resolve(config) : path.dirname(path.resolve(config));\n    defaultConfig.require.server.paths['$'] = defaultConfig.appDir;\n    </setDefaultAppDir>\n\n    \n    <loadConfigFromFile>\n    if (isDir && fs.existsSync(path.resolve(config, 'zest.cson')) || config.substr(config.length - 4, 4) == 'cson')\n      return loadConfig(getCSONConfigFile(isDir ? path.resolve(config, 'zest.cson') : path.resolve(config)), environment);\n    \n    else\n      return loadConfig(getJSONConfigFile(isDir ? path.resolve(config, 'zest.json') : path.resolve(config)), environment);\n    </loadConfigFromFile>\n  }\n  </processConfigParameter>\n\n  <ensureConfigurationNotAlreadySet>\n  if (setConfig)\n    throw 'Configuration has already been set. Start a new server instance for alternative configuration.';\n  setConfig = true;\n  </ensureConfigurationNotAlreadySet>\n  \n  <deepPrependConfiguration>\n  function deepPrepend(a, b) {\n    for (var p in b) {\n      if (b[p] instanceof Array) {\n        a[p] = a[p] || [];\n        a[p] = b[p].concat(a[p]);\n      }\n      else if (typeof b[p] == 'object' && b[p] !== null && a[p] !== null) {\n        a[p] = a[p] || {};\n        deepPrepend(a[p], b[p]);\n      }\n      else if (a[p] === undefined)\n        a[p] = b[p];\n    }\n  }\n  \n  deepPrepend(config, defaultConfig);\n  </deepPrependConfiguration>\n\n  <prepareOutConfig>\n  var outConfig = config.environments[environment || config.environment];\n  </prepareOutConfig>\n\n  <validateOutConfig>\n  if (typeof outConfig == 'undefined')\n    throw 'No configuration provided for environment \"' + environment + '\".';\n  </validateOutConfig>\n\n  <cleanupOutConfig>\n  delete config.environments;\n  </cleanupOutConfig>\n\n  <mergeConfiguration>\n  deepPrepend(outConfig, config);\n  </mergeConfiguration>\n\n  <setupRequireConfig>\n  var requireConfig = {\n    server: outConfig.require.server,\n    client: outConfig.require.client,\n    build: outConfig.require.build\n  };\n  delete outConfig.require.server;\n  delete outConfig.require.client;\n  delete outConfig.require.build;\n  \n  deepPrepend(requireConfig.server, outConfig.require);\n  deepPrepend(requireConfig.client, outConfig.require);\n  deepPrepend(requireConfig.build, outConfig.require);\n  \n  outConfig.require = requireConfig;\n  </setupRequireConfig>\n\n  <setBaseUrls>\n  outConfig.require.server.baseUrl = path.resolve(outConfig.appDir, outConfig.publicDir, outConfig.baseDir);\n  outConfig.require.client.baseUrl = '/' + outConfig.baseDir;\n  </setBaseUrls>\n\n  <setTypeAttribute>\n  if (outConfig.typeAttribute && outConfig.typeAttribute != 'component') {\n    var clientConfig = (outConfig.require.client.config = outConfig.require.client.config || {});\n    clientConfig['zest/render'] = clientConfig['zest/render'] || {};\n    clientConfig['zest/render'].typeAttribute = outConfig.typeAttribute;\n  }\n  </setTypeAttribute>\n  \n  return outConfig;\n}\n"], ["Director", "\nfunction Director () {\n    <checkForExistingInstance>\n    if (Director._instance) {\n        throw new Error('Director instance already exists')\n    }\n    </checkForExistingInstance>\n\n    <initialSetup>\n    this.sceneStack = []\n    this.window   = parent.window\n    this.document = this.window.document\n    </initialSetup>\n\n    <makePropertiesReadonly>\n    util.makeReadonly(this, 'canvas context sceneStack winSize isReady document window container isTouchScreen isMobile'.w)\n    </makePropertiesReadonly>\n}\n"], ["createTransactionResponse", "\nfunction createTransactionResponse(response, body) {\n  <constructTransactionResponseStructure>\n  const transactionRes = {\n    statusCode: response.statusCode,\n    headers: Object.assign({}, response.headers),\n  };\n  </constructTransactionResponseStructure>\n  <encodeTransactionResponseBody>\n  if (Buffer.byteLength(body || '')) {\n    transactionRes.bodyEncoding = detectBodyEncoding(body);\n    transactionRes.body = body.toString(transactionRes.bodyEncoding);\n  }\n  </encodeTransactionResponseBody>\n  return transactionRes;\n}\n"], ["assignDepthsAt", "\nfunction assignDepthsAt(i) {\n    \n    <getElementsAtDepth>\n    var eles = depths[i];\n    </getElementsAtDepth>\n\n    <processElementsForDepthAssignment>\n    for (var j = 0; j < eles.length; j++) {\n      var _ele2 = eles[j];\n\n      <removeNullElements>\n      if (_ele2 == null) {\n        eles.splice(j, 1);\n        j--;\n        continue;\n      }\n      </removeNullElements>\n\n      <setElementInfo>\n      setInfo(_ele2, {\n        depth: i,\n        index: j\n      });\n      </setElementInfo>\n    }\n    </processElementsForDepthAssignment>\n}\n"], ["closeItemView", "\nfunction(){\n    if (this.isClosed){ return; }\n\n    <triggerCloseEvents>\n    this.triggerMethod('item:before:close');\n    </triggerCloseEvents>\n\n    <performClose>\n    Marionette.View.prototype.close.apply(this, slice(arguments));\n    </performClose>\n\n    <triggerClosedEvent>\n    this.triggerMethod('item:closed');\n    </triggerClosedEvent>\n}\n"], ["convertPointToPolarCoordinates", "\nfunction (point) {\n        <calculateCartesianDifference>\n        var dx = point[0] - this.cx;\n        var dy = point[1] - this.cy;\n        </calculateCartesianDifference>\n\n        <defineAngleExtents>\n        var angleAxis = this.getAngleAxis();\n        var extent = angleAxis.getExtent();\n        var minAngle = Math.min(extent[0], extent[1]);\n        var maxAngle = Math.max(extent[0], extent[1]);\n        </defineAngleExtents>\n\n        <inverseAngleIfNecessary>\n        angleAxis.inverse\n            ? (minAngle = maxAngle - 360)\n            : (maxAngle = minAngle + 360);\n        </inverseAngleIfNecessary>\n\n        <calculateRadialDistance>\n        var radius = Math.sqrt(dx * dx + dy * dy);\n        </calculateRadialDistance>\n\n        <normalizeDirectionComponents>\n        dx /= radius;\n        dy /= radius;\n        </normalizeDirectionComponents>\n\n        <calculateRadian>\n        var radian = Math.atan2(-dy, dx) / Math.PI * 180;\n        </calculateRadian>\n\n        <fitRadianWithinAngleRange>\n        var dir = radian < minAngle ? 1 : -1;\n        while (radian < minAngle || radian > maxAngle) {\n            radian += dir * 360;\n        }\n        </fitRadianWithinAngleRange>\n\n        return [radius, radian];\n    }\n"], ["get_path", "\nfunction get_path(context, path) {\n\tvar options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n\t<findNodeByPath>\n\tvar node = get_node_by_path(context, path, options);\n\t</findNodeByPath>\n\n\t<retrieveNodeProperties>\n\treturn node_type(node) == NodeTypes.NODE ? get_all_node_props(context, node, options) : node;\n\t</retrieveNodeProperties>\n}\n"], ["indexOf", "\nfunction ( target, value ) {\n    <polyfillIndexOf>\n    if ( typeof Array.prototype.indexOf === 'function' ) {\n        this.indexOf = function ( target, value ) {\n            <useBuiltInIndexOf>\n            if ( this.is(target) ) {\n                return target.indexOf( value );\n            } else {\n                throw new Error('[ixBand] \"indexOf()\" ' + MSG_NOT_ARRAY);\n            }\n            </useBuiltInIndexOf>\n        };\n    } else {\n        this.indexOf = function ( target, value ) {\n            <implementIndexOfManually>\n            if ( this.is(target) ) {\n                var tArray = target,\n                    aryNum = tArray.length,\n                    result = -1, i;\n    \n                for ( i = 0; i < aryNum; ++i ) {\n                    if ( tArray[i] === value ) {\n                        result = i;\n                        break;\n                    }\n                }\n                return result;\n            } else {\n                throw new Error('[ixBand] \"indexOf()\" ' + MSG_NOT_ARRAY);\n            }\n            </implementIndexOfManually>\n        };\n    }\n    </polyfillIndexOf>\n\n    return this.indexOf( target, value );\n}\n"], "```\n\nThe function annotations above illustrate a balanced approach between over-segmenting and under-segmenting to help identify responsibilities that may violate the Single Responsibility Principle (SRP). The annotations provide a clearer structure for each function, marking sections of code that perform specific, separate purposes within the context of each function's overall responsibility."]