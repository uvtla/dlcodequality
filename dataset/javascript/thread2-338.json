[["buildFilter", "\nfunction buildFilter(recordTypes, valueExprCtx, testSpec) {\n    <errorMessageCreation>\n    const error = msg => new common.X2UsageError(\n        'Invalid filter specification' + (\n            valueExprCtx.basePath.length > 0 ?\n                ' on ' + valueExprCtx.basePath : '') + ': ' + msg\n    );\n    </errorMessageCreation>\n\n    <validateTestSpecification>\n    if (!Array.isArray(testSpec) || (testSpec.length === 0))\n        throw error(\n            'filter test specification must be an array and must not be empty.');\n    </validateTestSpecification>\n\n    <extractAndValidatePredicate>\n    const pred = testSpec[0];\n    if ((typeof pred) !== 'string')\n        throw error(`invalid type for predicate \"${pred}\".`);\n    const predParts = pred.match(\n            /^\\s*(?:(?::(!?\\w+)\\s*)|([^:=\\s].*?)\\s*(?:=>\\s*(!?\\w+)\\s*)?)$/i);\n    if (predParts === null)\n        throw error(`predicate \"${pred}\" has invalid syntax.`);\n    </extractAndValidatePredicate>\n\n    <handleLogicalJunction>\n    if (predParts[1] !== undefined) {\n\n        <validateNestedTestsArray>\n        if (!Array.isArray(testSpec[1]) || (testSpec.length > 2))\n            throw error(\n                'logical junction must be followed by exactly one' +\n                    ' array of nested tests.');\n        </validateNestedTestsArray>\n\n        <determineJunctionType>\n        let juncType, invert;\n        switch (predParts[1].toLowerCase()) {\n        case 'or':\n        case 'any':\n        case '!none':\n            juncType = 'OR'; invert = false;\n            break;\n        case '!or':\n        case '!any':\n        case 'none':\n            juncType = 'OR'; invert = true;\n            break;\n        case 'and':\n        case 'all':\n            juncType = 'AND'; invert = false;\n            break;\n        case '!and':\n        case '!all':\n            juncType = 'AND'; invert = true;\n            break;\n        default:\n            throw error(`unknown junction type \"${predParts[1]}\".`);\n        }\n        </determineJunctionType>\n\n        <createRecordsFilterJunction>\n        const junc = new RecordsFilterJunction(juncType, invert);\n        </createRecordsFilterJunction>\n\n        <populateJunctionWithNestedTests>\n        testSpec[1].forEach(nestedTestSpec => {\n            const nestedTest = buildFilter(\n                recordTypes, valueExprCtx, nestedTestSpec);\n            if (nestedTest)\n                junc.addElement(nestedTest);\n        });\n        </populateJunctionWithNestedTests>\n\n        <returnJunction>\n        return (junc.isEmpty() ? undefined : junc);\n        </returnJunction>\n    }\n    </handleLogicalJunction>\n\n    <handleValueExpression>\n    const valueExpr = new ValueExpression(valueExprCtx, predParts[2]);\n    </handleValueExpression>\n\n    <handleCollectionTests>\n    let testType, invert = false, testParams;\n\n    const singlePropValueExprCtx = (\n        valueExpr.isSinglePropRef() &&\n            valueExprCtx.getRelativeContext(predParts[2]));\n    if (singlePropValueExprCtx &&\n        !singlePropValueExprCtx.basePropertyDesc.isScalar()) {\n\n        <getCollectionFilterTestAndValidate>\n        let colFilterSpecInd = 1;\n        const rawTestType = (\n            predParts[3] !== undefined ? predParts[3] : '!empty');\n        switch (rawTestType.toLowerCase()) {\n        case '!empty':\n            invert = true;\n        case 'empty':\n            testType = 'empty';\n            break;\n        case '!count':\n            invert = true;\n        case 'count':\n            testType = 'count';\n            testParams = [ testSpec[1] ];\n            if (!Number.isInteger(testParams[0]))\n                throw error(\n                    `test \"${rawTestType}\" expects an integer number argument.`);\n            colFilterSpecInd = 2;\n            break;\n        default:\n            throw error(\n                `invalid collection test \"${pred}\" as it may only be \"empty\"` +\n                    ', \"!empty\", \"count\" or \"!count\".');\n        }\n        </getCollectionFilterTestAndValidate>\n\n        <getCollectionFilterSpec>\n        const colFilterSpec = testSpec[colFilterSpecInd];\n        if ((testSpec.length > colFilterSpecInd + 1) || (\n            (colFilterSpec !== undefined) && !Array.isArray(colFilterSpec)))\n            throw error(\n                'collection test may only have none or a single' +\n                    ' collection filter argument and it must be an array.');\n        </getCollectionFilterSpec>\n\n        <createRecordsFilterCollectionTest>\n        return new RecordsFilterCollectionTest(\n            recordTypes,\n            valueExprCtx.normalizePropertyRef(\n                predParts[2].match(/^((?:\\^\\.)*[^.]+)/)[1]),\n            testType, invert, testParams,\n            singlePropValueExprCtx,\n            colFilterSpec\n        );\n        </createRecordsFilterCollectionTest>\n    }\n    </handleCollectionTests>\n\n    <prepareTestParams>\n    function getSingleTestParam() {\n        const v = testSpec[1];\n        if ((testSpec.length > 2) || (v === undefined) ||\n            (v === null) || Array.isArray(v))\n            throw error(\n                `test \"${rawTestType}\" expects a single non-null,` +\n                    ` non-array argument.`);\n        return [ v ];\n    }\n    function getTwoTestParams() {\n        let v1, v2;\n        switch (testSpec.length) {\n        case 2:\n            if (Array.isArray(testSpec[1]) && (testSpec[1].length === 2)) {\n                v1 = testSpec[1][0];\n                v2 = testSpec[1][1];\n            }\n            break;\n        case 3:\n            v1 = testSpec[1];\n            v2 = testSpec[2];\n        }\n        if ((v1 === undefined) || (v2 === undefined) ||\n            (v1 === null) || (v2 === null) ||\n            Array.isArray(v1) || Array.isArray(v2))\n            throw error(\n                `test \"${rawTestType}\" expects two non-null,` +\n                    ` non-array arguments.`);\n        return [ v1, v2 ];\n    }\n    function getListTestParams() {\n        const f = (a, v) => {\n            if ((v === null) || (v === undefined))\n                throw error(\n                    `test \"${rawTestType}\" expects a list of non-null` +\n                        ` arguments.`);\n            if (Array.isArray(v))\n                v.forEach(vv => { f(a, vv); });\n            else\n                a.push(v);\n            return a;\n        };\n        const a = testSpec.slice(1).reduce(f, new Array());\n        if (a.length === 0)\n            throw error(\n                `test \"${rawTestType}\" expects a list of non-null arguments.`);\n        return a;\n    }\n    </prepareTestParams>\n\n    <determineSingleValueTest>\n    const rawTestType = (\n        predParts[3] ? predParts[3] : (\n            testSpec.length > 1 ? 'is' : 'present'));\n    switch (rawTestType.toLowerCase()) {\n    case 'is':\n    case 'eq':\n        testType = 'eq';\n        testParams = getSingleTestParam();\n        break;\n    case 'not':\n    case 'ne':\n    case '!eq':\n        testType = 'ne';\n        testParams = getSingleTestParam();\n        break;\n    case 'min':\n    case 'ge':\n    case '!lt':\n        testType = 'ge';\n        testParams = getSingleTestParam();\n        break;\n    case 'max':\n    case 'le':\n    case '!gt':\n        testType = 'le';\n        testParams = getSingleTestParam();\n        break;\n    case 'gt':\n        testType = 'gt';\n        testParams = getSingleTestParam();\n        break;\n    case 'lt':\n        testType = 'lt';\n        testParams = getSingleTestParam();\n        break;\n    case '!in':\n    case '!oneof':\n        invert = true;\n    case 'in':\n    case 'oneof':\n    case 'alt':\n        testType = 'in';\n        testParams = getListTestParams();\n        break;\n    case '!between':\n        invert = true;\n    case 'between':\n        testType = 'between';\n        testParams = getTwoTestParams();\n        break;\n    case '!contains':\n        invert = true;\n    case 'contains':\n        testType = 'contains';\n        testParams = getSingleTestParam();\n        break;\n    case '!containsi':\n    case '!substring':\n        invert = true;\n    case 'containsi':\n    case 'substring':\n        testType = 'containsi';\n        testParams = getSingleTestParam();\n        break;\n    case '!starts':\n        invert = true;\n    case 'starts':\n        testType = 'starts';\n        testParams = getSingleTestParam();\n        break;\n    case '!startsi':\n    case '!prefix':\n        invert = true;\n    case 'startsi':\n    case 'prefix':\n        testType = 'startsi';\n        testParams = getSingleTestParam();\n        break;\n    case '!matches':\n        invert = true;\n    case 'matches':\n        testType = 'matches';\n        testParams = getSingleTestParam();\n        break;\n    case '!matchesi':\n    case '!pattern':\n    case '!re':\n        invert = true;\n    case 'matchesi':\n    case 'pattern':\n    case 're':\n        testType = 'matchesi';\n        testParams = getSingleTestParam();\n        break;\n    case '!empty':\n    case 'present':\n        invert = true;\n    case 'empty':\n        testType = 'empty';\n        if (testSpec.length > 1)\n            throw error(`test \"${rawTestType}\" expects no arguments.`);\n        break;\n    default:\n        throw error(`unknown test \"${rawTestType}\".`);\n    }\n    </determineSingleValueTest>\n\n    <processValueExpressionPlaceholders>\n    if (testParams) {\n        for (let i = 0, len = testParams.length; i < len; i++) {\n            const testParam = testParams[i];\n            if (placeholders.isExpr(testParam)) {\n                testParams[i] = new ValueExpression(\n                    valueExprCtx, testParam.expr);\n            }\n        }\n    }\n    </processValueExpressionPlaceholders>\n\n    <returnRecordsFilterValueTest>\n    return new RecordsFilterValueTest(valueExpr, testType, invert, testParams);\n    </returnRecordsFilterValueTest>\n}\n"], ["HttpError", "\nfunction HttpError(message, options) {\n    <errorInitialization>\n    if (!(this instanceof HttpError)) {\n        return new HttpError(message, options);\n    }\n\n    HttpError.super_.call(this);\n    Error.captureStackTrace(this, this.constructor);\n    this.name = 'HttpError';\n    this.message = message;\n    this.status = 500;\n    </errorInitialization>\n\n    <processErrorOptions>\n    options = options || {};\n    if (options.code)     { this.code = options.code; }\n    if (options.errors)   { this.errors = options.errors; }\n    if (options.headers)  { this.headers = options.headers; }\n    if (options.cause)    { this.cause = options.cause; }\n    </processErrorOptions>\n}\n"], ["throttle", "\nfunction throttle(f, delay) {\n  var timeoutId;\n  var previous = 0;\n\n  <throttleExecution>\n  return function throttleExecute_() {\n    var args = arguments;\n    var now = +(new Date());\n    var remaining = delay - (now - previous);\n\n    if (remaining <= 0) {\n      clearTimeout(timeoutId);\n      timeoutId = null;\n      previous = now;\n\n      f.apply(null, args);\n    } else if (!timeoutId) {\n      timeoutId = setTimeout(function() {\n        previous = +(new Date());\n        timeoutId = null;\n\n        f.apply(null, args);\n      }, remaining);\n    }\n  };\n  </throttleExecution>\n}\n"], ["Client", "\nfunction Client (globalRequest, maxSockets) {\n  var emptyResponse = JSON.parse(JSON.stringify(response))\n  var body = ''\n  var httpAgent = null\n  var httpsAgent = null\n\n  <initializeAgents>\n  if (maxSockets) {\n    httpAgent = new http.Agent({ maxSockets: maxSockets })\n    httpsAgent = new https.Agent({ maxSockets: maxSockets })\n  }\n  </initializeAgents>\n\n  <emptyRequestFunction>\n  this.emptyRequest = function () {\n    return JSON.parse(JSON.stringify(request))\n  }\n  </emptyRequestFunction>\n\n  <isEmptyFunction>\n  function isEmpty (obj) {\n    for (var key in obj) {\n      if (obj.hasOwnProperty(key)) {\n        return false\n      }\n    }\n    return true\n  }\n  </isEmptyFunction>\n\n  <buildPathFunction>\n  function buildPath (basePath, queryParams) {\n    basePath = basePath.concat('?')\n    var url = basePath.concat(queryString.stringify(queryParams))\n    return url\n  }\n  </buildPathFunction>\n\n  <buildRequestFunction>\n  function buildRequest (globalRequest, endpointRequest) {\n    var request = JSON.parse(JSON.stringify(globalRequest))\n    request.host = endpointRequest.host || globalRequest.host\n    request.method = endpointRequest.method\n\n    if (endpointRequest.port) {\n      request.port = endpointRequest.port\n    }\n\n    <pathProcessing>\n    request.path = !isEmpty(endpointRequest.queryParams)\n      ? buildPath(endpointRequest.path, endpointRequest.queryParams)\n      : endpointRequest.path\n    </pathProcessing>\n\n    <headersProcessing>\n    if (!isEmpty(endpointRequest.headers)) {\n      for (var attrname in endpointRequest.headers) {\n        request.headers[attrname] = endpointRequest.headers[attrname]\n      }\n    }\n    </headersProcessing>\n\n    <bodyProcessing>\n    if (!isEmpty(endpointRequest.body)) {\n      body = JSON.stringify(endpointRequest.body)\n      request.headers['Content-Length'] = Buffer.byteLength(body)\n      request.headers['Content-Type'] = 'application/json'\n    }\n    </bodyProcessing>\n\n    <agentSelection>\n    if (maxSockets) {\n      request.agent = endpointRequest.test === true ? httpAgent : httpsAgent\n    }\n    </agentSelection>\n    return request\n  }\n  </buildRequestFunction>\n\n  <APIFunction>\n  this.API = function (endpointRequest, callback) {\n    var request = buildRequest(globalRequest, endpointRequest)\n\n    var requestProtocol = null;\n\n    <determineProtocol>\n    if (endpointRequest.test === true) {\n      requestProtocol = http\n      request.port = endpointRequest.port\n    } else {\n      requestProtocol = https\n    }\n    </determineProtocol>\n\n    <httpRequestSetup>\n    var httpRequest = requestProtocol.request(request, function (httpResponse) {\n      var responseBody = ''\n\n      <responseBodyAggregation>\n      httpResponse.on('data', function (chunk) {\n        responseBody += chunk\n      })\n      </responseBodyAggregation>\n\n      <responseEndHandling>\n      httpResponse.on('end', function () {\n        var response = JSON.parse(JSON.stringify(emptyResponse))\n        response.statusCode = httpResponse.statusCode\n        response.body = responseBody\n        response.headers = httpResponse.headers\n        callback(response)\n      })\n      </responseEndHandling>\n    })\n    </httpRequestSetup>\n\n    <errorHandling>\n    httpRequest.on('error', function (e) {\n      var response = JSON.parse(JSON.stringify(emptyResponse))\n      response.statusCode = e.statusCode || 500\n      response.body = JSON.stringify({\n        message: e.message,\n        name: e.name,\n        stack: e.stack\n      })\n      callback(response)\n    })\n    </errorHandling>\n\n    <bodyWriting>\n    if (!isEmpty(endpointRequest.body)) {\n      httpRequest.write(body)\n    }\n    </bodyWriting>\n\n    httpRequest.end()\n  }\n  </APIFunction>\n\n  return this\n}\n"], ["removeDecorator", "\nfunction (decorator, txt) {\n    var decostr = \"@\" + decorator;\n    var r = txt\n        .replace(decostr, \"\")\n        .trim()\n        ;\n    if (debug) console.log(`Cleaning deco: ${decorator} in  ${txt}\n    Result: ${r}\n    `);\n\n\n    return r;\n}\n"], ["execute", "\nfunction execute(req, res) {\n  this.state.pubsub.psubscribe(req.conn, req.args);\n}\n"], ["processNodeContentWithPosthtml", "\nfunction processNodeContentWithPosthtml(node, options) {\n    return function (content) {\n        return processWithPostHtml(options.plugins, path.join(path.dirname(options.from), node.attrs.href), content, [function (tree) {\n            \n            return tree.match(match('content'), function () {\n                return node.content || '';\n            });\n        }]);\n    };\n}\n"], ["get", "\nfunction get(uri, locals) {\n  const name = getLayoutName(uri),\n    model = name && files.getLayoutModules(name),\n    callHooks = _.get(locals, 'hooks') !== 'false',\n    reqExtension = _.get(locals, 'extension'),\n    renderModel = reqExtension && files.getLayoutModules(name, reqExtension),\n    executeRender = model && _.isFunction(model.render) && callHooks;\n\n  return models.get(model, renderModel, executeRender, uri, locals);\n}\n"], ["mousemove_callback", "\nfunction mousemove_callback(e) {\n    var x  = e.pageX || e.originalEvent.touches[0].pageX;\n    var y  = e.pageY || e.originalEvent.touches[0].pageY;\n\n    <cancelTimeoutOnMovement>\n    if (Math.abs(oX - x) > maxMove || Math.abs(oY - y) > maxMove) {\n        if (timeout) clearTimeout(timeout);\n    }\n    </cancelTimeoutOnMovement>\n}\n"], ["returnEntityToPool", "\nfunction (el) {\n    <checkElInUsed>\n    var index = this.usedEls.indexOf(el);\n    if (index === -1) {\n      warn('The returned entity was not previously pooled from ' + this.attrName);\n      return;\n    }\n    </checkElInUsed>\n    <removeElFromUsedAndAddToAvailable>\n    this.usedEls.splice(index, 1);\n    this.availableEls.push(el);\n    el.object3D.visible = false;\n    el.pause();\n    </removeElFromUsedAndAddToAvailable>\n    return el;\n  } \n"], "```\n\nIn the above annotations, I've identified distinct responsibilities based on blocks of instructions serving a specific function within each method. The labeling provides a clear view of the SRP compliance or violation within each function. It's essential to remember that simple operations and lines that do not form a meaningful instruction set do not constitute a separate responsibility under SRP and have not been tagged as such."]