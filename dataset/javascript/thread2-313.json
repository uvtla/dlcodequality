[["toordinal", "\nfunction _toordinal(year, month, day) {\n  var days_before_year = ((year - 1) * 365) + Math.floor((year - 1) / 4) - Math.floor((year - 1) / 100) + Math.floor((year - 1) / 400);\n  var days_before_month = _DAYS_BEFORE_MONTH[month] + (month > 2 && isleap(year) ? 1 : 0);\n  return (days_before_year + days_before_month + day);\n}\n"], ["safeCloneElement", "\nfunction safeCloneElement (element, props, ...children) {\n  <manageRefs>\n  const cloneRef = props.ref\n  const originalRef = element.ref\n  const originalRefIsAFunction = (typeof originalRef === 'function')\n  </manageRefs>\n\n  <mergeProps>\n  const mergedProps = {...props}\n  </mergeProps>\n\n  <mergeStyles>\n  if (element.props.style && props.style) {\n    mergedProps.style = { ...element.props.style, ...props.style }\n  }\n  </mergeStyles>\n\n  <mergeKeys>\n  mergedProps.key = element.key || props.key\n  </mergeKeys>\n\n  <chainEventHandlers>\n  Object.keys(props).forEach((prop) => {\n    if (prop.indexOf('on') === 0 && (\n        typeof props[prop] === 'function' ||\n        typeof element.props[prop] === 'function'\n    )) {\n      mergedProps[prop] = createChainedFunction(element.props[prop], props[prop])\n    }\n  })\n  </chainEventHandlers>\n\n  <cloneWithoutRefs>\n  if (originalRef == null || cloneRef == null) {\n    return React.cloneElement(element, mergedProps, ...children)\n  }\n  </cloneWithoutRefs>\n\n  <warnAndRefMerging>\n  warn(originalRefIsAFunction,\n    `Cloning an element with a ref that will be overwritten because the ref \\\nis not a function. Use a composable callback-style ref instead. \\\nIgnoring ref: ${originalRef}`)\n  </warnAndRefMerging>\n\n  <cloneWithRefs>\n  return React.cloneElement(element, {\n    ...mergedProps,\n    ref (component) {\n      cloneRef(component)\n      originalRef(component)\n    }\n  }, ...children)\n  </cloneWithRefs>\n}\n"], ["registerMock", "\nfunction registerMock(post) {\n  <createResponseObject>\n  var responseObj = {};\n  responseObj[\"statusCode\"] = parseInt(post.statusCode) || 200;\n  responseObj[\"header\"] = post.header || {\n          'Content-Type': post.contentType || 'application/json',\n          'Access-Control-Allow-Origin': '*'\n      };\n  responseObj[\"contentType\"] = post.contentType || \"application/json\";\n  if (typeof post.responseText == 'object') {\n      responseObj[\"responseText\"] = JSON.stringify(post.responseText);\n  } else {\n      responseObj[\"responseText\"] = post.responseText || \"This is a fake response\";\n  }\n  responseObj[\"responseFile\"] = post.responseFile;\n  responseObj[\"id\"] = post.id;\n  responseObj[\"keyValues\"] = post.keyValues || {};\n  responseObj[\"eval\"] = post.eval;\n  responseObj[\"delayTime\"] = parseInt(post.delayTime) || 0;\n  </createResponseObject>\n\n  <processRequestPath>\n  var requestPath = post.requestPath;\n  if (post.requestJSONBody == '' || post.requestJSONBody == null) {\n    mockReqRespMap[requestPath] = responseObj;\n  } else {\n    responseObj[\"requestJSONBody\"] = post.requestJSONBody;\n    var uniqueID = md5(JSON.stringify(post.requestJSONBody));\n    mockReqRespMap[requestPath + uniqueID] = responseObj;\n  }\n  </processRequestPath>\n}\n"], ["isRunByHusky", "\nfunction isRunByHusky (ppid) {\n  return find('pid', ppid).then(list => {\n    <processList>\n    debug('process list: %o', list)\n    const cmd = list[0] && list[0].cmd\n    const pppid = list[0] && list[0].ppid\n    </processList>\n\n    <checkCommands>\n    if (!cmd) {\n      return false\n    }\n    if (huskyCmdReg.test(cmd)) {\n      return true\n    }\n    </checkCommands>\n\n    <recursiveCheck>\n    return isRunByHusky(pppid)\n    </recursiveCheck>\n  })\n}\n"], ["methodsWrapper", "\nfunction() {\n  <parseArgs>\n  var self = this,\n      args = self.parseInsertArgs(arguments);\n  </parseArgs>\n\n  <executeMultimix>\n  return self.multimix({\n      insert: args.command\n  }, args.animate, args.callback);\n  </executeMultimix>\n}\n"], ["createBodystructure", "\nfunction createBodystructure(tree, options) {\n  <prepareOptions>\n  options = options || {};\n  </prepareOptions>\n\n  <walkerFunction>\n  var walker = function(node) {\n    <processNode>\n    switch((node.parsedHeader['content-type'] || {}).type) {\n        case 'multipart':\n            return processMultipartNode(node, options);\n        case 'text':\n            return processTextNode(node, options);\n        case 'message':\n            if (!options.attachmentRFC822) {\n                return processRFC822Node(node, options);\n            }\n            return processAttachmentNode(node, options);\n        default:\n            return processAttachmentNode(node, options);\n    }\n    </processNode>\n  };\n  </walkerFunction>\n\n  <walkerExecution>\n  return walker(tree);\n  </walkerExecution>\n}\n"], ["describeFunction", "\nfunction () {\n  <hasFunctionState>\n  if (this.hasFnState()) {\n      return when.resolve();\n  }\n  </hasFunctionState>\n\n  <initDescribeDfd>\n  if (!this._describeDfd) {\n      this.sendMessage(\"Describe\");\n      this._describeDfd = when.defer();\n  }\n  </initDescribeDfd>\n\n  <describePromise>\n  return this._describeDfd.promise;\n  </describePromise>\n}\n"], ["mkdir", "\nfunction mkdir(affixes, callback) {\n  <generateDirName>\n  var dirPath = generateName(affixes, 'd-');\n  </generateDirName>\n  <createDirectory>\n  fs.mkdir(dirPath, parseInt('0700', 8), function(err) {\n    if (!err) {\n      <manageCleanup>\n      deleteDirOnExit(dirPath);\n      </manageCleanup>\n    }\n    <invokeCallback>\n    if (callback) {\n      callback(err, dirPath);\n    }\n    </invokeCallback>\n  });\n  </createDirectory>\n}\n"], ["forOwn", "\nfunction forOwn(object, callback, thisArg) {\n  <prepareCallback>\n  callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3);\n  </prepareCallback>\n  <iterateObject>\n  return baseForOwn(object, callback);\n  </iterateObject>\n}\n"], ["createCar", "\nfunction createCar(car) {\n  <createCardComponents>\n  var back = createCardBack(assets.carBack);\n  var front = new CarFront(car);\n  var flippable = new FlippableCard(back, front);\n  </createCardComponents>\n  <setInitialPosition>\n  flippable.x = flippable.regX;\n  flippable.y = flippable.regY;\n  </setInitialPosition>\n  <returnFlippable>\n  return flippable;\n  </returnFlippable>\n}\n"], ""]