[["removeTrailingZeros", "\nfunction removeTrailingZeros(str) {\n  <validateInput>\n  if (typeof str != 'string') throw new Error('in removeTrailingZeros, data type mismatch'); </validateInput>\n\n  let iNonZero = -1;\n  <findLastNonZeroCharacter>\n  for (let i = str.length - 1; i >= 0; i--) {\n    if (charToVal(str[i]) != 0) {\n      iNonZero = i; \n      break;\n    }\n  } </findLastNonZeroCharacter>\n  <removeZeros>\n  str = str.slice(0, iNonZero + 1); </removeZeros>\n\n  return str;\n}\n"], ["secondFunction", "\nfunction (str, highlight) {\n  <initializeVariables>\n  var highlightLen = highlight.length;\n  var firstOccurrenceIdx; </initializeVariables>\n\n  <validateInput>\n  if (ariaUtilsType.isString(str) && highlightLen) { </validateInput>\n    <prepareHighlight>\n    highlight = highlight.toLowerCase();\n    var strLowerCased = str.toLowerCase(); </prepareHighlight>\n\n    <locateFirstOccurrence>\n    if (strLowerCased.indexOf(highlight) === 0) {\n      firstOccurrenceIdx = 0;\n    } else {\n      var highlightRegexSafe = highlight.replace(regExSpecials, \"\\\\$1\");\n      var regexResult = new RegExp(\"\\\\s\" + highlightRegexSafe, \"i\").exec(strLowerCased);\n      if (!regexResult) {\n        return ariaUtilsString.escapeForHTML(str);\n      } else {\n        firstOccurrenceIdx = regexResult.index + 1; \n      }\n    } </locateFirstOccurrence>\n\n    <formatString>\n    var a = firstOccurrenceIdx;\n    var b = firstOccurrenceIdx + highlightLen;\n    var middleOriginal = str.substring(a, b);\n    var middle = ariaUtilsString.stripAccents(middleOriginal).toLowerCase();\n    if (middle === highlight) {\n      return ariaUtilsString.escapeForHTML(str.substring(0, a)) + \"<strong>\" + ariaUtilsString.escapeForHTML(middleOriginal) + \"</strong>\" + ariaUtilsString.escapeForHTML(str.substring(b));\n    }\n    </formatString>\n  }\n\n  <handleNonHighlightCase>\n  return str ? ariaUtilsString.escapeForHTML(str) : str; </handleNonHighlightCase>\n}\n"], ["runPrintingExample", "\nfunction runPrintingExample(fn, logName, logTable, logCode, logSeparator, logScreenShot) {\n  <definePrintExampleFunction>\n  function printExample(name, makeTable, expected, screenshot) {\n    <extractFunctionCode>\n    let code = makeTable\n      .toString()\n      .split('\\n')\n      .slice(1, -2)\n      .join('\\n');\n    </extractFunctionCode>\n\n    <logExample>\n    logName(name);\n    if (screenshot && logScreenShot) {\n      logScreenShot(screenshot);\n    } else {\n      logTable(makeTable().toString());\n    }\n    logCode(code);\n    logSeparator('\\n'); </logExample>\n  } </definePrintExampleFunction>\n\n  <executeProvidedFunction>\n  fn(printExample); </executeProvidedFunction>\n}\n"], ["makeStylable", "\nfunction makeStylable(component, className, name, hooks) {\n\n  <createStylableClass>\n  return new (\n  \n  function () {\n    function Stylable() {\n      <initializeProperties>\n      _classCallCheck(this, Stylable);\n      this.name = name;\n      this.initialClassName = className;\n      this.classNames = [className];\n      this.component = component;\n      this.styles = {};\n      this.isUgly = true; </initializeProperties>\n    }\n    </createStylableClass>\n\n    <defineStylableMethods>\n    _createClass(Stylable, [{\n      // Several methods with their own responsibilities omitted for brevity\n    }]);\n    </defineStylableMethods>\n\n    return Stylable;\n  }())();\n}\n"], ["expandIncludes", "\nfunction expandIncludes(source, rootPath) {\n  var matcher = new RegExp(\"^([\\t ]*)include ([^/].*);\\n?\", \"gm\");\n  var match;\n  var expanded = '';\n  var after = source;\n  var includes = [];\n  var lastIndex = 0;\n\n  <processIncludes>\n  while (match = matcher.exec(source)) {\n    <captureMatchDetails>\n    var statement = match[0];\n    var indent = match[1];\n    var filePath = path.join(rootPath, match[2])\n    includes.push(filePath);\n    </captureMatchDetails>\n\n    <expandTextBeforeMatch>\n    expanded += source.substr(lastIndex, match.index - lastIndex); </expandTextBeforeMatch>\n\n    <annotateStartOfInclude>\n    expanded += indent + \"## Start Include: \" + filePath + \"\\n\"; </annotateStartOfInclude>\n\n    <readAndProcessIncludedFile>\n    try {\n      var fileContent = fs.readFileSync(filePath, 'utf8');\n      var indentedContent = singleTrailingNewline(NgindoxUtil.indentBlock(fileContent, indent));\n      expanded += expandIncludes(indentedContent, path.dirname(rootPath));\n    } catch (err) {\n      expanded += indent + \"## Error: \" + err + \"\\n\";\n    } </readAndProcessIncludedFile>\n\n    <annotateEndOfInclude>\n    expanded += indent + \"## End Include: \" + filePath + \"\\n\"; </annotateEndOfInclude>\n\n    <updateLastIndex>\n    lastIndex = matcher.lastIndex; </updateLastIndex>\n  }\n  </processIncludes>\n\n  <appendRemainingSource>\n  expanded += source.substr(lastIndex); </appendRemainingSource>\n\n  return expanded;\n}\n"], ["fixupCommand", "\nfunction fixupCommand(options, callback) {\n  <setDefaultPmBaseDir>\n  if (!options.pmBaseDir) {\n    if (fs.existsSync(path.resolve(options.cwd, '.strong-pm'))) {\n      options.pmBaseDir = '.strong-pm';\n    } else {\n      options.pmBaseDir = '.';\n    }\n  }\n  options.pmBaseDir = path.resolve(options.cwd, options.pmBaseDir); </setDefaultPmBaseDir>\n\n  <prepareExecutionScript>\n  options.execpath = process.execPath;\n  options.script = [\n    require.resolve('../bin/sl-pm'),\n    '--listen', options.pmPort,\n    '--base', options.pmBaseDir,\n    '--base-port', options.basePort,\n    '--driver', options.driver,\n  ].join(' '); </prepareExecutionScript>\n\n  <writeSeedEnvironment>\n  return writeSeedEnvironment(options, callback); </writeSeedEnvironment>\n}\n"], ["composeProjectOptions", "\nfunction(app) {\n  return {\n    <populateComposeProjectOptions>\n    compose: getComposeFiles(app),\n    project: app.name,\n    opts: {\n      app: app\n    } </populateComposeProjectOptions>\n  };\n}\n"], ["checkKeyExists", "\nfunction checkKeyExists(key) {\n  var scope = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'fallback';\n  <retrieveLocaleData>\n  var locale = store.state[moduleName].locale;\n  var fallback = store.state[moduleName].fallback;\n  var translations = store.state[moduleName].translations; </retrieveLocaleData>\n\n  <checkLocalTranslationExists>\n  if (translations.hasOwnProperty(locale) && translations[locale].hasOwnProperty(key)) {\n    return true;\n  } </checkLocalTranslationExists>\n\n  <strictScopeCheck>\n  if (scope == 'strict') {\n    return false;\n  } </strictScopeCheck>\n\n  <checkRegionalTranslationExists>\n  var localeRegional = locale.split('-');\n  if (localeRegional.length > 1 && translations.hasOwnProperty(localeRegional[0]) && translations[localeRegional[0]].hasOwnProperty(key)) {\n    return true;\n  } </checkRegionalTranslationExists>\n\n  <localeScopeCheck>\n  if (scope == 'locale') {\n    return false;\n  } </localeScopeCheck>\n\n  <checkFallbackTranslationExists>\n  if (translations.hasOwnProperty(fallback) && translations[fallback].hasOwnProperty(key)) {\n    return true;\n  } </checkFallbackTranslationExists>\n\n  return false;\n}\n"], ["makeURL", "\nfunction makeURL(content, contentType) {\n  if (content instanceof Blob) {\n    <createBlobURL>\n    return URL.createObjectURL(content, contentType); </createBlobURL>\n  } else {\n    <convertAndCreateBlobURL>\n    return URL.createObjectURL(makeBlob(content)); </convertAndCreateBlobURL>\n  }\n}\n"], ["parseHost", "\nfunction parseHost(uri) {\n  <extractProtocolAndHost>\n  const {protocol, host} = url.parse(uri); </extractProtocolAndHost>\n\n  <validateUri>\n  assert(protocol === 'http:' || protocol === 'https:',\n    'Bad URL for location.'); </validateUri>\n\n  <concatenateProtocolAndHost>\n  return `${protocol}\n} </concatenateProtocolAndHost>\n"], "```\n\nIn the above functions:\n\n- Compliant Functions: `removeTrailingZeros`, `runPrintingExample`, `composeProjectOptions`, `checkKeyExists`, `makeURL`\n- Non-Compliant Functions: The second function **(unnamed)**, `makeStylable`, `expandIncludes`, `fixupCommand`, `parseHost`"]