[["safeToArray", "\nfunction safeToArray(args) {\n        const seen = [];\n        const argsArray = [];\n\n        let res;\n\n        <processArgs>\n        if (args.length) {\n            for (let i = 0; i < args.length; i++) {\n\n                <handleUndefined>\n                if (typeof args[i] === 'undefined') {\n                    args[i] = 'undefined';\n                }\n                </handleUndefined>\n\n                <handleError>\n                else if (args[i] instanceof Error) {\n                    const errorObj = args[i];\n                    if (errorObj.stack) {\n                        args[i] = errorObj.stack;\n                    } else {\n                        args[i] = errorObj.toString();\n                    }\n                }\n                </handleError>\n\n                argsArray.push(args[i]);\n            }\n        }\n        </processArgs>\n\n        <addStackTrace>\n        if (process.env.VSCODE_LOG_STACK === 'true') {\n            const stack = new Error().stack;\n            argsArray.push({ __$stack: stack.split('\\n').slice(3).join('\\n') });\n        }\n        </addStackTrace>\n\n        <transformToJsonString>\n        try {\n            res = JSON.stringify(argsArray, function (key, value) {\n\n                <detectCircularReference>\n                if (isObject(value) || Array.isArray(value)) {\n                    if (seen.indexOf(value) !== -1) {\n                        return '[Circular]';\n                    }\n\n                    seen.push(value);\n                }\n                </detectCircularReference>\n\n                return value;\n            });\n        } catch (error) {\n            return 'Output omitted for an object that cannot be inspected (' + error.toString() + ')';\n        }\n        </transformToJsonString>\n\n        <truncateLongOutput>\n        if (res && res.length > MAX_LENGTH) {\n            return 'Output omitted for a large object that exceeds the limits';\n        }\n        </truncateLongOutput>\n\n        return res;\n}\n"], ["OnvifManager", "\nfunction OnvifManager() {\n    this.ws = null;\n    this.el = {\n        'frm_con' : $('#connect-form'),\n        'sel_dev' : $('#connect-form select[name=\"device\"]'),\n        'inp_usr' : $('#connect-form input[name=\"user\"]'),\n        'inp_pas' : $('#connect-form input[name=\"pass\"]'),\n        'btn_con' : $('#connect-form button[name=\"connect\"]'),\n        'div_pnl' : $('#connected-device'),\n        'img_snp' : $('#connected-device img.snapshot'),\n        'btn_dcn' : $('#connected-device button[name=\"disconnect\"]'),\n        'mdl_msg' : $('#message-modal'),\n        'ptz_spd' : $('input[name=\"ptz-speed\"]'),\n        'btn_hme' : $('#connected-device div.ptz-pad-box button.ptz-goto-home'),\n        'ptz_pad' : $('#connected-device div.ptz-pad-box'),\n        'zom_in'  : $('#connected-device div.ptz-zom-ctl-box button.ptz-zom-in'),\n        'zom_out' : $('#connected-device div.ptz-zom-ctl-box button.ptz-zom-ot'),\n    };\n    this.selected_address = '';\n    this.device_connected = false;\n    this.ptz_moving = false;\n    this.snapshot_w = 400;\n    this.snapshot_h = 300;\n}\n"], ["sendClientAlertMessage", "\nfunction sendClientAlertMessage(ws, alert) {\n  var msg = JSON.stringify({\n    custom: {\n      alert: alert\n    }\n  });\n  ws.write(msg);\n}\n"], ["map", "\nfunction map(obj, iteratee, context) {\n    var resultArray = [];\n\n    context = context || null;\n\n    <applyIteratee>\n    forEach(obj, function() {\n        resultArray.push(iteratee.apply(context, arguments));\n    });\n    </applyIteratee>\n\n    return resultArray;\n}\n"], ["HostEntry", "\nfunction HostEntry(addr, src) {\n  if (!(this instanceof HostEntry))\n    return new HostEntry(addr, src);\n\n  this.addr = addr || new NetAddress();\n  this.src = src || new NetAddress();\n  this.prev = null;\n  this.next = null;\n  this.used = false;\n  this.refCount = 0;\n  this.attempts = 0;\n  this.lastSuccess = 0;\n  this.lastAttempt = 0;\n\n  <fromOptions>\n  if (addr)\n    this.fromOptions(addr, src);\n  </fromOptions>\n}\n"], ["doormen", "\nfunction doormen( ... args ) {\n\tvar options , data , schema , context , sanitized ;\n\n\tif ( args.length < 2 || args.length > 3 ) {\n\t\tthrow new Error( 'doormen() needs at least 2 and at most 3 arguments' ) ;\n\t}\n\n\tif ( args.length === 2 ) { schema = args[ 0 ] ; data = args[ 1 ] ; }\n\telse { options = args[ 0 ] ; schema = args[ 1 ] ; data = args[ 2 ] ; }\n\n\t\n\tif ( typeof schema === 'string' ) { schema = doormen.sentence( schema ) ; }\n\n\tif ( ! schema || typeof schema !== 'object' ) {\n\t\tthrow new doormen.SchemaError( 'Bad schema, it should be an object or an array of object!' ) ;\n\t}\n\n\tif ( ! options || typeof options !== 'object' ) { options = {} ; }\n\n\tif ( ! options.patch || typeof options.patch !== 'object' || Array.isArray( options.patch ) ) { options.patch = false ; }\n\n\n\tcontext = {\n\t\tuserContext: options.userContext ,\n\t\tvalidate: true ,\n\t\terrors: [] ,\n\t\tpatch: options.patch ,\n\t\tcheck: check ,\n\t\tvalidatorError: validatorError ,\n\t\treport: !! options.report ,\n\t\texport: !! options.export\n\t} ;\n\n\t<sanitizeData>\n\tsanitized = context.check( schema , data , {\n\t\tpath: '' ,\n\t\tdisplayPath: data === null ? 'null' : ( Array.isArray( data ) ? 'array' : typeof data ) ,\t\n\t\tkey: ''\n\t} , false ) ;\n\t</sanitizeData>\n\n\tif ( context.report ) {\n\t\treturn {\n\t\t\tvalidate: context.validate ,\n\t\t\tsanitized: sanitized ,\n\t\t\terrors: context.errors\n\t\t} ;\n\t}\n\n\treturn sanitized ;\n\n}\n"], ["createLookupList", "\nfunction createLookupList(font) {\n  var ligatures = font.ligatures;\n\n  var groupedLigatures = {};\n\n  \n  <groupLigatures>\n  _.forEach(ligatures, function (ligature) {\n    var first = ligature.unicode[0];\n\n    if (!_.has(groupedLigatures, first)) {\n      groupedLigatures[first] = [];\n    }\n    groupedLigatures[first].push(ligature);\n  });\n  </groupLigatures>\n\n  var ligatureGroups = [];\n\n  <sortLigatureGroups>\n  _.forEach(groupedLigatures, function (ligatures, codePoint) {\n    codePoint = parseInt(codePoint, 10);\n    \n    \n    \n    ligatures.sort(function (ligA, ligB) {\n      return ligB.unicode.length - ligA.unicode.length;\n    });\n    ligatureGroups.push({\n      codePoint: codePoint,\n      ligatures: ligatures,\n      startGlyph: font.codePoints[codePoint]\n    });\n  });\n  </sortLigatureGroups>\n\n  <sortLigatureGroupsFinal>\n  ligatureGroups.sort(function (a, b) {\n    return a.startGlyph.id - b.startGlyph.id;\n  });\n  </sortLigatureGroupsFinal>\n\n  var offset = (0\n    + 2 \n    + 2 \n  );\n\n  var set = createLigatureList(font, ligatureGroups);\n\n  var length = (0\n    + offset\n    + set.length\n  );\n\n  var buffer = new ByteBuffer(length);\n\n  \n  <writeLookupList>\n  buffer.writeUint16(1);\n\n  \n  buffer.writeUint16(offset);\n\n  \n  buffer.writeBytes(set.buffer);\n  </writeLookupList>\n\n  return buffer;\n}\n"], ["convolve5x5Sharp", "\nfunction (inData, outData, width, height) {\n        convolve5x5(inData, outData, width, height,\n            [\n                [-1, -1, -1, -1, -1],\n                [-1, -1, -1, -1, -1],\n                [-1, -1, 24, -1, -1],\n                [-1, -1, -1, -1, -1],\n                [-1, -1, -1, -1, -1]\n            ],\n            false, true, true);\n}\n"], ["BlurClassConstructor", "\nfunction (element, options) {\n  this.internalID = randomID()\n  this.element = element\n  this.width = element.offsetWidth\n  this.height = element.offsetHeight\n  this.element = element\n  this.parent = this.element.parentNode\n  <setDefaultOptions>\n  this.options = Object.assign({}, Blur.DEFAULTS, options)\n  </setDefaultOptions>\n  <createOverlay>\n  this.overlayEl = this.createOverlay()\n  </createOverlay>\n  <attachListeners>\n  this.attachListeners()\n  </attachListeners>\n  <generateBlurredImage>\n  this.generateBlurredImage(this.options.url)\n  </generateBlurredImage>\n}\n"], ["generatePassword", "\nfunction password (n, special) {\n\tn = n || 3;\n\tspecial = special === true;\n\tvar result = \"\",\n\t\ti = -1,\n\t\tused = {},\n\t\thasSub = false,\n\t\thasExtra = false,\n\t\tflip, lth, pos, rnd, word;\n\n\t<substituteCharacters>\n\tfunction sub (x, idx) {\n\t\tif (!hasSub && word.indexOf(x) > -1) {\n\t\t\tword = word.replace(x, subs[idx]);\n\t\t\thasSub = true;\n\t\t\tflip = false;\n\t\t}\n\t}\n\t</substituteCharacters>\n\n\t<passwordComposition>\n\tif (!special) {\n\t\twhile (++i < n) {\n\t\t\tresult += words[random(nth, used)];\n\t\t}\n\t} else {\n\t\trnd = Math.floor(Math.random() * n);\n\n\t\twhile (++i < n) {\n\t\t\tword = words[random(nth, used)];\n\n\t\t\t<randomCaps>\n\t\t\tif (i === rnd) {\n\t\t\t  lth = word.length;\n\t\t\t  pos = Math.floor(Math.random() * lth);\n\n\t\t\t  if (pos === 0) {\n\t\t\t\tword = word.charAt(0).toUpperCase() + word.slice(1);\n\t\t\t  } else if (pos < lth - 1) {\n\t\t\t\tword = word.slice(0, pos) + word.charAt(pos).toUpperCase() + word.slice(pos + 1, lth);\n\t\t\t  } else {\n\t\t\t\tword = word.slice(0, pos) + word.charAt(pos).toUpperCase();\n\t\t\t  }\n\t\t\t}\n\t\t\t</randomCaps>\n\n\t\t\t<addSpecialChars>\n\t\t\telse if (i >= ( n / 2 )) {\n\n\t\t\t\t\n\t\t\t\tflip = Math.random() >= 0.5 ? 1 : 0;\n\n\t\t\t\t\n\t\t\t\tif (flip && !hasSub) {\n\t\t\t\t\treplace.forEach(sub);\n\t\t\t\t}\n\n\t\t\t\t\n\t\t\t\tif (flip && !hasExtra) {\n\t\t\t\t\tword += extra[Math.floor(Math.random() * eth)];\n\t\t\t\t\thasExtra = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t</addSpecialChars>\n\n\t\t\tresult += word;\n\t\t}\n\n\t\tif (!hasSub) {\n\t\t\tresult += subs[Math.floor(Math.random() * rth)];\n\t\t}\n\n\t\tif (!hasExtra) {\n\t\t\tresult += extra[Math.floor(Math.random() * eth)];\n\t\t}\n\t}\n\t</passwordComposition>\n\n\treturn result;\n}\n"], ""]