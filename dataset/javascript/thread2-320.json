[["analyzeModuleDefinition", "\nfunction analyzeModuleDefinition(node) {\n  var args = node.arguments;\n  var arg = 0;\n  <parseModuleName>\n  if ( arg < args.length\n       && args[arg].type === Syntax.Literal && typeof args[arg].value === 'string' ) {\n    warning(\"module explicitly defined a module name '\" + args[arg].value + \"'\");\n    currentModule.name = args[arg].value;\n    arg++;\n  }\n  </parseModuleName>\n  <parseDependencies>\n  if ( arg < args.length && args[arg].type === Syntax.ArrayExpression ) {\n    currentModule.dependencies = convertValue(args[arg], \"string[]\");\n    arg++;\n  }\n  </parseDependencies>\n  <parseFactory>\n  if ( arg < args.length && args[arg].type === Syntax.FunctionExpression ) {\n    currentModule.factory = args[arg];\n    arg++;\n  }\n  </parseFactory>\n  <resolveDependencies>\n  if ( currentModule.dependencies && currentModule.factory ) {\n    for ( var i = 0; i < currentModule.dependencies.length && i < currentModule.factory.params.length; i++ ) {\n      var name = currentModule.factory.params[i].name;\n      var module = resolveModuleName(currentModule.module, currentModule.dependencies[i]);\n      debug(\"  import \" + name + \" from '\" + module + \"'\");\n      currentModule.localNames[name] = {\n        module: module\n        \n      };\n    }\n  }\n  </resolveDependencies>\n  <collectShortcuts>\n  if ( currentModule.factory ) {\n    collectShortcuts(currentModule.factory.body);\n  }\n  </collectShortcuts>\n}\n"], ["moveToTop", "\nfunction moveToTop(child) {\n  var childIndex = this.getChildIndex(child);\n  <reorderElement>\n  if (childIndex > 0) {\n    this.children.splice(0, 0, this.children.splice(childIndex, 1)[0]); \n    child.pos.z = this.children[1].pos.z + 1;\n  }\n  </reorderElement>\n}\n"], ["history", "\nfunction history(params, cb) {\n  <configureRequest>\n  params.resourcePath = config.addURIParams(constants.STATS_BASE_PATH + \"/history\", params);\n  params.method = 'POST';\n  params.data = params.data || {};\n  </configureRequest>\n  <makeRequest>\n  mbaasRequest.admin(params, cb);\n  </makeRequest>\n}\n"], ["reduceArray", "\nfunction (arr, callback, initialValue) {\n  \n  <validateInput>\n  var len = arr.length;\n  if (typeof callback !== 'function') {\n      throw new TypeError('callback is not function!');\n  }\n\n  if (len === 0 && arguments.length == 2) {\n      throw new TypeError('arguments invalid');\n  }\n  </validateInput>\n\n  var k = 0;\n  var accumulator;\n  <initializeAccumulator>\n  if (arguments.length >= 3) {\n      accumulator = arguments[2];\n  }\n  else {\n      do {\n          if (k in arr) {\n              accumulator = arr[k++];\n              break;\n          }\n          k += 1;\n          if (k >= len) {\n              throw new TypeError();\n          }\n      }\n      while (TRUE);\n  }\n  </initializeAccumulator>\n\n  <accumulateValues>\n  while (k < len) {\n      if (k in arr) {\n          accumulator = callback.call(undefined, accumulator, arr[k], k, arr);\n      }\n      k++;\n  }\n  </accumulateValues>\n\n  return accumulator;\n}\n"], ["modUpdatePreparedState", "\nfunction modUpdatePreparedState(id) {\n  <initializeState>\n  var updatingModules = {};\n  </initializeState>\n  <updateDependencies>\n  update(id);\n  </updateDependencies>\n\n  function update(id) {\n    <prepareModule>\n    modPrepare(id);\n    if (!modIs(id, MODULE_ANALYZED)) {\n      return false;\n    }\n    </prepareModule>\n\n    <checkAndUpdateState>\n    if (modIs(id, MODULE_PREPARED) || updatingModules[id]) {\n      return true;\n    }\n\n    updatingModules[id] = 1;\n    var mod = modModules[id];\n    var prepared = true;\n    </checkAndUpdateState>\n\n    <processDependencies>\n    each(\n      mod.depMs,\n      function (dep) {\n        prepared = update(dep.absId) && prepared;\n      }\n    );\n    prepared && each(\n      mod.depRs,\n      function (dep) {\n        prepared = !!dep.absId;\n        return prepared;\n      }\n    );\n    </processDependencies>\n\n    <finalizePreparation>\n    if (prepared && !modIs(id, MODULE_PREPARED)) {\n      mod.state = MODULE_PREPARED;\n    }\n    updatingModules[id] = 0;\n    return prepared;\n    </finalizePreparation>\n  }\n}\n"], ["initializeSeries", "\nfunction (chart, options) {\n  var series = this,\n    <eventHandlers>\n    eventType,\n    events,\n    </eventHandlers>\n    chartSeries = chart.series,\n    <sortByIndexFunction>\n    sortByIndex = function (a, b) {\n      return pick(a.options.index, a._i) - pick(b.options.index, b._i);\n    };\n    </sortByIndexFunction>\n\n  <setupSeries>\n  series.chart = chart;\n  series.options = options = series.setOptions(options);\n  series.linkedSeries = [];\n  </setupSeries>\n\n  <bindAxes>\n  series.bindAxes();\n  </bindAxes>\n\n  <extendSeries>\n  extend(series, {\n      name: options.name,\n      state: NORMAL_STATE,\n      pointAttr: {},\n      visible: options.visible !== false,\n      selected: options.selected === true\n  });\n  </extendSeries>\n\n  <handleEvents>\n  \n  if (useCanVG) {\n      options.animation = false;\n  }\n  \n  events = options.events;\n  for (eventType in events) {\n      addEvent(series, eventType, events[eventType]);\n  }\n  \n  if (\n    (events && events.click) ||\n    (options.point && options.point.events && options.point.events.click) ||\n    options.allowPointSelect\n  ) {\n      chart.runTrackerClick = true;\n  }\n  </handleEvents>\n\n  <initializeData>\n  series.getColor();\n  series.getSymbol();\n  each(series.parallelArrays, function (key) {\n      series[key + 'Data'] = [];\n  });\n  series.setData(options.data, false);\n  </initializeData>\n\n  <configureCartesian>\n  if (series.isCartesian) {\n      chart.hasCartesianSeries = true;\n  }\n  </configureCartesian>\n\n  <updateChartSeries>\n  chartSeries.push(series);\n  series._i = chartSeries.length - 1;\n  stableSort(chartSeries, sortByIndex);\n  if (this.yAxis) {\n      stableSort(this.yAxis.series, sortByIndex);\n  }\n  each(chartSeries, function (series, i) {\n      series.index = i;\n      series.name = series.name || 'Series ' + (i + 1);\n  });\n  </updateChartSeries>\n\n}\n"], ["queryItems", "\nfunction(query) {\n  <retrieveItems>\n  var items = [];\n  for (var i = 0; i < this._store.length; i++) {\n      items.push(JSON.parse(this._store.getItem(this._store.key(i))));\n  }\n  </retrieveItems>\n  <queryResolved>\n  return resolvedPromise(_.query(items, query));\n  </queryResolved>\n}\n"], ["createSandbox", "\nfunction createSandbox(filename, socket) {\n  <initializeEventEmitter>\n  var self = new EventEmitter;\n  var listeners = new WeakMap;\n  </initializeEventEmitter>\n  <setupEventListeners>\n  self.addEventListener = function (type, listener) {\n    if (!listeners.has(listener)) {\n      var facade = function (event) {\n        if (!event.canceled) listener.apply(this, arguments);\n      };\n      listeners.set(listener, facade);\n      self.on(type, facade);\n    }\n  };\n  self.removeEventListener = function (type, listener) {\n    self.removeListener(type, listeners.get(listener));\n  };\n  </setupEventListeners>\n  <configureSandbox>\n  self.__filename = filename;\n  self.__dirname = path.dirname(filename);\n  self.postMessage = function postMessage(data) { message(socket, data); };\n  self.console = console;\n  self.process = process;\n  self.Buffer = Buffer;\n  self.clearImmediate = clearImmediate;\n  self.clearInterval = clearInterval;\n  self.clearTimeout = clearTimeout;\n  self.setImmediate = setImmediate;\n  self.setInterval = setInterval;\n  self.setTimeout = setTimeout;\n  self.module = module;\n  self.global = self;\n  self.self = self;\n  self.require = function (file) {\n    switch (true) {\n      case file === 'workway':\n        return self.workway;\n      case /^[./]/.test(file):\n        file = path.resolve(self.__dirname, file);\n      default:\n        return require(file);\n    }\n  };\n  </configureSandbox>\n  return self;\n}\n"], ["completeOrAbortUpload", "\nfunction () {\n  <finalizeUpload>\n  if (multipartUploadID) {\n    cachedClient.completeMultipartUpload(\n      {\n        Bucket: destinationDetails.Bucket,\n        Key: destinationDetails.Key,\n        UploadId: multipartUploadID,\n        MultipartUpload: {\n          Parts: partIds\n        }\n      },\n      function (err, result) {\n        if (err)\n          abortUpload('Failed to complete the multipart upload on S3: ' + JSON.stringify(err));\n        else {\n          \n          ws.emit('uploaded', result);\n          ws.emit('finish', result);\n          started = false;\n        }\n      }\n    );\n  }\n  </finalizeUpload>\n}\n"], ["readNumber", "\nfunction readNumber(size, bufferReader) {\n  <handleMultipleNumbers>\n  if (size !== 1) {\n    var numbers = new Array(size);\n    for (var i = 0; i < size; i++) {\n      numbers[i] = bufferReader();\n    }\n    return numbers;\n  }\n  </handleMultipleNumbers>\n  <handleSingleNumber>\n  else {\n    return bufferReader();\n  }\n  </handleSingleNumber>\n}\n"], "```"]