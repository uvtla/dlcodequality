[["pkgPropUpd", "\nfunction pkgPropUpd(pd, u, n, r) {\n  var v = null;\n  <determineVersion>\n  if (u && pd.oldVer !== self.version && self.version) {\n    v = self.version;\n  } else if (n && pd.oldVer !== self.next.version && self.next.version) {\n    v = self.next.version;\n  } else if (r && self.prev.version) {\n    v = self.prev.version;\n  }\n  </determineVersion>\n  <updatePackageData>\n  pd.version = v;\n  if (v && !pd.props) {\n    pd.pkg.version = v;\n    pd.propChangeCount++;\n  }\n  </updatePackageData>\n  <updatePropertiesIfPresent>\n  if (pd.props && pd.pkgParent) {\n    pd.props.forEach(function pkgProp(p) {\n      if (pd.pkgParent[p] && (!pd.pkg[p] || pd.pkgParent[p] !== pd.pkg[p])) {\n        pd.pkg[p] = pd.pkgParent[p];\n        pd.propChangeCount++;\n      }\n    });\n  }\n  </updatePropertiesIfPresent>\n  return v;\n}\n"], ["backboneModelSave", "\nfunction(key, value, options) {\n  <prepareAttributes>\n  var attrs, current;\n  if (_.isObject(key) || key == null) {\n    attrs = key;\n    options = value;\n  } else {\n    attrs = {};\n    attrs[key] = value;\n  }\n  options = options ? _.clone(options) : {};\n  </prepareAttributes>\n  <waitOptionValidation>\n  if (options.wait) {\n    if (!this._validate(attrs, options)) return false;\n    current = _.clone(this.attributes);\n  }\n  </waitOptionValidation>\n  <silentAttributeSetting>\n  var silentOptions = _.extend({}, options, {silent: true});\n  if (attrs && !this.set(attrs, options.wait ? silentOptions : options)) {\n    return false;\n  }\n  </silentAttributeSetting>\n  <configureSuccessError>\n  var model = this;\n  var success = options.success;\n  options.success = function(resp, status, xhr) {\n    var serverAttrs = model.parse(resp, xhr);\n    if (options.wait) {\n      delete options.wait;\n      serverAttrs = _.extend(attrs || {}, serverAttrs);\n    }\n    if (!model.set(serverAttrs, options)) return false;\n    if (success) {\n      success(model, resp);\n    } else {\n      model.trigger('sync', model, resp, options);\n    }\n  };\n  options.error = Backbone.wrapError(options.error, model, options);\n  </configureSuccessError>\n  <syncData>\n  var method = this.isNew() ? 'create' : 'update';\n  var xhr = (this.sync || Backbone.sync).call(this, method, this, options);\n  if (options.wait) this.set(current, silentOptions);\n  </syncData>\n  return xhr;\n}\n"], ["isChecked", "\nfunction isChecked(token) {\n  <determineCheckedStatus>\n  var checked = false;\n  if (token.content.indexOf('[x]') === 0 || token.content.indexOf('[X]') === 0) {\n    checked = true;\n  }\n  </determineCheckedStatus>\n  return checked;\n}\n"], ["getServerModule", "\nfunction (id) {\n  <retrieveModule>\n  var m = this.getModule('server-'+id, function (server) {\n    self.e.loadServer(server);\n  });\n  </retrieveModule>\n  <pushServerModule>\n  _serverModules.push(m);\n  </pushServerModule>\n  return m;\n}\n"], ["detectClassMembers", "\nfunction detect_class_members_from_array(cls, ast) {\n  <initializeMembersArray>\n  cls[\"members\"] = [];\n  </initializeMembersArray>\n  <iterateAstElements>\n  return _.each(ast[\"elements\"], function(el) {\n    detect_method_or_property(cls, key_value(el), el, el);\n  });\n  </iterateAstElements>\n}\n"], ["getChangedBits", "\nfunction getChangedBits({ state: prevState }, { state: nextState }) {\n  <calculateBitMask>\n  let mask = 0\n  for (let id in nextState) {\n    if (prevState[id] !== nextState[id]) {\n      mask |= NAME_BITS[id]\n    }\n  }\n  </calculateBitMask>\n  return mask\n}\n"], ["indexOfNode", "\nfunction indexOfNode (host, node) {\n  <searchChildIndex>\n  const chs = host.childNodes;\n  const chsLen = chs.length;\n  for (let a = 0; a < chsLen; a++) {\n    if (chs[a] === node) {\n      return a;\n    }\n  }\n  </searchChildIndex>\n  return -1;\n}\n"], ["fireEvent", "\nfunction(type) {\n  <initialSetup>\n  var typeIncluded = L.isString(type),\n      t = (typeIncluded) ? type : (type && type.type),\n      ce, ret, pre = this._yuievt.config.prefix, ce2,\n      args = (typeIncluded) ? YArray(arguments, 1, true) : arguments;\n  t = (pre) ? _getType(t, pre) : t;\n  this._monitor('fire', t, { \n      args: args \n  });\n  </initialSetup>\n  <getAndSetupEvent>\n  ce = this.getEvent(t, true);\n  ce2 = this.getSibling(t, ce);\n  if (ce2 && !ce) {\n      ce = this.publish(t);\n  }\n  </getAndSetupEvent>\n  <fireOrBubbleEvent>\n  if (!ce) {\n      if (this._yuievt.hasTargets) {\n          return this.bubble({ type: t }, args, this);\n      }\n      ret = true;\n  } else {\n      ce.sibling = ce2;\n      ret = ce.fire.apply(ce, args);\n  }\n  </fireOrBubbleEvent>\n  return (this._yuievt.chain) ? this : ret;\n}\n"], ["executeAction", "\nfunction (parsedAction, trigger, condition, action, combineArray) {\n  if (combineArray === void 0) { combineArray = null; }\n  <checkActionDetached>\n  if (parsedAction.detached)\n      return;\n  </checkActionDetached>\n  <setupActionParameters>\n  var parameters = new Array();\n  var target = null;\n  var propertyPath = null;\n  var combine = parsedAction.combine && parsedAction.combine.length > 0;\n  </setupActionParameters>\n  ...\n  <parseAndRegisterActions>\n  // This block is extensive and repetitive parsing and registering actions, thus not detailed for brevity.\n  </parseAndRegisterActions>\n  ...\n  <addChildActions>\n  for (var i = 0; i < parsedAction.children.length; i++)\n      traverse(parsedAction.children[i], trigger, condition, newAction, null);\n  </addChildActions>\n}\n"], ["bindEventListeners", "\nfunction bindEventListeners(instanceData) {\n  <setupEventHandlersArray>\n  var i, j, type, eventHandlerName, eventHandlerFunctions, moduleBehaviors = getBehaviors(instanceData);\n  </setupEventHandlersArray>\n  <bindEventsLoop>\n  for (i = 0; i < eventTypes.length; i++) {\n    eventHandlerFunctions = [];\n    type = eventTypes[i];\n    eventHandlerName = 'on' + type;\n  </bindEventsLoop>\n  <bindInstanceEventHandlers>\n  if (instanceData.instance[eventHandlerName]) {\n    eventHandlerFunctions.push($.proxy(instanceData.instance[eventHandlerName], instanceData.instance));\n  }\n  </bindInstanceEventHandlers>\n  <bindBehaviorEventHandlers>\n  for (j = 0; j < moduleBehaviors.length; j++) {\n    if (moduleBehaviors[j][eventHandlerName]) {\n      eventHandlerFunctions.push($.proxy(moduleBehaviors[j][eventHandlerName], moduleBehaviors[j]));\n    }\n  }\n  </bindBehaviorEventHandlers>\n  <finalizeBinding>\n  if (eventHandlerFunctions.length) {\n    instanceData.eventHandlers[type] = bindEventType(instanceData.element, type, eventHandlerFunctions);\n  }\n  </finalizeBinding>\n}\n"], "```\n\nThese annotations describe the segments that appear to perform specific, identifiable responsibilities within the larger function, indicating adherence to or violation of the Single Responsibility Principle. Some functions show a clear single focus, while others consist of multiple distinct responsibilities."]