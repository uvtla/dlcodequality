[["typof", "\nfunction typof (v) {\n  var s = Object.prototype.toString.call(v);\n  return s.substring(8, s.length - 1).toLowerCase()\n}\n"], ["applySelectionToTreeViewModel", "\nfunction (oTreeViewModelRules) {\n\t\t\tvar aSelectedRules = storage.getSelectedRules();\n\n\t\t\tif (!aSelectedRules) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tif (!oTreeViewModelRules) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t<updateSelectionInViewModel>\n\t\t\taSelectedRules.forEach(function (oRuleDescriptor) {\n\t\t\t\tObject.keys(oTreeViewModelRules).forEach(function(iKey) {\n\t\t\t\t\toTreeViewModelRules[iKey].nodes.forEach(function(oRule) {\n\t\t\t\t\t\tif (oRule.id === oRuleDescriptor.ruleId) {\n\t\t\t\t\t\t\toRule.selected = oRuleDescriptor.selected;\n\t\t\t\t\t\t\tif (!oRule.selected) {\n\t\t\t\t\t\t\t\toTreeViewModelRules[iKey].selected = false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t});\n\t\t\t</updateSelectionInViewModel>\n\n\t\t\treturn oTreeViewModelRules;\n\t\t}\n"], ["reject", "\nfunction reject(collection, predicate) {\n      var func = isArray(collection) ? arrayFilter : baseFilter;\n      return func(collection, negate(getIteratee(predicate, 3)));\n}\n"], ["uniqArr", "\nfunction uniqArr(arr) {\n    let obj = {};\n\n    arr.forEach(item => obj[item] = true);\n\n    return Object.keys(obj);\n}\n"], ["isBoundingBoxFinite", "\nfunction () {\n        var _min = this.min.array;\n        var _max = this.max.array;\n        return isFinite(_min[0]) && isFinite(_min[1]) && isFinite(_min[2])\n            && isFinite(_max[0]) && isFinite(_max[1]) && isFinite(_max[2]);\n}\n"], ["updateFlagState", "\nfunction(key, state) {\n        <removeFlag>\n        this._removeRemove(this.flags.remove, key);\n        </removeFlag>\n\n        <setOrUpdateFlag>\n        var op = this._getOp(this.flags.set, key);\n        if (op) {\n            op.state = state;\n        } else {\n            this.flags.set.push({key: key, state: state});\n        }\n        </setOrUpdateFlag>\n\n        return this;\n}\n"], ["clickAndWaitSecondaryNavbarList", "\nfunction (config) {\n\t\t\tvar _config = objectAssign({}, { wait: true }, config);\n\t\t\t<clickNavbarList>\n\t\t\tif (_config.list) {\n\t\t\t\tthis.click(this.getSecondaryNavbarListElement({ list: _config.list }));\n\t\t\t} else {\n\t\t\t\tthrow new Error('adminUIApp:must specify a navbar list!');\n\t\t\t}\n\t\t\t</clickNavbarList>\n\n\t\t\t<waitForListScreen>\n\t\t\tif (_config.wait) this.waitForListScreen();\n\t\t\t</waitForListScreen>\n\n\t\t\treturn this;\n\t\t}\n"], ["updateAnimatedTilesets", "\nfunction (dt) {\n            if (this.isAnimated) {\n                var result = false;\n                <updateAllAnimatedTilesets>\n                for (var i = 0; i < this.animatedTilesets.length; i++) {\n                    result = this.animatedTilesets[i].update(dt) || result;\n                }\n                </updateAllAnimatedTilesets>\n                return result;\n            }\n\n            return false;\n        }\n"], ["fixIsSpentFlag", "\nfunction fixIsSpentFlag(onDone){\n\t<queryOutputs>\n\tdb.query(\n\t\t\"SELECT outputs.unit, outputs.message_index, outputs.output_index \\n\\\n\t\tFROM outputs \\n\\\n\t\tCROSS JOIN inputs ON outputs.unit=inputs.src_unit AND outputs.message_index=inputs.src_message_index AND outputs.output_index=inputs.src_output_index \\n\\\n\t\tWHERE is_spent=0 AND type='transfer'\",\n\t\tfunction(rows){\n\t\t\tconsole.log(rows.length+\" previous outputs appear to be spent\");\n\t\t\tif (rows.length === 0)\n\t\t\t\treturn onDone();\n\t\t\tvar arrQueries = [];\n\t\t\trows.forEach(function(row){\n\t\t\t\tconsole.log('fixing is_spent for output', row);\n\t\t\t\tdb.addQuery(arrQueries, \n\t\t\t\t\t\"UPDATE outputs SET is_spent=1 WHERE unit=? AND message_index=? AND output_index=?\", [row.unit, row.message_index, row.output_index]);\n\t\t\t});\n\t\t\tasync.series(arrQueries, onDone);\n\t\t}\n\t);\n\t</queryOutputs>\n}\n"], ["onEvent", "\nfunction onEvent(data) {\n\tvar type = data.type;\n\n\t<logEvent>\n\tdebug('onEvent() | [type:%s, data:%o]', type, data);\n\t</logEvent>\n\n\t<handleEventStateChange>\n\tswitch (type) {\n\t\tcase 'statechange':\n\t\t\tthis.readyState = data.readyState;\n\t\t\tthis._enabled = data.enabled;\n\n\t\t\tswitch (data.readyState) {\n\t\t\t\tcase 'initializing':\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'live':\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'ended':\n\t\t\t\t\tthis._ended = true;\n\t\t\t\t\tthis.dispatchEvent(new Event('ended'));\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'failed':\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t}\n\t</handleEventStateChange>\n}\n"], ""]