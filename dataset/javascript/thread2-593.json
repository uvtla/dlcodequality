[["processSync", "\nfunction processSync(filename, content, updater, format) {\n  var text = String(content);\n\n  <parseContent>\n  var ast = esprima.parse(text, {\n    loc    : true,\n    comment: true,\n    source : filename\n  });\n  </parseContent>\n\n  <orderAstNodes>\n  var sorted = orderNodes(ast);\n  </orderAstNodes>\n\n  <associateCommentsWithNodes>\n  associateComments(ast, sorted);\n  </associateCommentsWithNodes>\n\n  <prepareSourcemap>\n  var converter     = convert.fromSource(text);\n  var originalMap   = converter && converter.toObject();\n  var sourceContent = text;\n  if (originalMap) {\n    sourcemapToAst(ast, originalMap);\n    sourceContent = originalMap.sourcesContent[0];\n  }\n  </prepareSourcemap>\n\n  <updateAst>\n  var updated = ((typeof updater === 'function') && updater(filename, ast)) || ast;\n  </updateAst>\n\n  <generateCode>\n  var pair = codegen.generate(updated, {\n    sourceMap        : true,\n    sourceMapWithCode: true,\n    format           : format || {}\n  });\n  </generateCode>\n\n  <setSourceContent>\n  var posixPath = filename.replace(/\\\\/g, '/');\n  pair.map.setSourceContent(posixPath, sourceContent);\n  </setSourceContent>\n\n  <generateMapComment>\n  var mapComment = convert.fromJSON(pair.map.toString()).toComment();\n  </generateMapComment>\n\n  <returnCodeWithComment>\n  return pair.code + mapComment;\n  </returnCodeWithComment>\n}\n"], ["isControlMethod", "\nfunction (methodName) {\n  var val = this.prototype[methodName],\n      type = typeof val;\n\n  return (methodName !== 'constructor') &&\n  (type === \"function\" || (type === \"string\" && (typeof this.prototype[val] === \"function\") )) &&\n  !! (Control.isSpecial(methodName) || processors[methodName] || /[^\\w]/.test(methodName));\n}\n"], ["compileMustache", "\nfunction(mustache, program, inverse) {\n  var params = mustache.params;\n  this.pushParams(params);\n\n  this.opcode('pushProgram', program);\n  this.opcode('pushProgram', inverse);\n\n  if(mustache.hash) {\n    this.hash(mustache.hash);\n  } else {\n    this.opcode('pushLiteral', '{}');\n  }\n\n  return params;\n}\n"], ["addMapsToModule", "\nfunction( maps ){\n  maps.forEach(function(map){\n    if(map && map.root && map.name && map.properties){\n    modules.maps[map.name] = JSON.parse(JSON.stringify(map));\n    }\n  });\n}\n"], ["isRenderMethod", "\nfunction isRenderMethod (props) {\n  return props.some((prop) => {\n    return prop.key.name === 'key' && prop.value.value === 'render'\n  }) && props.some((prop) => {\n    return prop.key.name === 'value' && t.isFunctionExpression(prop.value)\n  })\n}\n"], ["showDiff", "\nfunction showDiff(acediff, editor, startLine, endLine, className) {\n  var editor = acediff.editors[editor];\n\n  if (endLine < startLine) { \n    endLine = startLine;\n  }\n\n  const classNames = `${className} ${(endLine > startLine) ? 'lines' : 'targetOnly'}`;\n  endLine--; \n\n  <addMarkerToEditor>\n  editor.markers.push(editor.ace.session.addMarker(new Range(startLine, 0, endLine, 1), classNames, 'fullLine'));\n  </addMarkerToEditor>\n}\n"], ["generateAuthSignature", "\nfunction(publicKey, privateKey) {\n  var ts = new Date() / 1000 | 0;\n  return {\n    <timestampAndSignature>\n    ts: ts,\n    api_sig: crypto.createHmac('sha1', privateKey).update(ts.toString()).digest('hex'),\n    </timestampAndSignature>\n    <apiKey>\n    api_key: publicKey\n    </apiKey>\n  };\n}\n"], ["updateSweetAlertModal", "\nfunction setParameters(params) {\n  var modal = getModal();\n  var $title = modal.querySelector('h2'),\n      $text = modal.querySelector('p'),\n      $cancelBtn = modal.querySelector('button.cancel'),\n      $confirmBtn = modal.querySelector('button.confirm');\n\n  <setTitle>\n  $title.innerHTML = escapeHtml(params.title).split(\"\\n\").join(\"<br>\");\n  </setTitle>\n\n  <setText>\n  $text.innerHTML = escapeHtml(params.text || '').split(\"\\n\").join(\"<br>\");\n  if (params.text) {\n    show($text);\n  }\n  </setText>\n\n  <applyCustomClass>\n  if (params.customClass) {\n    addClass(modal, params.customClass);\n  }\n  </applyCustomClass>\n\n  <setupAlertTypeAndVisibility>\n  hide(modal.querySelectorAll('.icon'));\n  if (params.type) {\n    var validType = false;\n    for (var i = 0; i < alertTypes.length; i++) {\n      if (params.type === alertTypes[i]) {\n        validType = true;\n        break;\n      }\n    }\n    if (!validType) {\n      window.console.error('Unknown alert type: ' + params.type);\n      return false;\n    }\n    var $icon = modal.querySelector('.icon.' + params.type);\n    show($icon);\n\n    <animateIcon>\n    switch (params.type) {\n      case \"success\":\n        addClass($icon, 'animate');\n        addClass($icon.querySelector('.tip'), 'animateSuccessTip');\n        addClass($icon.querySelector('.long'), 'animateSuccessLong');\n        break;\n      case \"error\":\n        addClass($icon, 'animateErrorIcon');\n        addClass($icon.querySelector('.x-mark'), 'animateXMark');\n        break;\n      case \"warning\":\n        addClass($icon, 'pulseWarning');\n        addClass($icon.querySelector('.body'), 'pulseWarningIns');\n        addClass($icon.querySelector('.dot'), 'pulseWarningIns');\n        break;\n    }\n    </animateIcon>\n\n  </setupAlertTypeAndVisibility>\n\n  <setupCustomImageIcon>\n  if (params.imageUrl) {\n    var $customIcon = modal.querySelector('.icon.custom');\n\n    $customIcon.style.backgroundImage = 'url(' + params.imageUrl + ')';\n    show($customIcon);\n\n    var _imgWidth  = 80,\n        _imgHeight = 80;\n\n    if (params.imageSize) {\n      var imgWidth  = params.imageSize.split('x')[0];\n      var imgHeight = params.imageSize.split('x')[1];\n\n      if (!imgWidth || !imgHeight) {\n        window.console.error(\"Parameter imageSize expects value with format WIDTHxHEIGHT, got \" + params.imageSize);\n      } else {\n        _imgWidth  = imgWidth;\n        _imgHeight = imgHeight;\n\n        $customIcon.css({\n          'width': imgWidth + 'px',\n          'height': imgHeight + 'px'\n        });\n      }\n    }\n    $customIcon.setAttribute('style', $customIcon.getAttribute('style') + 'width:' + _imgWidth + 'px; height:' + _imgHeight + 'px');\n  }\n  </setupCustomImageIcon>\n\n  <setupButtonsAndAllowOutsideClick>\n  modal.setAttribute('data-has-cancel-button', params.showCancelButton);\n  if (params.showCancelButton) {\n    $cancelBtn.style.display = 'inline-block';\n  } else {\n    hide($cancelBtn);\n  }\n\n  if (params.cancelButtonText) {\n    $cancelBtn.innerHTML = escapeHtml(params.cancelButtonText);\n  }\n  if (params.confirmButtonText) {\n    $confirmBtn.innerHTML = escapeHtml(params.confirmButtonText);\n  }\n\n  $confirmBtn.style.backgroundColor = params.confirmButtonColor;\n\n  setFocusStyle($confirmBtn, params.confirmButtonColor);\n\n  modal.setAttribute('data-allow-ouside-click', params.allowOutsideClick);\n  </setupButtonsAndAllowOutsideClick>\n\n  <miscellaneousModalAttributes>\n  var hasDoneFunction = (params.doneFunction) ? true : false;\n  modal.setAttribute('data-has-done-function', hasDoneFunction);\n\n  modal.setAttribute('data-timer', params.timer);\n  </miscellaneousModalAttributes>\n}\n"], ["modifySeriesAndLegend", "\nfunction (chart) {\n  var series = this,\n      valueDecimals = chart.options.legend.valueDecimals,\n      legendItems = [],\n      name,\n      from,\n      to,\n      fromLabel,\n      toLabel,\n      colorRange,\n      valueRanges,\n      gradientColor,\n      grad,\n      tmpLabel,\n      horizontal = chart.options.legend.layout === 'horizontal';\n\n  <initSeries>\n  Highcharts.Series.prototype.init.apply(this, arguments);\n  </initSeries>\n  <handleColorRangeAndValueRanges>\n  colorRange = series.options.colorRange;\n  valueRanges = series.options.valueRanges;\n\n  if (valueRanges) {\n    <addValueRangesToLegendItems>\n    each(valueRanges, function (range) {\n      from = range.from;\n      to = range.to;\n      \n      \n      name = '';\n      if (from === UNDEFINED) {\n        name = '< ';\n      } else if (to === UNDEFINED) {\n        name = '> ';\n      }\n      if (from !== UNDEFINED) {\n        name += numberFormat(from, valueDecimals);\n      }\n      if (from !== UNDEFINED && to !== UNDEFINED) {\n        name += ' - ';\n      }\n      if (to !== UNDEFINED) {\n        name += numberFormat(to, valueDecimals);\n      }\n      \n      \n      legendItems.push(Highcharts.extend({\n        chart: series.chart,\n        name: name,\n        options: {},\n        drawLegendSymbol: seriesTypes.area.prototype.drawLegendSymbol,\n        visible: true,\n        setState: function () {},\n        setVisible: function () {}\n      }, range));\n    });\n    </addValueRangesToLegendItems>\n    <setSeriesLegendItems>\n    series.legendItems = legendItems;\n    </setSeriesLegendItems>\n\n  } else if (colorRange) {\n    <handleColorRangeGradient>\n    from = colorRange.from;\n    to = colorRange.to;\n    fromLabel = colorRange.fromLabel;\n    toLabel = colorRange.toLabel;\n\n    \n    grad = horizontal ? [0, 0, 1, 0] : [0, 1, 0, 0]; \n    if (!horizontal) {\n      tmpLabel = fromLabel;\n      fromLabel = toLabel;\n      toLabel = tmpLabel;\n    } \n\n    \n    gradientColor = {\n      linearGradient: { x1: grad[0], y1: grad[1], x2: grad[2], y2: grad[3] },\n      stops: \n      [\n        [0, from],\n        [1, to]\n      ]\n    };\n\n    \n    legendItems = [{\n      chart: series.chart,\n      options: {},\n      fromLabel: fromLabel,\n      toLabel: toLabel,\n      color: gradientColor,\n      drawLegendSymbol: this.drawLegendSymbolGradient,\n      visible: true,\n      setState: function () {},\n      setVisible: function () {}\n    }];\n    </handleColorRangeGradient>\n    <setSeriesLegendItemsGradient>\n    series.legendItems = legendItems;\n    </setSeriesLegendItemsGradient>\n  }\n  </handleColorRangeAndValueRanges>\n}\n"], ["getNearbyPlaces", "\nfunction getNearby() {\n  \n  if (nearbyPlaces)\n    return;\n\n  <logInitialRequest>\n  logResponse(\"[getNearby] get nearby data.\");\n  </logInitialRequest>\n\n  <getCurrentLocation>\n  navigator.geolocation.getCurrentPosition(function(location) {\n    \n    <logLocationResult>\n    logResponse(location);\n    </logLocationResult>\n\n    <requestNearbyPlaces>\n    $.ajax({\n        url: '/search',\n        data: {\n            type: 'place',\n            q: 'restaurant',\n            center: location.coords.latitude + ',' + location.coords.longitude,\n            distance: 1000,\n            fields: 'id,name,picture'\n        }\n    }).success(function (response) {\n        nearbyPlaces = response.data;\n        logResponse(nearbyPlaces);\n        displayPlaces(nearbyPlaces);\n    }).error(function(err) {\n        logResponse(\"Error fetching nearby place data.\");\n    });\n    </requestNearbyPlaces>\n  });\n  </getCurrentLocation>\n}\n"], ""]