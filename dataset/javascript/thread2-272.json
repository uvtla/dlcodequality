[["addToWorkingSet", "\nfunction addToWorkingSet(file, index, forceRedraw) {\n    DeprecationWarning.deprecationWarning(\"Use MainViewManager.addToWorkingSet() instead of DocumentManager.addToWorkingSet()\", true);\n    MainViewManager.addToWorkingSet(MainViewManager.ACTIVE_PANE, file, index, forceRedraw);\n}\n"], ["fetchDeviceInfo", "\nasync function fetchDeviceInfo(){\n\n    <executeNodeInfoCommand>\n    let {response} = await _virtualTerminal.executeCommand(_luaCommandBuilder.command.nodeInfo);\n    </executeNodeInfoCommand>\n\n    <processResponse>\n    const p = response.replace(/\\s+/gi, '-').split('-');\n    </processResponse>\n\n    \n    if (p.length === 8){\n        <buildEsp8266Response>\n        return {\n            version: p[0] + '.' + p[1] + '.' + p[2],\n            arch: 'esp8266',\n            chipID: parseInt(p[3]).toString(16),\n            flashID: parseInt(p[4]).toString(16),\n            flashsize: p[5] + 'kB',\n            flashmode: p[6],\n            flashspeed: parseInt(p[7]) / 1000000 + 'MHz'\n        };\n        </buildEsp8266Response>\n\n    \n    }else{\n        <executeChipIdCommand>\n        try{\n            ({response} = await _virtualTerminal.executeCommand(_luaCommandBuilder.command.chipid));\n        }\n        </executeChipIdCommand>\n\n        <processChipIdResponse>\n        const chipid = response.match(/^0x(\\w+)/);\n\n        if (chipid){\n            <buildEsp32Response>\n            return {\n                version: 'unknown',\n                arch: 'esp32',\n                chipID: chipid[1],\n                flashID: 'unknown',\n                flashsize: 'unknown',\n                flashmode:'unknown',\n                flashspeed: 'unknown'\n            };\n            </buildEsp32Response>\n        }else{\n            <throwChipIdError>\n            throw new Error('Invalid node.chipid() Response: ' + response);\n            </throwChipIdError>\n        }\n        </processChipIdResponse>\n\n        <catchChipIdError>\n        }catch(e){\n            _logger.debug(e);\n            throw new Error('Invalid node.chipid() Response: ' + response);\n        }\n        </catchChipIdError>\n    }\n}\n"], ["archive", "\nfunction archive(cb) {\n  <getClient>\n  db.getClient(function(err, client, done) {\n    <queryDatabase>\n    client.query(qb.select() + ' WHERE published = true', function(err, r) {\n      if(err) {\n        <handleError>\n        cb(err);\n        done(err);\n        </handleError>\n      } else {\n        <sendResults>\n        cb(null, r.rows);\n        done();\n        </sendResults>\n      }\n    });\n    </queryDatabase>\n  });\n  </getClient>\n}\n"], ["onClientError", "\nfunction onClientError(err) {\n    \n    if ((err || {}).errno !== 'ECONNRESET') {\n      <logAndEmitError>\n      log.error('An unhandled error occured when searching for the root DSE at \"%s\". Error: %j', url, err);\n      if (hasEvents.call(self, 'error')) self.emit('error', err)\n      </logAndEmitError>\n    }\n  }\n"], ["setEnvVariable", "\nfunction set(path, value, opts) {\n  <setDefaultOptions>\n  if (typeof opts === 'undefined') {\n    opts = {};\n  }\n  </setDefaultOptions>\n\n  <envVariableFormatting>\n  let env = toUnderscore(path);\n  if (!opts.caseSensitive) {\n    env = env.toUpperCase();\n  }\n  </envVariableFormatting>\n\n  <deleteThenSetEnvVariable>\n  del(path, opts);\n  process.env[env] = stringify(value, opts);\n  </deleteThenSetEnvVariable>\n}\n"], ["AdapterJsRTCObjectFactory", "\nfunction AdapterJsRTCObjectFactory(logger) {\n\n    Utils.checkArguments(arguments, 1);\n\n    this.createIceServers = function (urls, username, password) {\n        <iceServersFactory>\n        if (typeof(createIceServers) !== \"undefined\") {\n            return createIceServers(urls, username, password);\n        }\n        else {\n            logger.error(\"adapter.js not present or unsupported browser!\");\n            return null;\n        }\n        </iceServersFactory>\n    };\n\n    this.createRTCSessionDescription = function (sessionDescriptionString) {\n        <RTCSessionDescriptionFactory>\n        if (typeof(RTCSessionDescription) !== \"undefined\") {\n            return new RTCSessionDescription(sessionDescriptionString);\n        }\n        else {\n            logger.error(\"adapter.js not present or unsupported browser!\");\n            return null;\n        }\n        </RTCSessionDescriptionFactory>\n    };\n\n    this.createRTCIceCandidate = function (rtcIceCandidateString) {\n        <RTCIceCandidateFactory>\n        if (typeof(RTCIceCandidate) !== \"undefined\") {\n            return new RTCIceCandidate(rtcIceCandidateString);\n        }\n        else {\n            logger.error(\"adapter.js not present or unsupported browser!\");\n            return null;\n        }\n        </RTCIceCandidateFactory>\n    };\n\n    this.createRTCPeerConnection = function (config) {\n        <RTCPeerConnectionFactory>\n        if (typeof(RTCPeerConnection) !== \"undefined\") {\n            return new RTCPeerConnection(config);\n        }\n        else {\n            logger.error(\"adapter.js not present or unsupported browser!\");\n            return null;\n        }\n        </RTCPeerConnectionFactory>\n    };\n}\n"], ["calculateSegmentLength", "\nfunction(t, opt) {\n\n            var segments = this.segments;\n            <validateSegments>\n            var numSegments = segments.length;\n            if (numSegments === 0) return 0; \n            </validateSegments>\n\n            <initializeSegmentIndex>\n            var segmentIndex = t.segmentIndex;\n            if (segmentIndex < 0) return 0; \n            </initializeSegmentIndex>\n\n            <clampTValue>\n            var tValue = t.value;\n            if (segmentIndex >= numSegments) {\n                segmentIndex = numSegments - 1;\n                tValue = 1;\n            }\n            else if (tValue < 0) tValue = 0;\n            else if (tValue > 1) tValue = 1;\n            </clampTValue>\n\n            <setDefaultOptions>\n            opt = opt || {};\n            var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n            var segmentSubdivisions = (opt.segmentSubdivisions === undefined) ? this.getSegmentSubdivisions({ precision: precision }) : opt.segmentSubdivisions;\n            </setDefaultOptions>\n            \n\n            <calculateLength>\n            var subdivisions;\n            var length = 0;\n            for (var i = 0; i < segmentIndex; i++) {\n\n                <computeSegmentLength>\n                var segment = segments[i];\n                subdivisions = segmentSubdivisions[i];\n                length += segment.length({ precisison: precision, subdivisions: subdivisions });\n                </computeSegmentLength>\n            }\n\n            <computeLengthAtT>\n            segment = segments[segmentIndex];\n            subdivisions = segmentSubdivisions[segmentIndex];\n            length += segment.lengthAtT(tValue, { precisison: precision, subdivisions: subdivisions });\n            </computeLengthAtT>\n            </calculateLength>\n\n            return length;\n        }\n"], ["extractStateDefinitions", "\nfunction extractStateDefinitions (contractName, sourcesList, contracts) {\n  <initializeContracts>\n  if (!contracts) {\n    contracts = extractContractDefinitions(sourcesList)\n  }\n  </initializeContracts>\n  <findContractNode>\n  var node = contracts.contractsByName[contractName]\n  </findContractNode>\n\n  if (node) {\n    <collectStateItems>\n    var stateItems = []\n    var stateVar = []\n    var baseContracts = getLinearizedBaseContracts(node.id, contracts.contractsById)\n    baseContracts.reverse()\n    for (var k in baseContracts) {\n      var ctr = baseContracts[k]\n      for (var i in ctr.children) {\n        var item = ctr.children[i]\n        stateItems.push(item)\n        if (item.name === 'VariableDeclaration') {\n          stateVar.push(item)\n        }\n      }\n    }\n    </collectStateItems>\n\n    <returnStateDefinitions>\n    return {\n      stateDefinitions: stateItems,\n      stateVariables: stateVar\n    }\n    </returnStateDefinitions>\n  }\n  return null\n}\n"], ["generateNavGrid", "\nfunction generateNavGrid(domNodeWrapperList, domNode, widget, onClick, showOutline) {\n\t\tif(isPad){\n\t\t\treturn;\n\t\t}\n\t\tif(!domNodeWrapperList){\n\t\t\treturn;\n\t\t}\n\t\t<addToDomNodeWrapperList>\n\t\tdomNodeWrapperList.push({domNode: domNode});\n\t\t</addToDomNodeWrapperList>\n\n\t\t<applyOutline>\n\t\tif (!showOutline) {\n\t\t\tdomNode.style.outline = \"none\"; \n\t\t}\n\t\t</applyOutline>\n\n\t}\n"], ["setCheckboxState", "\nfunction setCheckboxState(page, ph, selectorAndState, callback) {\n    <evaluatePage>\n    page.evaluate(function (selectorAndState) {\n        try {\n            <getSelectorAndState>\n            var selector = selectorAndState[0];\n            var state = selectorAndState[1];\n            </getSelectorAndState>\n\n            <updateCheckbox>\n            var element = document.querySelector(selector);\n            element.checked = state;\n            </updateCheckbox>\n\n            <dispatchChangeEvent>\n            var event = document.createEvent('Event');\n            event.initEvent('change', true, false);\n            element.dispatchEvent(event);\n            </dispatchChangeEvent>\n\n            return null;\n        } catch (error) {\n            return error;\n        }\n    }, <handleEvaluation>\n    function (error) {\n        \n        if (error) {\n            callback(error, page, ph);\n            return;\n        }\n        callback(null, page, ph);\n    </handleEvaluation>, selectorAndState);\n}\n"], "\n```"]