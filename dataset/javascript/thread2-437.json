[["hex", "\nfunction hex(s) {\n  var m = /rgba?\\((\\d+), (\\d+), (\\d+)/.exec(s),\n    c = s.split(\"\");\n  if (m) {\n    <convertRGBtoHex>\n    s = ( m[1] << 16 | m[2] << 8 | m[3] ).toString(16);\n    while (s.length < 6)\n      s = \"0\" + s;\n    </convertRGBtoHex>\n  }\n  return \"#\" + (s.length == 6 ? s : c[1] + c[1] + c[2] + c[2] + c[3] + c[3]);\n}\n"], ["resolveByPlugin", "\nfunction resolveByPlugin(plugin, from, id) {\n\tif (plugin.exports && plugin.exports.normalize) {\n\t\treturn plugin.exports.normalize(id, resolveId.bind(null, from));\n\t}\n\treturn resolveId(from, id);\n}\n"], ["functionQueueCount", "\n<initialize>\nfunction(queueCount) {\n    var self = this;\n    this.queueCount = queueCount;\n    this.emitter = new EventEmitter();\n    this.processedCount = 0;\n\n    if(undefined === queueCount) {\n        this.queueCount = 1;\n    }\n</initialize>\n\n<eventListener>\n    this.emitter.on(\"done\", function(queueId, debugStr) {\n        queueId = parseInt(queueId);\n        if(isNaN(queueId)) return;\n        if(queueId >= self.queueCount || queueId < 0) return;\n\n        if(debugStr) {\n            <debug>\n            var logStr = \"( Done: \";\n            for(var i = 0; i < self.queue.length; i++) {\n                if(i !== 0) logStr += \", \";\n                logStr += \"[\" + self.queue[i].length + \"]\";\n            }\n            logStr += \" )\";\n            console.log(logStr);\n            </debug>\n        }\n\n        nextTick(function() {\n            self._runTask(queueId);\n        });\n    });\n</eventListener>\n\n<setQueues>\n    this.queue = [];\n    this.running = [];\n    for(var i = 0; i < this.queueCount; i++) {\n        this.queue.push([]);\n        this.running.push(false);\n    }\n</setQueues>\n\n<setupCleanup>\n    this.afterFinishCount = -1;\n    this.afterFinishLoop = false;\n    this.afterFinishProcessor = undefined;\n</setupCleanup>\n}\n"], ["initRead", "\nfunction initRead (reader, file) {\n  <setInitialValues>\n    if (reader.readyState === FileReader.LOADING) {\n        throw new FileError(FileError.INVALID_STATE_ERR);\n    }\n\n    reader._result = null;\n    reader._error = null;\n    reader._progress = 0;\n    reader._readyState = FileReader.LOADING;\n  </setInitialValues>\n\n  <handleLocalURL>\n    if (typeof file.localURL === 'string') {\n        reader._localURL = file.localURL;\n    } else {\n        reader._localURL = '';\n        return true;\n    }\n  </handleLocalURL>\n\n  <triggerOnloadstart>\n    if (reader.onloadstart) {\n        reader.onloadstart(new ProgressEvent('loadstart', {target: reader}));\n    }\n  </triggerOnloadstart>\n}\n"], ["forwardSearch", "\nfunction forwardSearch() {\n  <searchSetup>\n      cameFrom = open1Set.pop();\n      if (cameFrom.closed) {\n        return;\n      }\n\n      cameFrom.closed = true;\n  </searchSetup>\n\n  <evaluateNode>\n      if (cameFrom.f1 < lMin && (cameFrom.g1 + f2 - heuristic(from, cameFrom.node)) < lMin) {\n        graph.forEachLinkedNode(cameFrom.node.id, forwardVisitor);\n      }\n  </evaluateNode>\n\n  <updateOpenSet>\n      if (open1Set.length > 0) {\n        f1 = open1Set.peek().f1;\n      } \n  </updateOpenSet>\n}\n"], ["buildSchema", "\nfunction buildSchema(models, typeMap) {\n  let type;\n\n  <mapAndReduceModels>\n  var _models$map$reduce = models.map(model => {\n    type = typeMap[model.modelName];\n    return {\n      query: (0, _buildQuery2.default)(model, type),\n      mutation: (0, _buildMutation2.default)(model, type)\n    };\n  }).reduce((fields, modelField) => {\n    fields.query = (0, _assign2.default)({}, fields.query, modelField.query);\n    fields.mutation = (0, _assign2.default)({}, fields.mutation, modelField.mutation);\n    return fields;\n  }, { query: {}, mutation: {} });\n  </mapAndReduceModels>\n\n  <extractQueriesAndMutations>\n  const query = _models$map$reduce.query;\n  const mutation = _models$map$reduce.mutation;\n  </extractQueriesAndMutations>\n\n  return {\n    query: query,\n    mutation: mutation\n  };\n}\n"], ["linkProcessingFunction", "\nfunction(element) {\n  <queryAllLinks>\n  var links = element.querySelectorAll(\"a.xref, a.link, area\"),\n      i,\n      link,\n      href,\n      startsWithHash,\n      startsWithHTTP;\n  </queryAllLinks>\n\n  <processEachLink>\n  for (i = 0; i < links.length; i++) {\n    link = links[i];\n    href = link.getAttribute(\"href\");\n    startsWithHash = href.indexOf(\"#\") == 0;\n    startsWithHTTP = href.indexOf(\"http\") == 0;\n  </processEachLink>\n\n  <setExternalTargets>\n    if (startsWithHTTP) {\n      link.setAttribute('target', '_blank');\n    }\n  </setExternalTargets>\n\n  <continueIfNotHTTPorHash>\n    if (startsWithHTTP || startsWithHash) {\n      continue;\n    }\n  </continueIfNotHTTPorHash>\n\n  <rewriteHref>\n    if (href.indexOf(\"/docs/api/\") > -1) {\n      href = href.substr(0, href.lastIndexOf(\".html\"));\n      href = href.substr(href.lastIndexOf('/') + 1);\n      href = \"#/api/\" + href;\n    } else if (href.indexOf(\"explored.html\") > -1) { \n      href = href.split(\"../\").join(\"\");\n      href = oConfig.exploredURI + href;\n    } else { \n      href = href.substr(0, href.lastIndexOf(\".html\"));\n      href = \"#/topic/\" + href;\n    }\n  </rewriteHref>\n\n  <updateLinkHref>\n    link.setAttribute(\"href\", href);\n  </updateLinkHref>\n}\n"], ["convertLegacyPluginSchema", "\nfunction convertLegacyPluginSchema(schema) {\n  <initializeResult>\n    var result = {properties: {}, type: 'object'};\n  </initializeResult>\n\n  <processSchemaFields>\n    Object.keys(schema.fields).forEach(function (propertyName) {\n      result.properties[propertyName] = {\n        type: schema.fields[propertyName].type\n      };\n      if (schema.fields[propertyName].enum) {\n        result.properties[propertyName].enum = schema.fields[propertyName].enum;\n      }\n      if (schema.fields[propertyName].hasOwnProperty('default')) {\n        result.properties[propertyName].default = schema.fields[propertyName].default;\n      }\n      if (schema.fields[propertyName].hasOwnProperty('required')) {\n        result.properties[propertyName].required = schema.fields[propertyName].required;\n      }\n      if (result.properties[propertyName].type === 'table') {\n        <handleTableType>\n        result.properties[propertyName].type = 'object';\n        if (schema.fields[propertyName].schema.flexible) {\n          result.properties[propertyName].additionalProperties = convertLegacyPluginSchema(schema.fields[propertyName].schema);\n        } else {\n          result.properties[propertyName].properties = convertLegacyPluginSchema(schema.fields[propertyName].schema).properties;\n        }\n        </handleTableType>\n      }\n\n      <handleArrayType>\n      if (result.properties[propertyName].type === 'array') {\n        result.properties[propertyName].items = {type: 'string'}\n      }\n      </handleArrayType>\n    });\n  </processSchemaFields>\n\n  return result;\n}\n"], ["initializeCommands", "\nfunction initializeCommands() {\n  <getPreferences>\n    var prefs = getPreferences();\n  </getPreferences>\n\n  <registerCommands>\n    CommandManager.register(Strings.CMD_FILE_CLOSE_BELOW, closeBelow, function () {\n        handleClose(closeBelow);\n    });\n    CommandManager.register(Strings.CMD_FILE_CLOSE_OTHERS, closeOthers, function () {\n        handleClose(closeOthers);\n    });\n    CommandManager.register(Strings.CMD_FILE_CLOSE_ABOVE, closeAbove, function () {\n        handleClose(closeAbove);\n    });\n  </registerCommands>\n\n  <updateMenuItems>\n    if (prefs.closeBelow) {\n        workingSetListCmenu.addMenuItem(closeBelow, \"\", Menus.AFTER, Commands.FILE_CLOSE);\n    }\n    if (prefs.closeOthers) {\n        workingSetListCmenu.addMenuItem(closeOthers, \"\", Menus.AFTER, Commands.FILE_CLOSE);\n    }\n    if (prefs.closeAbove) {\n        workingSetListCmenu.addMenuItem(closeAbove, \"\", Menus.AFTER, Commands.FILE_CLOSE);\n    }\n    menuEntriesShown = prefs;\n  </updateMenuItems>\n}\n"], ["createIconFiles", "\nfunction (options, dir, callback) {\n  <iterateIcons>\n    async.forEachOf(options.icon, function (icon, resolution, callback) {\n      <constructIconFilePath>\n      var iconFile = path.join(dir, 'share/icons/hicolor', resolution, 'apps', options.id + '.png')\n      </constructIconFilePath>\n      \n      options.logger('Creating icon file at ' + iconFile)\n\n      <copyIconFile>\n      fs.copy(icon, iconFile, callback)\n      </copyIconFile>\n    }, function (err) {\n      <errorHandling>\n      callback(err && new Error('Error creating icon file: ' + (err.message || err)))\n      </errorHandling>\n    })\n  </iterateIcons>\n}\n"], "```"]