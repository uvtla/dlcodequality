[["ScreenImage_constructor", "\nfunction (screenOffset, imageSource) {\n    <ArgumentValidation>\n    if (!screenOffset) {\n        throw new ArgumentError(\n            Logger.logMessage(Logger.LEVEL_SEVERE, \"ScreenImage\", \"constructor\", \"missingOffset\"));\n    }\n    if (!imageSource) {\n        throw new ArgumentError(\n            Logger.logMessage(Logger.LEVEL_SEVERE, \"ScreenImage\", \"constructor\", \"missingImage\"));\n    }\n    </ArgumentValidation>\n\n    <BaseClassSetup>\n    Renderable.call(this);\n    </BaseClassSetup>\n\n    <PropertyInitialization>\n    this.screenOffset = screenOffset;\n    this._imageSource = imageSource;\n    this.imageColor = Color.WHITE;\n    this.imageOffset = new Offset(WorldWind.OFFSET_FRACTION, 0.5, WorldWind.OFFSET_FRACTION, 0.5);\n    this.imageScale = 1;\n    this.imageRotation = 0;\n    this.imageTilt = 0;\n    this.enabled = true;\n    this.opacity = 1;\n    this.pickDelegate = null;\n    this.activeTexture = null;\n    this.imageTransform = Matrix.fromIdentity();\n    this.texCoordMatrix = Matrix.fromIdentity();\n    this.imageBounds = null;\n    this.layer = null;\n    </PropertyInitialization>\n}\n"], ["deserializeProperty", "\nfunction deserializeProperty (bunsenId, value, bunsenModel) {\n  <SubModelRetrieval>\n  const subModel = getSubModel(bunsenModel, bunsenId)\n  </SubModelRetrieval>\n\n  <DeserializationLogic>\n  switch (subModel.type) {\n    case 'integer':\n      return parseInt(value)\n    case 'number':\n      return parseFloat(value)\n    default:\n      return value\n  }\n  </DeserializationLogic>\n}\n"], ["line_number", "\nfunction line_number(index, source) {\n  var i = start_index;\n  var count = 0;\n  <CharIterationAndCount>\n  while (i < index) {\n    if (source[i] === \"\\n\") {\n      count++;\n    }\n    i++;\n  }\n  </CharIterationAndCount>\n\n  <LineNumberAdjustment>\n  start_linenr = count + start_linenr;\n  start_index = index;\n  </LineNumberAdjustment>\n\n  return start_linenr;\n}\n"], ["Publisher", "\nfunction(message) {\n  <TimeoutCalculation>\n  let publishTimeout = message.timeout || options.publishTimeout || message.connectionPublishTimeout || 0;\n  logger.silly(`Publish called in state ${this.state}`);\n  </TimeoutCalculation>\n  \n  <PublishExecution>\n  return new Promise((resolve, reject) => {\n    let timeout;\n    let timedOut;\n    <TimeoutSetup>\n    if(publishTimeout > 0) {\n      timeout = setTimeout(() => {\n        timedOut = true;\n        reject(new Error('Publish took longer than configured timeout'));\n        this.removeDeferred(reject);\n      }, publishTimeout);\n    }\n    </TimeoutSetup>\n    \n    <SuccessAndFailureHandlers>\n    const onPublished = () => {\n      resolve();\n      this.removeDeferred(reject);\n    };\n    const onRejected = (err) => {\n      reject(err);\n      this.removeDeferred(reject);\n    };\n    </SuccessAndFailureHandlers>\n    \n    <PublishOperation>\n    let op = () => {\n      if(timeout) {\n        clearTimeout(timeout);\n        timeout = null;\n      }\n      if(!timedOut) {\n        return this.channel.publish(message)\n          .then(onPublished, onRejected);\n      }\n      return Promise.resolve();\n    };\n    </PublishOperation>\n    \n    <DeferAndHandle>\n    this.deferred.push(reject);\n    this.handle('publish', op);\n    </DeferAndHandle>\n    \n  });\n  </PublishExecution>\n}\n"], ["mul_inv", "\nfunction mul_inv(a, b){\n  var b0 = b;\n  var x0 = 0;\n  var x1 = 1;\n  var q, tmp;\n  if( b== 1){\n    return 1;\n  }\n  <ExtendedEuclideanAlgorithm>\n  while(a>1){\n    q = parseInt(a/b);\n    tmp = a;\n    a = b;\n    b = tmp%b;\n    tmp = x0;\n    x0 = x1 - (q * x0);\n    x1 = tmp;\n  }\n  </ExtendedEuclideanAlgorithm>\n  \n  <ResultAdjustment>\n  if(x1 <0){\n    x1 = x1+b0;\n  }\n  </ResultAdjustment>\n  \n  return x1;\n}\n"], ["addAmbushObject", "\nfunction add(object) {\n  <Validation>\n\tif (!_isValidAmbush(object)) {\n\t\treturn false;\n\t}\n  </Validation>\n\n  <DescriptionCleaning>\n\tobject.description = _cleanDescription(object.description);\n  </DescriptionCleaning>\n\n  <AdditionLogic>\n\tif (!_belongToAStoredAmbush(object.id)) {\n\t\tconst newObject = Object.assign({}, object);\n\t\tgoblin.ambush.push(newObject);\n\t\tgoblin.ambushEmitter.emit('change', { type: 'add', value: newObject });\n\t} else {\n\t\tlogger('AMBUSH_ADD_ERROR');\n\t}\n  </AdditionLogic>\n}\n"], ["getMaxPoints", "\nfunction getMaxPoints(font) {\n  <MaxPointsCalculation>\n  return _.max(_.map(font.glyphs, function (glyph) {\n    return _.reduce(glyph.ttfContours, function (sum, ctr) { return sum + ctr.length; }, 0);\n  }));\n  </MaxPointsCalculation>\n}\n"], ["locationSort", "\nfunction locationSort(_ref, _ref2) {\n  let locA = _ref.location;\n  let locB = _ref2.location;\n\n  <ComparisonLogic>\n  if (locA.line === locB.line) {\n    return locA.col - locB.col;\n  }\n  return locA.line - locB.line;\n  </ComparisonLogic>\n}\n"], ["transform", "\nfunction transform(context, file, fileSet, next) {\n  <FatalStatusCheck>\n  if (stats(file).fatal) {\n    next()\n  } else {\n  </FatalStatusCheck>\n    <DocumentTransformationSetup>\n    debug('Transforming document `%s`', file.path)\n    context.processor.run(context.tree, file, onrun)\n    </DocumentTransformationSetup>\n  }\n\n  <OnRunCompletion>\n  function onrun(error, node) {\n    debug('Transformed document (error: %s)', error)\n    context.tree = node\n    next(error)\n  }\n  </OnRunCompletion>\n}\n"], ["isRemovedToken", "\nfunction isRemovedToken(context, token) {\n  var removedNodes = context.removedNodes;\n  var nodeIdx = removedNodes.length - 1;\n\n  <NodeTraversal>\n  while (nodeIdx >= 0 && removedNodes[nodeIdx].start > token.start) {\n    nodeIdx--;\n  }\n  </NodeTraversal>\n\n  <NodeValidityCheck>\n  var node = removedNodes[nodeIdx];\n  if (nodeIdx === -1 || node.end < token.end) {\n    return false;\n  }\n  </NodeValidityCheck>\n\n  <TokenComparison>\n  var tokens = context.ast.tokens;\n  var tokenIdx = findTokenIndex(tokens, node.start);\n  while (tokens[tokenIdx].end <= node.end) {\n    if (token === tokens[tokenIdx]) {\n      return true;\n    }\n    tokenIdx++;\n  }\n  </TokenComparison>\n\n  return false;\n}\n"], "```"]